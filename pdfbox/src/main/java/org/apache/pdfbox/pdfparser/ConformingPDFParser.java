begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright 2010 adam.  *   *  Licensed under the Apache License, Version 2.0 (the "License");  *  you may not use this file except in compliance with the License.  *  You may obtain a copy of the License at  *   *       http://www.apache.org/licenses/LICENSE-2.0  *   *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSUnread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|ConformingPDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|persistence
operator|.
name|util
operator|.
name|COSObjectKey
import|;
end_import

begin_comment
comment|/**  *   * @author<a href="adam@apache.org">Adam Nichols</a>  */
end_comment

begin_class
specifier|public
class|class
name|ConformingPDFParser
extends|extends
name|BaseParser
block|{
specifier|protected
name|RandomAccess
name|inputFile
decl_stmt|;
name|List
argument_list|<
name|XrefEntry
argument_list|>
name|xrefEntries
decl_stmt|;
specifier|private
name|long
name|currentOffset
decl_stmt|;
specifier|private
name|ConformingPDDocument
name|doc
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|throwNonConformingException
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|recursivlyRead
init|=
literal|true
decl_stmt|;
comment|/**      * Constructor.      *      * @param inputFile The input stream that contains the PDF document.      *      * @throws IOException If there is an error initializing the stream.      */
specifier|public
name|ConformingPDFParser
parameter_list|(
name|File
name|inputFile
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|inputFile
operator|=
operator|new
name|RandomAccessFile
argument_list|(
name|inputFile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will parse the stream and populate the COSDocument object.  This will close      * the stream when it is done parsing.      *      * @throws IOException If there is an error reading from the stream or corrupt data      * is found.      */
specifier|public
name|void
name|parse
parameter_list|()
throws|throws
name|IOException
block|{
name|document
operator|=
operator|new
name|COSDocument
argument_list|()
expr_stmt|;
name|doc
operator|=
operator|new
name|ConformingPDDocument
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|currentOffset
operator|=
name|inputFile
operator|.
name|length
argument_list|()
operator|-
literal|1
expr_stmt|;
name|long
name|xRefTableLocation
init|=
name|parseTrailerInformation
argument_list|()
decl_stmt|;
name|currentOffset
operator|=
name|xRefTableLocation
expr_stmt|;
name|parseXrefTable
argument_list|()
expr_stmt|;
comment|// now that we read the xref table and put null references in the doc,
comment|// we can deference those objects now.
name|boolean
name|oldValue
init|=
name|recursivlyRead
decl_stmt|;
name|recursivlyRead
operator|=
literal|false
expr_stmt|;
name|List
argument_list|<
name|COSObjectKey
argument_list|>
name|keys
init|=
name|doc
operator|.
name|getObjectKeysFromPool
argument_list|()
decl_stmt|;
for|for
control|(
name|COSObjectKey
name|key
range|:
name|keys
control|)
block|{
comment|// getObject will put it into the document's object pool for us
name|getObject
argument_list|(
name|key
operator|.
name|getNumber
argument_list|()
argument_list|,
name|key
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|recursivlyRead
operator|=
name|oldValue
expr_stmt|;
block|}
comment|/**      * This will get the document that was parsed.  parse() must be called before this is called.      * When you are done with this document you must call close() on it to release      * resources.      *      * @return The document that was parsed.      *      * @throws IOException If there is an error getting the document.      */
specifier|public
name|COSDocument
name|getDocument
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|document
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"You must call parse() before calling getDocument()"
argument_list|)
throw|;
block|}
return|return
name|document
return|;
block|}
comment|/**      * This will get the PD document that was parsed.  When you are done with      * this document you must call close() on it to release resources.      *      * @return The document at the PD layer.      *      * @throws IOException If there is an error getting the document.      */
specifier|public
name|PDDocument
name|getPDDocument
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|doc
return|;
block|}
specifier|private
name|boolean
name|parseXrefTable
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|currentLine
init|=
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|throwNonConformingException
operator|&&
operator|!
literal|"xref"
operator|.
name|equals
argument_list|(
name|currentLine
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"xref table not found.\nExpected: xref\nFound: "
operator|+
name|currentLine
argument_list|)
throw|;
block|}
name|int
name|objectNumber
init|=
name|readInt
argument_list|()
decl_stmt|;
name|int
name|entries
init|=
name|readInt
argument_list|()
decl_stmt|;
name|xrefEntries
operator|=
operator|new
name|ArrayList
argument_list|<
name|XrefEntry
argument_list|>
argument_list|(
name|entries
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entries
condition|;
name|i
operator|++
control|)
name|xrefEntries
operator|.
name|add
argument_list|(
operator|new
name|XrefEntry
argument_list|(
name|objectNumber
operator|++
argument_list|,
name|readInt
argument_list|()
argument_list|,
name|readInt
argument_list|()
argument_list|,
name|readLine
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|protected
name|long
name|parseTrailerInformation
parameter_list|()
throws|throws
name|IOException
throws|,
name|NumberFormatException
block|{
name|consumeWhitespaceBackwards
argument_list|()
expr_stmt|;
name|String
name|currentLine
init|=
name|readLineBackwards
argument_list|()
decl_stmt|;
if|if
condition|(
name|throwNonConformingException
operator|&&
operator|!
literal|"%%EOF"
operator|.
name|equals
argument_list|(
name|currentLine
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Invalid EOF marker.\nExpected: %%EOF\nFound: "
operator|+
name|currentLine
argument_list|)
throw|;
block|}
name|long
name|xrefLocation
init|=
name|readLongBackwards
argument_list|()
decl_stmt|;
name|currentLine
operator|=
name|readLineBackwards
argument_list|()
expr_stmt|;
if|if
condition|(
name|throwNonConformingException
operator|&&
operator|!
literal|"startxref"
operator|.
name|equals
argument_list|(
name|currentLine
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Invalid trailer.\nExpected: startxref\nFound: "
operator|+
name|currentLine
argument_list|)
throw|;
block|}
name|document
operator|.
name|setTrailer
argument_list|(
name|readDictionaryBackwards
argument_list|()
argument_list|)
expr_stmt|;
name|consumeWhitespaceBackwards
argument_list|()
expr_stmt|;
name|currentLine
operator|=
name|readLineBackwards
argument_list|()
expr_stmt|;
if|if
condition|(
name|throwNonConformingException
operator|&&
operator|!
literal|"trailer"
operator|.
name|equals
argument_list|(
name|currentLine
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Invalid trailer.\nExpected: trailer\nFound: "
operator|+
name|currentLine
argument_list|)
throw|;
block|}
return|return
name|xrefLocation
return|;
block|}
specifier|protected
name|byte
name|readByteBackwards
parameter_list|()
throws|throws
name|IOException
block|{
name|inputFile
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
name|byte
name|singleByte
init|=
operator|(
name|byte
operator|)
name|inputFile
operator|.
name|read
argument_list|()
decl_stmt|;
name|currentOffset
operator|--
expr_stmt|;
return|return
name|singleByte
return|;
block|}
specifier|protected
name|byte
name|readByte
parameter_list|()
throws|throws
name|IOException
block|{
name|inputFile
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
name|byte
name|singleByte
init|=
operator|(
name|byte
operator|)
name|inputFile
operator|.
name|read
argument_list|()
decl_stmt|;
name|currentOffset
operator|++
expr_stmt|;
return|return
name|singleByte
return|;
block|}
specifier|protected
name|String
name|readBackwardUntilWhitespace
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|byte
name|singleByte
init|=
name|readByteBackwards
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|isWhitespace
argument_list|(
name|singleByte
argument_list|)
condition|)
block|{
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|)
name|singleByte
argument_list|)
expr_stmt|;
name|singleByte
operator|=
name|readByteBackwards
argument_list|()
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will read all bytes (backwards) until a non-whitespace character is      * found.  To save you an extra read, the non-whitespace character is      * returned.  If the current character is not whitespace, this method will      * just return the current char.      * @return the first non-whitespace character found      * @throws IOException if there is an error reading from the file      */
specifier|protected
name|byte
name|consumeWhitespaceBackwards
parameter_list|()
throws|throws
name|IOException
block|{
name|inputFile
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
name|byte
name|singleByte
init|=
operator|(
name|byte
operator|)
name|inputFile
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isWhitespace
argument_list|(
name|singleByte
argument_list|)
condition|)
return|return
name|singleByte
return|;
comment|// we have some whitespace, let's consume it
while|while
condition|(
name|isWhitespace
argument_list|(
name|singleByte
argument_list|)
condition|)
block|{
name|singleByte
operator|=
name|readByteBackwards
argument_list|()
expr_stmt|;
block|}
comment|// readByteBackwards will decrement the currentOffset to point the byte
comment|// before the one just read, so we increment it back to the current byte
name|currentOffset
operator|++
expr_stmt|;
return|return
name|singleByte
return|;
block|}
comment|/**      * This will read all bytes until a non-whitespace character is      * found.  To save you an extra read, the non-whitespace character is      * returned.  If the current character is not whitespace, this method will      * just return the current char.      * @return the first non-whitespace character found      * @throws IOException if there is an error reading from the file      */
specifier|protected
name|byte
name|consumeWhitespace
parameter_list|()
throws|throws
name|IOException
block|{
name|inputFile
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
name|byte
name|singleByte
init|=
operator|(
name|byte
operator|)
name|inputFile
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isWhitespace
argument_list|(
name|singleByte
argument_list|)
condition|)
return|return
name|singleByte
return|;
comment|// we have some whitespace, let's consume it
while|while
condition|(
name|isWhitespace
argument_list|(
name|singleByte
argument_list|)
condition|)
block|{
name|singleByte
operator|=
name|readByte
argument_list|()
expr_stmt|;
block|}
comment|// readByte() will increment the currentOffset to point the byte
comment|// after the one just read, so we decrement it back to the current byte
name|currentOffset
operator|--
expr_stmt|;
return|return
name|singleByte
return|;
block|}
comment|/**      * This will consume any whitespace, read in bytes until whitespace is found      * again and then parse the characters which have been read as a long.  The      * current offset will then point at the first whitespace character which      * preceeds the number.      * @return the parsed number      * @throws IOException if there is an error reading from the file      * @throws NumberFormatException if the bytes read can not be converted to a number      */
specifier|protected
name|long
name|readLongBackwards
parameter_list|()
throws|throws
name|IOException
throws|,
name|NumberFormatException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|consumeWhitespaceBackwards
argument_list|()
expr_stmt|;
name|byte
name|singleByte
init|=
name|readByteBackwards
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|isWhitespace
argument_list|(
name|singleByte
argument_list|)
condition|)
block|{
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|)
name|singleByte
argument_list|)
expr_stmt|;
name|singleByte
operator|=
name|readByteBackwards
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Number not found.  Expected number at offset: "
operator|+
name|currentOffset
argument_list|)
throw|;
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|readInt
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|consumeWhitespace
argument_list|()
expr_stmt|;
name|byte
name|singleByte
init|=
name|readByte
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|isWhitespace
argument_list|(
name|singleByte
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|singleByte
argument_list|)
expr_stmt|;
name|singleByte
operator|=
name|readByte
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Number not found.  Expected number at offset: "
operator|+
name|currentOffset
argument_list|)
throw|;
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will read in a number and return the COS version of the number (be      * it a COSInteger or a COSFloat).      * @return the COSNumber which was read/parsed      * @throws IOException      */
specifier|protected
name|COSNumber
name|readNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|consumeWhitespace
argument_list|()
expr_stmt|;
name|byte
name|singleByte
init|=
name|readByte
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|isWhitespace
argument_list|(
name|singleByte
argument_list|)
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|singleByte
argument_list|)
expr_stmt|;
name|singleByte
operator|=
name|readByte
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Number not found.  Expected number at offset: "
operator|+
name|currentOffset
argument_list|)
throw|;
return|return
name|parseNumber
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|protected
name|COSNumber
name|parseNumber
parameter_list|(
name|String
name|number
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|number
operator|.
name|matches
argument_list|(
literal|"^[0-9]+$"
argument_list|)
condition|)
return|return
name|COSInteger
operator|.
name|get
argument_list|(
name|number
argument_list|)
return|;
return|return
operator|new
name|COSFloat
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|number
argument_list|)
argument_list|)
return|;
block|}
specifier|protected
name|COSBase
name|processCosObject
parameter_list|(
name|String
name|string
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|string
operator|!=
literal|null
operator|&&
name|string
operator|.
name|endsWith
argument_list|(
literal|">"
argument_list|)
condition|)
block|{
comment|// string of hex codes
return|return
name|COSString
operator|.
name|parseHex
argument_list|(
name|string
operator|.
name|replaceAll
argument_list|(
literal|"^<"
argument_list|,
literal|""
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|">$"
argument_list|,
literal|""
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|protected
name|COSBase
name|readObjectBackwards
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBase
name|obj
init|=
literal|null
decl_stmt|;
name|consumeWhitespaceBackwards
argument_list|()
expr_stmt|;
name|String
name|lastSection
init|=
name|readBackwardUntilWhitespace
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"R"
operator|.
name|equals
argument_list|(
name|lastSection
argument_list|)
condition|)
block|{
comment|// indirect reference
name|long
name|gen
init|=
name|readLongBackwards
argument_list|()
decl_stmt|;
name|long
name|number
init|=
name|readLongBackwards
argument_list|()
decl_stmt|;
comment|// We just put a placeholder in the pool for now, we'll read the data later
name|doc
operator|.
name|putObjectInPool
argument_list|(
operator|new
name|COSUnread
argument_list|()
argument_list|,
name|number
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|obj
operator|=
operator|new
name|COSUnread
argument_list|(
name|number
argument_list|,
name|gen
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|">>"
operator|.
name|equals
argument_list|(
name|lastSection
argument_list|)
condition|)
block|{
comment|// dictionary
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not yet implemented"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|lastSection
operator|.
name|endsWith
argument_list|(
literal|"]"
argument_list|)
condition|)
block|{
comment|// array
name|COSArray
name|array
init|=
operator|new
name|COSArray
argument_list|()
decl_stmt|;
name|lastSection
operator|=
name|lastSection
operator|.
name|replaceAll
argument_list|(
literal|"]$"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|lastSection
operator|.
name|startsWith
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastSection
operator|.
name|matches
argument_list|(
literal|"^\\s*<.*>\\s*$"
argument_list|)
condition|)
comment|// it's a hex string
name|array
operator|.
name|add
argument_list|(
name|COSString
operator|.
name|parseHex
argument_list|(
name|lastSection
operator|.
name|replaceAll
argument_list|(
literal|"^\\s*<"
argument_list|,
literal|""
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|">\\s*$"
argument_list|,
literal|""
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lastSection
operator|=
name|readBackwardUntilWhitespace
argument_list|()
expr_stmt|;
block|}
name|lastSection
operator|=
name|lastSection
operator|.
name|replaceAll
argument_list|(
literal|"^\\["
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastSection
operator|.
name|matches
argument_list|(
literal|"^\\s*<.*>\\s*$"
argument_list|)
condition|)
comment|// it's a hex string
name|array
operator|.
name|add
argument_list|(
name|COSString
operator|.
name|parseHex
argument_list|(
name|lastSection
operator|.
name|replaceAll
argument_list|(
literal|"^\\s*<"
argument_list|,
literal|""
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|">\\s*$"
argument_list|,
literal|""
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|=
name|array
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastSection
operator|.
name|endsWith
argument_list|(
literal|">"
argument_list|)
condition|)
block|{
comment|// string of hex codes
name|obj
operator|=
name|processCosObject
argument_list|(
name|lastSection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// try a number, otherwise fall back on a string
try|try
block|{
name|Long
operator|.
name|parseLong
argument_list|(
name|lastSection
argument_list|)
expr_stmt|;
name|obj
operator|=
name|COSNumber
operator|.
name|get
argument_list|(
name|lastSection
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not yet implemented"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|obj
return|;
block|}
specifier|protected
name|COSName
name|readNameBackwards
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|name
init|=
name|readBackwardUntilWhitespace
argument_list|()
decl_stmt|;
name|name
operator|=
name|name
operator|.
name|replaceAll
argument_list|(
literal|"^/"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|COSName
operator|.
name|getPDFName
argument_list|(
name|name
argument_list|)
return|;
block|}
specifier|public
name|COSBase
name|getObject
parameter_list|(
name|long
name|objectNumber
parameter_list|,
name|long
name|generation
parameter_list|)
throws|throws
name|IOException
block|{
comment|// we could optionally, check to see if parse() have been called&
comment|// throw an exception here, but I don't think that's really necessary
name|XrefEntry
name|entry
init|=
name|xrefEntries
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|objectNumber
argument_list|)
decl_stmt|;
name|currentOffset
operator|=
name|entry
operator|.
name|getByteOffset
argument_list|()
expr_stmt|;
return|return
name|readObject
argument_list|(
name|objectNumber
argument_list|,
name|generation
argument_list|)
return|;
block|}
comment|/**      * This will read an object from the inputFile at whatever our currentOffset      * is.  If the object and generation are not the expected values and this      * object is set to throw an exception for non-conforming documents, then an      * exception will be thrown.      * @param objectNumber the object number you expect to read      * @param generation the generation you expect this object to be      * @return the object being read.      */
specifier|public
name|COSBase
name|readObject
parameter_list|(
name|long
name|objectNumber
parameter_list|,
name|long
name|generation
parameter_list|)
throws|throws
name|IOException
block|{
comment|// when recursivly reading, we always pull the object from the filesystem
if|if
condition|(
name|document
operator|!=
literal|null
operator|&&
name|recursivlyRead
condition|)
block|{
comment|// check to see if it is in the document cache before hitting the filesystem
name|COSBase
name|obj
init|=
name|doc
operator|.
name|getObjectFromPool
argument_list|(
name|objectNumber
argument_list|,
name|generation
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj
operator|!=
literal|null
condition|)
return|return
name|obj
return|;
block|}
name|int
name|actualObjectNumber
init|=
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|objectNumber
operator|!=
name|actualObjectNumber
condition|)
if|if
condition|(
name|throwNonConformingException
condition|)
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Object numer expected was "
operator|+
name|objectNumber
operator|+
literal|" but actual was "
operator|+
name|actualObjectNumber
argument_list|)
throw|;
name|consumeWhitespace
argument_list|()
expr_stmt|;
name|int
name|actualGeneration
init|=
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|generation
operator|!=
name|actualGeneration
condition|)
if|if
condition|(
name|throwNonConformingException
condition|)
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Generation expected was "
operator|+
name|generation
operator|+
literal|" but actual was "
operator|+
name|actualGeneration
argument_list|)
throw|;
name|consumeWhitespace
argument_list|()
expr_stmt|;
name|String
name|obj
init|=
name|readWord
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
literal|"obj"
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
condition|)
if|if
condition|(
name|throwNonConformingException
condition|)
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Expected keyword 'obj' but found "
operator|+
name|obj
argument_list|)
throw|;
comment|// put placeholder object in doc to prevent infinite recursion
comment|// e.g. read Root -> dereference object -> read object which has /Parent -> GOTO read Root
name|doc
operator|.
name|putObjectInPool
argument_list|(
operator|new
name|COSObject
argument_list|(
literal|null
argument_list|)
argument_list|,
name|objectNumber
argument_list|,
name|generation
argument_list|)
expr_stmt|;
name|COSBase
name|object
init|=
name|readObject
argument_list|()
decl_stmt|;
name|doc
operator|.
name|putObjectInPool
argument_list|(
name|object
argument_list|,
name|objectNumber
argument_list|,
name|generation
argument_list|)
expr_stmt|;
return|return
name|object
return|;
block|}
comment|/**      * This actually reads the object data.      * @return the object which is read      * @throws IOException      */
specifier|protected
name|COSBase
name|readObject
parameter_list|()
throws|throws
name|IOException
block|{
name|consumeWhitespace
argument_list|()
expr_stmt|;
name|String
name|string
init|=
name|readWord
argument_list|()
decl_stmt|;
if|if
condition|(
name|string
operator|.
name|startsWith
argument_list|(
literal|"<<"
argument_list|)
condition|)
block|{
comment|// this is a dictionary
name|COSDictionary
name|dictionary
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|boolean
name|atEndOfDictionary
init|=
literal|false
decl_stmt|;
comment|// remove the marker for the beginning of the dictionary
name|string
operator|=
name|string
operator|.
name|replaceAll
argument_list|(
literal|"^<<"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|string
argument_list|)
operator|||
name|string
operator|.
name|matches
argument_list|(
literal|"^\\w$"
argument_list|)
condition|)
name|string
operator|=
name|readWord
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|atEndOfDictionary
condition|)
block|{
name|COSName
name|name
init|=
name|COSName
operator|.
name|getPDFName
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|COSBase
name|object
init|=
name|readObject
argument_list|()
decl_stmt|;
name|dictionary
operator|.
name|setItem
argument_list|(
name|name
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|byte
name|singleByte
init|=
name|consumeWhitespace
argument_list|()
decl_stmt|;
if|if
condition|(
name|singleByte
operator|==
literal|'>'
condition|)
block|{
name|readByte
argument_list|()
expr_stmt|;
comment|// get rid of the second '>'
name|atEndOfDictionary
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|atEndOfDictionary
condition|)
name|string
operator|=
name|readWord
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
return|return
name|dictionary
return|;
block|}
elseif|else
if|if
condition|(
name|string
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
comment|// it's a dictionary label. i.e. /Type or /Pages or something similar
name|COSBase
name|name
init|=
name|COSName
operator|.
name|getPDFName
argument_list|(
name|string
argument_list|)
decl_stmt|;
return|return
name|name
return|;
block|}
elseif|else
if|if
condition|(
name|string
operator|.
name|startsWith
argument_list|(
literal|"-"
argument_list|)
condition|)
block|{
comment|// it's a negitive number
return|return
name|parseNumber
argument_list|(
name|string
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|string
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|>=
literal|'0'
operator|&&
name|string
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|<=
literal|'9'
condition|)
block|{
comment|// it's a COSInt or COSFloat, or a weak reference (i.e. "3 0 R")
comment|// we'll have to peek ahead a little to see if it's a reference or not
name|long
name|tempOffset
init|=
name|this
operator|.
name|currentOffset
decl_stmt|;
name|consumeWhitespace
argument_list|()
expr_stmt|;
name|String
name|tempString
init|=
name|readWord
argument_list|()
decl_stmt|;
if|if
condition|(
name|tempString
operator|.
name|matches
argument_list|(
literal|"^[0-9]+$"
argument_list|)
condition|)
block|{
comment|// it is an int, might be a weak reference...
name|tempString
operator|=
name|readWord
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
literal|"R"
operator|.
name|equals
argument_list|(
name|tempString
argument_list|)
condition|)
block|{
comment|// it's just a number, not a weak reference
name|this
operator|.
name|currentOffset
operator|=
name|tempOffset
expr_stmt|;
return|return
name|parseNumber
argument_list|(
name|string
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// it's just a number, not a weak reference
name|this
operator|.
name|currentOffset
operator|=
name|tempOffset
expr_stmt|;
return|return
name|parseNumber
argument_list|(
name|string
argument_list|)
return|;
block|}
comment|// it wasn't a number, so we need to parse the weak-reference
name|this
operator|.
name|currentOffset
operator|=
name|tempOffset
expr_stmt|;
name|int
name|number
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|gen
init|=
name|readInt
argument_list|()
decl_stmt|;
name|String
name|r
init|=
name|readWord
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
literal|"R"
operator|.
name|equals
argument_list|(
name|r
argument_list|)
condition|)
if|if
condition|(
name|throwNonConformingException
condition|)
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Expected keyword 'R' but found "
operator|+
name|r
argument_list|)
throw|;
if|if
condition|(
name|recursivlyRead
condition|)
block|{
comment|// seek to the object, read it, seek back to current location
name|long
name|tempLocation
init|=
name|this
operator|.
name|currentOffset
decl_stmt|;
name|this
operator|.
name|currentOffset
operator|=
name|this
operator|.
name|xrefEntries
operator|.
name|get
argument_list|(
name|number
argument_list|)
operator|.
name|getByteOffset
argument_list|()
expr_stmt|;
name|COSBase
name|returnValue
init|=
name|readObject
argument_list|(
name|number
argument_list|,
name|gen
argument_list|)
decl_stmt|;
name|this
operator|.
name|currentOffset
operator|=
name|tempLocation
expr_stmt|;
return|return
name|returnValue
return|;
block|}
else|else
block|{
comment|// Put a COSUnknown there as a placeholder
name|COSObject
name|obj
init|=
operator|new
name|COSObject
argument_list|(
operator|new
name|COSUnread
argument_list|()
argument_list|)
decl_stmt|;
name|obj
operator|.
name|setObjectNumber
argument_list|(
name|COSInteger
operator|.
name|get
argument_list|(
name|number
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|.
name|setGenerationNumber
argument_list|(
name|COSInteger
operator|.
name|get
argument_list|(
name|gen
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|string
operator|.
name|startsWith
argument_list|(
literal|"]"
argument_list|)
condition|)
block|{
comment|// end of an array, just return null
if|if
condition|(
literal|"]"
operator|.
name|equals
argument_list|(
name|string
argument_list|)
condition|)
return|return
literal|null
return|;
name|int
name|oldLength
init|=
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
name|this
operator|.
name|currentOffset
operator|-=
name|oldLength
expr_stmt|;
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|string
operator|.
name|startsWith
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
comment|// array of values
comment|// we'll just pay attention to the first part (this is in case there
comment|// is no whitespace between the "[" and the first element)
name|int
name|oldLength
init|=
name|string
operator|.
name|length
argument_list|()
decl_stmt|;
name|string
operator|=
literal|"["
expr_stmt|;
name|this
operator|.
name|currentOffset
operator|-=
operator|(
name|oldLength
operator|-
name|string
operator|.
name|length
argument_list|()
operator|+
literal|1
operator|)
expr_stmt|;
name|COSArray
name|array
init|=
operator|new
name|COSArray
argument_list|()
decl_stmt|;
name|COSBase
name|object
init|=
name|readObject
argument_list|()
decl_stmt|;
while|while
condition|(
name|object
operator|!=
literal|null
condition|)
block|{
name|array
operator|.
name|add
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|=
name|readObject
argument_list|()
expr_stmt|;
block|}
return|return
name|array
return|;
block|}
elseif|else
if|if
condition|(
name|string
operator|.
name|startsWith
argument_list|(
literal|"("
argument_list|)
condition|)
block|{
comment|// this is a string (not hex encoded), strip off the '(' and read until ')'
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|string
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|byte
name|singleByte
init|=
name|readByte
argument_list|()
decl_stmt|;
while|while
condition|(
name|singleByte
operator|!=
literal|')'
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|singleByte
argument_list|)
expr_stmt|;
name|singleByte
operator|=
name|readByte
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|COSString
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
return|;
comment|// fixme: should be calling COSString(byte[])
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not yet implemented: "
operator|+
name|string
operator|+
literal|" loation="
operator|+
name|this
operator|.
name|currentOffset
argument_list|)
throw|;
block|}
block|}
comment|/**      * This will read the next string from the stream.      * @return The string that was read from the stream.      * @throws IOException If there is an error reading from the stream.      */
annotation|@
name|Override
specifier|protected
name|String
name|readString
parameter_list|()
throws|throws
name|IOException
block|{
name|consumeWhitespace
argument_list|()
expr_stmt|;
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|isEndOfName
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
name|COSDictionary
name|readDictionaryBackwards
parameter_list|()
throws|throws
name|IOException
block|{
name|COSDictionary
name|dict
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
comment|// consume the last two '>' chars which signify the end of the dictionary
name|consumeWhitespaceBackwards
argument_list|()
expr_stmt|;
name|byte
name|singleByte
init|=
name|readByteBackwards
argument_list|()
decl_stmt|;
if|if
condition|(
name|throwNonConformingException
operator|&&
name|singleByte
operator|!=
literal|'>'
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|""
argument_list|)
throw|;
block|}
name|singleByte
operator|=
name|readByteBackwards
argument_list|()
expr_stmt|;
if|if
condition|(
name|throwNonConformingException
operator|&&
name|singleByte
operator|!=
literal|'>'
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|""
argument_list|)
throw|;
block|}
comment|// check to see if we're at the end of the dictionary
name|boolean
name|atEndOfDictionary
init|=
literal|false
decl_stmt|;
name|singleByte
operator|=
name|consumeWhitespaceBackwards
argument_list|()
expr_stmt|;
if|if
condition|(
name|singleByte
operator|==
literal|'<'
condition|)
block|{
name|inputFile
operator|.
name|seek
argument_list|(
name|currentOffset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|atEndOfDictionary
operator|=
operator|(
operator|(
name|byte
operator|)
name|inputFile
operator|.
name|read
argument_list|()
operator|)
operator|==
literal|'<'
expr_stmt|;
block|}
name|COSDictionary
name|backwardsDictionary
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
comment|// while we're not at the end of the dictionary, read in entries
while|while
condition|(
operator|!
name|atEndOfDictionary
condition|)
block|{
name|COSBase
name|object
init|=
name|readObjectBackwards
argument_list|()
decl_stmt|;
name|COSName
name|name
init|=
name|readNameBackwards
argument_list|()
decl_stmt|;
name|backwardsDictionary
operator|.
name|setItem
argument_list|(
name|name
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|singleByte
operator|=
name|consumeWhitespaceBackwards
argument_list|()
expr_stmt|;
if|if
condition|(
name|singleByte
operator|==
literal|'<'
condition|)
block|{
name|inputFile
operator|.
name|seek
argument_list|(
name|currentOffset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|atEndOfDictionary
operator|=
operator|(
operator|(
name|byte
operator|)
name|inputFile
operator|.
name|read
argument_list|()
operator|)
operator|==
literal|'<'
expr_stmt|;
block|}
block|}
comment|// the dictionaries preserve the order keys were added, as such we shall
comment|// add them in the proper order, not the reverse order
name|Set
argument_list|<
name|COSName
argument_list|>
name|backwardsKeys
init|=
name|backwardsDictionary
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|backwardsKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|dict
operator|.
name|setItem
argument_list|(
operator|(
name|COSName
operator|)
name|backwardsKeys
operator|.
name|toArray
argument_list|()
index|[
name|i
index|]
argument_list|,
name|backwardsDictionary
operator|.
name|getItem
argument_list|(
operator|(
name|COSName
operator|)
name|backwardsKeys
operator|.
name|toArray
argument_list|()
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|// consume the last two '<' chars
name|readByteBackwards
argument_list|()
expr_stmt|;
name|readByteBackwards
argument_list|()
expr_stmt|;
return|return
name|dict
return|;
block|}
comment|/**      * This will read a line starting with the byte at offset and going       * backwards until it finds a newline.  This should only be used if we are      * certain that the data will only be text, and not binary data.      *       * @return the string which was read      * @throws IOException if there was an error reading data from the file      */
specifier|protected
name|String
name|readLineBackwards
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|endOfObject
init|=
literal|false
decl_stmt|;
do|do
block|{
comment|// first we read the %%EOF marker
name|byte
name|singleByte
init|=
name|readByteBackwards
argument_list|()
decl_stmt|;
if|if
condition|(
name|singleByte
operator|==
literal|'\n'
condition|)
block|{
comment|// if ther's a preceeding \r, we'll eat that as well
name|inputFile
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|)
name|inputFile
operator|.
name|read
argument_list|()
operator|==
literal|'\r'
condition|)
name|currentOffset
operator|--
expr_stmt|;
name|endOfObject
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|singleByte
operator|==
literal|'\r'
condition|)
block|{
name|endOfObject
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|)
name|singleByte
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|endOfObject
condition|)
do|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will read a line starting with the byte at offset and going      * forward until it finds a newline.  This should only be used if we are      * certain that the data will only be text, and not binary data.      * @return the string which was read      * @throws IOException if there was an error reading data from the file      */
annotation|@
name|Override
specifier|protected
name|String
name|readLine
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|endOfLine
init|=
literal|false
decl_stmt|;
do|do
block|{
comment|// first we read the %%EOF marker
name|byte
name|singleByte
init|=
name|readByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|singleByte
operator|==
literal|'\n'
condition|)
block|{
comment|// if ther's a preceeding \r, we'll eat that as well
name|inputFile
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|)
name|inputFile
operator|.
name|read
argument_list|()
operator|==
literal|'\r'
condition|)
name|currentOffset
operator|++
expr_stmt|;
name|endOfLine
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|singleByte
operator|==
literal|'\r'
condition|)
block|{
name|endOfLine
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|singleByte
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|endOfLine
condition|)
do|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
name|String
name|readWord
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|stop
decl_stmt|;
do|do
block|{
name|byte
name|singleByte
init|=
name|readByte
argument_list|()
decl_stmt|;
name|stop
operator|=
name|this
operator|.
name|isWhitespace
argument_list|(
name|singleByte
argument_list|)
expr_stmt|;
comment|// there are some additional characters which indicate the next element/word has begun
comment|// ignore the first char we read, b/c the first char is the beginnging of this object, not the next one
if|if
condition|(
operator|!
name|stop
operator|&&
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|stop
operator|=
name|singleByte
operator|==
literal|'/'
operator|||
name|singleByte
operator|==
literal|'['
operator|||
name|singleByte
operator|==
literal|']'
operator|||
operator|(
name|singleByte
operator|==
literal|'>'
operator|&&
operator|!
literal|">"
operator|.
name|equals
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|stop
condition|)
comment|// we're stopping on a non-whitespace char, decrement the
name|this
operator|.
name|currentOffset
operator|--
expr_stmt|;
comment|// counter so we don't miss this character
block|}
if|if
condition|(
operator|!
name|stop
condition|)
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|singleByte
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|stop
condition|)
do|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * @return the recursivlyRead      */
specifier|public
name|boolean
name|isRecursivlyRead
parameter_list|()
block|{
return|return
name|recursivlyRead
return|;
block|}
comment|/**      * @param recursivlyRead the recursivlyRead to set      */
specifier|public
name|void
name|setRecursivlyRead
parameter_list|(
name|boolean
name|recursivlyRead
parameter_list|)
block|{
name|this
operator|.
name|recursivlyRead
operator|=
name|recursivlyRead
expr_stmt|;
block|}
block|}
end_class

end_unit

