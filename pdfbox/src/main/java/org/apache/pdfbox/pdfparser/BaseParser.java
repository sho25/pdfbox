begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|PushBackInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|persistence
operator|.
name|util
operator|.
name|COSObjectKey
import|;
end_import

begin_comment
comment|/**  * This class is used to contain parsing logic that will be used by both the  * PDFParser and the COSStreamParser.  *  * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  * @version $Revision$  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|BaseParser
block|{
specifier|private
specifier|static
specifier|final
name|long
name|OBJECT_NUMBER_THRESHOLD
init|=
literal|10000000000L
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|GENERATION_NUMBER_THRESHOLD
init|=
literal|65535
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ISO_8859_1
init|=
literal|"ISO-8859-1"
decl_stmt|;
comment|/**      * system property allowing to define size of push back buffer.      */
specifier|public
specifier|static
specifier|final
name|String
name|PROP_PUSHBACK_SIZE
init|=
literal|"org.apache.pdfbox.baseParser.pushBackSize"
decl_stmt|;
comment|/**      * Log instance.      */
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BaseParser
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|E
init|=
literal|'e'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|N
init|=
literal|'n'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|D
init|=
literal|'d'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|S
init|=
literal|'s'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|T
init|=
literal|'t'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|R
init|=
literal|'r'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|A
init|=
literal|'a'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|M
init|=
literal|'m'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|O
init|=
literal|'o'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|B
init|=
literal|'b'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|J
init|=
literal|'j'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|STRMBUFLEN
init|=
literal|2048
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|strmBuf
init|=
operator|new
name|byte
index|[
name|STRMBUFLEN
index|]
decl_stmt|;
comment|/**      * This is a byte array that will be used for comparisons.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ENDSTREAM
init|=
operator|new
name|byte
index|[]
block|{
name|E
block|,
name|N
block|,
name|D
block|,
name|S
block|,
name|T
block|,
name|R
block|,
name|E
block|,
name|A
block|,
name|M
block|}
decl_stmt|;
comment|/**      * This is a byte array that will be used for comparisons.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ENDOBJ
init|=
operator|new
name|byte
index|[]
block|{
name|E
block|,
name|N
block|,
name|D
block|,
name|O
block|,
name|B
block|,
name|J
block|}
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|public
specifier|static
specifier|final
name|String
name|DEF
init|=
literal|"def"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|ENDOBJ_STRING
init|=
literal|"endobj"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|ENDSTREAM_STRING
init|=
literal|"endstream"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|STREAM_STRING
init|=
literal|"stream"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|TRUE
init|=
literal|"true"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|FALSE
init|=
literal|"false"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|NULL
init|=
literal|"null"
decl_stmt|;
comment|/**      * This is the stream that will be read from.      */
specifier|protected
name|PushBackInputStream
name|pdfSource
decl_stmt|;
comment|/**      * This is the document that will be parsed.      */
specifier|protected
name|COSDocument
name|document
decl_stmt|;
comment|/**      * Default constructor.      */
specifier|public
name|BaseParser
parameter_list|()
block|{     }
comment|/**      * Constructor.      *      * @param input The input stream to read the data from.      * @throws IOException If there is an error reading the input stream.      */
specifier|public
name|BaseParser
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|pushbacksize
init|=
literal|65536
decl_stmt|;
try|try
block|{
name|pushbacksize
operator|=
name|Integer
operator|.
name|getInteger
argument_list|(
name|PROP_PUSHBACK_SIZE
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
comment|// PDFBOX-1946 getInteger calls System.getProperties,
comment|// which can get exception in an applet
comment|// ignore and use default
block|}
name|this
operator|.
name|pdfSource
operator|=
operator|new
name|PushBackInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|input
argument_list|,
literal|16384
argument_list|)
argument_list|,
name|pushbacksize
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *      * @param input The array to read the data from.      * @throws IOException If there is an error reading the byte data.      */
specifier|protected
name|BaseParser
parameter_list|(
name|byte
index|[]
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a new instance of a COSStream.      *       * @param dictionary the dictionary belonging to the stream      * @return the new COSStream      */
specifier|protected
specifier|final
name|COSStream
name|createCOSStream
parameter_list|(
name|COSDictionary
name|dictionary
parameter_list|)
block|{
if|if
condition|(
name|document
operator|!=
literal|null
condition|)
block|{
return|return
name|document
operator|.
name|createCOSStream
argument_list|(
name|dictionary
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Set the document for this stream.      *      * @param doc The current document.      */
specifier|public
name|void
name|setDocument
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
block|{
name|document
operator|=
name|doc
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isHexDigit
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
return|;
comment|// the line below can lead to problems with certain versions of the IBM JIT compiler
comment|// (and is slower anyway)
comment|//return (HEXDIGITS.indexOf(ch) != -1);
block|}
comment|/**      * This will parse a PDF dictionary value.      *      * @return The parsed Dictionary object.      *      * @throws IOException If there is an error parsing the dictionary object.      */
specifier|private
name|COSBase
name|parseCOSDictionaryValue
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBase
name|retval
init|=
literal|null
decl_stmt|;
name|long
name|numOffset
init|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|COSBase
name|number
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|char
name|next
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|>=
literal|'0'
operator|&&
name|next
operator|<=
literal|'9'
condition|)
block|{
name|long
name|genOffset
init|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|COSBase
name|generationNumber
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|readExpectedChar
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|number
operator|instanceof
name|COSInteger
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected number, actual="
operator|+
name|number
operator|+
literal|" at offset "
operator|+
name|numOffset
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|generationNumber
operator|instanceof
name|COSInteger
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected number, actual="
operator|+
name|number
operator|+
literal|" at offset "
operator|+
name|genOffset
argument_list|)
throw|;
block|}
name|COSObjectKey
name|key
init|=
operator|new
name|COSObjectKey
argument_list|(
operator|(
operator|(
name|COSInteger
operator|)
name|number
operator|)
operator|.
name|intValue
argument_list|()
argument_list|,
operator|(
operator|(
name|COSInteger
operator|)
name|generationNumber
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|retval
operator|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|number
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will parse a PDF dictionary.      *      * @return The parsed dictionary.      *      * @throws IOException IF there is an error reading the stream.      */
specifier|protected
name|COSDictionary
name|parseCOSDictionary
parameter_list|()
throws|throws
name|IOException
block|{
name|readExpectedChar
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|readExpectedChar
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSDictionary
name|obj
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'/'
condition|)
block|{
comment|//an invalid dictionary, we are expecting
comment|//the key, read until we can recover
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid dictionary, found: '"
operator|+
name|c
operator|+
literal|"' but expected: '/'"
argument_list|)
expr_stmt|;
name|int
name|read
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|read
operator|!=
operator|-
literal|1
operator|&&
name|read
operator|!=
literal|'/'
operator|&&
name|read
operator|!=
literal|'>'
condition|)
block|{
comment|// in addition to stopping when we find / or>, we also want
comment|// to stop when we find endstream or endobj.
if|if
condition|(
name|read
operator|==
name|E
condition|)
block|{
name|read
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|read
operator|==
name|N
condition|)
block|{
name|read
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|read
operator|==
name|D
condition|)
block|{
name|read
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|boolean
name|isStream
init|=
name|read
operator|==
name|S
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|T
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|R
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|E
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|A
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|M
decl_stmt|;
name|boolean
name|isObj
init|=
operator|!
name|isStream
operator|&&
name|read
operator|==
name|O
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|B
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|J
decl_stmt|;
if|if
condition|(
name|isStream
operator|||
name|isObj
condition|)
block|{
return|return
name|obj
return|;
comment|// we're done reading this object!
block|}
block|}
block|}
block|}
name|read
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|read
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|read
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|obj
return|;
block|}
block|}
else|else
block|{
name|COSName
name|key
init|=
name|parseCOSName
argument_list|()
decl_stmt|;
name|COSBase
name|value
init|=
name|parseCOSDictionaryValue
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
operator|)
operator|==
literal|'d'
condition|)
block|{
comment|//if the next string is 'def' then we are parsing a cmap stream
comment|//and want to ignore it, otherwise throw an exception.
name|String
name|potentialDEF
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|potentialDEF
operator|.
name|equals
argument_list|(
name|DEF
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|potentialDEF
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Bad Dictionary Declaration "
operator|+
name|pdfSource
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|.
name|setDirect
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|obj
operator|.
name|setItem
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|readExpectedChar
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|readExpectedChar
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
comment|/**      * This will read a COSStream from the input stream.      *      * @param dic The dictionary that goes with this stream.      *      * @return The parsed pdf stream.      *      * @throws IOException If there is an error reading the stream.      */
specifier|protected
name|COSStream
name|parseCOSStream
parameter_list|(
name|COSDictionary
name|dic
parameter_list|)
throws|throws
name|IOException
block|{
name|COSStream
name|stream
init|=
name|createCOSStream
argument_list|(
name|dic
argument_list|)
decl_stmt|;
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|readExpectedString
argument_list|(
name|STREAM_STRING
argument_list|)
expr_stmt|;
comment|//PDF Ref 3.2.7 A stream must be followed by either
comment|//a CRLF or LF but nothing else.
name|int
name|whitespace
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//see brother_scan_cover.pdf, it adds whitespaces
comment|//after the stream but before the start of the
comment|//data, so just read those first
while|while
condition|(
name|whitespace
operator|==
literal|0x20
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|whitespace
operator|==
literal|0x0D
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|whitespace
operator|!=
literal|0x0A
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
comment|//The spec says this is invalid but it happens in the real
comment|//world so we must support it.
block|}
block|}
elseif|else
if|if
condition|(
name|whitespace
operator|==
literal|0x0A
condition|)
block|{
comment|//that is fine
block|}
else|else
block|{
comment|//we are in an error.
comment|//but again we will do a lenient parsing and just assume that everything
comment|//is fine
name|pdfSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
block|}
comment|/*This needs to be dic.getItem because when we are parsing, the underlying object              * might still be null.              */
name|COSBase
name|streamLength
init|=
name|dic
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|)
decl_stmt|;
comment|//Need to keep track of the
name|out
operator|=
name|stream
operator|.
name|createFilteredStream
argument_list|(
name|streamLength
argument_list|)
expr_stmt|;
comment|// try to read stream length - even if it is an indirect object
name|int
name|length
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|streamLength
operator|instanceof
name|COSNumber
condition|)
block|{
name|length
operator|=
operator|(
operator|(
name|COSNumber
operator|)
name|streamLength
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
comment|// commented out next chunk since for the sequentially working PDFParser
comment|// we do not know if length object is redefined later on and the currently
comment|// read indirect object might be obsolete (e.g. not referenced in xref table);
comment|// this would result in reading wrong number of bytes;
comment|// Thus the only reliable information is a direct length.
comment|// This exclusion shouldn't harm much since in case of indirect objects they will
comment|// typically be defined after the stream object, thus keeping the directly
comment|// provided length will fix most cases
comment|// else if ( ( streamLength instanceof COSObject )&&
comment|//           ( ( (COSObject) streamLength ).getObject() instanceof COSNumber ) )
comment|// {
comment|//     length = ( (COSNumber) ( (COSObject) streamLength ).getObject() ).intValue();
comment|// }
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Couldn't determine length from dict: just
comment|// scan until we find endstream:
name|readUntilEndStream
argument_list|(
operator|new
name|EndstreamOutputStream
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Copy length bytes over:
name|int
name|left
init|=
name|length
decl_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|chunk
init|=
name|Math
operator|.
name|min
argument_list|(
name|left
argument_list|,
name|STRMBUFLEN
argument_list|)
decl_stmt|;
specifier|final
name|int
name|readCount
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|strmBuf
argument_list|,
literal|0
argument_list|,
name|chunk
argument_list|)
decl_stmt|;
if|if
condition|(
name|readCount
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|out
operator|.
name|write
argument_list|(
name|strmBuf
argument_list|,
literal|0
argument_list|,
name|readCount
argument_list|)
expr_stmt|;
name|left
operator|-=
name|readCount
expr_stmt|;
block|}
comment|// in order to handle broken documents we test if 'endstream' is reached
comment|// if not, length value possibly was wrong, fall back to scanning for endstream
comment|// fill buffer with next bytes and test for 'endstream' (with leading whitespaces)
name|int
name|readCount
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|strmBuf
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
decl_stmt|;
if|if
condition|(
name|readCount
operator|>
literal|0
condition|)
block|{
name|boolean
name|foundEndstream
init|=
literal|false
decl_stmt|;
name|int
name|nextEndstreamCIdx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|cIdx
init|=
literal|0
init|;
name|cIdx
operator|<
name|readCount
condition|;
name|cIdx
operator|++
control|)
block|{
specifier|final
name|int
name|ch
init|=
name|strmBuf
index|[
name|cIdx
index|]
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|ENDSTREAM
index|[
name|nextEndstreamCIdx
index|]
condition|)
block|{
if|if
condition|(
operator|++
name|nextEndstreamCIdx
operator|>=
name|ENDSTREAM
operator|.
name|length
condition|)
block|{
name|foundEndstream
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|nextEndstreamCIdx
operator|>
literal|0
operator|)
operator|||
operator|(
operator|!
name|isWhitespace
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
block|{
comment|// not found
break|break;
block|}
block|}
comment|// push back test bytes
name|pdfSource
operator|.
name|unread
argument_list|(
name|strmBuf
argument_list|,
literal|0
argument_list|,
name|readCount
argument_list|)
expr_stmt|;
comment|// if 'endstream' was not found fall back to scanning
if|if
condition|(
operator|!
name|foundEndstream
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Specified stream length "
operator|+
name|length
operator|+
literal|" is wrong. Fall back to reading stream until 'endstream'."
argument_list|)
expr_stmt|;
comment|// push back all read stream bytes
comment|// we got a buffered stream wrapper around filteredStream thus first flush to underlying stream
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|InputStream
name|writtenStreamBytes
init|=
name|stream
operator|.
name|getFilteredStream
argument_list|()
decl_stmt|;
name|ByteArrayOutputStream
name|bout
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|writtenStreamBytes
argument_list|,
name|bout
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|writtenStreamBytes
argument_list|)
expr_stmt|;
try|try
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|bout
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not push back "
operator|+
name|bout
operator|.
name|size
argument_list|()
operator|+
literal|" bytes in order to reparse stream. "
operator|+
literal|"Try increasing push back buffer using system property "
operator|+
name|PROP_PUSHBACK_SIZE
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
comment|// close and create new filtered stream
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|=
name|stream
operator|.
name|createFilteredStream
argument_list|()
expr_stmt|;
comment|// scan until we find endstream:
name|readUntilEndStream
argument_list|(
operator|new
name|EndstreamOutputStream
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|String
name|endStream
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|endStream
operator|.
name|equals
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
condition|)
block|{
comment|/*                  * Sometimes stream objects don't have an endstream tag so readUntilEndStream(out)                  * also can stop on endobj tags. If that's the case we need to make sure to unread                  * the endobj so parseObject() can handle that case normally.                  */
if|if
condition|(
name|endStream
operator|.
name|startsWith
argument_list|(
name|ENDOBJ_STRING
argument_list|)
condition|)
block|{
name|byte
index|[]
name|endobjarray
init|=
name|endStream
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
decl_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
name|endobjarray
argument_list|)
expr_stmt|;
block|}
comment|/*                  * Some PDF files don't contain a new line after endstream so we                  * need to make sure that the next object number is getting read separately                  * and not part of the endstream keyword. Ex. Some files would have "endstream8"                  * instead of "endstream"                  */
elseif|else
if|if
condition|(
name|endStream
operator|.
name|startsWith
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
condition|)
block|{
name|String
name|extra
init|=
name|endStream
operator|.
name|substring
argument_list|(
literal|9
argument_list|,
name|endStream
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|array
init|=
name|extra
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
decl_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*                      * If for some reason we get something else here, Read until we find the next                      * "endstream"                      */
name|readUntilEndStream
argument_list|(
operator|new
name|EndstreamOutputStream
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|readExpectedString
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|stream
return|;
block|}
comment|/**      * This method will read through the current stream object until      * we find the keyword "endstream" meaning we're at the end of this      * object. Some pdf files, however, forget to write some endstream tags      * and just close off objects with an "endobj" tag so we have to handle      * this case as well.      *       * This method is optimized using buffered IO and reduced number of      * byte compare operations.      *       * @param out  stream we write out to.      *       * @throws IOException      */
specifier|protected
name|void
name|readUntilEndStream
parameter_list|(
specifier|final
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|bufSize
decl_stmt|;
name|int
name|charMatchCount
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|keyw
init|=
name|ENDSTREAM
decl_stmt|;
specifier|final
name|int
name|quickTestOffset
init|=
literal|5
decl_stmt|;
comment|// last character position of shortest keyword ('endobj')
comment|// read next chunk into buffer; already matched chars are added to beginning of buffer
while|while
condition|(
operator|(
name|bufSize
operator|=
name|pdfSource
operator|.
name|read
argument_list|(
name|strmBuf
argument_list|,
name|charMatchCount
argument_list|,
name|STRMBUFLEN
operator|-
name|charMatchCount
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|bufSize
operator|+=
name|charMatchCount
expr_stmt|;
name|int
name|bIdx
init|=
name|charMatchCount
decl_stmt|;
name|int
name|quickTestIdx
decl_stmt|;
comment|// iterate over buffer, trying to find keyword match
for|for
control|(
name|int
name|maxQuicktestIdx
init|=
name|bufSize
operator|-
name|quickTestOffset
init|;
name|bIdx
operator|<
name|bufSize
condition|;
name|bIdx
operator|++
control|)
block|{
comment|// reduce compare operations by first test last character we would have to
comment|// match if current one matches; if it is not a character from keywords
comment|// we can move behind the test character;
comment|// this shortcut is inspired by the Boyer-Moore string search algorithm
comment|// and can reduce parsing time by approx. 20%
if|if
condition|(
operator|(
name|charMatchCount
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|quickTestIdx
operator|=
name|bIdx
operator|+
name|quickTestOffset
operator|)
operator|<
name|maxQuicktestIdx
operator|)
condition|)
block|{
specifier|final
name|byte
name|ch
init|=
name|strmBuf
index|[
name|quickTestIdx
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>
literal|'t'
operator|)
operator|||
operator|(
name|ch
operator|<
literal|'a'
operator|)
condition|)
block|{
comment|// last character we would have to match if current character would match
comment|// is not a character from keywords -> jump behind and start over
name|bIdx
operator|=
name|quickTestIdx
expr_stmt|;
continue|continue;
block|}
block|}
specifier|final
name|byte
name|ch
init|=
name|strmBuf
index|[
name|bIdx
index|]
decl_stmt|;
comment|// could be negative - but we only compare to ASCII
if|if
condition|(
name|ch
operator|==
name|keyw
index|[
name|charMatchCount
index|]
condition|)
block|{
if|if
condition|(
operator|++
name|charMatchCount
operator|==
name|keyw
operator|.
name|length
condition|)
block|{
comment|// match found
name|bIdx
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|charMatchCount
operator|==
literal|3
operator|)
operator|&&
operator|(
name|ch
operator|==
name|ENDOBJ
index|[
name|charMatchCount
index|]
operator|)
condition|)
block|{
comment|// maybe ENDSTREAM is missing but we could have ENDOBJ
name|keyw
operator|=
name|ENDOBJ
expr_stmt|;
name|charMatchCount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// no match; incrementing match start by 1 would be dumb since we already know matched chars
comment|// depending on current char read we may already have beginning of a new match:
comment|// 'e': first char matched;
comment|// 'n': if we are at match position idx 7 we already read 'e' thus 2 chars matched
comment|// for each other char we have to start matching first keyword char beginning with next
comment|// read position
name|charMatchCount
operator|=
operator|(
name|ch
operator|==
name|E
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|ch
operator|==
name|N
operator|)
operator|&&
operator|(
name|charMatchCount
operator|==
literal|7
operator|)
operator|)
condition|?
literal|2
else|:
literal|0
expr_stmt|;
comment|// search again for 'endstream'
name|keyw
operator|=
name|ENDSTREAM
expr_stmt|;
block|}
block|}
block|}
comment|// for
name|int
name|contentBytes
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|bIdx
operator|-
name|charMatchCount
argument_list|)
decl_stmt|;
comment|// write buffer content until first matched char to output stream
if|if
condition|(
name|contentBytes
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|strmBuf
argument_list|,
literal|0
argument_list|,
name|contentBytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|charMatchCount
operator|==
name|keyw
operator|.
name|length
condition|)
block|{
comment|// keyword matched; unread matched keyword (endstream/endobj) and following buffered content
name|pdfSource
operator|.
name|unread
argument_list|(
name|strmBuf
argument_list|,
name|contentBytes
argument_list|,
name|bufSize
operator|-
name|contentBytes
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// copy matched chars at start of buffer
name|System
operator|.
name|arraycopy
argument_list|(
name|keyw
argument_list|,
literal|0
argument_list|,
name|strmBuf
argument_list|,
literal|0
argument_list|,
name|charMatchCount
argument_list|)
expr_stmt|;
block|}
block|}
comment|// while
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// this writes a lonely CR or drops trailing CR LF and LF
block|}
comment|/**      * This is really a bug in the Document creators code, but it caused a crash      * in PDFBox, the first bug was in this format:      * /Title ( (5)      * /Creator which was patched in 1 place.      * However it missed the case where the Close Paren was escaped      *      * The second bug was in this format      * /Title (c:\)      * /Producer      *      * This patch  moves this code out of the parseCOSString method, so it can be used twice.      *      *      * @param bracesParameter the number of braces currently open.      *      * @return the corrected value of the brace counter      * @throws IOException      */
specifier|private
name|int
name|checkForMissingCloseParen
parameter_list|(
specifier|final
name|int
name|bracesParameter
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|braces
init|=
name|bracesParameter
decl_stmt|;
name|byte
index|[]
name|nextThreeBytes
init|=
operator|new
name|byte
index|[
literal|3
index|]
decl_stmt|;
name|int
name|amountRead
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|nextThreeBytes
argument_list|)
decl_stmt|;
comment|//lets handle the special case seen in Bull  River Rules and Regulations.pdf
comment|//The dictionary looks like this
comment|//    2 0 obj
comment|//<<
comment|//        /Type /Info
comment|//        /Creator (PaperPort http://www.scansoft.com)
comment|//        /Producer (sspdflib 1.0 http://www.scansoft.com)
comment|//        /Title ( (5)
comment|//        /Author ()
comment|//        /Subject ()
comment|//
comment|// Notice the /Title, the braces are not even but they should
comment|// be.  So lets assume that if we encounter an this scenario
comment|//<end_brace><new_line><opening_slash> then that
comment|// means that there is an error in the pdf and assume that
comment|// was the end of the document.
comment|//
if|if
condition|(
name|amountRead
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|nextThreeBytes
index|[
literal|0
index|]
operator|==
literal|0x0d
comment|// Look for a carriage return
operator|&&
name|nextThreeBytes
index|[
literal|1
index|]
operator|==
literal|0x0a
comment|// Look for a new line
operator|&&
name|nextThreeBytes
index|[
literal|2
index|]
operator|==
literal|0x2f
operator|)
comment|// Look for a slash /
comment|// Add a second case without a new line
operator|||
operator|(
name|nextThreeBytes
index|[
literal|0
index|]
operator|==
literal|0x0d
comment|// Look for a carriage return
operator|&&
name|nextThreeBytes
index|[
literal|1
index|]
operator|==
literal|0x2f
operator|)
condition|)
comment|// Look for a slash /
block|{
name|braces
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|amountRead
operator|>
literal|0
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|nextThreeBytes
argument_list|,
literal|0
argument_list|,
name|amountRead
argument_list|)
expr_stmt|;
block|}
return|return
name|braces
return|;
block|}
comment|/**      * This will parse a PDF string.      *      * @param isDictionary indicates if the stream is a dictionary or not      * @return The parsed PDF string.      *      * @throws IOException If there is an error reading from the stream.      * @deprecated Not needed anymore. Use {@link #parseCOSString()} instead. PDFBOX-1437      */
annotation|@
name|Deprecated
specifier|protected
name|COSString
name|parseCOSString
parameter_list|(
name|boolean
name|isDictionary
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|parseCOSString
argument_list|()
return|;
block|}
comment|/**      * This will parse a PDF string.      *      * @return The parsed PDF string.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|COSString
name|parseCOSString
parameter_list|()
throws|throws
name|IOException
block|{
name|char
name|nextChar
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
name|char
name|openBrace
decl_stmt|;
name|char
name|closeBrace
decl_stmt|;
if|if
condition|(
name|nextChar
operator|==
literal|'('
condition|)
block|{
name|openBrace
operator|=
literal|'('
expr_stmt|;
name|closeBrace
operator|=
literal|')'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextChar
operator|==
literal|'<'
condition|)
block|{
return|return
name|parseCOSHexString
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"parseCOSString string should start with '(' or '<' and not '"
operator|+
name|nextChar
operator|+
literal|"' "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
name|ByteArrayOutputStream
name|out
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
comment|//This is the number of braces read
comment|//
name|int
name|braces
init|=
literal|1
decl_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|braces
operator|>
literal|0
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
name|int
name|nextc
init|=
operator|-
literal|2
decl_stmt|;
comment|// not yet read
if|if
condition|(
name|ch
operator|==
name|closeBrace
condition|)
block|{
name|braces
operator|--
expr_stmt|;
name|braces
operator|=
name|checkForMissingCloseParen
argument_list|(
name|braces
argument_list|)
expr_stmt|;
if|if
condition|(
name|braces
operator|!=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|openBrace
condition|)
block|{
name|braces
operator|++
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|//patched by ram
name|char
name|next
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|next
condition|)
block|{
case|case
literal|'n'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|')'
case|:
comment|// PDFBox 276 /Title (c:\)
name|braces
operator|=
name|checkForMissingCloseParen
argument_list|(
name|braces
argument_list|)
expr_stmt|;
if|if
condition|(
name|braces
operator|!=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'('
case|:
case|case
literal|'\\'
case|:
name|out
operator|.
name|write
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
case|case
literal|13
case|:
comment|//this is a break in the line so ignore it and the newline and continue
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
while|while
condition|(
name|isEOL
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|nextc
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
name|StringBuffer
name|octal
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|octal
operator|.
name|append
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|char
name|digit
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|'0'
operator|&&
name|digit
operator|<=
literal|'7'
condition|)
block|{
name|octal
operator|.
name|append
argument_list|(
name|digit
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|digit
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|'0'
operator|&&
name|digit
operator|<=
literal|'7'
condition|)
block|{
name|octal
operator|.
name|append
argument_list|(
name|digit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextc
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
name|nextc
operator|=
name|c
expr_stmt|;
block|}
name|int
name|character
init|=
literal|0
decl_stmt|;
try|try
block|{
name|character
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|octal
operator|.
name|toString
argument_list|()
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected octal character, actual='"
operator|+
name|octal
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|out
operator|.
name|write
argument_list|(
name|character
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
comment|// dropping the backslash
comment|// see 7.3.4.2 Literal Strings for further information
name|out
operator|.
name|write
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextc
operator|!=
operator|-
literal|2
condition|)
block|{
name|c
operator|=
name|nextc
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|COSString
argument_list|(
name|out
operator|.
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will parse a PDF HEX string with fail fast semantic      * meaning that we stop if a not allowed character is found.      * This is necessary in order to detect malformed input and      * be able to skip to next object start.      *      * We assume starting '&lt;' was already read.      *       * @return The parsed PDF string.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|private
name|COSString
name|parseCOSHexString
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|StringBuilder
name|sBuf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|isHexDigit
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
name|sBuf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing closing bracket for hex string. Reached EOS."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\t'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\b'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\f'
operator|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
comment|// if invalid chars was found: discard last
comment|// hex character if it is not part of a pair
if|if
condition|(
name|sBuf
operator|.
name|length
argument_list|()
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|sBuf
operator|.
name|deleteCharAt
argument_list|(
name|sBuf
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// read till the closing bracket was found
do|do
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'>'
operator|&&
name|c
operator|>=
literal|0
condition|)
do|;
comment|// might have reached EOF while looking for the closing bracket
comment|// this can happen for malformed PDFs only. Make sure that there is
comment|// no endless loop.
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing closing bracket for hex string. Reached EOS."
argument_list|)
throw|;
block|}
comment|// exit loop
break|break;
block|}
block|}
return|return
name|COSString
operator|.
name|parseHex
argument_list|(
name|sBuf
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will parse a PDF array object.      *      * @return The parsed PDF array.      *      * @throws IOException If there is an error parsing the stream.      */
specifier|protected
name|COSArray
name|parseCOSArray
parameter_list|()
throws|throws
name|IOException
block|{
name|readExpectedChar
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|COSArray
name|po
init|=
operator|new
name|COSArray
argument_list|()
decl_stmt|;
name|COSBase
name|pbo
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|i
operator|=
name|pdfSource
operator|.
name|peek
argument_list|()
operator|)
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|char
operator|)
name|i
operator|!=
literal|']'
operator|)
condition|)
block|{
name|pbo
operator|=
name|parseDirObject
argument_list|()
expr_stmt|;
if|if
condition|(
name|pbo
operator|instanceof
name|COSObject
condition|)
block|{
comment|// We have to check if the expected values are there or not PDFBOX-385
if|if
condition|(
name|po
operator|.
name|get
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|instanceof
name|COSInteger
condition|)
block|{
name|COSInteger
name|genNumber
init|=
operator|(
name|COSInteger
operator|)
name|po
operator|.
name|remove
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|po
operator|.
name|get
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|instanceof
name|COSInteger
condition|)
block|{
name|COSInteger
name|number
init|=
operator|(
name|COSInteger
operator|)
name|po
operator|.
name|remove
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|COSObjectKey
name|key
init|=
operator|new
name|COSObjectKey
argument_list|(
name|number
operator|.
name|intValue
argument_list|()
argument_list|,
name|genNumber
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|pbo
operator|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the object reference is somehow wrong
name|pbo
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|pbo
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pbo
operator|!=
literal|null
condition|)
block|{
name|po
operator|.
name|add
argument_list|(
name|pbo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//it could be a bad object in the array which is just skipped
name|LOG
operator|.
name|warn
argument_list|(
literal|"Corrupt object reference at offset "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
comment|// This could also be an "endobj" or "endstream" which means we can assume that
comment|// the array has ended.
name|String
name|isThisTheEnd
init|=
name|readString
argument_list|()
decl_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
name|isThisTheEnd
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENDOBJ_STRING
operator|.
name|equals
argument_list|(
name|isThisTheEnd
argument_list|)
operator|||
name|ENDSTREAM_STRING
operator|.
name|equals
argument_list|(
name|isThisTheEnd
argument_list|)
condition|)
block|{
return|return
name|po
return|;
block|}
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
comment|//read ']'
name|skipSpaces
argument_list|()
expr_stmt|;
return|return
name|po
return|;
block|}
comment|/**      * Determine if a character terminates a PDF name.      *      * @param ch The character      * @return<code>true</code> if the character terminates a PDF name, otherwise<code>false</code>.      */
specifier|protected
name|boolean
name|isEndOfName
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|13
operator|||
name|ch
operator|==
literal|10
operator|||
name|ch
operator|==
literal|9
operator|||
name|ch
operator|==
literal|'>'
operator|||
name|ch
operator|==
literal|'<'
operator|||
name|ch
operator|==
literal|'['
operator|||
name|ch
operator|==
literal|'/'
operator|||
name|ch
operator|==
literal|']'
operator|||
name|ch
operator|==
literal|')'
operator|||
name|ch
operator|==
literal|'('
operator|)
return|;
block|}
comment|/**      * This will parse a PDF name from the stream.      *      * @return The parsed PDF name.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|COSName
name|parseCOSName
parameter_list|()
throws|throws
name|IOException
block|{
name|readExpectedChar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
comment|// costruisce il nome
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|char
name|ch1
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
name|char
name|ch2
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// Prior to PDF v1.2, the # was not a special character.  Also,
comment|// it has been observed that various PDF tools do not follow the
comment|// spec with respect to the # escape, even though they report
comment|// PDF versions of 1.2 or later.  The solution here is that we
comment|// interpret the # as an escape only when it is followed by two
comment|// valid hex digits.
comment|//
if|if
condition|(
name|isHexDigit
argument_list|(
name|ch1
argument_list|)
operator|&&
name|isHexDigit
argument_list|(
name|ch2
argument_list|)
condition|)
block|{
name|String
name|hex
init|=
literal|""
operator|+
name|ch1
operator|+
name|ch2
decl_stmt|;
try|try
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|hex
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: expected hex number, actual='"
operator|+
name|hex
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
name|c
operator|=
name|ch1
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isEndOfName
argument_list|(
name|ch
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|buffer
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|COSName
operator|.
name|getPDFName
argument_list|(
name|buffer
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will parse a boolean object from the stream.      *      * @return The parsed boolean object.      *      * @throws IOException If an IO error occurs during parsing.      */
specifier|protected
name|COSBoolean
name|parseBoolean
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBoolean
name|retval
init|=
literal|null
decl_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
block|{
name|String
name|trueString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|4
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|trueString
operator|.
name|equals
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean: expected='true' actual='"
operator|+
name|trueString
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
block|{
name|String
name|falseString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|5
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|falseString
operator|.
name|equals
argument_list|(
name|FALSE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean: expected='true' actual='"
operator|+
name|falseString
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean expected='t or f' actual='"
operator|+
name|c
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will parse a directory object from the stream.      *      * @return The parsed object.      *      * @throws IOException If there is an error during parsing.      */
specifier|protected
name|COSBase
name|parseDirObject
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBase
name|retval
init|=
literal|null
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|nextByte
init|=
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|nextByte
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
block|{
name|int
name|leftBracket
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//pull off first left bracket
name|c
operator|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
expr_stmt|;
comment|//check for second left bracket
name|pdfSource
operator|.
name|unread
argument_list|(
name|leftBracket
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|retval
operator|=
name|parseCOSDictionary
argument_list|()
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|parseCOSString
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'['
case|:
comment|// array
block|{
name|retval
operator|=
name|parseCOSArray
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
literal|'('
case|:
name|retval
operator|=
name|parseCOSString
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|// name
name|retval
operator|=
name|parseCOSName
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|// null
block|{
name|readExpectedString
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|COSNull
operator|.
name|NULL
expr_stmt|;
break|break;
block|}
case|case
literal|'t'
case|:
block|{
name|String
name|trueString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|4
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
name|trueString
operator|.
name|equals
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|TRUE
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected true actual='"
operator|+
name|trueString
operator|+
literal|"' "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
break|break;
block|}
case|case
literal|'f'
case|:
block|{
name|String
name|falseString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|5
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
name|falseString
operator|.
name|equals
argument_list|(
name|FALSE
argument_list|)
condition|)
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|FALSE
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected false actual='"
operator|+
name|falseString
operator|+
literal|"' "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
break|break;
block|}
case|case
literal|'R'
case|:
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|retval
operator|=
operator|new
name|COSObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|char
operator|)
operator|-
literal|1
case|:
return|return
literal|null
return|;
default|default:
block|{
if|if
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'.'
condition|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|ic
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|ic
expr_stmt|;
while|while
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'e'
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ic
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|ic
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|COSNumber
operator|.
name|get
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//This is not suppose to happen, but we will allow for it
comment|//so we are more compatible with POS writers that don't
comment|//follow the spec
name|String
name|badString
init|=
name|readString
argument_list|()
decl_stmt|;
comment|//throw new IOException( "Unknown dir object c='" + c +
comment|//"' peek='" + (char)pdfSource.peek() + "' " + pdfSource );
if|if
condition|(
name|badString
operator|==
literal|null
operator|||
name|badString
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|int
name|peek
init|=
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// we can end up in an infinite loop otherwise
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown dir object c='"
operator|+
name|c
operator|+
literal|"' cInt="
operator|+
operator|(
name|int
operator|)
name|c
operator|+
literal|" peek='"
operator|+
operator|(
name|char
operator|)
name|peek
operator|+
literal|"' peekInt="
operator|+
name|peek
operator|+
literal|" "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
comment|// if it's an endstream/endobj, we want to put it back so the caller will see it
if|if
condition|(
name|ENDOBJ_STRING
operator|.
name|equals
argument_list|(
name|badString
argument_list|)
operator|||
name|ENDSTREAM_STRING
operator|.
name|equals
argument_list|(
name|badString
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|badString
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read the next string from the stream.      *      * @return The string that was read from the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readString
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|isEndOfName
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Read one String and throw an exception if it is not the expected value.      *      * @param es the String value that is expected.      * @throws IOException if the String char is not the expected value or if an      * I/O error occurs.      */
specifier|protected
name|void
name|readExpectedString
parameter_list|(
name|String
name|es
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|s
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|equals
argument_list|(
name|es
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='"
operator|+
name|es
operator|+
literal|"' actual='"
operator|+
name|s
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Read one char and throw an exception if it is not the expected value.      *      * @param ec the char value that is expected.      * @throws IOException if the read char is not the expected value or if an      * I/O error occurs.      */
specifier|protected
name|void
name|readExpectedChar
parameter_list|(
name|char
name|ec
parameter_list|)
throws|throws
name|IOException
block|{
name|char
name|c
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|ec
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='"
operator|+
name|ec
operator|+
literal|"' actual='"
operator|+
name|c
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * This will read the next string from the stream up to a certain length.      *      * @param length The length to stop reading at.      *      * @return The string that was read from the stream of length 0 to length.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readString
parameter_list|(
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//average string size is around 2 and the normal string buffer size is
comment|//about 16 so lets save some space.
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|isClosing
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
operator|&&
name|buffer
operator|.
name|length
argument_list|()
operator|<
name|length
operator|&&
name|c
operator|!=
literal|'['
operator|&&
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|'('
operator|&&
name|c
operator|!=
literal|'/'
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will tell if the next character is a closing brace( close of PDF array ).      *      * @return true if the next byte is ']', false otherwise.      *      * @throws IOException If an IO error occurs.      */
specifier|protected
name|boolean
name|isClosing
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isClosing
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the next character is a closing brace( close of PDF array ).      *      * @param c The character to check against end of line      * @return true if the next byte is ']', false otherwise.      */
specifier|protected
name|boolean
name|isClosing
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|']'
return|;
block|}
comment|/**      * This will read bytes until the first end of line marker occurs.      * Note: if you later unread the results of this function, you'll      * need to add a newline character to the end of the string.      *      * @return The characters between the current position and the end of the line.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readLine
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pdfSource
operator|.
name|isEOF
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: End-of-File, expected line"
argument_list|)
throw|;
block|}
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
literal|11
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|isEOL
argument_list|(
name|c
argument_list|)
condition|)
block|{
break|break;
block|}
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will tell if the next byte to be read is an end of line byte.      *      * @return true if the next byte is 0x0A or 0x0D.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isEOL
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isEOL
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the next byte to be read is an end of line byte.      *      * @param c The character to check against end of line      * @return true if the next byte is 0x0A or 0x0D.      */
specifier|protected
name|boolean
name|isEOL
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|10
operator|||
name|c
operator|==
literal|13
return|;
block|}
comment|/**      * This will tell if the next byte is whitespace or not.      *      * @return true if the next byte in the stream is a whitespace character.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isWhitespace
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isWhitespace
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the next byte is whitespace or not.  These values are      * specified in table 1 (page 12) of ISO 32000-1:2008.      * @param c The character to check against whitespace      * @return true if the next byte in the stream is a whitespace character.      */
specifier|protected
name|boolean
name|isWhitespace
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|9
operator|||
name|c
operator|==
literal|12
operator|||
name|c
operator|==
literal|10
operator|||
name|c
operator|==
literal|13
operator|||
name|c
operator|==
literal|32
return|;
block|}
comment|/**      * This will skip all spaces and comments that are present.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|void
name|skipSpaces
parameter_list|()
throws|throws
name|IOException
block|{
comment|//log( "skipSpaces() " + pdfSource );
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// identical to, but faster as: isWhiteSpace(c) || c == 37
while|while
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|9
operator|||
name|c
operator|==
literal|12
operator|||
name|c
operator|==
literal|10
operator|||
name|c
operator|==
literal|13
operator|||
name|c
operator|==
literal|32
operator|||
name|c
operator|==
literal|37
condition|)
comment|//37 is the % character, a comment
block|{
if|if
condition|(
name|c
operator|==
literal|37
condition|)
block|{
comment|// skip past the comment section
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|isEOL
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|//log( "skipSpaces() done peek='" + (char)pdfSource.peek() + "'" );
block|}
comment|/**      * This will read a long from the Stream and throw an {@link IOException} if      * the long value is negative or has more than 10 digits (i.e. : bigger than      * {@link #OBJECT_NUMBER_THRESHOLD})      *      * @return the object number being read.      * @throws IOException if an I/O error occurs      */
specifier|protected
name|long
name|readObjectNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|retval
init|=
name|readLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
operator|||
name|retval
operator|>=
name|OBJECT_NUMBER_THRESHOLD
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object Number '"
operator|+
name|retval
operator|+
literal|"' has more than 10 digits or is negative"
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read a integer from the Stream and throw an {@link IllegalArgumentException} if the integer value      * has more than the maximum object revision (i.e. : bigger than {@link #GENERATION_NUMBER_THRESHOLD})      * @return the generation number being read.      * @throws IOException if an I/O error occurs      */
specifier|protected
name|int
name|readGenerationNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|retval
init|=
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|retval
argument_list|<
literal|0
operator|||
name|retval
argument_list|>
name|GENERATION_NUMBER_THRESHOLD
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Generation Number '"
operator|+
name|retval
operator|+
literal|"' has more than 5 digits"
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read an integer from the stream.      *      * @return The integer that was read from the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|int
name|readInt
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|intBuffer
init|=
name|readStringNumber
argument_list|()
decl_stmt|;
try|try
block|{
name|retval
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|intBuffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|intBuffer
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected an integer type at offset "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read an long from the stream.      *      * @return The long that was read from the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|long
name|readLong
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|long
name|retval
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|longBuffer
init|=
name|readStringNumber
argument_list|()
decl_stmt|;
try|try
block|{
name|retval
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|longBuffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|longBuffer
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected a long type at offset "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
operator|+
literal|", instead got '"
operator|+
name|longBuffer
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This method is used to read a token by the {@linkplain #readInt()} method      * and the {@linkplain #readLong()} method.      *      * @return the token to parse as integer or long by the calling method.      * @throws IOException throws by the {@link #pdfSource} methods.      */
specifier|protected
specifier|final
name|StringBuilder
name|readStringNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|lastByte
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|lastByte
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
operator|)
operator|!=
literal|32
operator|&&
name|lastByte
operator|!=
literal|10
operator|&&
name|lastByte
operator|!=
literal|13
operator|&&
name|lastByte
operator|!=
literal|60
operator|&&
comment|//see sourceforge bug 1714707
name|lastByte
operator|!=
literal|'['
operator|&&
comment|// PDFBOX-1845
name|lastByte
operator|!=
literal|'('
operator|&&
comment|// PDFBOX-2579
name|lastByte
operator|!=
literal|0
operator|&&
comment|//See sourceforge bug 853328
name|lastByte
operator|!=
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|lastByte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastByte
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|lastByte
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
comment|/**      * Skip to the start of the next object. This is used to recover from a      * corrupt object. This should handle all cases that parseObject supports.      * This assumes that the next object will start on its own line.      *      * @throws IOException      */
specifier|protected
name|void
name|skipToNextObj
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
literal|16
index|]
decl_stmt|;
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\d+\\s+\\d+\\s+obj.*"
argument_list|,
name|Pattern
operator|.
name|DOTALL
argument_list|)
decl_stmt|;
comment|/* Read a buffer of data each time to see if it starts with a          * known keyword. This is not the most efficient design, but we should          * rarely be needing this function. We could update this to use the          * circular buffer, like in readUntilEndStream().          */
while|while
condition|(
operator|!
name|pdfSource
operator|.
name|isEOF
argument_list|()
condition|)
block|{
name|int
name|l
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|<
literal|1
condition|)
block|{
break|break;
block|}
name|String
name|s
init|=
operator|new
name|String
argument_list|(
name|b
argument_list|,
literal|"US-ASCII"
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
literal|"trailer"
argument_list|)
operator|||
name|s
operator|.
name|startsWith
argument_list|(
literal|"xref"
argument_list|)
operator|||
name|s
operator|.
name|startsWith
argument_list|(
literal|"startxref"
argument_list|)
operator|||
name|s
operator|.
name|startsWith
argument_list|(
literal|"stream"
argument_list|)
operator|||
name|p
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
name|l
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Release all used resources.      */
specifier|public
name|void
name|clearResources
parameter_list|()
block|{
name|document
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|pdfSource
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|pdfSource
argument_list|)
expr_stmt|;
name|pdfSource
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**      * Parse object key (number and generation).      *      * @param continueOnError true to continue on error, false if not.      * @return a new object key.      * @throws IOException if something goes wrong.      */
specifier|protected
name|COSObjectKey
name|parseObjectKey
parameter_list|(
name|boolean
name|continueOnError
parameter_list|)
throws|throws
name|IOException
block|{
comment|//we are going to parse a normal object
name|long
name|number
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|genNum
decl_stmt|;
name|boolean
name|missingObjectNumber
init|=
literal|false
decl_stmt|;
try|try
block|{
name|char
name|peeked
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|peeked
operator|==
literal|'<'
condition|)
block|{
name|missingObjectNumber
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|number
operator|=
name|readObjectNumber
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//ok for some reason "GNU Ghostscript 5.10" puts two endobj
comment|//statements after an object, of course this is nonsense
comment|//but because we want to support as many PDFs as possible
comment|//we will simply try again
name|number
operator|=
name|readObjectNumber
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|missingObjectNumber
condition|)
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|genNum
operator|=
name|readGenerationNumber
argument_list|()
expr_stmt|;
name|String
name|objectKey
init|=
name|readString
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|objectKey
operator|.
name|equals
argument_list|(
literal|"obj"
argument_list|)
operator|&&
name|continueOnError
operator|&&
name|objectKey
operator|.
name|equals
argument_list|(
literal|"o"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='obj' actual='"
operator|+
name|objectKey
operator|+
literal|"' "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
comment|//assume that "o" was meant to be "obj" (this is a workaround for
comment|// PDFBOX-773 attached PDF Andersens_Fairy_Tales.pdf).
block|}
else|else
block|{
name|number
operator|=
operator|-
literal|1
expr_stmt|;
name|genNum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|new
name|COSObjectKey
argument_list|(
name|number
argument_list|,
name|genNum
argument_list|)
return|;
block|}
block|}
end_class

end_unit

