begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharacterCodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetDecoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObjectKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|Charsets
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|Charsets
operator|.
name|ISO_8859_1
import|;
end_import

begin_comment
comment|/**  * This class is used to contain parsing logic that will be used by both the  * PDFParser and the COSStreamParser.  *  * @author Ben Litchfield  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|BaseParser
block|{
specifier|private
specifier|static
specifier|final
name|long
name|OBJECT_NUMBER_THRESHOLD
init|=
literal|10000000000L
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|GENERATION_NUMBER_THRESHOLD
init|=
literal|65535
decl_stmt|;
specifier|static
specifier|final
name|int
name|MAX_LENGTH_LONG
init|=
name|Long
operator|.
name|toString
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
operator|.
name|length
argument_list|()
decl_stmt|;
comment|/**      * Log instance.      */
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BaseParser
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|E
init|=
literal|'e'
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|N
init|=
literal|'n'
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|D
init|=
literal|'d'
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|S
init|=
literal|'s'
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|T
init|=
literal|'t'
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|R
init|=
literal|'r'
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|A
init|=
literal|'a'
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|M
init|=
literal|'m'
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|O
init|=
literal|'o'
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|B
init|=
literal|'b'
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|J
init|=
literal|'j'
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|public
specifier|static
specifier|final
name|String
name|DEF
init|=
literal|"def"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|protected
specifier|static
specifier|final
name|String
name|ENDOBJ_STRING
init|=
literal|"endobj"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|protected
specifier|static
specifier|final
name|String
name|ENDSTREAM_STRING
init|=
literal|"endstream"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|protected
specifier|static
specifier|final
name|String
name|STREAM_STRING
init|=
literal|"stream"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|TRUE
init|=
literal|"true"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|FALSE
init|=
literal|"false"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|NULL
init|=
literal|"null"
decl_stmt|;
comment|/**      * ASCII code for line feed.      */
specifier|protected
specifier|static
specifier|final
name|byte
name|ASCII_LF
init|=
literal|10
decl_stmt|;
comment|/**      * ASCII code for carriage return.      */
specifier|protected
specifier|static
specifier|final
name|byte
name|ASCII_CR
init|=
literal|13
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|ASCII_ZERO
init|=
literal|48
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|ASCII_NINE
init|=
literal|57
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|ASCII_SPACE
init|=
literal|32
decl_stmt|;
comment|/**      * This is the stream that will be read from.      */
specifier|protected
specifier|final
name|SequentialSource
name|seqSource
decl_stmt|;
comment|/**      * This is the document that will be parsed.      */
specifier|protected
name|COSDocument
name|document
decl_stmt|;
comment|/**      * Default constructor.      */
specifier|public
name|BaseParser
parameter_list|(
name|SequentialSource
name|pdfSource
parameter_list|)
block|{
name|this
operator|.
name|seqSource
operator|=
name|pdfSource
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isHexDigit
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|isDigit
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
return|;
block|}
comment|/**      * This will parse a PDF dictionary value.      *      * @return The parsed Dictionary object.      *      * @throws IOException If there is an error parsing the dictionary object.      */
specifier|private
name|COSBase
name|parseCOSDictionaryValue
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|numOffset
init|=
name|seqSource
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|COSBase
name|value
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
comment|// proceed if the given object is a number and the following is a number as well
if|if
condition|(
operator|!
operator|(
name|value
operator|instanceof
name|COSNumber
operator|)
operator|||
operator|!
name|isDigit
argument_list|()
condition|)
block|{
return|return
name|value
return|;
block|}
comment|// read the remaining information of the object number
name|long
name|genOffset
init|=
name|seqSource
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|COSBase
name|generationNumber
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|readExpectedChar
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|value
operator|instanceof
name|COSInteger
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected number, actual="
operator|+
name|value
operator|+
literal|" at offset "
operator|+
name|numOffset
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|generationNumber
operator|instanceof
name|COSInteger
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected number, actual="
operator|+
name|value
operator|+
literal|" at offset "
operator|+
name|genOffset
argument_list|)
throw|;
block|}
name|COSObjectKey
name|key
init|=
operator|new
name|COSObjectKey
argument_list|(
operator|(
operator|(
name|COSInteger
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
argument_list|,
operator|(
operator|(
name|COSInteger
operator|)
name|generationNumber
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
comment|// dereference the object
return|return
name|getObjectFromPool
argument_list|(
name|key
argument_list|)
return|;
block|}
specifier|private
name|COSBase
name|getObjectFromPool
parameter_list|(
name|COSObjectKey
name|key
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|document
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"object reference "
operator|+
name|key
operator|+
literal|" at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
operator|+
literal|" in content stream"
argument_list|)
throw|;
block|}
return|return
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**      * This will parse a PDF dictionary.      *      * @return The parsed dictionary, never null.      *      * @throws IOException If there is an error reading the stream.      */
specifier|protected
name|COSDictionary
name|parseCOSDictionary
parameter_list|()
throws|throws
name|IOException
block|{
name|readExpectedChar
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|readExpectedChar
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSDictionary
name|obj
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|seqSource
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|parseCOSDictionaryNameValuePair
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// invalid dictionary, we were expecting a /Name, read until the end or until we can recover
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid dictionary, found: '"
operator|+
name|c
operator|+
literal|"' but expected: '/' at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|readUntilEndOfCOSDictionary
argument_list|()
condition|)
block|{
comment|// we couldn't recover
return|return
name|obj
return|;
block|}
block|}
block|}
name|readExpectedChar
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|readExpectedChar
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
comment|/**      * Keep reading until the end of the dictionary object or the file has been hit, or until a '/'      * has been found.      *      * @return true if the end of the object or the file has been found, false if not, i.e. that the      * caller can continue to parse the dictionary at the current position.      *      * @throws IOException if there is a reading error.      */
specifier|private
name|boolean
name|readUntilEndOfCOSDictionary
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
operator|-
literal|1
operator|&&
name|c
operator|!=
literal|'/'
operator|&&
name|c
operator|!=
literal|'>'
condition|)
block|{
comment|// in addition to stopping when we find / or>, we also want
comment|// to stop when we find endstream or endobj.
if|if
condition|(
name|c
operator|==
name|E
condition|)
block|{
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|N
condition|)
block|{
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|D
condition|)
block|{
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|boolean
name|isStream
init|=
name|c
operator|==
name|S
operator|&&
name|seqSource
operator|.
name|read
argument_list|()
operator|==
name|T
operator|&&
name|seqSource
operator|.
name|read
argument_list|()
operator|==
name|R
operator|&&
name|seqSource
operator|.
name|read
argument_list|()
operator|==
name|E
operator|&&
name|seqSource
operator|.
name|read
argument_list|()
operator|==
name|A
operator|&&
name|seqSource
operator|.
name|read
argument_list|()
operator|==
name|M
decl_stmt|;
name|boolean
name|isObj
init|=
operator|!
name|isStream
operator|&&
name|c
operator|==
name|O
operator|&&
name|seqSource
operator|.
name|read
argument_list|()
operator|==
name|B
operator|&&
name|seqSource
operator|.
name|read
argument_list|()
operator|==
name|J
decl_stmt|;
if|if
condition|(
name|isStream
operator|||
name|isObj
condition|)
block|{
comment|// we're done reading this object!
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|true
return|;
block|}
name|seqSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|parseCOSDictionaryNameValuePair
parameter_list|(
name|COSDictionary
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|COSName
name|key
init|=
name|parseCOSName
argument_list|()
decl_stmt|;
name|COSBase
name|value
init|=
name|parseCOSDictionaryValue
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char
operator|)
name|seqSource
operator|.
name|peek
argument_list|()
operator|)
operator|==
literal|'d'
condition|)
block|{
comment|// if the next string is 'def' then we are parsing a cmap stream
comment|// and want to ignore it, otherwise throw an exception.
name|String
name|potentialDEF
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|potentialDEF
operator|.
name|equals
argument_list|(
name|DEF
argument_list|)
condition|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|potentialDEF
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Bad dictionary declaration at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// label this item as direct, to avoid signature problems.
name|value
operator|.
name|setDirect
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|obj
operator|.
name|setItem
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|skipWhiteSpaces
parameter_list|()
throws|throws
name|IOException
block|{
comment|//PDF Ref 3.2.7 A stream must be followed by either
comment|//a CRLF or LF but nothing else.
name|int
name|whitespace
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//see brother_scan_cover.pdf, it adds whitespaces
comment|//after the stream but before the start of the
comment|//data, so just read those first
while|while
condition|(
name|ASCII_SPACE
operator|==
name|whitespace
condition|)
block|{
name|whitespace
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ASCII_CR
operator|==
name|whitespace
condition|)
block|{
name|whitespace
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|ASCII_LF
operator|!=
name|whitespace
condition|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
comment|//The spec says this is invalid but it happens in the real
comment|//world so we must support it.
block|}
block|}
elseif|else
if|if
condition|(
name|ASCII_LF
operator|!=
name|whitespace
condition|)
block|{
comment|//we are in an error.
comment|//but again we will do a lenient parsing and just assume that everything
comment|//is fine
name|seqSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This is really a bug in the Document creators code, but it caused a crash in PDFBox, the first bug was in this      * format: /Title ( (5) /Creator which was patched in 1 place.      *      * However it missed the case where the number of opening and closing parenthesis isn't balanced      *      * The second bug was in this format /Title (c:\) /Producer      *      * This patch moves this code out of the parseCOSString method, so it can be used twice.      *      * @param bracesParameter the number of braces currently open.      *      * @return the corrected value of the brace counter      * @throws IOException      */
specifier|private
name|int
name|checkForEndOfString
parameter_list|(
specifier|final
name|int
name|bracesParameter
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|braces
init|=
name|bracesParameter
decl_stmt|;
name|byte
index|[]
name|nextThreeBytes
init|=
operator|new
name|byte
index|[
literal|3
index|]
decl_stmt|;
name|int
name|amountRead
init|=
name|seqSource
operator|.
name|read
argument_list|(
name|nextThreeBytes
argument_list|)
decl_stmt|;
comment|// Check the next 3 bytes if available
comment|// The following cases are valid indicators for the end of the string
comment|// 1. Next line contains another COSObject: CR + LF + '/'
comment|// 2. COSDictionary ends in the next line: CR + LF + '>'
comment|// 3. Next line contains another COSObject: CR + '/'
comment|// 4. COSDictionary ends in the next line: CR + '>'
if|if
condition|(
name|amountRead
operator|==
literal|3
operator|&&
name|nextThreeBytes
index|[
literal|0
index|]
operator|==
name|ASCII_CR
condition|)
block|{
if|if
condition|(
operator|(
name|nextThreeBytes
index|[
literal|1
index|]
operator|==
name|ASCII_LF
operator|&&
operator|(
name|nextThreeBytes
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
operator|||
name|nextThreeBytes
index|[
literal|2
index|]
operator|==
literal|'>'
operator|)
operator|||
name|nextThreeBytes
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|nextThreeBytes
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
name|braces
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|amountRead
operator|>
literal|0
condition|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|nextThreeBytes
argument_list|,
literal|0
argument_list|,
name|amountRead
argument_list|)
expr_stmt|;
block|}
return|return
name|braces
return|;
block|}
comment|/**      * This will parse a PDF string.      *      * @return The parsed PDF string.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|COSString
name|parseCOSString
parameter_list|()
throws|throws
name|IOException
block|{
name|char
name|nextChar
init|=
operator|(
name|char
operator|)
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextChar
operator|==
literal|'<'
condition|)
block|{
return|return
name|parseCOSHexString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|nextChar
operator|!=
literal|'('
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"parseCOSString string should start with '(' or '<' and not '"
operator|+
name|nextChar
operator|+
literal|"' at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
name|ByteArrayOutputStream
name|out
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
comment|// This is the number of braces read
name|int
name|braces
init|=
literal|1
decl_stmt|;
name|int
name|c
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|braces
operator|>
literal|0
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
name|int
name|nextc
init|=
operator|-
literal|2
decl_stmt|;
comment|// not yet read
if|if
condition|(
name|ch
operator|==
literal|')'
condition|)
block|{
name|braces
operator|--
expr_stmt|;
name|braces
operator|=
name|checkForEndOfString
argument_list|(
name|braces
argument_list|)
expr_stmt|;
if|if
condition|(
name|braces
operator|!=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'('
condition|)
block|{
name|braces
operator|++
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|//patched by ram
name|char
name|next
init|=
operator|(
name|char
operator|)
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|next
condition|)
block|{
case|case
literal|'n'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|')'
case|:
comment|// PDFBox 276 /Title (c:\)
name|braces
operator|=
name|checkForEndOfString
argument_list|(
name|braces
argument_list|)
expr_stmt|;
if|if
condition|(
name|braces
operator|!=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'('
case|:
case|case
literal|'\\'
case|:
name|out
operator|.
name|write
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASCII_LF
case|:
case|case
name|ASCII_CR
case|:
comment|//this is a break in the line so ignore it and the newline and continue
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
while|while
condition|(
name|isEOL
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|nextc
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
name|StringBuilder
name|octal
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|octal
operator|.
name|append
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|char
name|digit
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|'0'
operator|&&
name|digit
operator|<=
literal|'7'
condition|)
block|{
name|octal
operator|.
name|append
argument_list|(
name|digit
argument_list|)
expr_stmt|;
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|digit
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|'0'
operator|&&
name|digit
operator|<=
literal|'7'
condition|)
block|{
name|octal
operator|.
name|append
argument_list|(
name|digit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextc
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
name|nextc
operator|=
name|c
expr_stmt|;
block|}
name|int
name|character
init|=
literal|0
decl_stmt|;
try|try
block|{
name|character
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|octal
operator|.
name|toString
argument_list|()
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected octal character, actual='"
operator|+
name|octal
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|out
operator|.
name|write
argument_list|(
name|character
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
comment|// dropping the backslash
comment|// see 7.3.4.2 Literal Strings for further information
name|out
operator|.
name|write
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextc
operator|!=
operator|-
literal|2
condition|)
block|{
name|c
operator|=
name|nextc
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|COSString
argument_list|(
name|out
operator|.
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will parse a PDF HEX string with fail fast semantic      * meaning that we stop if a not allowed character is found.      * This is necessary in order to detect malformed input and      * be able to skip to next object start.      *      * We assume starting '&lt;' was already read.      *       * @return The parsed PDF string.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|private
name|COSString
name|parseCOSHexString
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|StringBuilder
name|sBuf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|c
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|isHexDigit
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
name|sBuf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing closing bracket for hex string. Reached EOS."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\t'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\b'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\f'
operator|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
comment|// if invalid chars was found: discard last
comment|// hex character if it is not part of a pair
if|if
condition|(
name|sBuf
operator|.
name|length
argument_list|()
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|sBuf
operator|.
name|deleteCharAt
argument_list|(
name|sBuf
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// read till the closing bracket was found
do|do
block|{
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'>'
operator|&&
name|c
operator|>=
literal|0
condition|)
do|;
comment|// might have reached EOF while looking for the closing bracket
comment|// this can happen for malformed PDFs only. Make sure that there is
comment|// no endless loop.
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing closing bracket for hex string. Reached EOS."
argument_list|)
throw|;
block|}
comment|// exit loop
break|break;
block|}
block|}
return|return
name|COSString
operator|.
name|parseHex
argument_list|(
name|sBuf
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will parse a PDF array object.      *      * @return The parsed PDF array.      *      * @throws IOException If there is an error parsing the stream.      */
specifier|protected
name|COSArray
name|parseCOSArray
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|startPosition
init|=
name|seqSource
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|readExpectedChar
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|COSArray
name|po
init|=
operator|new
name|COSArray
argument_list|()
decl_stmt|;
name|COSBase
name|pbo
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|i
operator|=
name|seqSource
operator|.
name|peek
argument_list|()
operator|)
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|char
operator|)
name|i
operator|!=
literal|']'
operator|)
condition|)
block|{
name|pbo
operator|=
name|parseDirObject
argument_list|()
expr_stmt|;
if|if
condition|(
name|pbo
operator|instanceof
name|COSObject
condition|)
block|{
comment|// We have to check if the expected values are there or not PDFBOX-385
if|if
condition|(
name|po
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|po
operator|.
name|get
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|instanceof
name|COSInteger
condition|)
block|{
name|COSInteger
name|genNumber
init|=
operator|(
name|COSInteger
operator|)
name|po
operator|.
name|remove
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|po
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|po
operator|.
name|get
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|instanceof
name|COSInteger
condition|)
block|{
name|COSInteger
name|number
init|=
operator|(
name|COSInteger
operator|)
name|po
operator|.
name|remove
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|COSObjectKey
name|key
init|=
operator|new
name|COSObjectKey
argument_list|(
name|number
operator|.
name|longValue
argument_list|()
argument_list|,
name|genNumber
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|pbo
operator|=
name|getObjectFromPool
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the object reference is somehow wrong
name|pbo
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|pbo
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pbo
operator|!=
literal|null
condition|)
block|{
name|po
operator|.
name|add
argument_list|(
name|pbo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//it could be a bad object in the array which is just skipped
name|LOG
operator|.
name|warn
argument_list|(
literal|"Corrupt object reference at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
operator|+
literal|", start offset: "
operator|+
name|startPosition
argument_list|)
expr_stmt|;
comment|// This could also be an "endobj" or "endstream" which means we can assume that
comment|// the array has ended.
name|String
name|isThisTheEnd
init|=
name|readString
argument_list|()
decl_stmt|;
name|seqSource
operator|.
name|unread
argument_list|(
name|isThisTheEnd
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENDOBJ_STRING
operator|.
name|equals
argument_list|(
name|isThisTheEnd
argument_list|)
operator|||
name|ENDSTREAM_STRING
operator|.
name|equals
argument_list|(
name|isThisTheEnd
argument_list|)
condition|)
block|{
return|return
name|po
return|;
block|}
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
comment|// read ']'
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
return|return
name|po
return|;
block|}
comment|/**      * Determine if a character terminates a PDF name.      *      * @param ch The character      * @return true if the character terminates a PDF name, otherwise false.      */
specifier|protected
name|boolean
name|isEndOfName
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
return|return
name|ch
operator|==
name|ASCII_SPACE
operator|||
name|ch
operator|==
name|ASCII_CR
operator|||
name|ch
operator|==
name|ASCII_LF
operator|||
name|ch
operator|==
literal|9
operator|||
name|ch
operator|==
literal|'>'
operator|||
name|ch
operator|==
literal|'<'
operator|||
name|ch
operator|==
literal|'['
operator|||
name|ch
operator|==
literal|'/'
operator|||
name|ch
operator|==
literal|']'
operator|||
name|ch
operator|==
literal|')'
operator|||
name|ch
operator|==
literal|'('
operator|||
name|ch
operator|==
literal|0
operator|||
name|ch
operator|==
literal|'\f'
return|;
block|}
comment|/**      * This will parse a PDF name from the stream.      *      * @return The parsed PDF name.      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|COSName
name|parseCOSName
parameter_list|()
throws|throws
name|IOException
block|{
name|readExpectedChar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|ByteArrayOutputStream
name|buffer
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|int
name|c
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|ch
init|=
name|c
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|int
name|ch1
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
name|int
name|ch2
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// Prior to PDF v1.2, the # was not a special character.  Also,
comment|// it has been observed that various PDF tools do not follow the
comment|// spec with respect to the # escape, even though they report
comment|// PDF versions of 1.2 or later.  The solution here is that we
comment|// interpret the # as an escape only when it is followed by two
comment|// valid hex digits.
if|if
condition|(
name|isHexDigit
argument_list|(
operator|(
name|char
operator|)
name|ch1
argument_list|)
operator|&&
name|isHexDigit
argument_list|(
operator|(
name|char
operator|)
name|ch2
argument_list|)
condition|)
block|{
name|String
name|hex
init|=
literal|""
operator|+
operator|(
name|char
operator|)
name|ch1
operator|+
operator|(
name|char
operator|)
name|ch2
decl_stmt|;
try|try
block|{
name|buffer
operator|.
name|write
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|hex
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: expected hex digit, actual='"
operator|+
name|hex
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// check for premature EOF
if|if
condition|(
name|ch2
operator|==
operator|-
literal|1
operator|||
name|ch1
operator|==
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Premature EOF in BaseParser#parseCOSName"
argument_list|)
expr_stmt|;
name|c
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|seqSource
operator|.
name|unread
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
name|c
operator|=
name|ch1
expr_stmt|;
name|buffer
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isEndOfName
argument_list|(
name|ch
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|buffer
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|bytes
init|=
name|buffer
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|String
name|string
decl_stmt|;
if|if
condition|(
name|isValidUTF8
argument_list|(
name|bytes
argument_list|)
condition|)
block|{
name|string
operator|=
operator|new
name|String
argument_list|(
name|buffer
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// some malformed PDFs don't use UTF-8 see PDFBOX-3347
name|string
operator|=
operator|new
name|String
argument_list|(
name|buffer
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|Charsets
operator|.
name|WINDOWS_1252
argument_list|)
expr_stmt|;
block|}
return|return
name|COSName
operator|.
name|getPDFName
argument_list|(
name|string
argument_list|)
return|;
block|}
comment|/**      * Returns true if a byte sequence is valid UTF-8.      */
specifier|private
name|boolean
name|isValidUTF8
parameter_list|(
name|byte
index|[]
name|input
parameter_list|)
block|{
name|CharsetDecoder
name|cs
init|=
name|Charsets
operator|.
name|UTF_8
operator|.
name|newDecoder
argument_list|()
decl_stmt|;
try|try
block|{
name|cs
operator|.
name|decode
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|input
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|CharacterCodingException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Character could not be decoded using Charsets.UTF_8 - returning false"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**      * This will parse a boolean object from the stream.      *      * @return The parsed boolean object.      *      * @throws IOException If an IO error occurs during parsing.      */
specifier|protected
name|COSBoolean
name|parseBoolean
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBoolean
name|retval
init|=
literal|null
decl_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|seqSource
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
block|{
name|String
name|trueString
init|=
operator|new
name|String
argument_list|(
name|seqSource
operator|.
name|readFully
argument_list|(
literal|4
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|trueString
operator|.
name|equals
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean: expected='true' actual='"
operator|+
name|trueString
operator|+
literal|"' at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
block|{
name|String
name|falseString
init|=
operator|new
name|String
argument_list|(
name|seqSource
operator|.
name|readFully
argument_list|(
literal|5
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|falseString
operator|.
name|equals
argument_list|(
name|FALSE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean: expected='true' actual='"
operator|+
name|falseString
operator|+
literal|"' at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean expected='t or f' actual='"
operator|+
name|c
operator|+
literal|"' at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will parse a directory object from the stream.      *      * @return The parsed object.      *      * @throws IOException If there is an error during parsing.      */
specifier|protected
name|COSBase
name|parseDirObject
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBase
name|retval
init|=
literal|null
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|nextByte
init|=
name|seqSource
operator|.
name|peek
argument_list|()
decl_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|nextByte
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
block|{
comment|// pull off first left bracket
name|int
name|leftBracket
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// check for second left bracket
name|c
operator|=
operator|(
name|char
operator|)
name|seqSource
operator|.
name|peek
argument_list|()
expr_stmt|;
name|seqSource
operator|.
name|unread
argument_list|(
name|leftBracket
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|retval
operator|=
name|parseCOSDictionary
argument_list|()
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|parseCOSString
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'['
case|:
block|{
comment|// array
name|retval
operator|=
name|parseCOSArray
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
literal|'('
case|:
name|retval
operator|=
name|parseCOSString
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|// name
name|retval
operator|=
name|parseCOSName
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
block|{
comment|// null
name|readExpectedString
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|COSNull
operator|.
name|NULL
expr_stmt|;
break|break;
block|}
case|case
literal|'t'
case|:
block|{
name|String
name|trueString
init|=
operator|new
name|String
argument_list|(
name|seqSource
operator|.
name|readFully
argument_list|(
literal|4
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
name|trueString
operator|.
name|equals
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|TRUE
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected true actual='"
operator|+
name|trueString
operator|+
literal|"' "
operator|+
name|seqSource
operator|+
literal|"' at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
break|break;
block|}
case|case
literal|'f'
case|:
block|{
name|String
name|falseString
init|=
operator|new
name|String
argument_list|(
name|seqSource
operator|.
name|readFully
argument_list|(
literal|5
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
name|falseString
operator|.
name|equals
argument_list|(
name|FALSE
argument_list|)
condition|)
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|FALSE
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected false actual='"
operator|+
name|falseString
operator|+
literal|"' "
operator|+
name|seqSource
operator|+
literal|"' at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
break|break;
block|}
case|case
literal|'R'
case|:
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|retval
operator|=
operator|new
name|COSObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|char
operator|)
operator|-
literal|1
case|:
return|return
literal|null
return|;
default|default:
block|{
if|if
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'.'
condition|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|ic
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|ic
expr_stmt|;
while|while
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'e'
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ic
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|ic
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|!=
operator|-
literal|1
condition|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|COSNumber
operator|.
name|get
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//This is not suppose to happen, but we will allow for it
comment|//so we are more compatible with POS writers that don't
comment|//follow the spec
name|String
name|badString
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
name|badString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|peek
init|=
name|seqSource
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// we can end up in an infinite loop otherwise
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown dir object c='"
operator|+
name|c
operator|+
literal|"' cInt="
operator|+
operator|(
name|int
operator|)
name|c
operator|+
literal|" peek='"
operator|+
operator|(
name|char
operator|)
name|peek
operator|+
literal|"' peekInt="
operator|+
name|peek
operator|+
literal|" at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
comment|// if it's an endstream/endobj, we want to put it back so the caller will see it
if|if
condition|(
name|ENDOBJ_STRING
operator|.
name|equals
argument_list|(
name|badString
argument_list|)
operator|||
name|ENDSTREAM_STRING
operator|.
name|equals
argument_list|(
name|badString
argument_list|)
condition|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|badString
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read the next string from the stream.      *      * @return The string that was read from the stream, never null.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readString
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|c
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|isEndOfName
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Read one String and throw an exception if it is not the expected value.      *      * @param expectedString the String value that is expected.      * @throws IOException if the String char is not the expected value or if an      * I/O error occurs.      */
specifier|protected
name|void
name|readExpectedString
parameter_list|(
name|String
name|expectedString
parameter_list|)
throws|throws
name|IOException
block|{
name|readExpectedString
argument_list|(
name|expectedString
operator|.
name|toCharArray
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reads given pattern from {@link #seqSource}. Skipping whitespace at start and end if wanted.      *       * @param expectedString pattern to be skipped      * @param skipSpaces if set to true spaces before and after the string will be skipped      * @throws IOException if pattern could not be read      */
specifier|protected
specifier|final
name|void
name|readExpectedString
parameter_list|(
specifier|final
name|char
index|[]
name|expectedString
parameter_list|,
name|boolean
name|skipSpaces
parameter_list|)
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
for|for
control|(
name|char
name|c
range|:
name|expectedString
control|)
block|{
if|if
condition|(
name|seqSource
operator|.
name|read
argument_list|()
operator|!=
name|c
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected string '"
operator|+
operator|new
name|String
argument_list|(
name|expectedString
argument_list|)
operator|+
literal|"' but missed at character '"
operator|+
name|c
operator|+
literal|"' at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
comment|/**      * Read one char and throw an exception if it is not the expected value.      *      * @param ec the char value that is expected.      * @throws IOException if the read char is not the expected value or if an      * I/O error occurs.      */
specifier|protected
name|void
name|readExpectedChar
parameter_list|(
name|char
name|ec
parameter_list|)
throws|throws
name|IOException
block|{
name|char
name|c
init|=
operator|(
name|char
operator|)
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|ec
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='"
operator|+
name|ec
operator|+
literal|"' actual='"
operator|+
name|c
operator|+
literal|"' at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * This will read the next string from the stream up to a certain length.      *      * @param length The length to stop reading at.      *      * @return The string that was read from the stream of length 0 to length.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readString
parameter_list|(
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|c
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//average string size is around 2 and the normal string buffer size is
comment|//about 16 so lets save some space.
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|isClosing
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
operator|&&
name|buffer
operator|.
name|length
argument_list|()
operator|<
name|length
operator|&&
name|c
operator|!=
literal|'['
operator|&&
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|'('
operator|&&
name|c
operator|!=
literal|'/'
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will tell if the next character is a closing brace( close of PDF array ).      *      * @return true if the next byte is ']', false otherwise.      *      * @throws IOException If an IO error occurs.      */
specifier|protected
name|boolean
name|isClosing
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isClosing
argument_list|(
name|seqSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the next character is a closing brace( close of PDF array ).      *      * @param c The character to check against end of line      * @return true if the next byte is ']', false otherwise.      */
specifier|protected
name|boolean
name|isClosing
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|']'
return|;
block|}
comment|/**      * This will read bytes until the first end of line marker occurs.      * NOTE: The EOL marker may consists of 1 (CR or LF) or 2 (CR and CL) bytes      * which is an important detail if one wants to unread the line.      *      * @return The characters between the current position and the end of the line.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readLine
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|seqSource
operator|.
name|isEOF
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: End-of-File, expected line"
argument_list|)
throw|;
block|}
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
literal|11
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// CR and LF are valid EOLs
if|if
condition|(
name|isEOL
argument_list|(
name|c
argument_list|)
condition|)
block|{
break|break;
block|}
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
comment|// CR+LF is also a valid EOL
if|if
condition|(
name|isCR
argument_list|(
name|c
argument_list|)
operator|&&
name|isLF
argument_list|(
name|seqSource
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will tell if the next byte to be read is an end of line byte.      *      * @return true if the next byte is 0x0A or 0x0D.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isEOL
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isEOL
argument_list|(
name|seqSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the next byte to be read is an end of line byte.      *      * @param c The character to check against end of line      * @return true if the next byte is 0x0A or 0x0D.      */
specifier|protected
name|boolean
name|isEOL
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|isLF
argument_list|(
name|c
argument_list|)
operator|||
name|isCR
argument_list|(
name|c
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isLF
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|ASCII_LF
operator|==
name|c
return|;
block|}
specifier|private
name|boolean
name|isCR
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|ASCII_CR
operator|==
name|c
return|;
block|}
comment|/**      * This will tell if the next byte is whitespace or not.      *      * @return true if the next byte in the stream is a whitespace character.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isWhitespace
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isWhitespace
argument_list|(
name|seqSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if a character is whitespace or not.  These values are      * specified in table 1 (page 12) of ISO 32000-1:2008.      * @param c The character to check against whitespace      * @return true if the character is a whitespace character.      */
specifier|protected
name|boolean
name|isWhitespace
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|9
operator|||
name|c
operator|==
literal|12
operator|||
name|c
operator|==
name|ASCII_LF
operator|||
name|c
operator|==
name|ASCII_CR
operator|||
name|c
operator|==
name|ASCII_SPACE
return|;
block|}
comment|/**      * This will tell if the next byte is a space or not.      *      * @return true if the next byte in the stream is a space character.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isSpace
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isSpace
argument_list|(
name|seqSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the given value is a space or not.      *       * @param c The character to check against space      * @return true if the next byte in the stream is a space character.      */
specifier|protected
name|boolean
name|isSpace
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|ASCII_SPACE
operator|==
name|c
return|;
block|}
comment|/**      * This will tell if the next byte is a digit or not.      *      * @return true if the next byte in the stream is a digit.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isDigit
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isDigit
argument_list|(
name|seqSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the given value is a digit or not.      *       * @param c The character to be checked      * @return true if the next byte in the stream is a digit.      */
specifier|protected
specifier|static
name|boolean
name|isDigit
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|>=
name|ASCII_ZERO
operator|&&
name|c
operator|<=
name|ASCII_NINE
return|;
block|}
comment|/**      * This will skip all spaces and comments that are present.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|void
name|skipSpaces
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|seqSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// 37 is the % character, a comment
while|while
condition|(
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|37
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|37
condition|)
block|{
comment|// skip past the comment section
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|isEOL
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|=
name|seqSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This will read a long from the Stream and throw an {@link IOException} if      * the long value is negative or has more than 10 digits (i.e. : bigger than      * {@link #OBJECT_NUMBER_THRESHOLD})      *      * @return the object number being read.      * @throws IOException if an I/O error occurs      */
specifier|protected
name|long
name|readObjectNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|retval
init|=
name|readLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
operator|||
name|retval
operator|>=
name|OBJECT_NUMBER_THRESHOLD
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object Number '"
operator|+
name|retval
operator|+
literal|"' has more than 10 digits or is negative"
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read a integer from the Stream and throw an {@link IllegalArgumentException} if the integer value      * has more than the maximum object revision (i.e. : bigger than {@link #GENERATION_NUMBER_THRESHOLD})      * @return the generation number being read.      * @throws IOException if an I/O error occurs      */
specifier|protected
name|int
name|readGenerationNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|retval
init|=
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|retval
argument_list|<
literal|0
operator|||
name|retval
argument_list|>
name|GENERATION_NUMBER_THRESHOLD
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Generation Number '"
operator|+
name|retval
operator|+
literal|"' has more than 5 digits"
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read an integer from the stream.      *      * @return The integer that was read from the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|int
name|readInt
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|intBuffer
init|=
name|readStringNumber
argument_list|()
decl_stmt|;
try|try
block|{
name|retval
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|intBuffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|intBuffer
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected an integer type at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read an long from the stream.      *      * @return The long that was read from the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|long
name|readLong
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|long
name|retval
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|longBuffer
init|=
name|readStringNumber
argument_list|()
decl_stmt|;
try|try
block|{
name|retval
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|longBuffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|longBuffer
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected a long type at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
operator|+
literal|", instead got '"
operator|+
name|longBuffer
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This method is used to read a token by the {@linkplain #readInt()} method      * and the {@linkplain #readLong()} method.      *      * @return the token to parse as integer or long by the calling method.      * @throws IOException throws by the {@link #seqSource} methods.      */
specifier|protected
specifier|final
name|StringBuilder
name|readStringNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|lastByte
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|lastByte
operator|=
name|seqSource
operator|.
name|read
argument_list|()
operator|)
operator|!=
name|ASCII_SPACE
operator|&&
name|lastByte
operator|!=
name|ASCII_LF
operator|&&
name|lastByte
operator|!=
name|ASCII_CR
operator|&&
name|lastByte
operator|!=
literal|60
operator|&&
comment|//see sourceforge bug 1714707
name|lastByte
operator|!=
literal|'['
operator|&&
comment|// PDFBOX-1845
name|lastByte
operator|!=
literal|'('
operator|&&
comment|// PDFBOX-2579
name|lastByte
operator|!=
literal|0
operator|&&
comment|//See sourceforge bug 853328
name|lastByte
operator|!=
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|lastByte
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|.
name|length
argument_list|()
operator|>
name|MAX_LENGTH_LONG
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Number '"
operator|+
name|buffer
operator|+
literal|"' is getting too long, stop reading at offset "
operator|+
name|seqSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|lastByte
operator|!=
operator|-
literal|1
condition|)
block|{
name|seqSource
operator|.
name|unread
argument_list|(
name|lastByte
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
block|}
end_class

end_unit

