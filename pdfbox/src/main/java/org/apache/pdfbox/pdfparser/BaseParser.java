begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessRead
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObjectKey
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|Charsets
operator|.
name|ISO_8859_1
import|;
end_import

begin_comment
comment|/**  * This class is used to contain parsing logic that will be used by both the  * PDFParser and the COSStreamParser.  *  * @author Ben Litchfield  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|BaseParser
block|{
specifier|private
specifier|static
specifier|final
name|long
name|OBJECT_NUMBER_THRESHOLD
init|=
literal|10000000000L
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|GENERATION_NUMBER_THRESHOLD
init|=
literal|65535
decl_stmt|;
comment|/**      * system property allowing to define size of push back buffer.      */
specifier|public
specifier|static
specifier|final
name|String
name|PROP_PUSHBACK_SIZE
init|=
literal|"org.apache.pdfbox.baseParser.pushBackSize"
decl_stmt|;
comment|/**      * Log instance.      */
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BaseParser
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|E
init|=
literal|'e'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|N
init|=
literal|'n'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|D
init|=
literal|'d'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|S
init|=
literal|'s'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|T
init|=
literal|'t'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|R
init|=
literal|'r'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|A
init|=
literal|'a'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|M
init|=
literal|'m'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|O
init|=
literal|'o'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|B
init|=
literal|'b'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|J
init|=
literal|'j'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|STRMBUFLEN
init|=
literal|2048
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|strmBuf
init|=
operator|new
name|byte
index|[
name|STRMBUFLEN
index|]
decl_stmt|;
comment|/**      * This is a byte array that will be used for comparisons.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ENDSTREAM
init|=
operator|new
name|byte
index|[]
block|{
name|E
block|,
name|N
block|,
name|D
block|,
name|S
block|,
name|T
block|,
name|R
block|,
name|E
block|,
name|A
block|,
name|M
block|}
decl_stmt|;
comment|/**      * This is a byte array that will be used for comparisons.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ENDOBJ
init|=
operator|new
name|byte
index|[]
block|{
name|E
block|,
name|N
block|,
name|D
block|,
name|O
block|,
name|B
block|,
name|J
block|}
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|public
specifier|static
specifier|final
name|String
name|DEF
init|=
literal|"def"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|protected
specifier|static
specifier|final
name|String
name|ENDOBJ_STRING
init|=
literal|"endobj"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|protected
specifier|static
specifier|final
name|String
name|ENDSTREAM_STRING
init|=
literal|"endstream"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|protected
specifier|static
specifier|final
name|String
name|STREAM_STRING
init|=
literal|"stream"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|TRUE
init|=
literal|"true"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|FALSE
init|=
literal|"false"
decl_stmt|;
comment|/**      * This is a string constant that will be used for comparisons.      */
specifier|private
specifier|static
specifier|final
name|String
name|NULL
init|=
literal|"null"
decl_stmt|;
comment|/**      * ASCII code for line feed.      */
specifier|protected
specifier|static
specifier|final
name|byte
name|ASCII_LF
init|=
literal|10
decl_stmt|;
comment|/**      * ASCII code for carriage return.      */
specifier|protected
specifier|static
specifier|final
name|byte
name|ASCII_CR
init|=
literal|13
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|ASCII_ZERO
init|=
literal|48
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|ASCII_NINE
init|=
literal|57
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
name|ASCII_SPACE
init|=
literal|32
decl_stmt|;
comment|/**      * This is the stream that will be read from.      */
specifier|protected
name|RandomAccessRead
name|pdfSource
decl_stmt|;
comment|/**      * This is the document that will be parsed.      */
specifier|protected
name|COSDocument
name|document
decl_stmt|;
comment|/**      * Default constructor.      */
specifier|public
name|BaseParser
parameter_list|()
block|{     }
comment|/**      * Constructor.      *      * @param input The input stream to read the data from.      * @throws IOException If there is an error reading the input stream.      */
specifier|public
name|BaseParser
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|pdfSource
operator|=
operator|new
name|RandomAccessBuffer
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isHexDigit
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
name|isDigit
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
return|;
block|}
comment|/**      * This will parse a PDF dictionary value.      *      * @return The parsed Dictionary object.      *      * @throws IOException If there is an error parsing the dictionary object.      */
specifier|private
name|COSBase
name|parseCOSDictionaryValue
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|numOffset
init|=
name|pdfSource
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|COSBase
name|number
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isDigit
argument_list|()
condition|)
block|{
return|return
name|number
return|;
block|}
name|long
name|genOffset
init|=
name|pdfSource
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|COSBase
name|generationNumber
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|readExpectedChar
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|number
operator|instanceof
name|COSInteger
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected number, actual="
operator|+
name|number
operator|+
literal|" at offset "
operator|+
name|numOffset
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|generationNumber
operator|instanceof
name|COSInteger
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected number, actual="
operator|+
name|number
operator|+
literal|" at offset "
operator|+
name|genOffset
argument_list|)
throw|;
block|}
name|COSObjectKey
name|key
init|=
operator|new
name|COSObjectKey
argument_list|(
operator|(
operator|(
name|COSInteger
operator|)
name|number
operator|)
operator|.
name|longValue
argument_list|()
argument_list|,
operator|(
operator|(
name|COSInteger
operator|)
name|generationNumber
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|getObjectFromPool
argument_list|(
name|key
argument_list|)
return|;
block|}
specifier|private
name|COSBase
name|getObjectFromPool
parameter_list|(
name|COSObjectKey
name|key
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|document
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"object reference "
operator|+
name|key
operator|+
literal|" at offset "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
operator|+
literal|" in content stream"
argument_list|)
throw|;
block|}
return|return
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**      * This will parse a PDF dictionary.      *      * @return The parsed dictionary.      *      * @throws IOException If there is an error reading the stream.      */
specifier|protected
name|COSDictionary
name|parseCOSDictionary
parameter_list|()
throws|throws
name|IOException
block|{
name|readExpectedChar
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|readExpectedChar
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSDictionary
name|obj
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|parseCOSDictionaryNameValuePair
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// invalid dictionary, we were expecting a /Name, read until the end or until we can recover
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid dictionary, found: '"
operator|+
name|c
operator|+
literal|"' but expected: '/'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|readUntilEndOfCOSDictionary
argument_list|()
condition|)
block|{
comment|// we couldn't recover
return|return
name|obj
return|;
block|}
block|}
block|}
name|readExpectedChar
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|readExpectedChar
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
comment|/**      * Keep reading until the end of the dictionary object or the file has been hit, or until a '/'      * has been found.      *      * @return true if the end of the object or the file has been found, false if not, i.e. that the      * caller can continue to parse the dictionary at the current position.      *      * @throws IOException if there is a reading error.      */
specifier|private
name|boolean
name|readUntilEndOfCOSDictionary
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
operator|-
literal|1
operator|&&
name|c
operator|!=
literal|'/'
operator|&&
name|c
operator|!=
literal|'>'
condition|)
block|{
comment|// in addition to stopping when we find / or>, we also want
comment|// to stop when we find endstream or endobj.
if|if
condition|(
name|c
operator|==
name|E
condition|)
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|N
condition|)
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|D
condition|)
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|boolean
name|isStream
init|=
name|c
operator|==
name|S
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|T
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|R
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|E
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|A
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|M
decl_stmt|;
name|boolean
name|isObj
init|=
operator|!
name|isStream
operator|&&
name|c
operator|==
name|O
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|B
operator|&&
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
name|J
decl_stmt|;
if|if
condition|(
name|isStream
operator|||
name|isObj
condition|)
block|{
comment|// we're done reading this object!
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|true
return|;
block|}
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|parseCOSDictionaryNameValuePair
parameter_list|(
name|COSDictionary
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|COSName
name|key
init|=
name|parseCOSName
argument_list|()
decl_stmt|;
name|COSBase
name|value
init|=
name|parseCOSDictionaryValue
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
operator|)
operator|==
literal|'d'
condition|)
block|{
comment|// if the next string is 'def' then we are parsing a cmap stream
comment|// and want to ignore it, otherwise throw an exception.
name|String
name|potentialDEF
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|potentialDEF
operator|.
name|equals
argument_list|(
name|DEF
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
name|potentialDEF
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Bad Dictionary Declaration "
operator|+
name|pdfSource
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|.
name|setDirect
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|obj
operator|.
name|setItem
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|skipWhiteSpaces
parameter_list|()
throws|throws
name|IOException
block|{
comment|//PDF Ref 3.2.7 A stream must be followed by either
comment|//a CRLF or LF but nothing else.
name|int
name|whitespace
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//see brother_scan_cover.pdf, it adds whitespaces
comment|//after the stream but before the start of the
comment|//data, so just read those first
while|while
condition|(
name|ASCII_SPACE
operator|==
name|whitespace
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ASCII_CR
operator|==
name|whitespace
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|ASCII_LF
operator|!=
name|whitespace
condition|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|//The spec says this is invalid but it happens in the real
comment|//world so we must support it.
block|}
block|}
elseif|else
if|if
condition|(
name|ASCII_LF
operator|!=
name|whitespace
condition|)
block|{
comment|//we are in an error.
comment|//but again we will do a lenient parsing and just assume that everything
comment|//is fine
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This method will read through the current stream object until      * we find the keyword "endstream" meaning we're at the end of this      * object. Some pdf files, however, forget to write some endstream tags      * and just close off objects with an "endobj" tag so we have to handle      * this case as well.      *       * This method is optimized using buffered IO and reduced number of      * byte compare operations.      *       * @param out  stream we write out to.      *       * @throws IOException if something went wrong      */
specifier|protected
name|void
name|readUntilEndStream
parameter_list|(
specifier|final
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|bufSize
decl_stmt|;
name|int
name|charMatchCount
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|keyw
init|=
name|ENDSTREAM
decl_stmt|;
comment|// last character position of shortest keyword ('endobj')
specifier|final
name|int
name|quickTestOffset
init|=
literal|5
decl_stmt|;
comment|// read next chunk into buffer; already matched chars are added to beginning of buffer
while|while
condition|(
operator|(
name|bufSize
operator|=
name|pdfSource
operator|.
name|read
argument_list|(
name|strmBuf
argument_list|,
name|charMatchCount
argument_list|,
name|STRMBUFLEN
operator|-
name|charMatchCount
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|bufSize
operator|+=
name|charMatchCount
expr_stmt|;
name|int
name|bIdx
init|=
name|charMatchCount
decl_stmt|;
name|int
name|quickTestIdx
decl_stmt|;
comment|// iterate over buffer, trying to find keyword match
for|for
control|(
name|int
name|maxQuicktestIdx
init|=
name|bufSize
operator|-
name|quickTestOffset
init|;
name|bIdx
operator|<
name|bufSize
condition|;
name|bIdx
operator|++
control|)
block|{
comment|// reduce compare operations by first test last character we would have to
comment|// match if current one matches; if it is not a character from keywords
comment|// we can move behind the test character;
comment|// this shortcut is inspired by the Boyer-Moore string search algorithm
comment|// and can reduce parsing time by approx. 20%
if|if
condition|(
operator|(
name|charMatchCount
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|quickTestIdx
operator|=
name|bIdx
operator|+
name|quickTestOffset
operator|)
operator|<
name|maxQuicktestIdx
operator|)
condition|)
block|{
specifier|final
name|byte
name|ch
init|=
name|strmBuf
index|[
name|quickTestIdx
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>
literal|'t'
operator|)
operator|||
operator|(
name|ch
operator|<
literal|'a'
operator|)
condition|)
block|{
comment|// last character we would have to match if current character would match
comment|// is not a character from keywords -> jump behind and start over
name|bIdx
operator|=
name|quickTestIdx
expr_stmt|;
continue|continue;
block|}
block|}
comment|// could be negative - but we only compare to ASCII
specifier|final
name|byte
name|ch
init|=
name|strmBuf
index|[
name|bIdx
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|keyw
index|[
name|charMatchCount
index|]
condition|)
block|{
if|if
condition|(
operator|++
name|charMatchCount
operator|==
name|keyw
operator|.
name|length
condition|)
block|{
comment|// match found
name|bIdx
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|charMatchCount
operator|==
literal|3
operator|)
operator|&&
operator|(
name|ch
operator|==
name|ENDOBJ
index|[
name|charMatchCount
index|]
operator|)
condition|)
block|{
comment|// maybe ENDSTREAM is missing but we could have ENDOBJ
name|keyw
operator|=
name|ENDOBJ
expr_stmt|;
name|charMatchCount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// no match; incrementing match start by 1 would be dumb since we already know matched chars
comment|// depending on current char read we may already have beginning of a new match:
comment|// 'e': first char matched;
comment|// 'n': if we are at match position idx 7 we already read 'e' thus 2 chars matched
comment|// for each other char we have to start matching first keyword char beginning with next
comment|// read position
name|charMatchCount
operator|=
operator|(
name|ch
operator|==
name|E
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|ch
operator|==
name|N
operator|)
operator|&&
operator|(
name|charMatchCount
operator|==
literal|7
operator|)
operator|)
condition|?
literal|2
else|:
literal|0
expr_stmt|;
comment|// search again for 'endstream'
name|keyw
operator|=
name|ENDSTREAM
expr_stmt|;
block|}
block|}
block|}
comment|// for
name|int
name|contentBytes
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|bIdx
operator|-
name|charMatchCount
argument_list|)
decl_stmt|;
comment|// write buffer content until first matched char to output stream
if|if
condition|(
name|contentBytes
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|strmBuf
argument_list|,
literal|0
argument_list|,
name|contentBytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|charMatchCount
operator|==
name|keyw
operator|.
name|length
condition|)
block|{
comment|// keyword matched; unread matched keyword (endstream/endobj) and following buffered content
name|pdfSource
operator|.
name|rewind
argument_list|(
name|bufSize
operator|-
name|contentBytes
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// copy matched chars at start of buffer
name|System
operator|.
name|arraycopy
argument_list|(
name|keyw
argument_list|,
literal|0
argument_list|,
name|strmBuf
argument_list|,
literal|0
argument_list|,
name|charMatchCount
argument_list|)
expr_stmt|;
block|}
block|}
comment|// this writes a lonely CR or drops trailing CR LF and LF
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * This is really a bug in the Document creators code, but it caused a crash      * in PDFBox, the first bug was in this format:      * /Title ( (5)      * /Creator which was patched in 1 place.      * However it missed the case where the Close Paren was escaped      *      * The second bug was in this format      * /Title (c:\)      * /Producer      *      * This patch  moves this code out of the parseCOSString method, so it can be used twice.      *      *      * @param bracesParameter the number of braces currently open.      *      * @return the corrected value of the brace counter      * @throws IOException      */
specifier|private
name|int
name|checkForMissingCloseParen
parameter_list|(
specifier|final
name|int
name|bracesParameter
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|braces
init|=
name|bracesParameter
decl_stmt|;
name|byte
index|[]
name|nextThreeBytes
init|=
operator|new
name|byte
index|[
literal|3
index|]
decl_stmt|;
name|int
name|amountRead
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|nextThreeBytes
argument_list|)
decl_stmt|;
comment|//lets handle the special case seen in Bull  River Rules and Regulations.pdf
comment|//The dictionary looks like this
comment|//    2 0 obj
comment|//<<
comment|//        /Type /Info
comment|//        /Creator (PaperPort http://www.scansoft.com)
comment|//        /Producer (sspdflib 1.0 http://www.scansoft.com)
comment|//        /Title ( (5)
comment|//        /Author ()
comment|//        /Subject ()
comment|//
comment|// Notice the /Title, the braces are not even but they should
comment|// be.  So lets assume that if we encounter an this scenario
comment|//<end_brace><new_line><opening_slash> then that
comment|// means that there is an error in the pdf and assume that
comment|// was the end of the document.
comment|//
if|if
condition|(
name|amountRead
operator|==
literal|3
operator|&&
operator|(
operator|(
name|nextThreeBytes
index|[
literal|0
index|]
operator|==
name|ASCII_CR
comment|// Look for a carriage return
operator|&&
name|nextThreeBytes
index|[
literal|1
index|]
operator|==
name|ASCII_LF
comment|// Look for a new line
operator|&&
name|nextThreeBytes
index|[
literal|2
index|]
operator|==
literal|0x2f
operator|)
comment|// Look for a slash /
comment|// Add a second case without a new line
operator|||
operator|(
name|nextThreeBytes
index|[
literal|0
index|]
operator|==
name|ASCII_CR
comment|// Look for a carriage return
operator|&&
name|nextThreeBytes
index|[
literal|1
index|]
operator|==
literal|0x2f
operator|)
operator|)
condition|)
comment|// Look for a slash /
block|{
name|braces
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|amountRead
operator|>
literal|0
condition|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
name|amountRead
argument_list|)
expr_stmt|;
block|}
return|return
name|braces
return|;
block|}
comment|/**      * This will parse a PDF string.      *      * @return The parsed PDF string.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|COSString
name|parseCOSString
parameter_list|()
throws|throws
name|IOException
block|{
name|char
name|nextChar
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
name|char
name|openBrace
decl_stmt|;
name|char
name|closeBrace
decl_stmt|;
if|if
condition|(
name|nextChar
operator|==
literal|'('
condition|)
block|{
name|openBrace
operator|=
literal|'('
expr_stmt|;
name|closeBrace
operator|=
literal|')'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextChar
operator|==
literal|'<'
condition|)
block|{
return|return
name|parseCOSHexString
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"parseCOSString string should start with '(' or '<' and not '"
operator|+
name|nextChar
operator|+
literal|"' "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
name|ByteArrayOutputStream
name|out
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
comment|//This is the number of braces read
comment|//
name|int
name|braces
init|=
literal|1
decl_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|braces
operator|>
literal|0
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
name|int
name|nextc
init|=
operator|-
literal|2
decl_stmt|;
comment|// not yet read
if|if
condition|(
name|ch
operator|==
name|closeBrace
condition|)
block|{
name|braces
operator|--
expr_stmt|;
name|braces
operator|=
name|checkForMissingCloseParen
argument_list|(
name|braces
argument_list|)
expr_stmt|;
if|if
condition|(
name|braces
operator|!=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|openBrace
condition|)
block|{
name|braces
operator|++
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|//patched by ram
name|char
name|next
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|next
condition|)
block|{
case|case
literal|'n'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|out
operator|.
name|write
argument_list|(
literal|'\f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|')'
case|:
comment|// PDFBox 276 /Title (c:\)
name|braces
operator|=
name|checkForMissingCloseParen
argument_list|(
name|braces
argument_list|)
expr_stmt|;
if|if
condition|(
name|braces
operator|!=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'('
case|:
case|case
literal|'\\'
case|:
name|out
operator|.
name|write
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASCII_LF
case|:
case|case
name|ASCII_CR
case|:
comment|//this is a break in the line so ignore it and the newline and continue
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
while|while
condition|(
name|isEOL
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|nextc
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
name|StringBuffer
name|octal
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|octal
operator|.
name|append
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|char
name|digit
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|'0'
operator|&&
name|digit
operator|<=
literal|'7'
condition|)
block|{
name|octal
operator|.
name|append
argument_list|(
name|digit
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|digit
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|'0'
operator|&&
name|digit
operator|<=
literal|'7'
condition|)
block|{
name|octal
operator|.
name|append
argument_list|(
name|digit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextc
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
name|nextc
operator|=
name|c
expr_stmt|;
block|}
name|int
name|character
init|=
literal|0
decl_stmt|;
try|try
block|{
name|character
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|octal
operator|.
name|toString
argument_list|()
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected octal character, actual='"
operator|+
name|octal
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|out
operator|.
name|write
argument_list|(
name|character
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
comment|// dropping the backslash
comment|// see 7.3.4.2 Literal Strings for further information
name|out
operator|.
name|write
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextc
operator|!=
operator|-
literal|2
condition|)
block|{
name|c
operator|=
name|nextc
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|COSString
argument_list|(
name|out
operator|.
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will parse a PDF HEX string with fail fast semantic      * meaning that we stop if a not allowed character is found.      * This is necessary in order to detect malformed input and      * be able to skip to next object start.      *      * We assume starting '&lt;' was already read.      *       * @return The parsed PDF string.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|private
name|COSString
name|parseCOSHexString
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|StringBuilder
name|sBuf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|isHexDigit
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
name|sBuf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing closing bracket for hex string. Reached EOS."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\t'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\b'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\f'
operator|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
comment|// if invalid chars was found: discard last
comment|// hex character if it is not part of a pair
if|if
condition|(
name|sBuf
operator|.
name|length
argument_list|()
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|sBuf
operator|.
name|deleteCharAt
argument_list|(
name|sBuf
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// read till the closing bracket was found
do|do
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'>'
operator|&&
name|c
operator|>=
literal|0
condition|)
do|;
comment|// might have reached EOF while looking for the closing bracket
comment|// this can happen for malformed PDFs only. Make sure that there is
comment|// no endless loop.
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing closing bracket for hex string. Reached EOS."
argument_list|)
throw|;
block|}
comment|// exit loop
break|break;
block|}
block|}
return|return
name|COSString
operator|.
name|parseHex
argument_list|(
name|sBuf
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will parse a PDF array object.      *      * @return The parsed PDF array.      *      * @throws IOException If there is an error parsing the stream.      */
specifier|protected
name|COSArray
name|parseCOSArray
parameter_list|()
throws|throws
name|IOException
block|{
name|readExpectedChar
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|COSArray
name|po
init|=
operator|new
name|COSArray
argument_list|()
decl_stmt|;
name|COSBase
name|pbo
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|i
operator|=
name|pdfSource
operator|.
name|peek
argument_list|()
operator|)
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|char
operator|)
name|i
operator|!=
literal|']'
operator|)
condition|)
block|{
name|pbo
operator|=
name|parseDirObject
argument_list|()
expr_stmt|;
if|if
condition|(
name|pbo
operator|instanceof
name|COSObject
condition|)
block|{
comment|// We have to check if the expected values are there or not PDFBOX-385
if|if
condition|(
name|po
operator|.
name|get
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|instanceof
name|COSInteger
condition|)
block|{
name|COSInteger
name|genNumber
init|=
operator|(
name|COSInteger
operator|)
name|po
operator|.
name|remove
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|po
operator|.
name|get
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|instanceof
name|COSInteger
condition|)
block|{
name|COSInteger
name|number
init|=
operator|(
name|COSInteger
operator|)
name|po
operator|.
name|remove
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|COSObjectKey
name|key
init|=
operator|new
name|COSObjectKey
argument_list|(
name|number
operator|.
name|longValue
argument_list|()
argument_list|,
name|genNumber
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|pbo
operator|=
name|getObjectFromPool
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the object reference is somehow wrong
name|pbo
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|pbo
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pbo
operator|!=
literal|null
condition|)
block|{
name|po
operator|.
name|add
argument_list|(
name|pbo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//it could be a bad object in the array which is just skipped
name|LOG
operator|.
name|warn
argument_list|(
literal|"Corrupt object reference at offset "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
comment|// This could also be an "endobj" or "endstream" which means we can assume that
comment|// the array has ended.
name|String
name|isThisTheEnd
init|=
name|readString
argument_list|()
decl_stmt|;
name|pdfSource
operator|.
name|rewind
argument_list|(
name|isThisTheEnd
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENDOBJ_STRING
operator|.
name|equals
argument_list|(
name|isThisTheEnd
argument_list|)
operator|||
name|ENDSTREAM_STRING
operator|.
name|equals
argument_list|(
name|isThisTheEnd
argument_list|)
condition|)
block|{
return|return
name|po
return|;
block|}
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
comment|// read ']'
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
return|return
name|po
return|;
block|}
comment|/**      * Determine if a character terminates a PDF name.      *      * @param ch The character      * @return<code>true</code> if the character terminates a PDF name, otherwise<code>false</code>.      */
specifier|protected
name|boolean
name|isEndOfName
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|==
name|ASCII_SPACE
operator|||
name|ch
operator|==
name|ASCII_CR
operator|||
name|ch
operator|==
name|ASCII_LF
operator|||
name|ch
operator|==
literal|9
operator|||
name|ch
operator|==
literal|'>'
operator|||
name|ch
operator|==
literal|'<'
operator|||
name|ch
operator|==
literal|'['
operator|||
name|ch
operator|==
literal|'/'
operator|||
name|ch
operator|==
literal|']'
operator|||
name|ch
operator|==
literal|')'
operator|||
name|ch
operator|==
literal|'('
operator|)
return|;
block|}
comment|/**      * This will parse a PDF name from the stream.      *      * @return The parsed PDF name.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|COSName
name|parseCOSName
parameter_list|()
throws|throws
name|IOException
block|{
name|readExpectedChar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
comment|// costruisce il nome
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|char
name|ch1
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
name|char
name|ch2
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// Prior to PDF v1.2, the # was not a special character.  Also,
comment|// it has been observed that various PDF tools do not follow the
comment|// spec with respect to the # escape, even though they report
comment|// PDF versions of 1.2 or later.  The solution here is that we
comment|// interpret the # as an escape only when it is followed by two
comment|// valid hex digits.
comment|//
if|if
condition|(
name|isHexDigit
argument_list|(
name|ch1
argument_list|)
operator|&&
name|isHexDigit
argument_list|(
name|ch2
argument_list|)
condition|)
block|{
name|String
name|hex
init|=
literal|""
operator|+
name|ch1
operator|+
name|ch2
decl_stmt|;
try|try
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|hex
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: expected hex number, actual='"
operator|+
name|hex
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|ch1
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isEndOfName
argument_list|(
name|ch
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|buffer
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|COSName
operator|.
name|getPDFName
argument_list|(
name|buffer
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will parse a boolean object from the stream.      *      * @return The parsed boolean object.      *      * @throws IOException If an IO error occurs during parsing.      */
specifier|protected
name|COSBoolean
name|parseBoolean
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBoolean
name|retval
init|=
literal|null
decl_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
block|{
name|String
name|trueString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|4
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|trueString
operator|.
name|equals
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean: expected='true' actual='"
operator|+
name|trueString
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
block|{
name|String
name|falseString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|5
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|falseString
operator|.
name|equals
argument_list|(
name|FALSE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean: expected='true' actual='"
operator|+
name|falseString
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean expected='t or f' actual='"
operator|+
name|c
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will parse a directory object from the stream.      *      * @return The parsed object.      *      * @throws IOException If there is an error during parsing.      */
specifier|protected
name|COSBase
name|parseDirObject
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBase
name|retval
init|=
literal|null
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|nextByte
init|=
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|nextByte
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
block|{
comment|// pull off first left bracket
name|int
name|leftBracket
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// check for second left bracket
name|c
operator|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
expr_stmt|;
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|retval
operator|=
name|parseCOSDictionary
argument_list|()
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|parseCOSString
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'['
case|:
block|{
comment|// array
name|retval
operator|=
name|parseCOSArray
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
literal|'('
case|:
name|retval
operator|=
name|parseCOSString
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|// name
name|retval
operator|=
name|parseCOSName
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
block|{
comment|// null
name|readExpectedString
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|retval
operator|=
name|COSNull
operator|.
name|NULL
expr_stmt|;
break|break;
block|}
case|case
literal|'t'
case|:
block|{
name|String
name|trueString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|4
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
name|trueString
operator|.
name|equals
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|TRUE
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected true actual='"
operator|+
name|trueString
operator|+
literal|"' "
operator|+
name|pdfSource
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
break|break;
block|}
case|case
literal|'f'
case|:
block|{
name|String
name|falseString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|5
argument_list|)
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
if|if
condition|(
name|falseString
operator|.
name|equals
argument_list|(
name|FALSE
argument_list|)
condition|)
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|FALSE
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected false actual='"
operator|+
name|falseString
operator|+
literal|"' "
operator|+
name|pdfSource
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
break|break;
block|}
case|case
literal|'R'
case|:
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|retval
operator|=
operator|new
name|COSObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|char
operator|)
operator|-
literal|1
case|:
return|return
literal|null
return|;
default|default:
block|{
if|if
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'.'
condition|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|ic
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|ic
expr_stmt|;
while|while
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'e'
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ic
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|ic
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|COSNumber
operator|.
name|get
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//This is not suppose to happen, but we will allow for it
comment|//so we are more compatible with POS writers that don't
comment|//follow the spec
name|String
name|badString
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
name|badString
operator|==
literal|null
operator|||
name|badString
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|int
name|peek
init|=
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// we can end up in an infinite loop otherwise
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown dir object c='"
operator|+
name|c
operator|+
literal|"' cInt="
operator|+
operator|(
name|int
operator|)
name|c
operator|+
literal|" peek='"
operator|+
operator|(
name|char
operator|)
name|peek
operator|+
literal|"' peekInt="
operator|+
name|peek
operator|+
literal|" "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
comment|// if it's an endstream/endobj, we want to put it back so the caller will see it
if|if
condition|(
name|ENDOBJ_STRING
operator|.
name|equals
argument_list|(
name|badString
argument_list|)
operator|||
name|ENDSTREAM_STRING
operator|.
name|equals
argument_list|(
name|badString
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
name|badString
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read the next string from the stream.      *      * @return The string that was read from the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readString
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|isEndOfName
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Read one String and throw an exception if it is not the expected value.      *      * @param expectedString the String value that is expected.      * @throws IOException if the String char is not the expected value or if an      * I/O error occurs.      */
specifier|protected
name|void
name|readExpectedString
parameter_list|(
name|String
name|expectedString
parameter_list|)
throws|throws
name|IOException
block|{
name|readExpectedString
argument_list|(
name|expectedString
operator|.
name|toCharArray
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reads given pattern from {@link #pdfSource}. Skipping whitespace at start and end if wanted.      *       * @param expectedString pattern to be skipped      * @param skipSpaces if set to true spaces before and after the string will be skipped      * @throws IOException if pattern could not be read      */
specifier|protected
specifier|final
name|void
name|readExpectedString
parameter_list|(
specifier|final
name|char
index|[]
name|expectedString
parameter_list|,
name|boolean
name|skipSpaces
parameter_list|)
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
for|for
control|(
name|char
name|c
range|:
name|expectedString
control|)
block|{
if|if
condition|(
name|pdfSource
operator|.
name|read
argument_list|()
operator|!=
name|c
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected string '"
operator|+
operator|new
name|String
argument_list|(
name|expectedString
argument_list|)
operator|+
literal|"' but missed at character '"
operator|+
name|c
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
comment|/**      * Read one char and throw an exception if it is not the expected value.      *      * @param ec the char value that is expected.      * @throws IOException if the read char is not the expected value or if an      * I/O error occurs.      */
specifier|protected
name|void
name|readExpectedChar
parameter_list|(
name|char
name|ec
parameter_list|)
throws|throws
name|IOException
block|{
name|char
name|c
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|ec
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='"
operator|+
name|ec
operator|+
literal|"' actual='"
operator|+
name|c
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * This will read the next string from the stream up to a certain length.      *      * @param length The length to stop reading at.      *      * @return The string that was read from the stream of length 0 to length.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readString
parameter_list|(
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//average string size is around 2 and the normal string buffer size is
comment|//about 16 so lets save some space.
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|isClosing
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
operator|&&
name|buffer
operator|.
name|length
argument_list|()
operator|<
name|length
operator|&&
name|c
operator|!=
literal|'['
operator|&&
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|'('
operator|&&
name|c
operator|!=
literal|'/'
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will tell if the next character is a closing brace( close of PDF array ).      *      * @return true if the next byte is ']', false otherwise.      *      * @throws IOException If an IO error occurs.      */
specifier|protected
name|boolean
name|isClosing
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isClosing
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the next character is a closing brace( close of PDF array ).      *      * @param c The character to check against end of line      * @return true if the next byte is ']', false otherwise.      */
specifier|protected
name|boolean
name|isClosing
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|']'
return|;
block|}
comment|/**      * This will read bytes until the first end of line marker occurs.      * NOTE: The EOL marker may consists of 1 (CR or LF) or 2 (CR and CL) bytes      * which is an important detail if one wants to unread the line.      *      * @return The characters between the current position and the end of the line.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readLine
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pdfSource
operator|.
name|isEOF
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: End-of-File, expected line"
argument_list|)
throw|;
block|}
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
literal|11
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// CR and LF are valid EOLs
if|if
condition|(
name|isEOL
argument_list|(
name|c
argument_list|)
condition|)
block|{
break|break;
block|}
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
comment|// CR+LF is also a valid EOL
if|if
condition|(
name|isCR
argument_list|(
name|c
argument_list|)
operator|&&
name|isLF
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will tell if the next byte to be read is an end of line byte.      *      * @return true if the next byte is 0x0A or 0x0D.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isEOL
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isEOL
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the next byte to be read is an end of line byte.      *      * @param c The character to check against end of line      * @return true if the next byte is 0x0A or 0x0D.      */
specifier|protected
name|boolean
name|isEOL
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|isLF
argument_list|(
name|c
argument_list|)
operator|||
name|isCR
argument_list|(
name|c
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isLF
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|ASCII_LF
operator|==
name|c
return|;
block|}
specifier|private
name|boolean
name|isCR
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|ASCII_CR
operator|==
name|c
return|;
block|}
comment|/**      * This will tell if the next byte is whitespace or not.      *      * @return true if the next byte in the stream is a whitespace character.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isWhitespace
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isWhitespace
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if a character is whitespace or not.  These values are      * specified in table 1 (page 12) of ISO 32000-1:2008.      * @param c The character to check against whitespace      * @return true if the character is a whitespace character.      */
specifier|protected
name|boolean
name|isWhitespace
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|9
operator|||
name|c
operator|==
literal|12
operator|||
name|c
operator|==
name|ASCII_LF
operator|||
name|c
operator|==
name|ASCII_CR
operator|||
name|c
operator|==
name|ASCII_SPACE
return|;
block|}
comment|/**      * This will tell if the next byte is a space or not.      *      * @return true if the next byte in the stream is a space character.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isSpace
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isSpace
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the given value is a space or not.      *       * @param c The character to check against space      * @return true if the next byte in the stream is a space character.      */
specifier|protected
name|boolean
name|isSpace
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|ASCII_SPACE
operator|==
name|c
return|;
block|}
comment|/**      * This will tell if the next byte is a digit or not.      *      * @return true if the next byte in the stream is a digit.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isDigit
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isDigit
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the given value is a digit or not.      *       * @param c The character to be checked      * @return true if the next byte in the stream is a digit.      */
specifier|protected
specifier|static
name|boolean
name|isDigit
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|>=
name|ASCII_ZERO
operator|&&
name|c
operator|<=
name|ASCII_NINE
return|;
block|}
comment|/**      * This will skip all spaces and comments that are present.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|void
name|skipSpaces
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// 37 is the % character, a comment
while|while
condition|(
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|37
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|37
condition|)
block|{
comment|// skip past the comment section
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|isEOL
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This will read a long from the Stream and throw an {@link IOException} if      * the long value is negative or has more than 10 digits (i.e. : bigger than      * {@link #OBJECT_NUMBER_THRESHOLD})      *      * @return the object number being read.      * @throws IOException if an I/O error occurs      */
specifier|protected
name|long
name|readObjectNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|retval
init|=
name|readLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
operator|||
name|retval
operator|>=
name|OBJECT_NUMBER_THRESHOLD
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object Number '"
operator|+
name|retval
operator|+
literal|"' has more than 10 digits or is negative"
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read a integer from the Stream and throw an {@link IllegalArgumentException} if the integer value      * has more than the maximum object revision (i.e. : bigger than {@link #GENERATION_NUMBER_THRESHOLD})      * @return the generation number being read.      * @throws IOException if an I/O error occurs      */
specifier|protected
name|int
name|readGenerationNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|retval
init|=
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|retval
argument_list|<
literal|0
operator|||
name|retval
argument_list|>
name|GENERATION_NUMBER_THRESHOLD
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Generation Number '"
operator|+
name|retval
operator|+
literal|"' has more than 5 digits"
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read an integer from the stream.      *      * @return The integer that was read from the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|int
name|readInt
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|intBuffer
init|=
name|readStringNumber
argument_list|()
decl_stmt|;
try|try
block|{
name|retval
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|intBuffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
name|intBuffer
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected an integer type at offset "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read an long from the stream.      *      * @return The long that was read from the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|long
name|readLong
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|long
name|retval
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|longBuffer
init|=
name|readStringNumber
argument_list|()
decl_stmt|;
try|try
block|{
name|retval
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|longBuffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
name|longBuffer
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected a long type at offset "
operator|+
name|pdfSource
operator|.
name|getPosition
argument_list|()
operator|+
literal|", instead got '"
operator|+
name|longBuffer
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This method is used to read a token by the {@linkplain #readInt()} method      * and the {@linkplain #readLong()} method.      *      * @return the token to parse as integer or long by the calling method.      * @throws IOException throws by the {@link #pdfSource} methods.      */
specifier|protected
specifier|final
name|StringBuilder
name|readStringNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|lastByte
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|lastByte
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
operator|)
operator|!=
name|ASCII_SPACE
operator|&&
name|lastByte
operator|!=
name|ASCII_LF
operator|&&
name|lastByte
operator|!=
name|ASCII_CR
operator|&&
name|lastByte
operator|!=
literal|60
operator|&&
comment|//see sourceforge bug 1714707
name|lastByte
operator|!=
literal|'['
operator|&&
comment|// PDFBOX-1845
name|lastByte
operator|!=
literal|'('
operator|&&
comment|// PDFBOX-2579
name|lastByte
operator|!=
literal|0
operator|&&
comment|//See sourceforge bug 853328
name|lastByte
operator|!=
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|lastByte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastByte
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|rewind
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
block|}
end_class

end_unit

