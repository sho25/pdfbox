begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObjectKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessRead
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
operator|.
name|XrefTrailerResolver
operator|.
name|XRefType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|SecurityHandler
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|Charsets
operator|.
name|ISO_8859_1
import|;
end_import

begin_comment
comment|/**  * PDF-Parser which first reads startxref and xref tables in order to know valid objects and parse only these objects.  *   * First {@link PDFParser#parse()} or  {@link FDFParser#parse()} must be called before page objects  * can be retrieved, e.g. {@link PDFParser#getPDDocument()}.  *   * This class is a much enhanced version of<code>QuickParser</code> presented in<a  * href="https://issues.apache.org/jira/browse/PDFBOX-1104">PDFBOX-1104</a> by Jeremy Villalobos.  */
end_comment

begin_class
specifier|public
class|class
name|COSParser
extends|extends
name|BaseParser
block|{
specifier|private
specifier|static
specifier|final
name|String
name|PDF_HEADER
init|=
literal|"%PDF-"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|FDF_HEADER
init|=
literal|"%FDF-"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|PDF_DEFAULT_VERSION
init|=
literal|"1.4"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|FDF_DEFAULT_VERSION
init|=
literal|"1.0"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|XREF_TABLE
init|=
operator|new
name|char
index|[]
block|{
literal|'x'
block|,
literal|'r'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|XREF_STREAM
init|=
operator|new
name|char
index|[]
block|{
literal|'/'
block|,
literal|'X'
block|,
literal|'R'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|STARTXREF
init|=
operator|new
name|char
index|[]
block|{
literal|'s'
block|,
literal|'t'
block|,
literal|'a'
block|,
literal|'r'
block|,
literal|'t'
block|,
literal|'x'
block|,
literal|'r'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|ENDSTREAM
init|=
operator|new
name|byte
index|[]
block|{
name|E
block|,
name|N
block|,
name|D
block|,
name|S
block|,
name|T
block|,
name|R
block|,
name|E
block|,
name|A
block|,
name|M
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|ENDOBJ
init|=
operator|new
name|byte
index|[]
block|{
name|E
block|,
name|N
block|,
name|D
block|,
name|O
block|,
name|B
block|,
name|J
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|MINIMUM_SEARCH_OFFSET
init|=
literal|6
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|X
init|=
literal|'x'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|STRMBUFLEN
init|=
literal|2048
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|strmBuf
init|=
operator|new
name|byte
index|[
name|STRMBUFLEN
index|]
decl_stmt|;
specifier|protected
specifier|final
name|RandomAccessRead
name|source
decl_stmt|;
comment|/**      * Only parse the PDF file minimally allowing access to basic information.      */
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_PARSEMINIMAL
init|=
literal|"org.apache.pdfbox.pdfparser.nonSequentialPDFParser.parseMinimal"
decl_stmt|;
comment|/**      * The range within the %%EOF marker will be searched.      * Useful if there are additional characters after %%EOF within the PDF.       */
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_EOFLOOKUPRANGE
init|=
literal|"org.apache.pdfbox.pdfparser.nonSequentialPDFParser.eofLookupRange"
decl_stmt|;
comment|/**      * How many trailing bytes to read for EOF marker.      */
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_TRAIL_BYTECOUNT
init|=
literal|2048
decl_stmt|;
comment|/**      * EOF-marker.      */
specifier|protected
specifier|static
specifier|final
name|char
index|[]
name|EOF_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'%'
block|,
literal|'%'
block|,
literal|'E'
block|,
literal|'O'
block|,
literal|'F'
block|}
decl_stmt|;
comment|/**      * obj-marker.      */
specifier|protected
specifier|static
specifier|final
name|char
index|[]
name|OBJ_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'o'
block|,
literal|'b'
block|,
literal|'j'
block|}
decl_stmt|;
specifier|private
name|long
name|trailerOffset
decl_stmt|;
comment|/**      * file length.      */
specifier|protected
name|long
name|fileLen
decl_stmt|;
comment|/**      * is parser using auto healing capacity ?      */
specifier|private
name|boolean
name|isLenient
init|=
literal|true
decl_stmt|;
specifier|protected
name|boolean
name|initialParseDone
init|=
literal|false
decl_stmt|;
comment|/**      * Contains all found objects of a brute force search.      */
specifier|private
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|bfSearchCOSObjectKeyOffsets
init|=
literal|null
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Long
argument_list|>
name|bfSearchXRefTablesOffsets
init|=
literal|null
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Long
argument_list|>
name|bfSearchXRefStreamsOffsets
init|=
literal|null
decl_stmt|;
comment|/**      * The security handler.      */
specifier|protected
name|SecurityHandler
name|securityHandler
init|=
literal|null
decl_stmt|;
comment|/**      *  how many trailing bytes to read for EOF marker.      */
specifier|private
name|int
name|readTrailBytes
init|=
name|DEFAULT_TRAIL_BYTECOUNT
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|COSParser
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**       * Collects all Xref/trailer objects and resolves them into single      * object using startxref reference.       */
specifier|protected
name|XrefTrailerResolver
name|xrefTrailerResolver
init|=
operator|new
name|XrefTrailerResolver
argument_list|()
decl_stmt|;
comment|/**      * The prefix for the temp file being used.       */
specifier|public
specifier|static
specifier|final
name|String
name|TMP_FILE_PREFIX
init|=
literal|"tmpPDF"
decl_stmt|;
comment|/**      * Default constructor.      */
specifier|public
name|COSParser
parameter_list|(
name|RandomAccessRead
name|source
parameter_list|)
block|{
name|super
argument_list|(
operator|new
name|RandomAccessSource
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
block|}
comment|/**      * Sets how many trailing bytes of PDF file are searched for EOF marker and 'startxref' marker. If not set we use      * default value {@link #DEFAULT_TRAIL_BYTECOUNT}.      *       *<p>We check that new value is at least 16. However for practical use cases this value should not be lower than      * 1000; even 2000 was found to not be enough in some cases where some trailing garbage like HTML snippets followed      * the EOF marker.</p>      *       *<p>      * In case system property {@link #SYSPROP_EOFLOOKUPRANGE} is defined this value will be set on initialization but      * can be overwritten later.      *</p>      *       * @param byteCount number of trailing bytes      */
specifier|public
name|void
name|setEOFLookupRange
parameter_list|(
name|int
name|byteCount
parameter_list|)
block|{
if|if
condition|(
name|byteCount
operator|>
literal|15
condition|)
block|{
name|readTrailBytes
operator|=
name|byteCount
expr_stmt|;
block|}
block|}
comment|/**      * Parses cross reference tables.      *       * @param startXRefOffset start offset of the first table      * @return the trailer dictionary      * @throws IOException if something went wrong      */
specifier|protected
name|COSDictionary
name|parseXref
parameter_list|(
name|long
name|startXRefOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|source
operator|.
name|seek
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
name|long
name|startXrefOffset
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|parseStartXref
argument_list|()
argument_list|)
decl_stmt|;
comment|// check the startxref offset
name|long
name|fixedOffset
init|=
name|checkXRefOffset
argument_list|(
name|startXrefOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
condition|)
block|{
name|startXrefOffset
operator|=
name|fixedOffset
expr_stmt|;
block|}
name|document
operator|.
name|setStartXref
argument_list|(
name|startXrefOffset
argument_list|)
expr_stmt|;
name|long
name|prev
init|=
name|startXrefOffset
decl_stmt|;
comment|// ---- parse whole chain of xref tables/object streams using PREV reference
name|long
name|lastPrev
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|prev
operator|>
literal|0
operator|&&
name|prev
operator|!=
name|lastPrev
condition|)
block|{
name|lastPrev
operator|=
name|prev
expr_stmt|;
comment|// seek to xref table
name|source
operator|.
name|seek
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|// skip white spaces
name|skipSpaces
argument_list|()
expr_stmt|;
comment|// -- parse xref
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|==
name|X
condition|)
block|{
comment|// xref table and trailer
comment|// use existing parser to parse xref table
name|parseXrefTable
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|// parse the last trailer.
name|trailerOffset
operator|=
name|source
operator|.
name|getPosition
argument_list|()
expr_stmt|;
comment|// PDFBOX-1739 skip extra xref entries in RegisSTAR documents
if|if
condition|(
name|isLenient
condition|)
block|{
name|int
name|nextCharacter
init|=
name|source
operator|.
name|peek
argument_list|()
decl_stmt|;
while|while
condition|(
name|nextCharacter
operator|!=
literal|'t'
operator|&&
name|isDigit
argument_list|(
name|nextCharacter
argument_list|)
condition|)
block|{
if|if
condition|(
name|source
operator|.
name|getPosition
argument_list|()
operator|==
name|trailerOffset
condition|)
block|{
comment|// warn only the first time
name|LOG
operator|.
name|warn
argument_list|(
literal|"Expected trailer object at position "
operator|+
name|trailerOffset
operator|+
literal|", keep trying"
argument_list|)
expr_stmt|;
block|}
name|readLine
argument_list|()
expr_stmt|;
name|nextCharacter
operator|=
name|source
operator|.
name|peek
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|parseTrailer
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected trailer object at position: "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getCurrentTrailer
argument_list|()
decl_stmt|;
comment|// check for a XRef stream, it may contain some object ids of compressed objects
if|if
condition|(
name|trailer
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|)
condition|)
block|{
name|int
name|streamOffset
init|=
name|trailer
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|)
decl_stmt|;
comment|// check the xref stream reference
name|fixedOffset
operator|=
name|checkXRefStreamOffset
argument_list|(
name|streamOffset
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
operator|&&
name|fixedOffset
operator|!=
name|streamOffset
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"/XRefStm offset "
operator|+
name|streamOffset
operator|+
literal|" is incorrect, corrected to "
operator|+
name|fixedOffset
argument_list|)
expr_stmt|;
name|streamOffset
operator|=
operator|(
name|int
operator|)
name|fixedOffset
expr_stmt|;
name|trailer
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|,
name|streamOffset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|streamOffset
operator|>
literal|0
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
name|streamOffset
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
try|try
block|{
name|parseXrefObjStream
argument_list|(
name|prev
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to parse /XRefStm at offset "
operator|+
name|streamOffset
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|ex
throw|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Skipped XRef stream due to a corrupt offset:"
operator|+
name|streamOffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Skipped XRef stream due to a corrupt offset:"
operator|+
name|streamOffset
argument_list|)
throw|;
block|}
block|}
block|}
name|prev
operator|=
name|trailer
operator|.
name|getLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|>
literal|0
condition|)
block|{
comment|// check the xref table reference
name|fixedOffset
operator|=
name|checkXRefOffset
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
operator|&&
name|fixedOffset
operator|!=
name|prev
condition|)
block|{
name|prev
operator|=
name|fixedOffset
expr_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// parse xref stream
name|prev
operator|=
name|parseXrefObjStream
argument_list|(
name|prev
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|>
literal|0
condition|)
block|{
comment|// check the xref table reference
name|fixedOffset
operator|=
name|checkXRefOffset
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
operator|&&
name|fixedOffset
operator|!=
name|prev
condition|)
block|{
name|prev
operator|=
name|fixedOffset
expr_stmt|;
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getCurrentTrailer
argument_list|()
decl_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|prev
operator|==
name|lastPrev
condition|)
block|{
comment|//TODO better idea needed? PDFBOX-3446
throw|throw
operator|new
name|IOException
argument_list|(
literal|"/Prev loop at offset "
operator|+
name|prev
argument_list|)
throw|;
block|}
comment|// ---- build valid xrefs out of the xref chain
name|xrefTrailerResolver
operator|.
name|setStartxref
argument_list|(
name|startXrefOffset
argument_list|)
expr_stmt|;
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|document
operator|.
name|setTrailer
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
name|document
operator|.
name|setIsXRefStream
argument_list|(
name|XRefType
operator|.
name|STREAM
operator|==
name|xrefTrailerResolver
operator|.
name|getXrefType
argument_list|()
argument_list|)
expr_stmt|;
comment|// check the offsets of all referenced objects
name|checkXrefOffsets
argument_list|()
expr_stmt|;
comment|// copy xref table
name|document
operator|.
name|addXRefTable
argument_list|(
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|trailer
return|;
block|}
comment|/**      * Parses an xref object stream starting with indirect object id.      *       * @return value of PREV item in dictionary or<code>-1</code> if no such item exists      */
specifier|private
name|long
name|parseXrefObjStream
parameter_list|(
name|long
name|objByteOffset
parameter_list|,
name|boolean
name|isStandalone
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- parse indirect object head
name|readObjectNumber
argument_list|()
expr_stmt|;
name|readGenerationNumber
argument_list|()
expr_stmt|;
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|COSDictionary
name|dict
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
name|COSStream
name|xrefStream
init|=
name|parseCOSStream
argument_list|(
name|dict
argument_list|)
decl_stmt|;
name|parseXrefStream
argument_list|(
name|xrefStream
argument_list|,
name|objByteOffset
argument_list|,
name|isStandalone
argument_list|)
expr_stmt|;
name|xrefStream
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|dict
operator|.
name|getLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
return|;
block|}
comment|/**      * Looks for and parses startxref. We first look for last '%%EOF' marker (within last      * {@link #DEFAULT_TRAIL_BYTECOUNT} bytes (or range set via {@link #setEOFLookupRange(int)}) and go back to find      *<code>startxref</code>.      *       * @return the offset of StartXref      * @throws IOException If something went wrong.      */
specifier|protected
specifier|final
name|long
name|getStartxrefOffset
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|buf
decl_stmt|;
name|long
name|skipBytes
decl_stmt|;
comment|// read trailing bytes into buffer
try|try
block|{
specifier|final
name|int
name|trailByteCount
init|=
operator|(
name|fileLen
operator|<
name|readTrailBytes
operator|)
condition|?
operator|(
name|int
operator|)
name|fileLen
else|:
name|readTrailBytes
decl_stmt|;
name|buf
operator|=
operator|new
name|byte
index|[
name|trailByteCount
index|]
expr_stmt|;
name|skipBytes
operator|=
name|fileLen
operator|-
name|trailByteCount
expr_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|skipBytes
argument_list|)
expr_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|readBytes
decl_stmt|;
while|while
condition|(
name|off
operator|<
name|trailByteCount
condition|)
block|{
name|readBytes
operator|=
name|source
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|trailByteCount
operator|-
name|off
argument_list|)
expr_stmt|;
comment|// in order to not get stuck in a loop we check readBytes (this should never happen)
if|if
condition|(
name|readBytes
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No more bytes to read for trailing buffer, but expected: "
operator|+
operator|(
name|trailByteCount
operator|-
name|off
operator|)
argument_list|)
throw|;
block|}
name|off
operator|+=
name|readBytes
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|source
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// find last '%%EOF'
name|int
name|bufOff
init|=
name|lastIndexOf
argument_list|(
name|EOF_MARKER
argument_list|,
name|buf
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufOff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
comment|// in lenient mode the '%%EOF' isn't needed
name|bufOff
operator|=
name|buf
operator|.
name|length
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Missing end of file marker '"
operator|+
operator|new
name|String
argument_list|(
name|EOF_MARKER
argument_list|)
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing end of file marker '"
operator|+
operator|new
name|String
argument_list|(
name|EOF_MARKER
argument_list|)
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
comment|// find last startxref preceding EOF marker
name|bufOff
operator|=
name|lastIndexOf
argument_list|(
name|STARTXREF
argument_list|,
name|buf
argument_list|,
name|bufOff
argument_list|)
expr_stmt|;
name|long
name|startXRefOffset
init|=
name|skipBytes
operator|+
name|bufOff
decl_stmt|;
if|if
condition|(
name|bufOff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Can't find offset for startxref"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing 'startxref' marker."
argument_list|)
throw|;
block|}
block|}
return|return
name|startXRefOffset
return|;
block|}
comment|/**      * Searches last appearance of pattern within buffer. Lookup before _lastOff and goes back until 0.      *       * @param pattern pattern to search for      * @param buf buffer to search pattern in      * @param endOff offset (exclusive) where lookup starts at      *       * @return start offset of pattern within buffer or<code>-1</code> if pattern could not be found      */
specifier|protected
name|int
name|lastIndexOf
parameter_list|(
specifier|final
name|char
index|[]
name|pattern
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|endOff
parameter_list|)
block|{
specifier|final
name|int
name|lastPatternChOff
init|=
name|pattern
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|bufOff
init|=
name|endOff
decl_stmt|;
name|int
name|patOff
init|=
name|lastPatternChOff
decl_stmt|;
name|char
name|lookupCh
init|=
name|pattern
index|[
name|patOff
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|bufOff
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|bufOff
index|]
operator|==
name|lookupCh
condition|)
block|{
if|if
condition|(
operator|--
name|patOff
operator|<
literal|0
condition|)
block|{
comment|// whole pattern matched
return|return
name|bufOff
return|;
block|}
comment|// matched current char, advance to preceding one
name|lookupCh
operator|=
name|pattern
index|[
name|patOff
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|patOff
operator|<
name|lastPatternChOff
condition|)
block|{
comment|// no char match but already matched some chars; reset
name|patOff
operator|=
name|lastPatternChOff
expr_stmt|;
name|lookupCh
operator|=
name|pattern
index|[
name|patOff
index|]
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**      * Return true if parser is lenient. Meaning auto healing capacity of the parser are used.      *      * @return true if parser is lenient      */
specifier|public
name|boolean
name|isLenient
parameter_list|()
block|{
return|return
name|isLenient
return|;
block|}
comment|/**      * Change the parser leniency flag.      *      * This method can only be called before the parsing of the file.      *      * @param lenient try to handle malformed PDFs.      *      */
specifier|public
name|void
name|setLenient
parameter_list|(
name|boolean
name|lenient
parameter_list|)
block|{
if|if
condition|(
name|initialParseDone
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot change leniency after parsing"
argument_list|)
throw|;
block|}
name|this
operator|.
name|isLenient
operator|=
name|lenient
expr_stmt|;
block|}
comment|/**      * Creates a unique object id using object number and object generation      * number. (requires object number&lt; 2^31))      */
specifier|private
name|long
name|getObjectId
parameter_list|(
specifier|final
name|COSObject
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|.
name|getObjectNumber
argument_list|()
operator|<<
literal|32
operator||
name|obj
operator|.
name|getGenerationNumber
argument_list|()
return|;
block|}
comment|/**      * Adds all from newObjects to toBeParsedList if it is not an COSObject or      * we didn't add this COSObject already (checked via addedObjects).      */
specifier|private
name|void
name|addNewToList
parameter_list|(
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|COSBase
argument_list|>
name|newObjects
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
parameter_list|)
block|{
for|for
control|(
name|COSBase
name|newObject
range|:
name|newObjects
control|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|newObject
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds newObject to toBeParsedList if it is not an COSObject or we didn't      * add this COSObject already (checked via addedObjects).      */
specifier|private
name|void
name|addNewToList
parameter_list|(
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
parameter_list|,
specifier|final
name|COSBase
name|newObject
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
parameter_list|)
block|{
if|if
condition|(
name|newObject
operator|instanceof
name|COSObject
condition|)
block|{
specifier|final
name|long
name|objId
init|=
name|getObjectId
argument_list|(
operator|(
name|COSObject
operator|)
name|newObject
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|addedObjects
operator|.
name|add
argument_list|(
name|objId
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|toBeParsedList
operator|.
name|add
argument_list|(
name|newObject
argument_list|)
expr_stmt|;
block|}
comment|/**      * Will parse every object necessary to load a single page from the pdf document. We try our      * best to order objects according to offset in file before reading to minimize seek operations.      *      * @param dict the COSObject from the parent pages.      * @param excludeObjects dictionary object reference entries with these names will not be parsed      *      * @throws IOException if something went wrong      */
specifier|protected
name|void
name|parseDictObjects
parameter_list|(
name|COSDictionary
name|dict
parameter_list|,
name|COSName
modifier|...
name|excludeObjects
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- create queue for objects waiting for further parsing
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
init|=
operator|new
name|LinkedList
argument_list|<
name|COSBase
argument_list|>
argument_list|()
decl_stmt|;
comment|// offset ordered object map
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|COSObject
argument_list|>
argument_list|>
name|objToBeParsed
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|COSObject
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// in case of compressed objects offset points to stmObj
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|parsedObjects
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|addExcludedToList
argument_list|(
name|excludeObjects
argument_list|,
name|dict
argument_list|,
name|parsedObjects
argument_list|)
expr_stmt|;
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|dict
operator|.
name|getValues
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
comment|// ---- go through objects to be parsed
while|while
condition|(
operator|!
operator|(
name|toBeParsedList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|objToBeParsed
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
comment|// -- first get all COSObject from other kind of objects and
comment|// put them in objToBeParsed; afterwards toBeParsedList is empty
name|COSBase
name|baseObj
decl_stmt|;
while|while
condition|(
operator|(
name|baseObj
operator|=
name|toBeParsedList
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|baseObj
operator|instanceof
name|COSDictionary
condition|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
operator|(
operator|(
name|COSDictionary
operator|)
name|baseObj
operator|)
operator|.
name|getValues
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseObj
operator|instanceof
name|COSArray
condition|)
block|{
for|for
control|(
name|COSBase
name|cosBase
range|:
operator|(
operator|(
name|COSArray
operator|)
name|baseObj
operator|)
control|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|cosBase
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|baseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|obj
init|=
operator|(
name|COSObject
operator|)
name|baseObj
decl_stmt|;
name|long
name|objId
init|=
name|getObjectId
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
argument_list|,
name|obj
operator|.
name|getGenerationNumber
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parsedObjects
operator|.
name|contains
argument_list|(
name|objId
argument_list|)
condition|)
block|{
name|Long
name|fileOffset
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
comment|// it is allowed that object references point to null,
comment|// thus we have to test
if|if
condition|(
name|fileOffset
operator|!=
literal|null
operator|&&
name|fileOffset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fileOffset
operator|>
literal|0
condition|)
block|{
name|objToBeParsed
operator|.
name|put
argument_list|(
name|fileOffset
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// negative offset means we have a compressed
comment|// object within object stream;
comment|// get offset of object stream
name|fileOffset
operator|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
operator|new
name|COSObjectKey
argument_list|(
operator|(
name|int
operator|)
operator|-
name|fileOffset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fileOffset
operator|==
literal|null
operator|)
operator|||
operator|(
name|fileOffset
operator|<=
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid object stream xref object reference for key '"
operator|+
name|objKey
operator|+
literal|"': "
operator|+
name|fileOffset
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|COSObject
argument_list|>
name|stmObjects
init|=
name|objToBeParsed
operator|.
name|get
argument_list|(
name|fileOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmObjects
operator|==
literal|null
condition|)
block|{
name|stmObjects
operator|=
operator|new
name|ArrayList
argument_list|<
name|COSObject
argument_list|>
argument_list|()
expr_stmt|;
name|objToBeParsed
operator|.
name|put
argument_list|(
name|fileOffset
argument_list|,
name|stmObjects
argument_list|)
expr_stmt|;
block|}
name|stmObjects
operator|.
name|add
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// NULL object
name|COSObject
name|pdfObject
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
name|pdfObject
operator|.
name|setObject
argument_list|(
name|COSNull
operator|.
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// ---- read first COSObject with smallest offset
comment|// resulting object will be added to toBeParsedList
if|if
condition|(
name|objToBeParsed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
for|for
control|(
name|COSObject
name|obj
range|:
name|objToBeParsed
operator|.
name|remove
argument_list|(
name|objToBeParsed
operator|.
name|firstKey
argument_list|()
argument_list|)
control|)
block|{
name|COSBase
name|parsedObj
init|=
name|parseObjectDynamically
argument_list|(
name|obj
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|parsedObj
operator|!=
literal|null
condition|)
block|{
name|obj
operator|.
name|setObject
argument_list|(
name|parsedObj
argument_list|)
expr_stmt|;
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|parsedObj
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
name|parsedObjects
operator|.
name|add
argument_list|(
name|getObjectId
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// add objects not to be parsed to list of already parsed objects
specifier|private
name|void
name|addExcludedToList
parameter_list|(
name|COSName
index|[]
name|excludeObjects
parameter_list|,
name|COSDictionary
name|dict
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|parsedObjects
parameter_list|)
block|{
if|if
condition|(
name|excludeObjects
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|COSName
name|objName
range|:
name|excludeObjects
control|)
block|{
name|COSBase
name|baseObj
init|=
name|dict
operator|.
name|getItem
argument_list|(
name|objName
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|parsedObjects
operator|.
name|add
argument_list|(
name|getObjectId
argument_list|(
operator|(
name|COSObject
operator|)
name|baseObj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * This will parse the next object from the stream and add it to the local state.       *       * @param obj object to be parsed (we only take object number and generation number for lookup start offset)      * @param requireExistingNotCompressedObj if<code>true</code> object to be parsed must not be contained within      * compressed stream      * @return the parsed object (which is also added to document object)      *       * @throws IOException If an IO error occurs.      */
specifier|protected
specifier|final
name|COSBase
name|parseObjectDynamically
parameter_list|(
name|COSObject
name|obj
parameter_list|,
name|boolean
name|requireExistingNotCompressedObj
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|parseObjectDynamically
argument_list|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
argument_list|,
name|obj
operator|.
name|getGenerationNumber
argument_list|()
argument_list|,
name|requireExistingNotCompressedObj
argument_list|)
return|;
block|}
comment|/**      * This will parse the next object from the stream and add it to the local state.       * It's reduced to parsing an indirect object.      *       * @param objNr object number of object to be parsed      * @param objGenNr object generation number of object to be parsed      * @param requireExistingNotCompressedObj if<code>true</code> the object to be parsed must be defined in xref      * (comment: null objects may be missing from xref) and it must not be a compressed object within object stream      * (this is used to circumvent being stuck in a loop in a malicious PDF)      *       * @return the parsed object (which is also added to document object)      *       * @throws IOException If an IO error occurs.      */
specifier|protected
name|COSBase
name|parseObjectDynamically
parameter_list|(
name|long
name|objNr
parameter_list|,
name|int
name|objGenNr
parameter_list|,
name|boolean
name|requireExistingNotCompressedObj
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- create object key and get object (container) from pool
specifier|final
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|objNr
argument_list|,
name|objGenNr
argument_list|)
decl_stmt|;
specifier|final
name|COSObject
name|pdfObject
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|pdfObject
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// not previously parsed
comment|// ---- read offset or object stream object number from xref table
name|Long
name|offsetOrObjstmObNr
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
comment|// sanity test to circumvent loops with broken documents
if|if
condition|(
name|requireExistingNotCompressedObj
operator|&&
operator|(
operator|(
name|offsetOrObjstmObNr
operator|==
literal|null
operator|)
operator|||
operator|(
name|offsetOrObjstmObNr
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object must be defined and must not be compressed object: "
operator|+
name|objKey
operator|.
name|getNumber
argument_list|()
operator|+
literal|":"
operator|+
name|objKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
throw|;
block|}
comment|// maybe something is wrong with the xref table -> perform brute force search for all objects
if|if
condition|(
name|offsetOrObjstmObNr
operator|==
literal|null
operator|&&
name|isLenient
operator|&&
name|bfSearchCOSObjectKeyOffsets
operator|==
literal|null
condition|)
block|{
name|bfSearchForObjects
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfSearchCOSObjectKeyOffsets
operator|!=
literal|null
operator|&&
operator|!
name|bfSearchCOSObjectKeyOffsets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Add all new read objects from brute force search to the xref table"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|xrefOffset
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
argument_list|>
name|entries
init|=
name|bfSearchCOSObjectKeyOffsets
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|COSObjectKey
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// add all missing objects to the xref table
if|if
condition|(
operator|!
name|xrefOffset
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|xrefOffset
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|offsetOrObjstmObNr
operator|=
name|xrefOffset
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|offsetOrObjstmObNr
operator|==
literal|null
condition|)
block|{
comment|// not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)
name|pdfObject
operator|.
name|setObject
argument_list|(
name|COSNull
operator|.
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsetOrObjstmObNr
operator|>
literal|0
condition|)
block|{
comment|// offset of indirect object in file
name|parseFileObject
argument_list|(
name|offsetOrObjstmObNr
argument_list|,
name|objKey
argument_list|,
name|pdfObject
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// xref value is object nr of object stream containing object to be parsed
comment|// since our object was not found it means object stream was not parsed so far
name|parseObjectStream
argument_list|(
operator|(
name|int
operator|)
operator|-
name|offsetOrObjstmObNr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pdfObject
operator|.
name|getObject
argument_list|()
return|;
block|}
specifier|private
name|void
name|parseFileObject
parameter_list|(
name|Long
name|offsetOrObjstmObNr
parameter_list|,
specifier|final
name|COSObjectKey
name|objKey
parameter_list|,
specifier|final
name|COSObject
name|pdfObject
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- go to object start
name|source
operator|.
name|seek
argument_list|(
name|offsetOrObjstmObNr
argument_list|)
expr_stmt|;
comment|// ---- we must have an indirect object
specifier|final
name|long
name|readObjNr
init|=
name|readObjectNumber
argument_list|()
decl_stmt|;
specifier|final
name|int
name|readObjGen
init|=
name|readGenerationNumber
argument_list|()
decl_stmt|;
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// ---- consistency check
if|if
condition|(
operator|(
name|readObjNr
operator|!=
name|objKey
operator|.
name|getNumber
argument_list|()
operator|)
operator|||
operator|(
name|readObjGen
operator|!=
name|objKey
operator|.
name|getGeneration
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"XREF for "
operator|+
name|objKey
operator|.
name|getNumber
argument_list|()
operator|+
literal|":"
operator|+
name|objKey
operator|.
name|getGeneration
argument_list|()
operator|+
literal|" points to wrong object: "
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
operator|+
literal|" at offset "
operator|+
name|offsetOrObjstmObNr
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSBase
name|pb
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|String
name|endObjectKey
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
name|endObjectKey
operator|.
name|equals
argument_list|(
name|STREAM_STRING
argument_list|)
condition|)
block|{
name|source
operator|.
name|rewind
argument_list|(
name|endObjectKey
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSStream
name|stream
init|=
name|parseCOSStream
argument_list|(
operator|(
name|COSDictionary
operator|)
name|pb
argument_list|)
decl_stmt|;
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
name|securityHandler
operator|.
name|decryptStream
argument_list|(
name|stream
argument_list|,
name|objKey
operator|.
name|getNumber
argument_list|()
argument_list|,
name|objKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|pb
operator|=
name|stream
expr_stmt|;
block|}
else|else
block|{
comment|// this is not legal
comment|// the combination of a dict and the stream/endstream
comment|// forms a complete stream object
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream not preceded by dictionary (offset: "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|")."
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|endObjectKey
operator|=
name|readLine
argument_list|()
expr_stmt|;
comment|// we have case with a second 'endstream' before endobj
if|if
condition|(
operator|!
name|endObjectKey
operator|.
name|startsWith
argument_list|(
name|ENDOBJ_STRING
argument_list|)
operator|&&
name|endObjectKey
operator|.
name|startsWith
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
condition|)
block|{
name|endObjectKey
operator|=
name|endObjectKey
operator|.
name|substring
argument_list|(
literal|9
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|endObjectKey
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// no other characters in extra endstream line
comment|// read next line
name|endObjectKey
operator|=
name|readLine
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
name|securityHandler
operator|.
name|decrypt
argument_list|(
name|pb
argument_list|,
name|objKey
operator|.
name|getNumber
argument_list|()
argument_list|,
name|objKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|pdfObject
operator|.
name|setObject
argument_list|(
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endObjectKey
operator|.
name|startsWith
argument_list|(
name|ENDOBJ_STRING
argument_list|)
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Object ("
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
operator|+
literal|") at offset "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|" does not end with 'endobj' but with '"
operator|+
name|endObjectKey
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object ("
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
operator|+
literal|") at offset "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|" does not end with 'endobj' but with '"
operator|+
name|endObjectKey
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|parseObjectStream
parameter_list|(
name|int
name|objstmObjNr
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|COSBase
name|objstmBaseObj
init|=
name|parseObjectDynamically
argument_list|(
name|objstmObjNr
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|objstmBaseObj
operator|instanceof
name|COSStream
condition|)
block|{
comment|// parse object stream
name|PDFObjectStreamParser
name|parser
init|=
operator|new
name|PDFObjectStreamParser
argument_list|(
operator|(
name|COSStream
operator|)
name|objstmBaseObj
argument_list|,
name|document
argument_list|)
decl_stmt|;
try|try
block|{
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stop reading object stream "
operator|+
name|objstmObjNr
operator|+
literal|" due to an exception"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
comment|// the error is handled in parseDictObjects
return|return;
block|}
else|else
block|{
throw|throw
name|exception
throw|;
block|}
block|}
comment|// register all objects which are referenced to be contained in object stream
for|for
control|(
name|COSObject
name|next
range|:
name|parser
operator|.
name|getObjects
argument_list|()
control|)
block|{
name|COSObjectKey
name|stmObjKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|Long
name|offset
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
name|stmObjKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|null
operator|&&
name|offset
operator|==
operator|-
name|objstmObjNr
condition|)
block|{
name|COSObject
name|stmObj
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|stmObjKey
argument_list|)
decl_stmt|;
name|stmObj
operator|.
name|setObject
argument_list|(
name|next
operator|.
name|getObject
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**       * Returns length value referred to or defined in given object.       */
specifier|private
name|COSNumber
name|getLength
parameter_list|(
specifier|final
name|COSBase
name|lengthBaseObj
parameter_list|,
specifier|final
name|COSName
name|streamType
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|lengthBaseObj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|COSNumber
name|retVal
init|=
literal|null
decl_stmt|;
comment|// maybe length was given directly
if|if
condition|(
name|lengthBaseObj
operator|instanceof
name|COSNumber
condition|)
block|{
name|retVal
operator|=
operator|(
name|COSNumber
operator|)
name|lengthBaseObj
expr_stmt|;
block|}
comment|// length in referenced object
elseif|else
if|if
condition|(
name|lengthBaseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|lengthObj
init|=
operator|(
name|COSObject
operator|)
name|lengthBaseObj
decl_stmt|;
if|if
condition|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// not read so far, keep current stream position
specifier|final
name|long
name|curFileOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|boolean
name|isObjectStream
init|=
name|COSName
operator|.
name|OBJ_STM
operator|.
name|equals
argument_list|(
name|streamType
argument_list|)
decl_stmt|;
name|parseObjectDynamically
argument_list|(
name|lengthObj
argument_list|,
name|isObjectStream
argument_list|)
expr_stmt|;
comment|// reset current stream position
name|source
operator|.
name|seek
argument_list|(
name|curFileOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Length object content was not read."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|instanceof
name|COSNumber
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong type of referenced length object "
operator|+
name|lengthObj
operator|+
literal|": "
operator|+
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
name|retVal
operator|=
operator|(
name|COSNumber
operator|)
name|lengthObj
operator|.
name|getObject
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong type of length object: "
operator|+
name|lengthBaseObj
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|retVal
return|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|STREAMCOPYBUFLEN
init|=
literal|8192
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|streamCopyBuf
init|=
operator|new
name|byte
index|[
name|STREAMCOPYBUFLEN
index|]
decl_stmt|;
comment|/**      * This will read a COSStream from the input stream using length attribute within dictionary. If      * length attribute is a indirect reference it is first resolved to get the stream length. This      * means we copy stream data without testing for 'endstream' or 'endobj' and thus it is no      * problem if these keywords occur within stream. We require 'endstream' to be found after      * stream data is read.      *      * @param dic dictionary that goes with this stream.      *      * @return parsed pdf stream.      *      * @throws IOException if an error occurred reading the stream, like problems with reading      * length attribute, stream does not end with 'endstream' after data read, stream too short etc.      */
specifier|protected
name|COSStream
name|parseCOSStream
parameter_list|(
name|COSDictionary
name|dic
parameter_list|)
throws|throws
name|IOException
block|{
name|COSStream
name|stream
init|=
name|document
operator|.
name|createCOSStream
argument_list|(
name|dic
argument_list|)
decl_stmt|;
comment|// read 'stream'; this was already tested in parseObjectsDynamically()
name|readString
argument_list|()
expr_stmt|;
name|skipWhiteSpaces
argument_list|()
expr_stmt|;
comment|/*          * This needs to be dic.getItem because when we are parsing, the underlying object might still be null.          */
name|COSNumber
name|streamLengthObj
init|=
name|getLength
argument_list|(
name|dic
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|)
argument_list|,
name|dic
operator|.
name|getCOSName
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|streamLengthObj
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The stream doesn't provide any stream length, using fallback readUntilEnd, at offset "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing length for stream."
argument_list|)
throw|;
block|}
block|}
comment|// get output stream to copy data to
if|if
condition|(
name|streamLengthObj
operator|!=
literal|null
operator|&&
name|validateStreamLength
argument_list|(
name|streamLengthObj
operator|.
name|longValue
argument_list|()
argument_list|)
condition|)
block|{
name|OutputStream
name|out
init|=
name|stream
operator|.
name|createRawOutputStream
argument_list|()
decl_stmt|;
try|try
block|{
name|readValidStream
argument_list|(
name|out
argument_list|,
name|streamLengthObj
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// restore original (possibly incorrect) length
name|stream
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|,
name|streamLengthObj
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|OutputStream
name|out
init|=
name|stream
operator|.
name|createRawOutputStream
argument_list|()
decl_stmt|;
try|try
block|{
name|readUntilEndStream
argument_list|(
operator|new
name|EndstreamOutputStream
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// restore original (possibly incorrect) length
if|if
condition|(
name|streamLengthObj
operator|!=
literal|null
condition|)
block|{
name|stream
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|,
name|streamLengthObj
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|String
name|endStream
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
name|endStream
operator|.
name|equals
argument_list|(
literal|"endobj"
argument_list|)
operator|&&
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"stream ends with 'endobj' instead of 'endstream' at offset "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
comment|// avoid follow-up warning about missing endobj
name|source
operator|.
name|rewind
argument_list|(
name|ENDOBJ
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endStream
operator|.
name|length
argument_list|()
operator|>
literal|9
operator|&&
name|isLenient
operator|&&
name|endStream
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|9
argument_list|)
operator|.
name|equals
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"stream ends with '"
operator|+
name|endStream
operator|+
literal|"' instead of 'endstream' at offset "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
comment|// unread the "extra" bytes
name|source
operator|.
name|rewind
argument_list|(
name|endStream
operator|.
name|substring
argument_list|(
literal|9
argument_list|)
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|endStream
operator|.
name|equals
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error reading stream, expected='endstream' actual='"
operator|+
name|endStream
operator|+
literal|"' at offset "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|stream
return|;
block|}
comment|/**      * This method will read through the current stream object until      * we find the keyword "endstream" meaning we're at the end of this      * object. Some pdf files, however, forget to write some endstream tags      * and just close off objects with an "endobj" tag so we have to handle      * this case as well.      *       * This method is optimized using buffered IO and reduced number of      * byte compare operations.      *       * @param out  stream we write out to.      *       * @throws IOException if something went wrong      */
specifier|private
name|void
name|readUntilEndStream
parameter_list|(
specifier|final
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|bufSize
decl_stmt|;
name|int
name|charMatchCount
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|keyw
init|=
name|ENDSTREAM
decl_stmt|;
comment|// last character position of shortest keyword ('endobj')
specifier|final
name|int
name|quickTestOffset
init|=
literal|5
decl_stmt|;
comment|// read next chunk into buffer; already matched chars are added to beginning of buffer
while|while
condition|(
operator|(
name|bufSize
operator|=
name|source
operator|.
name|read
argument_list|(
name|strmBuf
argument_list|,
name|charMatchCount
argument_list|,
name|STRMBUFLEN
operator|-
name|charMatchCount
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|bufSize
operator|+=
name|charMatchCount
expr_stmt|;
name|int
name|bIdx
init|=
name|charMatchCount
decl_stmt|;
name|int
name|quickTestIdx
decl_stmt|;
comment|// iterate over buffer, trying to find keyword match
for|for
control|(
name|int
name|maxQuicktestIdx
init|=
name|bufSize
operator|-
name|quickTestOffset
init|;
name|bIdx
operator|<
name|bufSize
condition|;
name|bIdx
operator|++
control|)
block|{
comment|// reduce compare operations by first test last character we would have to
comment|// match if current one matches; if it is not a character from keywords
comment|// we can move behind the test character; this shortcut is inspired by the
comment|// Boyer-Moore string search algorithm and can reduce parsing time by approx. 20%
name|quickTestIdx
operator|=
name|bIdx
operator|+
name|quickTestOffset
expr_stmt|;
if|if
condition|(
name|charMatchCount
operator|==
literal|0
operator|&&
name|quickTestIdx
operator|<
name|maxQuicktestIdx
condition|)
block|{
specifier|final
name|byte
name|ch
init|=
name|strmBuf
index|[
name|quickTestIdx
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>
literal|'t'
operator|)
operator|||
operator|(
name|ch
operator|<
literal|'a'
operator|)
condition|)
block|{
comment|// last character we would have to match if current character would match
comment|// is not a character from keywords -> jump behind and start over
name|bIdx
operator|=
name|quickTestIdx
expr_stmt|;
continue|continue;
block|}
block|}
comment|// could be negative - but we only compare to ASCII
specifier|final
name|byte
name|ch
init|=
name|strmBuf
index|[
name|bIdx
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|keyw
index|[
name|charMatchCount
index|]
condition|)
block|{
if|if
condition|(
operator|++
name|charMatchCount
operator|==
name|keyw
operator|.
name|length
condition|)
block|{
comment|// match found
name|bIdx
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|charMatchCount
operator|==
literal|3
operator|)
operator|&&
operator|(
name|ch
operator|==
name|ENDOBJ
index|[
name|charMatchCount
index|]
operator|)
condition|)
block|{
comment|// maybe ENDSTREAM is missing but we could have ENDOBJ
name|keyw
operator|=
name|ENDOBJ
expr_stmt|;
name|charMatchCount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// no match; incrementing match start by 1 would be dumb since we already know
comment|// matched chars depending on current char read we may already have beginning
comment|// of a new match: 'e': first char matched; 'n': if we are at match position
comment|// idx 7 we already read 'e' thus 2 chars matched for each other char we have
comment|// to start matching first keyword char beginning with next read position
name|charMatchCount
operator|=
operator|(
name|ch
operator|==
name|E
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|ch
operator|==
name|N
operator|)
operator|&&
operator|(
name|charMatchCount
operator|==
literal|7
operator|)
operator|)
condition|?
literal|2
else|:
literal|0
expr_stmt|;
comment|// search again for 'endstream'
name|keyw
operator|=
name|ENDSTREAM
expr_stmt|;
block|}
block|}
block|}
name|int
name|contentBytes
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|bIdx
operator|-
name|charMatchCount
argument_list|)
decl_stmt|;
comment|// write buffer content until first matched char to output stream
if|if
condition|(
name|contentBytes
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|strmBuf
argument_list|,
literal|0
argument_list|,
name|contentBytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|charMatchCount
operator|==
name|keyw
operator|.
name|length
condition|)
block|{
comment|// keyword matched; unread matched keyword (endstream/endobj) and following buffered content
name|source
operator|.
name|rewind
argument_list|(
name|bufSize
operator|-
name|contentBytes
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// copy matched chars at start of buffer
name|System
operator|.
name|arraycopy
argument_list|(
name|keyw
argument_list|,
literal|0
argument_list|,
name|strmBuf
argument_list|,
literal|0
argument_list|,
name|charMatchCount
argument_list|)
expr_stmt|;
block|}
block|}
comment|// this writes a lonely CR or drops trailing CR LF and LF
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|readValidStream
parameter_list|(
name|OutputStream
name|out
parameter_list|,
name|COSNumber
name|streamLengthObj
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|remainBytes
init|=
name|streamLengthObj
operator|.
name|longValue
argument_list|()
decl_stmt|;
while|while
condition|(
name|remainBytes
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|chunk
init|=
operator|(
name|remainBytes
operator|>
name|STREAMCOPYBUFLEN
operator|)
condition|?
name|STREAMCOPYBUFLEN
else|:
operator|(
name|int
operator|)
name|remainBytes
decl_stmt|;
specifier|final
name|int
name|readBytes
init|=
name|source
operator|.
name|read
argument_list|(
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
name|chunk
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBytes
operator|<=
literal|0
condition|)
block|{
comment|// shouldn't happen, the stream length has already been validated
throw|throw
operator|new
name|IOException
argument_list|(
literal|"read error at offset "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
operator|+
literal|": expected "
operator|+
name|chunk
operator|+
literal|" bytes, but read() returns "
operator|+
name|readBytes
argument_list|)
throw|;
block|}
name|out
operator|.
name|write
argument_list|(
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
name|readBytes
argument_list|)
expr_stmt|;
name|remainBytes
operator|-=
name|readBytes
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|validateStreamLength
parameter_list|(
name|long
name|streamLength
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|streamLengthIsValid
init|=
literal|true
decl_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|long
name|expectedEndOfStream
init|=
name|originOffset
operator|+
name|streamLength
decl_stmt|;
if|if
condition|(
name|expectedEndOfStream
operator|>
name|fileLen
condition|)
block|{
name|streamLengthIsValid
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"The end of the stream is out of range, using workaround to read the stream, "
operator|+
literal|"stream start position: "
operator|+
name|originOffset
operator|+
literal|", length: "
operator|+
name|streamLength
operator|+
literal|", expected end position: "
operator|+
name|expectedEndOfStream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source
operator|.
name|seek
argument_list|(
name|expectedEndOfStream
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isString
argument_list|(
name|ENDSTREAM
argument_list|)
condition|)
block|{
name|streamLengthIsValid
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"The end of the stream doesn't point to the correct offset, using workaround to read the stream, "
operator|+
literal|"stream start position: "
operator|+
name|originOffset
operator|+
literal|", length: "
operator|+
name|streamLength
operator|+
literal|", expected end position: "
operator|+
name|expectedEndOfStream
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
return|return
name|streamLengthIsValid
return|;
block|}
comment|/**      * Check if the cross reference table/stream can be found at the current offset.      *       * @param startXRefOffset      * @return the revised offset      * @throws IOException      */
specifier|private
name|long
name|checkXRefOffset
parameter_list|(
name|long
name|startXRefOffset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// repair mode isn't available in non-lenient mode
if|if
condition|(
operator|!
name|isLenient
condition|)
block|{
return|return
name|startXRefOffset
return|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|==
name|X
operator|&&
name|isString
argument_list|(
name|XREF_TABLE
argument_list|)
condition|)
block|{
return|return
name|startXRefOffset
return|;
block|}
if|if
condition|(
name|startXRefOffset
operator|>
literal|0
condition|)
block|{
name|long
name|fixedOffset
init|=
name|checkXRefStreamOffset
argument_list|(
name|startXRefOffset
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
condition|)
block|{
return|return
name|fixedOffset
return|;
block|}
block|}
comment|// try to find a fixed offset
return|return
name|calculateXRefFixedOffset
argument_list|(
name|startXRefOffset
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Check if the cross reference stream can be found at the current offset.      *       * @param startXRefOffset the expected start offset of the XRef stream      * @param checkOnly check only but don't repair the offset if set to true      * @return the revised offset      * @throws IOException if something went wrong      */
specifier|private
name|long
name|checkXRefStreamOffset
parameter_list|(
name|long
name|startXRefOffset
parameter_list|,
name|boolean
name|checkOnly
parameter_list|)
throws|throws
name|IOException
block|{
comment|// repair mode isn't available in non-lenient mode
if|if
condition|(
operator|!
name|isLenient
operator|||
name|startXRefOffset
operator|==
literal|0
condition|)
block|{
return|return
name|startXRefOffset
return|;
block|}
comment|// seek to offset-1
name|source
operator|.
name|seek
argument_list|(
name|startXRefOffset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|nextValue
init|=
name|source
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// the first character has to be a whitespace, and then a digit
if|if
condition|(
name|isWhitespace
argument_list|(
name|nextValue
argument_list|)
condition|)
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
name|isDigit
argument_list|()
condition|)
block|{
try|try
block|{
comment|// it's a XRef stream
name|readObjectNumber
argument_list|()
expr_stmt|;
name|readGenerationNumber
argument_list|()
expr_stmt|;
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// check the dictionary to avoid false positives
name|COSDictionary
name|dict
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict
operator|!=
literal|null
operator|&&
literal|"XRef"
operator|.
name|equals
argument_list|(
name|dict
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|startXRefOffset
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
comment|// there wasn't an object of a xref stream
comment|// try to repair the offset
name|source
operator|.
name|seek
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// try to find a fixed offset
return|return
name|checkOnly
condition|?
operator|-
literal|1
else|:
name|calculateXRefFixedOffset
argument_list|(
name|startXRefOffset
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Try to find a fixed offset for the given xref table/stream.      *       * @param objectOffset the given offset where to look at      * @param streamsOnly search for xref streams only      * @return the fixed offset      *       * @throws IOException if something went wrong      */
specifier|private
name|long
name|calculateXRefFixedOffset
parameter_list|(
name|long
name|objectOffset
parameter_list|,
name|boolean
name|streamsOnly
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|objectOffset
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid object offset "
operator|+
name|objectOffset
operator|+
literal|" when searching for a xref table/stream"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// start a brute force search for all xref tables and try to find the offset we are looking for
name|long
name|newOffset
init|=
name|bfSearchForXRef
argument_list|(
name|objectOffset
argument_list|,
name|streamsOnly
argument_list|)
decl_stmt|;
if|if
condition|(
name|newOffset
operator|>
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fixed reference for xref table/stream "
operator|+
name|objectOffset
operator|+
literal|" -> "
operator|+
name|newOffset
argument_list|)
expr_stmt|;
return|return
name|newOffset
return|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't find the object xref table/stream at offset "
operator|+
name|objectOffset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/**      * Check the XRef table by dereferencing all objects and fixing the offset if necessary.      *       * @throws IOException if something went wrong.      */
specifier|private
name|void
name|checkXrefOffsets
parameter_list|()
throws|throws
name|IOException
block|{
comment|// repair mode isn't available in non-lenient mode
if|if
condition|(
operator|!
name|isLenient
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|xrefOffset
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|xrefOffset
operator|!=
literal|null
condition|)
block|{
name|boolean
name|bruteForceSearch
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|objectEntry
range|:
name|xrefOffset
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|COSObjectKey
name|objectKey
init|=
name|objectEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Long
name|objectOffset
init|=
name|objectEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// a negative offset number represents a object number itself
comment|// see type 2 entry in xref stream
if|if
condition|(
name|objectOffset
operator|!=
literal|null
operator|&&
name|objectOffset
operator|>=
literal|0
operator|&&
operator|!
name|checkObjectKeys
argument_list|(
name|objectKey
argument_list|,
name|objectOffset
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stop checking xref offsets as at least one couldn't be dereferenced"
argument_list|)
expr_stmt|;
name|bruteForceSearch
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bruteForceSearch
condition|)
block|{
name|bfSearchForObjects
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfSearchCOSObjectKeyOffsets
operator|!=
literal|null
operator|&&
operator|!
name|bfSearchCOSObjectKeyOffsets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|COSObjectKey
argument_list|>
name|objStreams
init|=
operator|new
name|ArrayList
argument_list|<
name|COSObjectKey
argument_list|>
argument_list|()
decl_stmt|;
comment|// find all object streams
for|for
control|(
name|COSObjectKey
name|key
range|:
name|xrefOffset
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Long
name|offset
init|=
name|xrefOffset
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|null
operator|&&
name|offset
operator|<
literal|0
condition|)
block|{
name|COSObjectKey
name|objStream
init|=
operator|new
name|COSObjectKey
argument_list|(
operator|-
name|offset
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|objStreams
operator|.
name|contains
argument_list|(
name|objStream
argument_list|)
condition|)
block|{
name|objStreams
operator|.
name|add
argument_list|(
operator|new
name|COSObjectKey
argument_list|(
operator|-
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// remove all found object streams
if|if
condition|(
operator|!
name|objStreams
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|COSObjectKey
name|key
range|:
name|bfSearchCOSObjectKeyOffsets
operator|.
name|keySet
argument_list|()
control|)
block|{
name|objStreams
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
comment|// remove all objects which are part of an object stream which wasn't found
for|for
control|(
name|COSObjectKey
name|key
range|:
name|objStreams
control|)
block|{
name|Set
argument_list|<
name|Long
argument_list|>
name|objects
init|=
name|xrefTrailerResolver
operator|.
name|getContainedObjectNumbers
argument_list|(
call|(
name|int
call|)
argument_list|(
name|key
operator|.
name|getNumber
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Long
name|objNr
range|:
name|objects
control|)
block|{
name|xrefOffset
operator|.
name|remove
argument_list|(
operator|new
name|COSObjectKey
argument_list|(
name|objNr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// remove all objects which are part of an object stream which wasn't found
for|for
control|(
name|COSObjectKey
name|key
range|:
name|objStreams
control|)
block|{
name|Set
argument_list|<
name|Long
argument_list|>
name|objects
init|=
name|xrefTrailerResolver
operator|.
name|getContainedObjectNumbers
argument_list|(
call|(
name|int
call|)
argument_list|(
name|key
operator|.
name|getNumber
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Long
name|objNr
range|:
name|objects
control|)
block|{
name|xrefOffset
operator|.
name|remove
argument_list|(
operator|new
name|COSObjectKey
argument_list|(
name|objNr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Replaced read xref table with the results of a brute force search"
argument_list|)
expr_stmt|;
name|xrefOffset
operator|.
name|putAll
argument_list|(
name|bfSearchCOSObjectKeyOffsets
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Check if the given object can be found at the given offset.      *       * @param objectKey the object we are looking for      * @param offset the offset where to look      * @return returns true if the given object can be dereferenced at the given offset      * @throws IOException if something went wrong      */
specifier|private
name|boolean
name|checkObjectKeys
parameter_list|(
name|COSObjectKey
name|objectKey
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// there can't be any object at the very beginning of a pdf
if|if
condition|(
name|offset
operator|<
name|MINIMUM_SEARCH_OFFSET
condition|)
block|{
return|return
literal|false
return|;
block|}
name|long
name|objectNr
init|=
name|objectKey
operator|.
name|getNumber
argument_list|()
decl_stmt|;
name|int
name|objectGen
init|=
name|objectKey
operator|.
name|getGeneration
argument_list|()
decl_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|String
name|objectString
init|=
name|createObjectString
argument_list|(
name|objectNr
argument_list|,
name|objectGen
argument_list|)
decl_stmt|;
try|try
block|{
name|source
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isString
argument_list|(
name|objectString
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
condition|)
block|{
comment|// everything is ok, return origin object key
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
comment|// Swallow the exception, obviously there isn't any valid object number
block|}
finally|finally
block|{
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
comment|// no valid object number found
return|return
literal|false
return|;
block|}
comment|/**      * Create a string for the given object id.      *       * @param objectID the object id      * @param genID the generation id      * @return the generated string      */
specifier|private
name|String
name|createObjectString
parameter_list|(
name|long
name|objectID
parameter_list|,
name|int
name|genID
parameter_list|)
block|{
return|return
name|Long
operator|.
name|toString
argument_list|(
name|objectID
argument_list|)
operator|+
literal|" "
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|genID
argument_list|)
operator|+
literal|" obj"
return|;
block|}
comment|/**      * Brute force search for every object in the pdf.      *         * @throws IOException if something went wrong      */
specifier|private
name|void
name|bfSearchForObjects
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bfSearchCOSObjectKeyOffsets
operator|==
literal|null
condition|)
block|{
name|bfSearchCOSObjectKeyOffsets
operator|=
operator|new
name|HashMap
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
argument_list|()
expr_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|long
name|currentOffset
init|=
name|MINIMUM_SEARCH_OFFSET
decl_stmt|;
name|String
name|objString
init|=
literal|" obj"
decl_stmt|;
name|char
index|[]
name|string
init|=
name|objString
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
do|do
block|{
name|source
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isString
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|long
name|tempOffset
init|=
name|currentOffset
operator|-
literal|1
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
name|int
name|genID
init|=
name|source
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// is the next char a digit?
if|if
condition|(
name|isDigit
argument_list|(
name|genID
argument_list|)
condition|)
block|{
name|genID
operator|-=
literal|48
expr_stmt|;
name|tempOffset
operator|--
expr_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSpace
argument_list|()
condition|)
block|{
while|while
condition|(
name|tempOffset
operator|>
name|MINIMUM_SEARCH_OFFSET
operator|&&
name|isSpace
argument_list|()
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
block|}
name|int
name|length
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|tempOffset
operator|>
name|MINIMUM_SEARCH_OFFSET
operator|&&
name|isDigit
argument_list|()
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
name|byte
index|[]
name|objIDBytes
init|=
name|source
operator|.
name|readFully
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|String
name|objIdString
init|=
operator|new
name|String
argument_list|(
name|objIDBytes
argument_list|,
literal|0
argument_list|,
name|objIDBytes
operator|.
name|length
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
name|Long
name|objectID
decl_stmt|;
try|try
block|{
name|objectID
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|objIdString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
name|objectID
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|objectID
operator|!=
literal|null
condition|)
block|{
name|bfSearchCOSObjectKeyOffsets
operator|.
name|put
argument_list|(
operator|new
name|COSObjectKey
argument_list|(
name|objectID
argument_list|,
name|genID
argument_list|)
argument_list|,
name|tempOffset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|currentOffset
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|source
operator|.
name|isEOF
argument_list|()
condition|)
do|;
comment|// reestablish origin position
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Search for the offset of the given xref table/stream among those found by a brute force search.      *       * @param streamsOnly search for xref streams only      * @return the offset of the xref entry      * @throws IOException if something went wrong      */
specifier|private
name|long
name|bfSearchForXRef
parameter_list|(
name|long
name|xrefOffset
parameter_list|,
name|boolean
name|streamsOnly
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|newOffset
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|newOffsetTable
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|newOffsetStream
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|streamsOnly
condition|)
block|{
name|bfSearchForXRefTables
argument_list|()
expr_stmt|;
block|}
name|bfSearchForXRefStreams
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|streamsOnly
operator|&&
name|bfSearchXRefTablesOffsets
operator|!=
literal|null
condition|)
block|{
comment|// TODO to be optimized, this won't work in every case
name|newOffsetTable
operator|=
name|searchNearestValue
argument_list|(
name|bfSearchXRefTablesOffsets
argument_list|,
name|xrefOffset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfSearchXRefStreamsOffsets
operator|!=
literal|null
condition|)
block|{
comment|// TODO to be optimized, this won't work in every case
name|newOffsetStream
operator|=
name|searchNearestValue
argument_list|(
name|bfSearchXRefStreamsOffsets
argument_list|,
name|xrefOffset
argument_list|)
expr_stmt|;
block|}
comment|// choose the nearest value
if|if
condition|(
name|newOffsetTable
operator|>
operator|-
literal|1
operator|&&
name|newOffsetStream
operator|>
operator|-
literal|1
condition|)
block|{
name|long
name|differenceTable
init|=
name|xrefOffset
operator|-
name|newOffsetTable
decl_stmt|;
name|long
name|differenceStream
init|=
name|xrefOffset
operator|-
name|newOffsetStream
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|differenceTable
argument_list|)
operator|>
name|Math
operator|.
name|abs
argument_list|(
name|differenceStream
argument_list|)
condition|)
block|{
name|newOffset
operator|=
name|newOffsetStream
expr_stmt|;
name|bfSearchXRefStreamsOffsets
operator|.
name|remove
argument_list|(
name|newOffsetStream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newOffset
operator|=
name|newOffsetTable
expr_stmt|;
name|bfSearchXRefTablesOffsets
operator|.
name|remove
argument_list|(
name|newOffsetTable
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|newOffsetTable
operator|>
operator|-
literal|1
condition|)
block|{
name|newOffset
operator|=
name|newOffsetTable
expr_stmt|;
name|bfSearchXRefTablesOffsets
operator|.
name|remove
argument_list|(
name|newOffsetTable
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newOffsetStream
operator|>
operator|-
literal|1
condition|)
block|{
name|newOffset
operator|=
name|newOffsetStream
expr_stmt|;
name|bfSearchXRefStreamsOffsets
operator|.
name|remove
argument_list|(
name|newOffsetStream
argument_list|)
expr_stmt|;
block|}
return|return
name|newOffset
return|;
block|}
specifier|private
name|long
name|searchNearestValue
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|values
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
name|long
name|newValue
init|=
operator|-
literal|1
decl_stmt|;
name|Long
name|currentDifference
init|=
literal|null
decl_stmt|;
name|int
name|currentOffsetIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|numberOfOffsets
init|=
name|values
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// find the nearest value
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfOffsets
condition|;
name|i
operator|++
control|)
block|{
name|long
name|newDifference
init|=
name|offset
operator|-
name|values
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// find the nearest offset
if|if
condition|(
name|currentDifference
operator|==
literal|null
operator|||
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|currentDifference
argument_list|)
operator|>
name|Math
operator|.
name|abs
argument_list|(
name|newDifference
argument_list|)
operator|)
condition|)
block|{
name|currentDifference
operator|=
name|newDifference
expr_stmt|;
name|currentOffsetIndex
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|currentOffsetIndex
operator|>
operator|-
literal|1
condition|)
block|{
name|newValue
operator|=
name|values
operator|.
name|get
argument_list|(
name|currentOffsetIndex
argument_list|)
expr_stmt|;
block|}
return|return
name|newValue
return|;
block|}
comment|/**      * Brute force search for all xref entries (tables).      *       * @throws IOException if something went wrong      */
specifier|private
name|void
name|bfSearchForXRefTables
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bfSearchXRefTablesOffsets
operator|==
literal|null
condition|)
block|{
comment|// a pdf may contain more than one xref entry
name|bfSearchXRefTablesOffsets
operator|=
operator|new
name|Vector
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|MINIMUM_SEARCH_OFFSET
argument_list|)
expr_stmt|;
comment|// search for xref tables
while|while
condition|(
operator|!
name|source
operator|.
name|isEOF
argument_list|()
condition|)
block|{
if|if
condition|(
name|isString
argument_list|(
name|XREF_TABLE
argument_list|)
condition|)
block|{
name|long
name|newOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|newOffset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// ensure that we don't read "startxref" instead of "xref"
if|if
condition|(
name|isWhitespace
argument_list|()
condition|)
block|{
name|bfSearchXRefTablesOffsets
operator|.
name|add
argument_list|(
name|newOffset
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|newOffset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Brute force search for all /XRef entries (streams).      *       * @throws IOException if something went wrong      */
specifier|private
name|void
name|bfSearchForXRefStreams
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bfSearchXRefStreamsOffsets
operator|==
literal|null
condition|)
block|{
comment|// a pdf may contain more than one /XRef entry
name|bfSearchXRefStreamsOffsets
operator|=
operator|new
name|Vector
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|MINIMUM_SEARCH_OFFSET
argument_list|)
expr_stmt|;
comment|// search for XRef streams
name|String
name|objString
init|=
literal|" obj"
decl_stmt|;
name|char
index|[]
name|string
init|=
name|objString
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|source
operator|.
name|isEOF
argument_list|()
condition|)
block|{
if|if
condition|(
name|isString
argument_list|(
name|XREF_STREAM
argument_list|)
condition|)
block|{
comment|// search backwards for the beginning of the stream
name|long
name|newOffset
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|xrefOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|boolean
name|objFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|30
operator|&&
operator|!
name|objFound
condition|;
name|i
operator|++
control|)
block|{
name|long
name|currentOffset
init|=
name|xrefOffset
operator|-
operator|(
name|i
operator|*
literal|10
operator|)
decl_stmt|;
if|if
condition|(
name|currentOffset
operator|>
literal|0
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|isString
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|long
name|tempOffset
init|=
name|currentOffset
operator|-
literal|1
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
name|int
name|genID
init|=
name|source
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// is the next char a digit?
if|if
condition|(
name|isDigit
argument_list|(
name|genID
argument_list|)
condition|)
block|{
name|genID
operator|-=
literal|48
expr_stmt|;
name|tempOffset
operator|--
expr_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSpace
argument_list|()
condition|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
while|while
condition|(
name|tempOffset
operator|>
name|MINIMUM_SEARCH_OFFSET
operator|&&
name|isDigit
argument_list|()
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
name|newOffset
operator|=
name|source
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fixed reference for xref stream "
operator|+
name|xrefOffset
operator|+
literal|" -> "
operator|+
name|newOffset
argument_list|)
expr_stmt|;
name|objFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|currentOffset
operator|++
expr_stmt|;
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|newOffset
operator|>
operator|-
literal|1
condition|)
block|{
name|bfSearchXRefStreamsOffsets
operator|.
name|add
argument_list|(
name|newOffset
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|xrefOffset
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Rebuild the trailer dictionary if startxref can't be found.      *        * @return the rebuild trailer dictionary      *       * @throws IOException if something went wrong      */
specifier|protected
specifier|final
name|COSDictionary
name|rebuildTrailer
parameter_list|()
throws|throws
name|IOException
block|{
name|COSDictionary
name|trailer
init|=
literal|null
decl_stmt|;
name|bfSearchForObjects
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfSearchCOSObjectKeyOffsets
operator|!=
literal|null
condition|)
block|{
name|xrefTrailerResolver
operator|.
name|reset
argument_list|()
expr_stmt|;
name|xrefTrailerResolver
operator|.
name|nextXrefObj
argument_list|(
literal|0
argument_list|,
name|XRefType
operator|.
name|TABLE
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|entry
range|:
name|bfSearchCOSObjectKeyOffsets
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|xrefTrailerResolver
operator|.
name|setXRef
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|xrefTrailerResolver
operator|.
name|setStartxref
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|trailer
operator|=
name|xrefTrailerResolver
operator|.
name|getTrailer
argument_list|()
expr_stmt|;
name|getDocument
argument_list|()
operator|.
name|setTrailer
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
comment|// search for the different parts of the trailer dictionary
for|for
control|(
name|Entry
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|entry
range|:
name|bfSearchCOSObjectKeyOffsets
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Long
name|offset
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|readObjectNumber
argument_list|()
expr_stmt|;
name|readGenerationNumber
argument_list|()
expr_stmt|;
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|COSDictionary
name|dictionary
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
if|if
condition|(
name|dictionary
operator|!=
literal|null
condition|)
block|{
comment|// document catalog
if|if
condition|(
name|COSName
operator|.
name|CATALOG
operator|.
name|equals
argument_list|(
name|dictionary
operator|.
name|getCOSName
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
argument_list|)
condition|)
block|{
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|,
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// info dictionary
elseif|else
if|if
condition|(
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|MOD_DATE
argument_list|)
operator|&&
operator|(
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|TITLE
argument_list|)
operator|||
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|AUTHOR
argument_list|)
operator|||
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|SUBJECT
argument_list|)
operator|||
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|KEYWORDS
argument_list|)
operator|||
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|CREATOR
argument_list|)
operator|||
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|PRODUCER
argument_list|)
operator|||
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|CREATION_DATE
argument_list|)
operator|)
condition|)
block|{
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|,
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// TODO encryption dictionary
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipped object "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|", either it's corrupt or not a dictionary"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|trailer
return|;
block|}
comment|/**      * This will parse the startxref section from the stream.      * The startxref value is ignored.      *      * @return the startxref value or -1 on parsing error      * @throws IOException If an IO error occurs.      */
specifier|private
name|long
name|parseStartXref
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|startXref
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|isString
argument_list|(
name|STARTXREF
argument_list|)
condition|)
block|{
name|readString
argument_list|()
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
comment|// This integer is the byte offset of the first object referenced by the xref or xref stream
name|startXref
operator|=
name|readLong
argument_list|()
expr_stmt|;
block|}
return|return
name|startXref
return|;
block|}
comment|/**      * Checks if the given string can be found at the current offset.      *       * @param string the bytes of the string to look for      * @return true if the bytes are in place, false if not      * @throws IOException if something went wrong      */
specifier|private
name|boolean
name|isString
parameter_list|(
name|byte
index|[]
name|string
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|bytesMatching
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|==
name|string
index|[
literal|0
index|]
condition|)
block|{
name|int
name|length
init|=
name|string
operator|.
name|length
decl_stmt|;
name|byte
index|[]
name|bytesRead
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|int
name|numberOfBytes
init|=
name|source
operator|.
name|read
argument_list|(
name|bytesRead
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|numberOfBytes
operator|<
name|length
condition|)
block|{
name|int
name|readMore
init|=
name|source
operator|.
name|read
argument_list|(
name|bytesRead
argument_list|,
name|numberOfBytes
argument_list|,
name|length
operator|-
name|numberOfBytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|readMore
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|numberOfBytes
operator|+=
name|readMore
expr_stmt|;
block|}
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|string
argument_list|,
name|bytesRead
argument_list|)
condition|)
block|{
name|bytesMatching
operator|=
literal|true
expr_stmt|;
block|}
name|source
operator|.
name|rewind
argument_list|(
name|numberOfBytes
argument_list|)
expr_stmt|;
block|}
return|return
name|bytesMatching
return|;
block|}
comment|/**      * Checks if the given string can be found at the current offset.      *       * @param string the bytes of the string to look for      * @return true if the bytes are in place, false if not      * @throws IOException if something went wrong      */
specifier|private
name|boolean
name|isString
parameter_list|(
name|char
index|[]
name|string
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|bytesMatching
init|=
literal|true
decl_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|string
control|)
block|{
if|if
condition|(
name|source
operator|.
name|read
argument_list|()
operator|!=
name|c
condition|)
block|{
name|bytesMatching
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
return|return
name|bytesMatching
return|;
block|}
comment|/**      * This will parse the trailer from the stream and add it to the state.      *      * @return false on parsing error      * @throws IOException If an IO error occurs.      */
specifier|private
name|boolean
name|parseTrailer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|!=
literal|'t'
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//read "trailer"
name|long
name|currentOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|String
name|nextLine
init|=
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nextLine
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|"trailer"
argument_list|)
condition|)
block|{
comment|// in some cases the EOL is missing and the trailer immediately
comment|// continues with "<<" or with a blank character
comment|// even if this does not comply with PDF reference we want to support as many PDFs as possible
comment|// Acrobat reader can also deal with this.
if|if
condition|(
name|nextLine
operator|.
name|startsWith
argument_list|(
literal|"trailer"
argument_list|)
condition|)
block|{
comment|// we can't just unread a portion of the read data as we don't know if the EOL consist of 1 or 2 bytes
name|int
name|len
init|=
literal|"trailer"
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// jump back right after "trailer"
name|source
operator|.
name|seek
argument_list|(
name|currentOffset
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// in some cases the EOL is missing and the trailer continues with "<<"
comment|// even if this does not comply with PDF reference we want to support as many PDFs as possible
comment|// Acrobat reader can also deal with this.
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSDictionary
name|parsedTrailer
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
name|xrefTrailerResolver
operator|.
name|setTrailer
argument_list|(
name|parsedTrailer
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Parse the header of a pdf.      *       * @return true if a PDF header was found      * @throws IOException if something went wrong      */
specifier|protected
name|boolean
name|parsePDFHeader
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|parseHeader
argument_list|(
name|PDF_HEADER
argument_list|,
name|PDF_DEFAULT_VERSION
argument_list|)
return|;
block|}
comment|/**      * Parse the header of a fdf.      *       * @return true if a FDF header was found      * @throws IOException if something went wrong      */
specifier|protected
name|boolean
name|parseFDFHeader
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|parseHeader
argument_list|(
name|FDF_HEADER
argument_list|,
name|FDF_DEFAULT_VERSION
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|parseHeader
parameter_list|(
name|String
name|headerMarker
parameter_list|,
name|String
name|defaultVersion
parameter_list|)
throws|throws
name|IOException
block|{
comment|// read first line
name|String
name|header
init|=
name|readLine
argument_list|()
decl_stmt|;
comment|// some pdf-documents are broken and the pdf-version is in one of the following lines
if|if
condition|(
operator|!
name|header
operator|.
name|contains
argument_list|(
name|headerMarker
argument_list|)
condition|)
block|{
name|header
operator|=
name|readLine
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|header
operator|.
name|contains
argument_list|(
name|headerMarker
argument_list|)
condition|)
block|{
comment|// if a line starts with a digit, it has to be the first one with data in it
if|if
condition|(
operator|(
name|header
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|Character
operator|.
name|isDigit
argument_list|(
name|header
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
name|header
operator|=
name|readLine
argument_list|()
expr_stmt|;
block|}
block|}
comment|// nothing found
if|if
condition|(
operator|!
name|header
operator|.
name|contains
argument_list|(
name|headerMarker
argument_list|)
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|//sometimes there is some garbage in the header before the header
comment|//actually starts, so lets try to find the header first.
name|int
name|headerStart
init|=
name|header
operator|.
name|indexOf
argument_list|(
name|headerMarker
argument_list|)
decl_stmt|;
comment|// greater than zero because if it is zero then there is no point of trimming
if|if
condition|(
name|headerStart
operator|>
literal|0
condition|)
block|{
comment|//trim off any leading characters
name|header
operator|=
name|header
operator|.
name|substring
argument_list|(
name|headerStart
argument_list|,
name|header
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// This is used if there is garbage after the header on the same line
if|if
condition|(
name|header
operator|.
name|startsWith
argument_list|(
name|headerMarker
argument_list|)
operator|&&
operator|!
name|header
operator|.
name|matches
argument_list|(
name|headerMarker
operator|+
literal|"\\d.\\d"
argument_list|)
condition|)
block|{
if|if
condition|(
name|header
operator|.
name|length
argument_list|()
operator|<
name|headerMarker
operator|.
name|length
argument_list|()
operator|+
literal|3
condition|)
block|{
comment|// No version number at all, set to 1.4 as default
name|header
operator|=
name|headerMarker
operator|+
name|defaultVersion
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"No version found, set to "
operator|+
name|defaultVersion
operator|+
literal|" as default."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|headerGarbage
init|=
name|header
operator|.
name|substring
argument_list|(
name|headerMarker
operator|.
name|length
argument_list|()
operator|+
literal|3
argument_list|,
name|header
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|"\n"
decl_stmt|;
name|header
operator|=
name|header
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|headerMarker
operator|.
name|length
argument_list|()
operator|+
literal|3
argument_list|)
expr_stmt|;
name|source
operator|.
name|rewind
argument_list|(
name|headerGarbage
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
name|float
name|headerVersion
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|String
index|[]
name|headerParts
init|=
name|header
operator|.
name|split
argument_list|(
literal|"-"
argument_list|)
decl_stmt|;
if|if
condition|(
name|headerParts
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|headerVersion
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|headerParts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Can't parse the header version."
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|headerVersion
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|headerVersion
operator|=
literal|1.7f
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error getting header version: "
operator|+
name|header
argument_list|)
throw|;
block|}
block|}
name|document
operator|.
name|setVersion
argument_list|(
name|headerVersion
argument_list|)
expr_stmt|;
comment|// rewind
name|source
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * This will parse the xref table from the stream and add it to the state      * The XrefTable contents are ignored.      * @param startByteOffset the offset to start at      * @return false on parsing error      * @throws IOException If an IO error occurs.      */
specifier|protected
name|boolean
name|parseXrefTable
parameter_list|(
name|long
name|startByteOffset
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|!=
literal|'x'
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|xref
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|xref
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|"xref"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check for trailer after xref
name|String
name|str
init|=
name|readString
argument_list|()
decl_stmt|;
name|byte
index|[]
name|b
init|=
name|str
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
decl_stmt|;
name|source
operator|.
name|rewind
argument_list|(
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// signal start of new XRef
name|xrefTrailerResolver
operator|.
name|nextXrefObj
argument_list|(
name|startByteOffset
argument_list|,
name|XRefType
operator|.
name|TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
literal|"trailer"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"skipping empty xref table"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Xref tables can have multiple sections. Each starts with a starting object id and a count.
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|currentLine
init|=
name|readLine
argument_list|()
decl_stmt|;
name|String
index|[]
name|splitString
init|=
name|currentLine
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|;
if|if
condition|(
name|splitString
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected XRefTable Entry: "
operator|+
name|currentLine
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// first obj id
name|long
name|currObjID
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|splitString
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|// the number of objects in the xref table
name|int
name|count
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|splitString
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|source
operator|.
name|isEOF
argument_list|()
operator|||
name|isEndOfName
argument_list|(
operator|(
name|char
operator|)
name|source
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|==
literal|'t'
condition|)
block|{
break|break;
block|}
comment|//Ignore table contents
name|currentLine
operator|=
name|readLine
argument_list|()
expr_stmt|;
name|splitString
operator|=
name|currentLine
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|splitString
operator|.
name|length
operator|<
literal|3
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"invalid xref line: "
operator|+
name|currentLine
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* This supports the corrupt table as reported in                  * PDFBOX-474 (XXXX XXX XX n) */
if|if
condition|(
name|splitString
index|[
name|splitString
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|equals
argument_list|(
literal|"n"
argument_list|)
condition|)
block|{
try|try
block|{
name|long
name|currOffset
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|splitString
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|currGenID
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|splitString
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|currObjID
argument_list|,
name|currGenID
argument_list|)
decl_stmt|;
name|xrefTrailerResolver
operator|.
name|setXRef
argument_list|(
name|objKey
argument_list|,
name|currOffset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|splitString
index|[
literal|2
index|]
operator|.
name|equals
argument_list|(
literal|"f"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupt XRefTable Entry - ObjID:"
operator|+
name|currObjID
argument_list|)
throw|;
block|}
name|currObjID
operator|++
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isDigit
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Fills XRefTrailerResolver with data of given stream.      * Stream must be of type XRef.      * @param stream the stream to be read      * @param objByteOffset the offset to start at      * @param isStandalone should be set to true if the stream is not part of a hybrid xref table      * @throws IOException if there is an error parsing the stream      */
specifier|private
name|void
name|parseXrefStream
parameter_list|(
name|COSStream
name|stream
parameter_list|,
name|long
name|objByteOffset
parameter_list|,
name|boolean
name|isStandalone
parameter_list|)
throws|throws
name|IOException
block|{
comment|// the cross reference stream of a hybrid xref table will be added to the existing one
comment|// and we must not override the offset and the trailer
if|if
condition|(
name|isStandalone
condition|)
block|{
name|xrefTrailerResolver
operator|.
name|nextXrefObj
argument_list|(
name|objByteOffset
argument_list|,
name|XRefType
operator|.
name|STREAM
argument_list|)
expr_stmt|;
name|xrefTrailerResolver
operator|.
name|setTrailer
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
name|PDFXrefStreamParser
name|parser
init|=
operator|new
name|PDFXrefStreamParser
argument_list|(
name|stream
argument_list|,
name|document
argument_list|,
name|xrefTrailerResolver
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
block|}
comment|/**      * This will get the document that was parsed.  parse() must be called before this is called.      * When you are done with this document you must call close() on it to release      * resources.      *      * @return The document that was parsed.      *      * @throws IOException If there is an error getting the document.      */
specifier|public
name|COSDocument
name|getDocument
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|document
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"You must call parse() before calling getDocument()"
argument_list|)
throw|;
block|}
return|return
name|document
return|;
block|}
comment|/**      * Parse the values of the trailer dictionary and return the root object.      *      * @param trailer The trailer dictionary.      * @return The parsed root object.      * @throws IOException If an IO error occurs or if the root object is      * missing in the trailer dictionary.      */
specifier|protected
name|COSBase
name|parseTrailerValuesDynamically
parameter_list|(
name|COSDictionary
name|trailer
parameter_list|)
throws|throws
name|IOException
block|{
comment|// PDFBOX-1557 - ensure that all COSObject are loaded in the trailer
comment|// PDFBOX-1606 - after securityHandler has been instantiated
for|for
control|(
name|COSBase
name|trailerEntry
range|:
name|trailer
operator|.
name|getValues
argument_list|()
control|)
block|{
if|if
condition|(
name|trailerEntry
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|tmpObj
init|=
operator|(
name|COSObject
operator|)
name|trailerEntry
decl_stmt|;
name|parseObjectDynamically
argument_list|(
name|tmpObj
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// parse catalog or root object
name|COSObject
name|root
init|=
operator|(
name|COSObject
operator|)
name|trailer
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing root object specification in trailer."
argument_list|)
throw|;
block|}
return|return
name|parseObjectDynamically
argument_list|(
name|root
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
end_class

end_unit

