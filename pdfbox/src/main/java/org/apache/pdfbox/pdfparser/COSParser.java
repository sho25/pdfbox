begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|GeneralSecurityException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|KeyStore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObjectKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|ICOSParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessRead
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
operator|.
name|XrefTrailerResolver
operator|.
name|XRefType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|AccessPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|DecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|InvalidPasswordException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|PDEncryption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|PublicKeyDecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|SecurityHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|StandardDecryptionMaterial
import|;
end_import

begin_comment
comment|/**  * COS-Parser which first reads startxref and xref tables in order to know valid objects and parse only these objects.  *   * This class is a much enhanced version of<code>QuickParser</code> presented in  *<a href="https://issues.apache.org/jira/browse/PDFBOX-1104">PDFBOX-1104</a> by Jeremy Villalobos.  */
end_comment

begin_class
specifier|public
class|class
name|COSParser
extends|extends
name|BaseParser
implements|implements
name|ICOSParser
block|{
specifier|private
specifier|static
specifier|final
name|String
name|PDF_HEADER
init|=
literal|"%PDF-"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|FDF_HEADER
init|=
literal|"%FDF-"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|PDF_DEFAULT_VERSION
init|=
literal|"1.4"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|FDF_DEFAULT_VERSION
init|=
literal|"1.0"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|XREF_TABLE
init|=
operator|new
name|char
index|[]
block|{
literal|'x'
block|,
literal|'r'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|XREF_STREAM
init|=
operator|new
name|char
index|[]
block|{
literal|'/'
block|,
literal|'X'
block|,
literal|'R'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|STARTXREF
init|=
operator|new
name|char
index|[]
block|{
literal|'s'
block|,
literal|'t'
block|,
literal|'a'
block|,
literal|'r'
block|,
literal|'t'
block|,
literal|'x'
block|,
literal|'r'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|ENDSTREAM
init|=
operator|new
name|byte
index|[]
block|{
name|E
block|,
name|N
block|,
name|D
block|,
name|S
block|,
name|T
block|,
name|R
block|,
name|E
block|,
name|A
block|,
name|M
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|ENDOBJ
init|=
operator|new
name|byte
index|[]
block|{
name|E
block|,
name|N
block|,
name|D
block|,
name|O
block|,
name|B
block|,
name|J
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|MINIMUM_SEARCH_OFFSET
init|=
literal|6
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|X
init|=
literal|'x'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|STRMBUFLEN
init|=
literal|2048
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|strmBuf
init|=
operator|new
name|byte
index|[
name|STRMBUFLEN
index|]
decl_stmt|;
specifier|protected
specifier|final
name|RandomAccessRead
name|source
decl_stmt|;
specifier|private
name|AccessPermission
name|accessPermission
decl_stmt|;
specifier|private
name|InputStream
name|keyStoreInputStream
init|=
literal|null
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"squid:S2068"
block|}
argument_list|)
specifier|private
name|String
name|password
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|keyAlias
init|=
literal|null
decl_stmt|;
comment|/**      * The range within the %%EOF marker will be searched.      * Useful if there are additional characters after %%EOF within the PDF.       */
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_EOFLOOKUPRANGE
init|=
literal|"org.apache.pdfbox.pdfparser.nonSequentialPDFParser.eofLookupRange"
decl_stmt|;
comment|/**      * How many trailing bytes to read for EOF marker.      */
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_TRAIL_BYTECOUNT
init|=
literal|2048
decl_stmt|;
comment|/**      * EOF-marker.      */
specifier|protected
specifier|static
specifier|final
name|char
index|[]
name|EOF_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'%'
block|,
literal|'%'
block|,
literal|'E'
block|,
literal|'O'
block|,
literal|'F'
block|}
decl_stmt|;
comment|/**      * obj-marker.      */
specifier|protected
specifier|static
specifier|final
name|char
index|[]
name|OBJ_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'o'
block|,
literal|'b'
block|,
literal|'j'
block|}
decl_stmt|;
comment|/**      * trailer-marker.      */
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|TRAILER_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'t'
block|,
literal|'r'
block|,
literal|'a'
block|,
literal|'i'
block|,
literal|'l'
block|,
literal|'e'
block|,
literal|'r'
block|}
decl_stmt|;
comment|/**      * ObjStream-marker.      */
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|OBJ_STREAM
init|=
operator|new
name|char
index|[]
block|{
literal|'/'
block|,
literal|'O'
block|,
literal|'b'
block|,
literal|'j'
block|,
literal|'S'
block|,
literal|'t'
block|,
literal|'m'
block|}
decl_stmt|;
comment|/**      * file length.      */
specifier|protected
name|long
name|fileLen
decl_stmt|;
comment|/**      * is parser using auto healing capacity ?      */
specifier|private
name|boolean
name|isLenient
init|=
literal|true
decl_stmt|;
specifier|protected
name|boolean
name|initialParseDone
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|trailerWasRebuild
init|=
literal|false
decl_stmt|;
comment|/**      * Contains all found objects of a brute force search.      */
specifier|private
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|bfSearchCOSObjectKeyOffsets
init|=
literal|null
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Long
argument_list|>
name|bfSearchXRefTablesOffsets
init|=
literal|null
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Long
argument_list|>
name|bfSearchXRefStreamsOffsets
init|=
literal|null
decl_stmt|;
specifier|private
name|PDEncryption
name|encryption
init|=
literal|null
decl_stmt|;
comment|/**      * The security handler.      */
specifier|protected
name|SecurityHandler
name|securityHandler
init|=
literal|null
decl_stmt|;
comment|/**      *  how many trailing bytes to read for EOF marker.      */
specifier|private
name|int
name|readTrailBytes
init|=
name|DEFAULT_TRAIL_BYTECOUNT
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|COSParser
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**       * Collects all Xref/trailer objects and resolves them into single      * object using startxref reference.       */
specifier|protected
name|XrefTrailerResolver
name|xrefTrailerResolver
init|=
operator|new
name|XrefTrailerResolver
argument_list|()
decl_stmt|;
comment|/**      * The prefix for the temp file being used.       */
specifier|public
specifier|static
specifier|final
name|String
name|TMP_FILE_PREFIX
init|=
literal|"tmpPDF"
decl_stmt|;
comment|/**      * Default constructor.      *      * @param source input representing the pdf.      */
specifier|public
name|COSParser
parameter_list|(
name|RandomAccessRead
name|source
parameter_list|)
block|{
name|super
argument_list|(
operator|new
name|RandomAccessSource
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
block|}
comment|/**      * Constructor for encrypted pdfs.      *       * @param source input representing the pdf.      * @param password password to be used for decryption.      * @param keyStore key store to be used for decryption when using public key security      * @param keyAlias alias to be used for decryption when using public key security      *       */
specifier|public
name|COSParser
parameter_list|(
name|RandomAccessRead
name|source
parameter_list|,
name|String
name|password
parameter_list|,
name|InputStream
name|keyStore
parameter_list|,
name|String
name|keyAlias
parameter_list|)
block|{
name|super
argument_list|(
operator|new
name|RandomAccessSource
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|this
operator|.
name|password
operator|=
name|password
expr_stmt|;
name|this
operator|.
name|keyAlias
operator|=
name|keyAlias
expr_stmt|;
name|keyStoreInputStream
operator|=
name|keyStore
expr_stmt|;
block|}
comment|/**      * Sets how many trailing bytes of PDF file are searched for EOF marker and 'startxref' marker. If not set we use      * default value {@link #DEFAULT_TRAIL_BYTECOUNT}.      *       *<p>We check that new value is at least 16. However for practical use cases this value should not be lower than      * 1000; even 2000 was found to not be enough in some cases where some trailing garbage like HTML snippets followed      * the EOF marker.</p>      *       *<p>      * In case system property {@link #SYSPROP_EOFLOOKUPRANGE} is defined this value will be set on initialization but      * can be overwritten later.      *</p>      *       * @param byteCount number of trailing bytes      */
specifier|public
name|void
name|setEOFLookupRange
parameter_list|(
name|int
name|byteCount
parameter_list|)
block|{
if|if
condition|(
name|byteCount
operator|>
literal|15
condition|)
block|{
name|readTrailBytes
operator|=
name|byteCount
expr_stmt|;
block|}
block|}
comment|/**      * Read the trailer information and provide a COSDictionary containing the trailer information.      *       * @return a COSDictionary containing the trailer information      * @throws IOException if something went wrong      */
specifier|protected
name|COSDictionary
name|retrieveTrailer
parameter_list|()
throws|throws
name|IOException
block|{
name|COSDictionary
name|trailer
init|=
literal|null
decl_stmt|;
name|boolean
name|rebuildTrailer
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// parse startxref
comment|// TODO FDF files don't have a startxref value, so that rebuildTrailer is triggered
name|long
name|startXRefOffset
init|=
name|getStartxrefOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|startXRefOffset
operator|>
operator|-
literal|1
condition|)
block|{
name|trailer
operator|=
name|parseXref
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rebuildTrailer
operator|=
name|isLenient
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
if|if
condition|(
name|isLenient
argument_list|()
condition|)
block|{
name|rebuildTrailer
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|exception
throw|;
block|}
block|}
comment|// check if the trailer contains a Root object
if|if
condition|(
name|trailer
operator|!=
literal|null
operator|&&
name|trailer
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|)
operator|==
literal|null
condition|)
block|{
name|rebuildTrailer
operator|=
name|isLenient
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rebuildTrailer
condition|)
block|{
name|trailer
operator|=
name|rebuildTrailer
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// prepare decryption if necessary
name|prepareDecryption
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfSearchCOSObjectKeyOffsets
operator|!=
literal|null
operator|&&
operator|!
name|bfSearchCOSObjectKeyOffsets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bfSearchForObjStreams
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|trailer
return|;
block|}
comment|/**      * Parses cross reference tables.      *       * @param startXRefOffset start offset of the first table      * @return the trailer dictionary      * @throws IOException if something went wrong      */
specifier|private
name|COSDictionary
name|parseXref
parameter_list|(
name|long
name|startXRefOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|source
operator|.
name|seek
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
name|long
name|startXrefOffset
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|parseStartXref
argument_list|()
argument_list|)
decl_stmt|;
comment|// check the startxref offset
name|long
name|fixedOffset
init|=
name|checkXRefOffset
argument_list|(
name|startXrefOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
condition|)
block|{
name|startXrefOffset
operator|=
name|fixedOffset
expr_stmt|;
block|}
name|document
operator|.
name|setStartXref
argument_list|(
name|startXrefOffset
argument_list|)
expr_stmt|;
name|long
name|prev
init|=
name|startXrefOffset
decl_stmt|;
comment|// ---- parse whole chain of xref tables/object streams using PREV reference
name|Set
argument_list|<
name|Long
argument_list|>
name|prevSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|prev
operator|>
literal|0
condition|)
block|{
comment|// seek to xref table
name|source
operator|.
name|seek
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|// skip white spaces
name|skipSpaces
argument_list|()
expr_stmt|;
comment|// -- parse xref
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|==
name|X
condition|)
block|{
comment|// xref table and trailer
comment|// use existing parser to parse xref table
if|if
condition|(
operator|!
name|parseXrefTable
argument_list|(
name|prev
argument_list|)
operator|||
operator|!
name|parseTrailer
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected trailer object at offset "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getCurrentTrailer
argument_list|()
decl_stmt|;
comment|// check for a XRef stream, it may contain some object ids of compressed objects
if|if
condition|(
name|trailer
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|)
condition|)
block|{
name|int
name|streamOffset
init|=
name|trailer
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|)
decl_stmt|;
comment|// check the xref stream reference
name|fixedOffset
operator|=
name|checkXRefOffset
argument_list|(
name|streamOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
operator|&&
name|fixedOffset
operator|!=
name|streamOffset
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"/XRefStm offset "
operator|+
name|streamOffset
operator|+
literal|" is incorrect, corrected to "
operator|+
name|fixedOffset
argument_list|)
expr_stmt|;
name|streamOffset
operator|=
operator|(
name|int
operator|)
name|fixedOffset
expr_stmt|;
name|trailer
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|,
name|streamOffset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|streamOffset
operator|>
literal|0
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
name|streamOffset
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
try|try
block|{
name|parseXrefObjStream
argument_list|(
name|prev
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to parse /XRefStm at offset "
operator|+
name|streamOffset
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|ex
throw|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Skipped XRef stream due to a corrupt offset:"
operator|+
name|streamOffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Skipped XRef stream due to a corrupt offset:"
operator|+
name|streamOffset
argument_list|)
throw|;
block|}
block|}
block|}
name|prev
operator|=
name|trailer
operator|.
name|getLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|>
literal|0
condition|)
block|{
comment|// check the xref table reference
name|fixedOffset
operator|=
name|checkXRefOffset
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
operator|&&
name|fixedOffset
operator|!=
name|prev
condition|)
block|{
name|prev
operator|=
name|fixedOffset
expr_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// parse xref stream
name|prev
operator|=
name|parseXrefObjStream
argument_list|(
name|prev
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|>
literal|0
condition|)
block|{
comment|// check the xref table reference
name|fixedOffset
operator|=
name|checkXRefOffset
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
operator|&&
name|fixedOffset
operator|!=
name|prev
condition|)
block|{
name|prev
operator|=
name|fixedOffset
expr_stmt|;
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getCurrentTrailer
argument_list|()
decl_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|prevSet
operator|.
name|contains
argument_list|(
name|prev
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"/Prev loop at offset "
operator|+
name|prev
argument_list|)
throw|;
block|}
name|prevSet
operator|.
name|add
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
comment|// ---- build valid xrefs out of the xref chain
name|xrefTrailerResolver
operator|.
name|setStartxref
argument_list|(
name|startXrefOffset
argument_list|)
expr_stmt|;
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|document
operator|.
name|setTrailer
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
name|document
operator|.
name|setIsXRefStream
argument_list|(
name|XRefType
operator|.
name|STREAM
operator|==
name|xrefTrailerResolver
operator|.
name|getXrefType
argument_list|()
argument_list|)
expr_stmt|;
comment|// check the offsets of all referenced objects
name|checkXrefOffsets
argument_list|()
expr_stmt|;
comment|// copy xref table
name|document
operator|.
name|addXRefTable
argument_list|(
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|trailer
return|;
block|}
comment|/**      * Parses an xref object stream starting with indirect object id.      *       * @return value of PREV item in dictionary or<code>-1</code> if no such item exists      */
specifier|private
name|long
name|parseXrefObjStream
parameter_list|(
name|long
name|objByteOffset
parameter_list|,
name|boolean
name|isStandalone
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- parse indirect object head
name|long
name|objectNumber
init|=
name|readObjectNumber
argument_list|()
decl_stmt|;
comment|// remember the highest XRef object number to avoid it being reused in incremental saving
name|long
name|currentHighestXRefObjectNumber
init|=
name|document
operator|.
name|getHighestXRefObjectNumber
argument_list|()
decl_stmt|;
name|document
operator|.
name|setHighestXRefObjectNumber
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|currentHighestXRefObjectNumber
argument_list|,
name|objectNumber
argument_list|)
argument_list|)
expr_stmt|;
name|readGenerationNumber
argument_list|()
expr_stmt|;
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|COSDictionary
name|dict
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
try|try
init|(
name|COSStream
name|xrefStream
init|=
name|parseCOSStream
argument_list|(
name|dict
argument_list|)
init|)
block|{
name|parseXrefStream
argument_list|(
name|xrefStream
argument_list|,
name|objByteOffset
argument_list|,
name|isStandalone
argument_list|)
expr_stmt|;
block|}
return|return
name|dict
operator|.
name|getLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
return|;
block|}
comment|/**      * Looks for and parses startxref. We first look for last '%%EOF' marker (within last      * {@link #DEFAULT_TRAIL_BYTECOUNT} bytes (or range set via {@link #setEOFLookupRange(int)}) and go back to find      *<code>startxref</code>.      *       * @return the offset of StartXref      * @throws IOException If something went wrong.      */
specifier|private
name|long
name|getStartxrefOffset
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|buf
decl_stmt|;
name|long
name|skipBytes
decl_stmt|;
comment|// read trailing bytes into buffer
try|try
block|{
specifier|final
name|int
name|trailByteCount
init|=
operator|(
name|fileLen
operator|<
name|readTrailBytes
operator|)
condition|?
operator|(
name|int
operator|)
name|fileLen
else|:
name|readTrailBytes
decl_stmt|;
name|buf
operator|=
operator|new
name|byte
index|[
name|trailByteCount
index|]
expr_stmt|;
name|skipBytes
operator|=
name|fileLen
operator|-
name|trailByteCount
expr_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|skipBytes
argument_list|)
expr_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|readBytes
decl_stmt|;
while|while
condition|(
name|off
operator|<
name|trailByteCount
condition|)
block|{
name|readBytes
operator|=
name|source
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|trailByteCount
operator|-
name|off
argument_list|)
expr_stmt|;
comment|// in order to not get stuck in a loop we check readBytes (this should never happen)
if|if
condition|(
name|readBytes
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No more bytes to read for trailing buffer, but expected: "
operator|+
operator|(
name|trailByteCount
operator|-
name|off
operator|)
argument_list|)
throw|;
block|}
name|off
operator|+=
name|readBytes
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|source
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// find last '%%EOF'
name|int
name|bufOff
init|=
name|lastIndexOf
argument_list|(
name|EOF_MARKER
argument_list|,
name|buf
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufOff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
comment|// in lenient mode the '%%EOF' isn't needed
name|bufOff
operator|=
name|buf
operator|.
name|length
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Missing end of file marker '"
operator|+
operator|new
name|String
argument_list|(
name|EOF_MARKER
argument_list|)
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing end of file marker '"
operator|+
operator|new
name|String
argument_list|(
name|EOF_MARKER
argument_list|)
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
comment|// find last startxref preceding EOF marker
name|bufOff
operator|=
name|lastIndexOf
argument_list|(
name|STARTXREF
argument_list|,
name|buf
argument_list|,
name|bufOff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufOff
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing 'startxref' marker."
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|skipBytes
operator|+
name|bufOff
return|;
block|}
block|}
comment|/**      * Searches last appearance of pattern within buffer. Lookup before _lastOff and goes back until 0.      *       * @param pattern pattern to search for      * @param buf buffer to search pattern in      * @param endOff offset (exclusive) where lookup starts at      *       * @return start offset of pattern within buffer or<code>-1</code> if pattern could not be found      */
specifier|protected
name|int
name|lastIndexOf
parameter_list|(
specifier|final
name|char
index|[]
name|pattern
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|endOff
parameter_list|)
block|{
specifier|final
name|int
name|lastPatternChOff
init|=
name|pattern
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|bufOff
init|=
name|endOff
decl_stmt|;
name|int
name|patOff
init|=
name|lastPatternChOff
decl_stmt|;
name|char
name|lookupCh
init|=
name|pattern
index|[
name|patOff
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|bufOff
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|bufOff
index|]
operator|==
name|lookupCh
condition|)
block|{
if|if
condition|(
operator|--
name|patOff
operator|<
literal|0
condition|)
block|{
comment|// whole pattern matched
return|return
name|bufOff
return|;
block|}
comment|// matched current char, advance to preceding one
name|lookupCh
operator|=
name|pattern
index|[
name|patOff
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|patOff
operator|<
name|lastPatternChOff
condition|)
block|{
comment|// no char match but already matched some chars; reset
name|patOff
operator|=
name|lastPatternChOff
expr_stmt|;
name|lookupCh
operator|=
name|pattern
index|[
name|patOff
index|]
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**      * Return true if parser is lenient. Meaning auto healing capacity of the parser are used.      *      * @return true if parser is lenient      */
specifier|public
name|boolean
name|isLenient
parameter_list|()
block|{
return|return
name|isLenient
return|;
block|}
comment|/**      * Change the parser leniency flag.      *      * This method can only be called before the parsing of the file.      *      * @param lenient try to handle malformed PDFs.      *      */
specifier|protected
name|void
name|setLenient
parameter_list|(
name|boolean
name|lenient
parameter_list|)
block|{
if|if
condition|(
name|initialParseDone
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot change leniency after parsing"
argument_list|)
throw|;
block|}
name|this
operator|.
name|isLenient
operator|=
name|lenient
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|COSBase
name|dereferenceCOSObject
parameter_list|(
name|COSObject
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|currentPos
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|COSBase
name|parsedObj
init|=
name|parseObjectDynamically
argument_list|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
argument_list|,
name|obj
operator|.
name|getGenerationNumber
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentPos
operator|>
literal|0
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
name|currentPos
argument_list|)
expr_stmt|;
block|}
return|return
name|parsedObj
return|;
block|}
comment|/**      * Parse the object for the given object number.        *       * @param objNr object number of object to be parsed      * @param objGenNr object generation number of object to be parsed      * @param requireExistingNotCompressedObj if<code>true</code> the object to be parsed must be defined in xref      * (comment: null objects may be missing from xref) and it must not be a compressed object within object stream      * (this is used to circumvent being stuck in a loop in a malicious PDF)      *       * @return the parsed object (which is also added to document object)      *       * @throws IOException If an IO error occurs.      */
specifier|protected
specifier|synchronized
name|COSBase
name|parseObjectDynamically
parameter_list|(
name|long
name|objNr
parameter_list|,
name|int
name|objGenNr
parameter_list|,
name|boolean
name|requireExistingNotCompressedObj
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- create object key and get object (container) from pool
specifier|final
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|objNr
argument_list|,
name|objGenNr
argument_list|)
decl_stmt|;
specifier|final
name|COSObject
name|pdfObject
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
name|COSBase
name|referencedObject
init|=
operator|!
name|pdfObject
operator|.
name|isObjectNull
argument_list|()
condition|?
name|pdfObject
operator|.
name|getObject
argument_list|()
else|:
literal|null
decl_stmt|;
comment|// not previously parsed
if|if
condition|(
name|referencedObject
operator|==
literal|null
condition|)
block|{
comment|// read offset or object stream object number from xref table
name|Long
name|offsetOrObjstmObNr
init|=
name|document
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
comment|// maybe something is wrong with the xref table -> perform brute force search for all objects
if|if
condition|(
name|offsetOrObjstmObNr
operator|==
literal|null
operator|&&
name|isLenient
condition|)
block|{
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|bfCOSObjectKeyOffsets
init|=
name|getBFCOSObjectOffsets
argument_list|()
decl_stmt|;
name|offsetOrObjstmObNr
operator|=
name|bfCOSObjectKeyOffsets
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsetOrObjstmObNr
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Set missing offset "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|" for object "
operator|+
name|objKey
argument_list|)
expr_stmt|;
name|document
operator|.
name|getXrefTable
argument_list|()
operator|.
name|put
argument_list|(
name|objKey
argument_list|,
name|offsetOrObjstmObNr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// sanity test to circumvent loops with broken documents
if|if
condition|(
name|requireExistingNotCompressedObj
operator|&&
operator|(
operator|(
name|offsetOrObjstmObNr
operator|==
literal|null
operator|)
operator|||
operator|(
name|offsetOrObjstmObNr
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object must be defined and must not be compressed object: "
operator|+
name|objKey
operator|.
name|getNumber
argument_list|()
operator|+
literal|":"
operator|+
name|objKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|offsetOrObjstmObNr
operator|==
literal|null
condition|)
block|{
comment|// not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)
comment|// remove parser to avoid endless recursion
name|pdfObject
operator|.
name|setToNull
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsetOrObjstmObNr
operator|>
literal|0
condition|)
block|{
comment|// offset of indirect object in file
name|referencedObject
operator|=
name|parseFileObject
argument_list|(
name|offsetOrObjstmObNr
argument_list|,
name|objKey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// xref value is object nr of object stream containing object to be parsed
comment|// since our object was not found it means object stream was not parsed so far
name|referencedObject
operator|=
name|parseObjectStreamObject
argument_list|(
operator|(
name|int
operator|)
operator|-
name|offsetOrObjstmObNr
argument_list|,
name|objKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|referencedObject
operator|==
literal|null
operator|||
name|referencedObject
operator|instanceof
name|COSNull
condition|)
block|{
name|pdfObject
operator|.
name|setToNull
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|referencedObject
return|;
block|}
specifier|private
name|COSBase
name|parseFileObject
parameter_list|(
name|Long
name|offsetOrObjstmObNr
parameter_list|,
specifier|final
name|COSObjectKey
name|objKey
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- go to object start
name|source
operator|.
name|seek
argument_list|(
name|offsetOrObjstmObNr
argument_list|)
expr_stmt|;
comment|// ---- we must have an indirect object
specifier|final
name|long
name|readObjNr
init|=
name|readObjectNumber
argument_list|()
decl_stmt|;
specifier|final
name|int
name|readObjGen
init|=
name|readGenerationNumber
argument_list|()
decl_stmt|;
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// ---- consistency check
if|if
condition|(
operator|(
name|readObjNr
operator|!=
name|objKey
operator|.
name|getNumber
argument_list|()
operator|)
operator|||
operator|(
name|readObjGen
operator|!=
name|objKey
operator|.
name|getGeneration
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"XREF for "
operator|+
name|objKey
operator|.
name|getNumber
argument_list|()
operator|+
literal|":"
operator|+
name|objKey
operator|.
name|getGeneration
argument_list|()
operator|+
literal|" points to wrong object: "
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
operator|+
literal|" at offset "
operator|+
name|offsetOrObjstmObNr
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSBase
name|parsedObject
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|String
name|endObjectKey
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
name|endObjectKey
operator|.
name|equals
argument_list|(
name|STREAM_STRING
argument_list|)
condition|)
block|{
name|source
operator|.
name|rewind
argument_list|(
name|endObjectKey
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|ISO_8859_1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsedObject
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSStream
name|stream
init|=
name|parseCOSStream
argument_list|(
operator|(
name|COSDictionary
operator|)
name|parsedObject
argument_list|)
decl_stmt|;
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
name|securityHandler
operator|.
name|decryptStream
argument_list|(
name|stream
argument_list|,
name|objKey
operator|.
name|getNumber
argument_list|()
argument_list|,
name|objKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|parsedObject
operator|=
name|stream
expr_stmt|;
block|}
else|else
block|{
comment|// this is not legal
comment|// the combination of a dict and the stream/endstream
comment|// forms a complete stream object
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream not preceded by dictionary (offset: "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|")."
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|endObjectKey
operator|=
name|readLine
argument_list|()
expr_stmt|;
comment|// we have case with a second 'endstream' before endobj
if|if
condition|(
operator|!
name|endObjectKey
operator|.
name|startsWith
argument_list|(
name|ENDOBJ_STRING
argument_list|)
operator|&&
name|endObjectKey
operator|.
name|startsWith
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
condition|)
block|{
name|endObjectKey
operator|=
name|endObjectKey
operator|.
name|substring
argument_list|(
literal|9
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|endObjectKey
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// no other characters in extra endstream line
comment|// read next line
name|endObjectKey
operator|=
name|readLine
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
name|securityHandler
operator|.
name|decrypt
argument_list|(
name|parsedObject
argument_list|,
name|objKey
operator|.
name|getNumber
argument_list|()
argument_list|,
name|objKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|endObjectKey
operator|.
name|startsWith
argument_list|(
name|ENDOBJ_STRING
argument_list|)
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Object ("
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
operator|+
literal|") at offset "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|" does not end with 'endobj' but with '"
operator|+
name|endObjectKey
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object ("
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
operator|+
literal|") at offset "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|" does not end with 'endobj' but with '"
operator|+
name|endObjectKey
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
return|return
name|parsedObject
return|;
block|}
comment|/**      * Parse the object with the given key from the object stream with the given number.      *       * @param objstmObjNr the number of the offset stream      * @param key the key of the object to be parsed      * @return the parsed object      * @throws IOException if something went wrong when parsing the object      */
specifier|protected
name|COSBase
name|parseObjectStreamObject
parameter_list|(
name|int
name|objstmObjNr
parameter_list|,
name|COSObjectKey
name|key
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|COSBase
name|objstmBaseObj
init|=
name|parseObjectDynamically
argument_list|(
name|objstmObjNr
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|COSBase
name|objectStreamObject
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|objstmBaseObj
operator|instanceof
name|COSStream
condition|)
block|{
comment|// parse object stream
name|PDFObjectStreamParser
name|parser
init|=
literal|null
decl_stmt|;
try|try
block|{
name|parser
operator|=
operator|new
name|PDFObjectStreamParser
argument_list|(
operator|(
name|COSStream
operator|)
name|objstmBaseObj
argument_list|,
name|document
argument_list|)
expr_stmt|;
name|objectStreamObject
operator|=
name|parser
operator|.
name|parseObject
argument_list|(
name|key
operator|.
name|getNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"object stream "
operator|+
name|objstmObjNr
operator|+
literal|" could not be parsed due to an exception"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|ex
throw|;
block|}
block|}
block|}
return|return
name|objectStreamObject
return|;
block|}
comment|/**       * Returns length value referred to or defined in given object.       */
specifier|private
name|COSNumber
name|getLength
parameter_list|(
specifier|final
name|COSBase
name|lengthBaseObj
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|lengthBaseObj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// maybe length was given directly
if|if
condition|(
name|lengthBaseObj
operator|instanceof
name|COSNumber
condition|)
block|{
return|return
operator|(
name|COSNumber
operator|)
name|lengthBaseObj
return|;
block|}
comment|// length in referenced object
if|if
condition|(
name|lengthBaseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|lengthObj
init|=
operator|(
name|COSObject
operator|)
name|lengthBaseObj
decl_stmt|;
name|COSBase
name|length
init|=
name|lengthObj
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Length object content was not read."
argument_list|)
throw|;
block|}
if|if
condition|(
name|COSNull
operator|.
name|NULL
operator|==
name|length
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Length object ("
operator|+
name|lengthObj
operator|.
name|getObjectNumber
argument_list|()
operator|+
literal|" "
operator|+
name|lengthObj
operator|.
name|getGenerationNumber
argument_list|()
operator|+
literal|") not found"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|length
operator|instanceof
name|COSNumber
condition|)
block|{
return|return
operator|(
name|COSNumber
operator|)
name|length
return|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong type of referenced length object "
operator|+
name|lengthObj
operator|+
literal|": "
operator|+
name|length
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong type of length object: "
operator|+
name|lengthBaseObj
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|STREAMCOPYBUFLEN
init|=
literal|8192
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|streamCopyBuf
init|=
operator|new
name|byte
index|[
name|STREAMCOPYBUFLEN
index|]
decl_stmt|;
comment|/**      * This will read a COSStream from the input stream using length attribute within dictionary. If      * length attribute is a indirect reference it is first resolved to get the stream length. This      * means we copy stream data without testing for 'endstream' or 'endobj' and thus it is no      * problem if these keywords occur within stream. We require 'endstream' to be found after      * stream data is read.      *      * @param dic dictionary that goes with this stream.      *      * @return parsed pdf stream.      *      * @throws IOException if an error occurred reading the stream, like problems with reading      * length attribute, stream does not end with 'endstream' after data read, stream too short etc.      */
specifier|protected
name|COSStream
name|parseCOSStream
parameter_list|(
name|COSDictionary
name|dic
parameter_list|)
throws|throws
name|IOException
block|{
name|COSStream
name|stream
init|=
name|document
operator|.
name|createCOSStream
argument_list|(
name|dic
argument_list|)
decl_stmt|;
comment|// read 'stream'; this was already tested in parseObjectsDynamically()
name|readString
argument_list|()
expr_stmt|;
name|skipWhiteSpaces
argument_list|()
expr_stmt|;
comment|/*          * This needs to be dic.getItem because when we are parsing, the underlying object might still be null.          */
name|COSNumber
name|streamLengthObj
init|=
name|getLength
argument_list|(
name|dic
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|streamLengthObj
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The stream doesn't provide any stream length, using fallback readUntilEnd, at offset "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing length for stream."
argument_list|)
throw|;
block|}
block|}
comment|// get output stream to copy data to
try|try
init|(
name|OutputStream
name|out
init|=
name|stream
operator|.
name|createRawOutputStream
argument_list|()
init|)
block|{
if|if
condition|(
name|streamLengthObj
operator|!=
literal|null
operator|&&
name|validateStreamLength
argument_list|(
name|streamLengthObj
operator|.
name|longValue
argument_list|()
argument_list|)
condition|)
block|{
name|readValidStream
argument_list|(
name|out
argument_list|,
name|streamLengthObj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|readUntilEndStream
argument_list|(
operator|new
name|EndstreamOutputStream
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|endStream
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
name|endStream
operator|.
name|equals
argument_list|(
literal|"endobj"
argument_list|)
operator|&&
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"stream ends with 'endobj' instead of 'endstream' at offset "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
comment|// avoid follow-up warning about missing endobj
name|source
operator|.
name|rewind
argument_list|(
name|ENDOBJ
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endStream
operator|.
name|length
argument_list|()
operator|>
literal|9
operator|&&
name|isLenient
operator|&&
name|endStream
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|9
argument_list|)
operator|.
name|equals
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"stream ends with '"
operator|+
name|endStream
operator|+
literal|"' instead of 'endstream' at offset "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
comment|// unread the "extra" bytes
name|source
operator|.
name|rewind
argument_list|(
name|endStream
operator|.
name|substring
argument_list|(
literal|9
argument_list|)
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|ISO_8859_1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|endStream
operator|.
name|equals
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error reading stream, expected='endstream' actual='"
operator|+
name|endStream
operator|+
literal|"' at offset "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|stream
return|;
block|}
comment|/**      * This method will read through the current stream object until      * we find the keyword "endstream" meaning we're at the end of this      * object. Some pdf files, however, forget to write some endstream tags      * and just close off objects with an "endobj" tag so we have to handle      * this case as well.      *       * This method is optimized using buffered IO and reduced number of      * byte compare operations.      *       * @param out  stream we write out to.      *       * @throws IOException if something went wrong      */
specifier|private
name|void
name|readUntilEndStream
parameter_list|(
specifier|final
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|bufSize
decl_stmt|;
name|int
name|charMatchCount
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|keyw
init|=
name|ENDSTREAM
decl_stmt|;
comment|// last character position of shortest keyword ('endobj')
specifier|final
name|int
name|quickTestOffset
init|=
literal|5
decl_stmt|;
comment|// read next chunk into buffer; already matched chars are added to beginning of buffer
while|while
condition|(
operator|(
name|bufSize
operator|=
name|source
operator|.
name|read
argument_list|(
name|strmBuf
argument_list|,
name|charMatchCount
argument_list|,
name|STRMBUFLEN
operator|-
name|charMatchCount
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|bufSize
operator|+=
name|charMatchCount
expr_stmt|;
name|int
name|bIdx
init|=
name|charMatchCount
decl_stmt|;
name|int
name|quickTestIdx
decl_stmt|;
comment|// iterate over buffer, trying to find keyword match
for|for
control|(
name|int
name|maxQuicktestIdx
init|=
name|bufSize
operator|-
name|quickTestOffset
init|;
name|bIdx
operator|<
name|bufSize
condition|;
name|bIdx
operator|++
control|)
block|{
comment|// reduce compare operations by first test last character we would have to
comment|// match if current one matches; if it is not a character from keywords
comment|// we can move behind the test character; this shortcut is inspired by the
comment|// Boyer-Moore string search algorithm and can reduce parsing time by approx. 20%
name|quickTestIdx
operator|=
name|bIdx
operator|+
name|quickTestOffset
expr_stmt|;
if|if
condition|(
name|charMatchCount
operator|==
literal|0
operator|&&
name|quickTestIdx
operator|<
name|maxQuicktestIdx
condition|)
block|{
specifier|final
name|byte
name|ch
init|=
name|strmBuf
index|[
name|quickTestIdx
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>
literal|'t'
operator|)
operator|||
operator|(
name|ch
operator|<
literal|'a'
operator|)
condition|)
block|{
comment|// last character we would have to match if current character would match
comment|// is not a character from keywords -> jump behind and start over
name|bIdx
operator|=
name|quickTestIdx
expr_stmt|;
continue|continue;
block|}
block|}
comment|// could be negative - but we only compare to ASCII
specifier|final
name|byte
name|ch
init|=
name|strmBuf
index|[
name|bIdx
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|keyw
index|[
name|charMatchCount
index|]
condition|)
block|{
if|if
condition|(
operator|++
name|charMatchCount
operator|==
name|keyw
operator|.
name|length
condition|)
block|{
comment|// match found
name|bIdx
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|charMatchCount
operator|==
literal|3
operator|)
operator|&&
operator|(
name|ch
operator|==
name|ENDOBJ
index|[
name|charMatchCount
index|]
operator|)
condition|)
block|{
comment|// maybe ENDSTREAM is missing but we could have ENDOBJ
name|keyw
operator|=
name|ENDOBJ
expr_stmt|;
name|charMatchCount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// no match; incrementing match start by 1 would be dumb since we already know
comment|// matched chars depending on current char read we may already have beginning
comment|// of a new match: 'e': first char matched; 'n': if we are at match position
comment|// idx 7 we already read 'e' thus 2 chars matched for each other char we have
comment|// to start matching first keyword char beginning with next read position
name|charMatchCount
operator|=
operator|(
name|ch
operator|==
name|E
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|ch
operator|==
name|N
operator|)
operator|&&
operator|(
name|charMatchCount
operator|==
literal|7
operator|)
operator|)
condition|?
literal|2
else|:
literal|0
expr_stmt|;
comment|// search again for 'endstream'
name|keyw
operator|=
name|ENDSTREAM
expr_stmt|;
block|}
block|}
block|}
name|int
name|contentBytes
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|bIdx
operator|-
name|charMatchCount
argument_list|)
decl_stmt|;
comment|// write buffer content until first matched char to output stream
if|if
condition|(
name|contentBytes
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|strmBuf
argument_list|,
literal|0
argument_list|,
name|contentBytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|charMatchCount
operator|==
name|keyw
operator|.
name|length
condition|)
block|{
comment|// keyword matched; unread matched keyword (endstream/endobj) and following buffered content
name|source
operator|.
name|rewind
argument_list|(
name|bufSize
operator|-
name|contentBytes
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// copy matched chars at start of buffer
name|System
operator|.
name|arraycopy
argument_list|(
name|keyw
argument_list|,
literal|0
argument_list|,
name|strmBuf
argument_list|,
literal|0
argument_list|,
name|charMatchCount
argument_list|)
expr_stmt|;
block|}
block|}
comment|// this writes a lonely CR or drops trailing CR LF and LF
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|readValidStream
parameter_list|(
name|OutputStream
name|out
parameter_list|,
name|COSNumber
name|streamLengthObj
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|remainBytes
init|=
name|streamLengthObj
operator|.
name|longValue
argument_list|()
decl_stmt|;
while|while
condition|(
name|remainBytes
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|chunk
init|=
operator|(
name|remainBytes
operator|>
name|STREAMCOPYBUFLEN
operator|)
condition|?
name|STREAMCOPYBUFLEN
else|:
operator|(
name|int
operator|)
name|remainBytes
decl_stmt|;
specifier|final
name|int
name|readBytes
init|=
name|source
operator|.
name|read
argument_list|(
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
name|chunk
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBytes
operator|<=
literal|0
condition|)
block|{
comment|// shouldn't happen, the stream length has already been validated
throw|throw
operator|new
name|IOException
argument_list|(
literal|"read error at offset "
operator|+
name|source
operator|.
name|getPosition
argument_list|()
operator|+
literal|": expected "
operator|+
name|chunk
operator|+
literal|" bytes, but read() returns "
operator|+
name|readBytes
argument_list|)
throw|;
block|}
name|out
operator|.
name|write
argument_list|(
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
name|readBytes
argument_list|)
expr_stmt|;
name|remainBytes
operator|-=
name|readBytes
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|validateStreamLength
parameter_list|(
name|long
name|streamLength
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|streamLengthIsValid
init|=
literal|true
decl_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|long
name|expectedEndOfStream
init|=
name|originOffset
operator|+
name|streamLength
decl_stmt|;
if|if
condition|(
name|expectedEndOfStream
operator|>
name|fileLen
condition|)
block|{
name|streamLengthIsValid
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"The end of the stream is out of range, using workaround to read the stream, "
operator|+
literal|"stream start position: "
operator|+
name|originOffset
operator|+
literal|", length: "
operator|+
name|streamLength
operator|+
literal|", expected end position: "
operator|+
name|expectedEndOfStream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|source
operator|.
name|seek
argument_list|(
name|expectedEndOfStream
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isString
argument_list|(
name|ENDSTREAM
argument_list|)
condition|)
block|{
name|streamLengthIsValid
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"The end of the stream doesn't point to the correct offset, using workaround to read the stream, "
operator|+
literal|"stream start position: "
operator|+
name|originOffset
operator|+
literal|", length: "
operator|+
name|streamLength
operator|+
literal|", expected end position: "
operator|+
name|expectedEndOfStream
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
return|return
name|streamLengthIsValid
return|;
block|}
comment|/**      * Check if the cross reference table/stream can be found at the current offset.      *       * @param startXRefOffset      * @return the revised offset      * @throws IOException      */
specifier|private
name|long
name|checkXRefOffset
parameter_list|(
name|long
name|startXRefOffset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// repair mode isn't available in non-lenient mode
if|if
condition|(
operator|!
name|isLenient
condition|)
block|{
return|return
name|startXRefOffset
return|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|==
name|X
operator|&&
name|isString
argument_list|(
name|XREF_TABLE
argument_list|)
condition|)
block|{
return|return
name|startXRefOffset
return|;
block|}
if|if
condition|(
name|startXRefOffset
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|checkXRefStreamOffset
argument_list|(
name|startXRefOffset
argument_list|)
condition|)
block|{
return|return
name|startXRefOffset
return|;
block|}
else|else
block|{
return|return
name|calculateXRefFixedOffset
argument_list|(
name|startXRefOffset
argument_list|)
return|;
block|}
block|}
comment|// can't find a valid offset
return|return
operator|-
literal|1
return|;
block|}
comment|/**      * Check if the cross reference stream can be found at the current offset.      *       * @param startXRefOffset the expected start offset of the XRef stream      * @return the revised offset      * @throws IOException if something went wrong      */
specifier|private
name|boolean
name|checkXRefStreamOffset
parameter_list|(
name|long
name|startXRefOffset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// repair mode isn't available in non-lenient mode
if|if
condition|(
operator|!
name|isLenient
operator|||
name|startXRefOffset
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// seek to offset-1
name|source
operator|.
name|seek
argument_list|(
name|startXRefOffset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|int
name|nextValue
init|=
name|source
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// the first character has to be a whitespace, and then a digit
if|if
condition|(
name|isWhitespace
argument_list|(
name|nextValue
argument_list|)
condition|)
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
name|isDigit
argument_list|()
condition|)
block|{
try|try
block|{
comment|// it's a XRef stream
name|readObjectNumber
argument_list|()
expr_stmt|;
name|readGenerationNumber
argument_list|()
expr_stmt|;
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// check the dictionary to avoid false positives
name|COSDictionary
name|dict
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"XRef"
operator|.
name|equals
argument_list|(
name|dict
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
comment|// there wasn't an object of a xref stream
name|LOG
operator|.
name|debug
argument_list|(
literal|"No Xref stream at given location "
operator|+
name|startXRefOffset
argument_list|,
name|exception
argument_list|)
expr_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Try to find a fixed offset for the given xref table/stream.      *       * @param objectOffset the given offset where to look at      * @return the fixed offset      *       * @throws IOException if something went wrong      */
specifier|private
name|long
name|calculateXRefFixedOffset
parameter_list|(
name|long
name|objectOffset
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|objectOffset
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid object offset "
operator|+
name|objectOffset
operator|+
literal|" when searching for a xref table/stream"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// start a brute force search for all xref tables and try to find the offset we are looking for
name|long
name|newOffset
init|=
name|bfSearchForXRef
argument_list|(
name|objectOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|newOffset
operator|>
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fixed reference for xref table/stream "
operator|+
name|objectOffset
operator|+
literal|" -> "
operator|+
name|newOffset
argument_list|)
expr_stmt|;
return|return
name|newOffset
return|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't find the object xref table/stream at offset "
operator|+
name|objectOffset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|private
name|boolean
name|validateXrefOffsets
parameter_list|(
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|xrefOffset
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|xrefOffset
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|objectEntry
range|:
name|xrefOffset
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|COSObjectKey
name|objectKey
init|=
name|objectEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Long
name|objectOffset
init|=
name|objectEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// a negative offset number represents an object number itself
comment|// see type 2 entry in xref stream
if|if
condition|(
name|objectOffset
operator|!=
literal|null
operator|&&
name|objectOffset
operator|>=
literal|0
operator|&&
operator|!
name|checkObjectKey
argument_list|(
name|objectKey
argument_list|,
name|objectOffset
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stop checking xref offsets as at least one ("
operator|+
name|objectKey
operator|+
literal|") couldn't be dereferenced"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Check the XRef table by dereferencing all objects and fixing the offset if necessary.      *       * @throws IOException if something went wrong.      */
specifier|private
name|void
name|checkXrefOffsets
parameter_list|()
throws|throws
name|IOException
block|{
comment|// repair mode isn't available in non-lenient mode
if|if
condition|(
operator|!
name|isLenient
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|xrefOffset
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|validateXrefOffsets
argument_list|(
name|xrefOffset
argument_list|)
condition|)
block|{
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|bfCOSObjectKeyOffsets
init|=
name|getBFCOSObjectOffsets
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|bfCOSObjectKeyOffsets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Replaced read xref table with the results of a brute force search"
argument_list|)
expr_stmt|;
name|xrefOffset
operator|.
name|clear
argument_list|()
expr_stmt|;
name|xrefOffset
operator|.
name|putAll
argument_list|(
name|bfCOSObjectKeyOffsets
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Check if the given object can be found at the given offset.      *       * @param objectKey the object we are looking for      * @param offset the offset where to look      * @return returns true if the given object can be dereferenced at the given offset      * @throws IOException if something went wrong      */
specifier|private
name|boolean
name|checkObjectKey
parameter_list|(
name|COSObjectKey
name|objectKey
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// there can't be any object at the very beginning of a pdf
if|if
condition|(
name|offset
operator|<
name|MINIMUM_SEARCH_OFFSET
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|objectKeyFound
init|=
literal|false
decl_stmt|;
try|try
block|{
name|source
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|// try to read the given object/generation number
if|if
condition|(
name|objectKey
operator|.
name|getNumber
argument_list|()
operator|==
name|readObjectNumber
argument_list|()
condition|)
block|{
name|int
name|genNumber
init|=
name|readGenerationNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|genNumber
operator|==
name|objectKey
operator|.
name|getGeneration
argument_list|()
condition|)
block|{
comment|// finally try to read the object marker
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|objectKeyFound
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isLenient
operator|&&
name|genNumber
operator|>
name|objectKey
operator|.
name|getGeneration
argument_list|()
condition|)
block|{
comment|// finally try to read the object marker
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|objectKeyFound
operator|=
literal|true
expr_stmt|;
name|objectKey
operator|.
name|fixGeneration
argument_list|(
name|genNumber
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
comment|// Swallow the exception, obviously there isn't any valid object number
name|LOG
operator|.
name|debug
argument_list|(
literal|"No valid object at given location "
operator|+
name|offset
operator|+
literal|" - ignoring"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
comment|// return resulting value
return|return
name|objectKeyFound
return|;
block|}
specifier|private
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|getBFCOSObjectOffsets
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bfSearchCOSObjectKeyOffsets
operator|==
literal|null
condition|)
block|{
name|bfSearchForObjects
argument_list|()
expr_stmt|;
block|}
return|return
name|bfSearchCOSObjectKeyOffsets
return|;
block|}
comment|/**      * Brute force search for every object in the pdf.      *         * @throws IOException if something went wrong      */
specifier|private
name|void
name|bfSearchForObjects
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|lastEOFMarker
init|=
name|bfSearchForLastEOFMarker
argument_list|()
decl_stmt|;
name|bfSearchCOSObjectKeyOffsets
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|long
name|currentOffset
init|=
name|MINIMUM_SEARCH_OFFSET
decl_stmt|;
name|long
name|lastObjectId
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
name|int
name|lastGenID
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
name|long
name|lastObjOffset
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
name|char
index|[]
name|endobjString
init|=
literal|"ndo"
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|char
index|[]
name|endobjRemainingString
init|=
literal|"bj"
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|boolean
name|endOfObjFound
init|=
literal|false
decl_stmt|;
do|do
block|{
name|source
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
name|int
name|nextChar
init|=
name|source
operator|.
name|read
argument_list|()
decl_stmt|;
name|currentOffset
operator|++
expr_stmt|;
if|if
condition|(
name|isWhitespace
argument_list|(
name|nextChar
argument_list|)
operator|&&
name|isString
argument_list|(
name|OBJ_MARKER
argument_list|)
condition|)
block|{
name|long
name|tempOffset
init|=
name|currentOffset
operator|-
literal|2
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
name|int
name|genID
init|=
name|source
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// is the next char a digit?
if|if
condition|(
name|isDigit
argument_list|(
name|genID
argument_list|)
condition|)
block|{
name|genID
operator|-=
literal|48
expr_stmt|;
name|tempOffset
operator|--
expr_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isWhitespace
argument_list|()
condition|)
block|{
while|while
condition|(
name|tempOffset
operator|>
name|MINIMUM_SEARCH_OFFSET
operator|&&
name|isWhitespace
argument_list|()
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
block|}
name|boolean
name|objectIDFound
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|tempOffset
operator|>
name|MINIMUM_SEARCH_OFFSET
operator|&&
name|isDigit
argument_list|()
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
name|objectIDFound
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|objectIDFound
condition|)
block|{
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
name|long
name|objectId
init|=
name|readObjectNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastObjOffset
operator|>
literal|0
condition|)
block|{
comment|// add the former object ID only if there was a subsequent object ID
name|bfSearchCOSObjectKeyOffsets
operator|.
name|put
argument_list|(
operator|new
name|COSObjectKey
argument_list|(
name|lastObjectId
argument_list|,
name|lastGenID
argument_list|)
argument_list|,
name|lastObjOffset
argument_list|)
expr_stmt|;
block|}
name|lastObjectId
operator|=
name|objectId
expr_stmt|;
name|lastGenID
operator|=
name|genID
expr_stmt|;
name|lastObjOffset
operator|=
name|tempOffset
operator|+
literal|1
expr_stmt|;
name|currentOffset
operator|+=
name|OBJ_MARKER
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|endOfObjFound
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// check for "endo" as abbreviation for "endobj", as the pdf may be cut off
comment|// in the middle of the keyword, see PDFBOX-3936.
comment|// We could possibly implement a more intelligent algorithm if necessary
elseif|else
if|if
condition|(
name|nextChar
operator|==
literal|'e'
operator|&&
name|isString
argument_list|(
name|endobjString
argument_list|)
condition|)
block|{
name|currentOffset
operator|+=
name|endobjString
operator|.
name|length
expr_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|.
name|isEOF
argument_list|()
condition|)
block|{
name|endOfObjFound
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isString
argument_list|(
name|endobjRemainingString
argument_list|)
condition|)
block|{
name|currentOffset
operator|+=
name|endobjRemainingString
operator|.
name|length
expr_stmt|;
name|endOfObjFound
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
block|}
block|}
do|while
condition|(
name|currentOffset
operator|<
name|lastEOFMarker
operator|&&
operator|!
name|source
operator|.
name|isEOF
argument_list|()
condition|)
do|;
if|if
condition|(
operator|(
name|lastEOFMarker
operator|<
name|Long
operator|.
name|MAX_VALUE
operator|||
name|endOfObjFound
operator|)
operator|&&
name|lastObjOffset
operator|>
literal|0
condition|)
block|{
comment|// if the pdf wasn't cut off in the middle or if the last object ends with a "endobj" marker
comment|// the last object id has to be added here so that it can't get lost as there isn't any subsequent object id
name|bfSearchCOSObjectKeyOffsets
operator|.
name|put
argument_list|(
operator|new
name|COSObjectKey
argument_list|(
name|lastObjectId
argument_list|,
name|lastGenID
argument_list|)
argument_list|,
name|lastObjOffset
argument_list|)
expr_stmt|;
block|}
comment|// reestablish origin position
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
comment|/**      * Search for the offset of the given xref table/stream among those found by a brute force search.      *       * @return the offset of the xref entry      * @throws IOException if something went wrong      */
specifier|private
name|long
name|bfSearchForXRef
parameter_list|(
name|long
name|xrefOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|newOffset
init|=
operator|-
literal|1
decl_stmt|;
comment|// initialize bfSearchXRefTablesOffsets -> not null
name|bfSearchForXRefTables
argument_list|()
expr_stmt|;
comment|// initialize bfSearchXRefStreamsOffsets -> not null
name|bfSearchForXRefStreams
argument_list|()
expr_stmt|;
comment|// TODO to be optimized, this won't work in every case
name|long
name|newOffsetTable
init|=
name|searchNearestValue
argument_list|(
name|bfSearchXRefTablesOffsets
argument_list|,
name|xrefOffset
argument_list|)
decl_stmt|;
comment|// TODO to be optimized, this won't work in every case
name|long
name|newOffsetStream
init|=
name|searchNearestValue
argument_list|(
name|bfSearchXRefStreamsOffsets
argument_list|,
name|xrefOffset
argument_list|)
decl_stmt|;
comment|// choose the nearest value
if|if
condition|(
name|newOffsetTable
operator|>
operator|-
literal|1
operator|&&
name|newOffsetStream
operator|>
operator|-
literal|1
condition|)
block|{
name|long
name|differenceTable
init|=
name|xrefOffset
operator|-
name|newOffsetTable
decl_stmt|;
name|long
name|differenceStream
init|=
name|xrefOffset
operator|-
name|newOffsetStream
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|differenceTable
argument_list|)
operator|>
name|Math
operator|.
name|abs
argument_list|(
name|differenceStream
argument_list|)
condition|)
block|{
name|newOffset
operator|=
name|newOffsetStream
expr_stmt|;
name|bfSearchXRefStreamsOffsets
operator|.
name|remove
argument_list|(
name|newOffsetStream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newOffset
operator|=
name|newOffsetTable
expr_stmt|;
name|bfSearchXRefTablesOffsets
operator|.
name|remove
argument_list|(
name|newOffsetTable
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|newOffsetTable
operator|>
operator|-
literal|1
condition|)
block|{
name|newOffset
operator|=
name|newOffsetTable
expr_stmt|;
name|bfSearchXRefTablesOffsets
operator|.
name|remove
argument_list|(
name|newOffsetTable
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newOffsetStream
operator|>
operator|-
literal|1
condition|)
block|{
name|newOffset
operator|=
name|newOffsetStream
expr_stmt|;
name|bfSearchXRefStreamsOffsets
operator|.
name|remove
argument_list|(
name|newOffsetStream
argument_list|)
expr_stmt|;
block|}
return|return
name|newOffset
return|;
block|}
specifier|private
name|long
name|searchNearestValue
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|values
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
name|long
name|newValue
init|=
operator|-
literal|1
decl_stmt|;
name|Long
name|currentDifference
init|=
literal|null
decl_stmt|;
name|int
name|currentOffsetIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|numberOfOffsets
init|=
name|values
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// find the nearest value
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfOffsets
condition|;
name|i
operator|++
control|)
block|{
name|long
name|newDifference
init|=
name|offset
operator|-
name|values
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// find the nearest offset
if|if
condition|(
name|currentDifference
operator|==
literal|null
operator|||
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|currentDifference
argument_list|)
operator|>
name|Math
operator|.
name|abs
argument_list|(
name|newDifference
argument_list|)
operator|)
condition|)
block|{
name|currentDifference
operator|=
name|newDifference
expr_stmt|;
name|currentOffsetIndex
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|currentOffsetIndex
operator|>
operator|-
literal|1
condition|)
block|{
name|newValue
operator|=
name|values
operator|.
name|get
argument_list|(
name|currentOffsetIndex
argument_list|)
expr_stmt|;
block|}
return|return
name|newValue
return|;
block|}
comment|/**      * Brute force search for all trailer marker.      *       * @throws IOException if something went wrong      */
specifier|private
name|boolean
name|bfSearchForTrailer
parameter_list|(
name|COSDictionary
name|trailer
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|COSDictionary
argument_list|>
name|trailerDicts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|MINIMUM_SEARCH_OFFSET
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|source
operator|.
name|isEOF
argument_list|()
condition|)
block|{
comment|// search for trailer marker
if|if
condition|(
name|isString
argument_list|(
name|TRAILER_MARKER
argument_list|)
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
name|source
operator|.
name|getPosition
argument_list|()
operator|+
name|TRAILER_MARKER
operator|.
name|length
argument_list|)
expr_stmt|;
try|try
block|{
name|boolean
name|rootFound
init|=
literal|false
decl_stmt|;
name|boolean
name|infoFound
init|=
literal|false
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSDictionary
name|trailerDict
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
name|StringBuilder
name|trailerKeys
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|COSObject
name|rootObj
init|=
name|trailerDict
operator|.
name|getCOSObject
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootObj
operator|!=
literal|null
condition|)
block|{
name|long
name|objNumber
init|=
name|rootObj
operator|.
name|getObjectNumber
argument_list|()
decl_stmt|;
name|int
name|genNumber
init|=
name|rootObj
operator|.
name|getGenerationNumber
argument_list|()
decl_stmt|;
name|trailerKeys
operator|.
name|append
argument_list|(
name|objNumber
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|trailerKeys
operator|.
name|append
argument_list|(
name|genNumber
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|rootFound
operator|=
literal|true
expr_stmt|;
block|}
name|COSObject
name|infoObj
init|=
name|trailerDict
operator|.
name|getCOSObject
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoObj
operator|!=
literal|null
condition|)
block|{
name|long
name|objNumber
init|=
name|infoObj
operator|.
name|getObjectNumber
argument_list|()
decl_stmt|;
name|int
name|genNumber
init|=
name|infoObj
operator|.
name|getGenerationNumber
argument_list|()
decl_stmt|;
name|trailerKeys
operator|.
name|append
argument_list|(
name|objNumber
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|trailerKeys
operator|.
name|append
argument_list|(
name|genNumber
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|infoFound
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|rootFound
operator|&&
name|infoFound
condition|)
block|{
name|trailerDicts
operator|.
name|put
argument_list|(
name|trailerKeys
operator|.
name|toString
argument_list|()
argument_list|,
name|trailerDict
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"An exception occurred during brute force search for trailer - ignoring"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
comment|// eliminate double entries
name|int
name|trailerdictsSize
init|=
name|trailerDicts
operator|.
name|size
argument_list|()
decl_stmt|;
name|String
name|firstEntry
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|trailerdictsSize
operator|>
literal|0
condition|)
block|{
name|String
index|[]
name|keys
init|=
operator|new
name|String
index|[
name|trailerdictsSize
index|]
decl_stmt|;
name|trailerDicts
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
name|keys
argument_list|)
expr_stmt|;
name|firstEntry
operator|=
name|keys
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|trailerdictsSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|firstEntry
operator|.
name|equals
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|trailerDicts
operator|.
name|remove
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// continue if one entry is left only
if|if
condition|(
name|trailerDicts
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|boolean
name|rootFound
init|=
literal|false
decl_stmt|;
name|boolean
name|infoFound
init|=
literal|false
decl_stmt|;
name|COSDictionary
name|trailerDict
init|=
name|trailerDicts
operator|.
name|get
argument_list|(
name|firstEntry
argument_list|)
decl_stmt|;
name|COSBase
name|rootObj
init|=
name|trailerDict
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootObj
operator|instanceof
name|COSObject
condition|)
block|{
comment|// check if the dictionary can be dereferenced and is the one we are looking for
name|COSBase
name|rootDict
init|=
operator|(
operator|(
name|COSObject
operator|)
name|rootObj
operator|)
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|rootDict
operator|instanceof
name|COSDictionary
operator|&&
name|isCatalog
argument_list|(
operator|(
name|COSDictionary
operator|)
name|rootDict
argument_list|)
condition|)
block|{
name|rootFound
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|COSBase
name|infoObj
init|=
name|trailerDict
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoObj
operator|instanceof
name|COSObject
condition|)
block|{
comment|// check if the dictionary can be dereferenced and is the one we are looking for
name|COSBase
name|infoDict
init|=
operator|(
operator|(
name|COSObject
operator|)
name|infoObj
operator|)
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|infoDict
operator|instanceof
name|COSDictionary
operator|&&
name|isInfo
argument_list|(
operator|(
name|COSDictionary
operator|)
name|infoDict
argument_list|)
condition|)
block|{
name|infoFound
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rootFound
operator|&&
name|infoFound
condition|)
block|{
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|,
name|rootObj
argument_list|)
expr_stmt|;
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|,
name|infoObj
argument_list|)
expr_stmt|;
if|if
condition|(
name|trailerDict
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
condition|)
block|{
name|COSBase
name|encObj
init|=
name|trailerDict
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
decl_stmt|;
if|if
condition|(
name|encObj
operator|instanceof
name|COSObject
condition|)
block|{
comment|// check if the dictionary can be dereferenced
comment|// TODO check if the dictionary is an encryption dictionary?
name|COSBase
name|encDict
init|=
operator|(
operator|(
name|COSObject
operator|)
name|encObj
operator|)
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|encDict
operator|instanceof
name|COSDictionary
condition|)
block|{
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|,
name|encObj
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|trailerDict
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|ID
argument_list|)
condition|)
block|{
name|COSBase
name|idObj
init|=
name|trailerDict
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|idObj
operator|instanceof
name|COSArray
condition|)
block|{
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ID
argument_list|,
name|idObj
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Brute force search for the last EOF marker.      *       * @throws IOException if something went wrong      */
specifier|private
name|long
name|bfSearchForLastEOFMarker
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|lastEOFMarker
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|MINIMUM_SEARCH_OFFSET
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|source
operator|.
name|isEOF
argument_list|()
condition|)
block|{
comment|// search for EOF marker
if|if
condition|(
name|isString
argument_list|(
name|EOF_MARKER
argument_list|)
condition|)
block|{
name|long
name|tempMarker
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|tempMarker
operator|+
literal|5
argument_list|)
expr_stmt|;
try|try
block|{
comment|// check if the following data is some valid pdf content
comment|// which most likely indicates that the pdf is linearized,
comment|// updated or just cut off somewhere in the middle
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isString
argument_list|(
name|XREF_TABLE
argument_list|)
condition|)
block|{
name|readObjectNumber
argument_list|()
expr_stmt|;
name|readGenerationNumber
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
comment|// save the EOF marker as the following data is most likely some garbage
name|LOG
operator|.
name|debug
argument_list|(
literal|"An exception occurred during brute force for last EOF - ignoring"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
name|lastEOFMarker
operator|=
name|tempMarker
expr_stmt|;
block|}
block|}
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
comment|// no EOF marker found
if|if
condition|(
name|lastEOFMarker
operator|==
operator|-
literal|1
condition|)
block|{
name|lastEOFMarker
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
return|return
name|lastEOFMarker
return|;
block|}
comment|/**      * Brute force search for all object streams.      *       * @throws IOException if something went wrong      */
specifier|private
name|void
name|bfSearchForObjStreams
parameter_list|()
throws|throws
name|IOException
block|{
comment|// save origin offset
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|// log warning about skipped stream
name|bfSearchForObjStreamOffsets
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
comment|//
operator|.
name|filter
argument_list|(
name|o
lambda|->
name|bfSearchCOSObjectKeyOffsets
operator|.
name|get
argument_list|(
name|o
operator|.
name|getValue
argument_list|()
argument_list|)
operator|==
literal|null
argument_list|)
comment|//
operator|.
name|forEach
argument_list|(
name|o
lambda|->
name|LOG
operator|.
name|warn
argument_list|(
literal|"Skipped incomplete object stream:"
operator|+
name|o
operator|.
name|getValue
argument_list|()
operator|+
literal|" at "
operator|+
name|o
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// collect all stream offsets
name|List
argument_list|<
name|Long
argument_list|>
name|objStreamOffsets
init|=
name|bfSearchForObjStreamOffsets
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
comment|//
operator|.
name|filter
argument_list|(
name|o
lambda|->
name|bfSearchCOSObjectKeyOffsets
operator|.
name|get
argument_list|(
name|o
operator|.
name|getValue
argument_list|()
argument_list|)
operator|!=
literal|null
argument_list|)
comment|//
operator|.
name|filter
argument_list|(
name|o
lambda|->
name|o
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
name|bfSearchCOSObjectKeyOffsets
operator|.
name|get
argument_list|(
name|o
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
argument_list|)
comment|//
operator|.
name|map
argument_list|(
name|Map
operator|.
name|Entry
operator|::
name|getKey
argument_list|)
comment|//
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
comment|// add all found compressed objects to the brute force search result
for|for
control|(
name|Long
name|offset
range|:
name|objStreamOffsets
control|)
block|{
name|source
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|long
name|stmObjNumber
init|=
name|readObjectNumber
argument_list|()
decl_stmt|;
name|int
name|stmGenNumber
init|=
name|readGenerationNumber
argument_list|()
decl_stmt|;
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|COSStream
name|stream
init|=
literal|null
decl_stmt|;
try|try
block|{
name|COSDictionary
name|dict
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
name|stream
operator|=
name|parseCOSStream
argument_list|(
name|dict
argument_list|)
expr_stmt|;
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
name|securityHandler
operator|.
name|decryptStream
argument_list|(
name|stream
argument_list|,
name|stmObjNumber
argument_list|,
name|stmGenNumber
argument_list|)
expr_stmt|;
block|}
name|PDFObjectStreamParser
name|objStreamParser
init|=
operator|new
name|PDFObjectStreamParser
argument_list|(
name|stream
argument_list|,
name|document
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|objectNumbers
init|=
name|objStreamParser
operator|.
name|readObjectNumbers
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|xrefOffset
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
decl_stmt|;
for|for
control|(
name|Long
name|objNumber
range|:
name|objectNumbers
operator|.
name|keySet
argument_list|()
control|)
block|{
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|objNumber
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Long
name|existingOffset
init|=
name|bfSearchCOSObjectKeyOffsets
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingOffset
operator|!=
literal|null
operator|&&
name|existingOffset
operator|<
literal|0
condition|)
block|{
comment|// translate stream object key to its offset
name|COSObjectKey
name|objStmKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|existingOffset
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|existingOffset
operator|=
name|bfSearchCOSObjectKeyOffsets
operator|.
name|get
argument_list|(
name|objStmKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|existingOffset
operator|==
literal|null
operator|||
name|offset
operator|>
name|existingOffset
condition|)
block|{
name|bfSearchCOSObjectKeyOffsets
operator|.
name|put
argument_list|(
name|objKey
argument_list|,
operator|-
name|stmObjNumber
argument_list|)
expr_stmt|;
name|xrefOffset
operator|.
name|put
argument_list|(
name|objKey
argument_list|,
operator|-
name|stmObjNumber
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipped corrupt stream: ("
operator|+
name|stmObjNumber
operator|+
literal|" 0 at offset "
operator|+
name|offset
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|stream
operator|!=
literal|null
condition|)
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// restore origin offset
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
comment|/**      * Search for all offsets of object streams within the given pdf      *       * @return a map of all offsets for object streams      * @throws IOException if something went wrong      */
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|COSObjectKey
argument_list|>
name|bfSearchForObjStreamOffsets
parameter_list|()
throws|throws
name|IOException
block|{
name|HashMap
argument_list|<
name|Long
argument_list|,
name|COSObjectKey
argument_list|>
name|bfSearchObjStreamsOffsets
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|MINIMUM_SEARCH_OFFSET
argument_list|)
expr_stmt|;
name|char
index|[]
name|string
init|=
literal|" obj"
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|source
operator|.
name|isEOF
argument_list|()
condition|)
block|{
comment|// search for object stream marker
if|if
condition|(
name|isString
argument_list|(
name|OBJ_STREAM
argument_list|)
condition|)
block|{
name|long
name|currentPosition
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|// search backwards for the beginning of the object
name|long
name|newOffset
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|objFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|40
operator|&&
operator|!
name|objFound
condition|;
name|i
operator|++
control|)
block|{
name|long
name|currentOffset
init|=
name|currentPosition
operator|-
operator|(
name|i
operator|*
literal|10
operator|)
decl_stmt|;
if|if
condition|(
name|currentOffset
operator|>
literal|0
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|isString
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|long
name|tempOffset
init|=
name|currentOffset
operator|-
literal|1
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
name|int
name|genID
init|=
name|source
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// is the next char a digit?
if|if
condition|(
name|isDigit
argument_list|(
name|genID
argument_list|)
condition|)
block|{
name|tempOffset
operator|--
expr_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSpace
argument_list|()
condition|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
while|while
condition|(
name|tempOffset
operator|>
name|MINIMUM_SEARCH_OFFSET
operator|&&
name|isDigit
argument_list|()
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
name|newOffset
operator|=
name|source
operator|.
name|getPosition
argument_list|()
expr_stmt|;
name|long
name|objNumber
init|=
name|readObjectNumber
argument_list|()
decl_stmt|;
name|int
name|genNumber
init|=
name|readGenerationNumber
argument_list|()
decl_stmt|;
name|COSObjectKey
name|streamObjectKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|objNumber
argument_list|,
name|genNumber
argument_list|)
decl_stmt|;
name|bfSearchObjStreamsOffsets
operator|.
name|put
argument_list|(
name|newOffset
argument_list|,
name|streamObjectKey
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Dictionary start for object stream -> "
operator|+
name|newOffset
argument_list|)
expr_stmt|;
name|objFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|currentOffset
operator|++
expr_stmt|;
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|source
operator|.
name|seek
argument_list|(
name|currentPosition
operator|+
name|OBJ_STREAM
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
return|return
name|bfSearchObjStreamsOffsets
return|;
block|}
comment|/**      * Brute force search for all xref entries (tables).      *       * @throws IOException if something went wrong      */
specifier|private
name|void
name|bfSearchForXRefTables
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bfSearchXRefTablesOffsets
operator|==
literal|null
condition|)
block|{
comment|// a pdf may contain more than one xref entry
name|bfSearchXRefTablesOffsets
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|MINIMUM_SEARCH_OFFSET
argument_list|)
expr_stmt|;
comment|// search for xref tables
while|while
condition|(
operator|!
name|source
operator|.
name|isEOF
argument_list|()
condition|)
block|{
if|if
condition|(
name|isString
argument_list|(
name|XREF_TABLE
argument_list|)
condition|)
block|{
name|long
name|newOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|newOffset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// ensure that we don't read "startxref" instead of "xref"
if|if
condition|(
name|isWhitespace
argument_list|()
condition|)
block|{
name|bfSearchXRefTablesOffsets
operator|.
name|add
argument_list|(
name|newOffset
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|newOffset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Brute force search for all /XRef entries (streams).      *       * @throws IOException if something went wrong      */
specifier|private
name|void
name|bfSearchForXRefStreams
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bfSearchXRefStreamsOffsets
operator|==
literal|null
condition|)
block|{
comment|// a pdf may contain more than one /XRef entry
name|bfSearchXRefStreamsOffsets
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|MINIMUM_SEARCH_OFFSET
argument_list|)
expr_stmt|;
comment|// search for XRef streams
name|String
name|objString
init|=
literal|" obj"
decl_stmt|;
name|char
index|[]
name|string
init|=
name|objString
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|source
operator|.
name|isEOF
argument_list|()
condition|)
block|{
if|if
condition|(
name|isString
argument_list|(
name|XREF_STREAM
argument_list|)
condition|)
block|{
comment|// search backwards for the beginning of the stream
name|long
name|newOffset
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|xrefOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|boolean
name|objFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|40
operator|&&
operator|!
name|objFound
condition|;
name|i
operator|++
control|)
block|{
name|long
name|currentOffset
init|=
name|xrefOffset
operator|-
operator|(
name|i
operator|*
literal|10
operator|)
decl_stmt|;
if|if
condition|(
name|currentOffset
operator|>
literal|0
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|isString
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|long
name|tempOffset
init|=
name|currentOffset
operator|-
literal|1
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
name|int
name|genID
init|=
name|source
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// is the next char a digit?
if|if
condition|(
name|isDigit
argument_list|(
name|genID
argument_list|)
condition|)
block|{
name|tempOffset
operator|--
expr_stmt|;
name|source
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSpace
argument_list|()
condition|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
name|source
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
while|while
condition|(
name|tempOffset
operator|>
name|MINIMUM_SEARCH_OFFSET
operator|&&
name|isDigit
argument_list|()
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
name|newOffset
operator|=
name|source
operator|.
name|getPosition
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fixed reference for xref stream "
operator|+
name|xrefOffset
operator|+
literal|" -> "
operator|+
name|newOffset
argument_list|)
expr_stmt|;
name|objFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|currentOffset
operator|++
expr_stmt|;
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|newOffset
operator|>
operator|-
literal|1
condition|)
block|{
name|bfSearchXRefStreamsOffsets
operator|.
name|add
argument_list|(
name|newOffset
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|xrefOffset
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Rebuild the trailer dictionary if startxref can't be found.      *        * @return the rebuild trailer dictionary      *       * @throws IOException if something went wrong      */
specifier|private
name|COSDictionary
name|rebuildTrailer
parameter_list|()
throws|throws
name|IOException
block|{
name|COSDictionary
name|trailer
init|=
literal|null
decl_stmt|;
name|bfSearchForObjects
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfSearchCOSObjectKeyOffsets
operator|!=
literal|null
condition|)
block|{
comment|// reset trailer resolver
name|xrefTrailerResolver
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// use the found objects to rebuild the trailer resolver
name|xrefTrailerResolver
operator|.
name|nextXrefObj
argument_list|(
literal|0
argument_list|,
name|XRefType
operator|.
name|TABLE
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|entry
range|:
name|bfSearchCOSObjectKeyOffsets
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|xrefTrailerResolver
operator|.
name|setXRef
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|xrefTrailerResolver
operator|.
name|setStartxref
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|trailer
operator|=
name|xrefTrailerResolver
operator|.
name|getTrailer
argument_list|()
expr_stmt|;
name|document
operator|.
name|setTrailer
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
name|boolean
name|searchForObjStreamsDone
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|bfSearchForTrailer
argument_list|(
name|trailer
argument_list|)
operator|&&
operator|!
name|searchForTrailerItems
argument_list|(
name|trailer
argument_list|)
condition|)
block|{
comment|// root entry wasn't found, maybe it is part of an object stream
name|bfSearchForObjStreams
argument_list|()
expr_stmt|;
name|searchForObjStreamsDone
operator|=
literal|true
expr_stmt|;
comment|// search again for the root entry
name|searchForTrailerItems
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
block|}
comment|// prepare decryption if necessary
name|prepareDecryption
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|searchForObjStreamsDone
condition|)
block|{
name|bfSearchForObjStreams
argument_list|()
expr_stmt|;
block|}
block|}
name|trailerWasRebuild
operator|=
literal|true
expr_stmt|;
return|return
name|trailer
return|;
block|}
comment|/**      * Search for the different parts of the trailer dictionary.      *      * @param trailer      * @return true if the root was found, false if not.      */
specifier|private
name|boolean
name|searchForTrailerItems
parameter_list|(
name|COSDictionary
name|trailer
parameter_list|)
block|{
name|boolean
name|rootFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|COSObjectKey
name|key
range|:
name|bfSearchCOSObjectKeyOffsets
operator|.
name|keySet
argument_list|()
control|)
block|{
name|COSObject
name|cosObject
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|COSBase
name|baseObject
init|=
name|cosObject
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|baseObject
operator|instanceof
name|COSDictionary
operator|)
condition|)
block|{
continue|continue;
block|}
name|COSDictionary
name|dictionary
init|=
operator|(
name|COSDictionary
operator|)
name|baseObject
decl_stmt|;
comment|// document catalog
if|if
condition|(
name|isCatalog
argument_list|(
name|dictionary
argument_list|)
condition|)
block|{
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|,
name|cosObject
argument_list|)
expr_stmt|;
name|rootFound
operator|=
literal|true
expr_stmt|;
block|}
comment|// info dictionary
elseif|else
if|if
condition|(
name|isInfo
argument_list|(
name|dictionary
argument_list|)
condition|)
block|{
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|,
name|cosObject
argument_list|)
expr_stmt|;
block|}
comment|// encryption dictionary, if existing, is lost
comment|// We can't run "Algorithm 2" from PDF specification because of missing ID
block|}
return|return
name|rootFound
return|;
block|}
comment|/**      * Check if all entries of the pages dictionary are present. Those which can't be dereferenced are removed.      *       * @param root the root dictionary of the pdf      * @throws java.io.IOException if the page tree root is null      */
specifier|protected
name|void
name|checkPages
parameter_list|(
name|COSDictionary
name|root
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|trailerWasRebuild
condition|)
block|{
comment|// check if all page objects are dereferenced
name|COSBase
name|pages
init|=
name|root
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|PAGES
argument_list|)
decl_stmt|;
if|if
condition|(
name|pages
operator|instanceof
name|COSDictionary
condition|)
block|{
name|checkPagesDictionary
argument_list|(
operator|(
name|COSDictionary
operator|)
name|pages
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|root
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|PAGES
argument_list|)
operator|instanceof
name|COSDictionary
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Page tree root must be a dictionary"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|int
name|checkPagesDictionary
parameter_list|(
name|COSDictionary
name|pagesDict
parameter_list|,
name|Set
argument_list|<
name|COSObject
argument_list|>
name|set
parameter_list|)
block|{
comment|// check for kids
name|COSBase
name|kids
init|=
name|pagesDict
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|KIDS
argument_list|)
decl_stmt|;
name|int
name|numberOfPages
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|kids
operator|instanceof
name|COSArray
condition|)
block|{
name|COSArray
name|kidsArray
init|=
operator|(
name|COSArray
operator|)
name|kids
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|COSBase
argument_list|>
name|kidsList
init|=
name|kidsArray
operator|.
name|toList
argument_list|()
decl_stmt|;
for|for
control|(
name|COSBase
name|kid
range|:
name|kidsList
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|kid
operator|instanceof
name|COSObject
operator|)
operator|||
name|set
operator|.
name|contains
argument_list|(
operator|(
name|COSObject
operator|)
name|kid
argument_list|)
condition|)
block|{
name|kidsArray
operator|.
name|remove
argument_list|(
name|kid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|COSObject
name|kidObject
init|=
operator|(
name|COSObject
operator|)
name|kid
decl_stmt|;
name|COSBase
name|kidBaseobject
init|=
name|kidObject
operator|.
name|getObject
argument_list|()
decl_stmt|;
comment|// object wasn't dereferenced -> remove it
if|if
condition|(
name|kidBaseobject
operator|==
literal|null
operator|||
name|kidBaseobject
operator|.
name|equals
argument_list|(
name|COSNull
operator|.
name|NULL
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Removed null object "
operator|+
name|kid
operator|+
literal|" from pages dictionary"
argument_list|)
expr_stmt|;
name|kidsArray
operator|.
name|remove
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kidBaseobject
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSDictionary
name|kidDictionary
init|=
operator|(
name|COSDictionary
operator|)
name|kidBaseobject
decl_stmt|;
name|COSName
name|type
init|=
name|kidDictionary
operator|.
name|getCOSName
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|COSName
operator|.
name|PAGES
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|// process nested pages dictionaries
name|set
operator|.
name|add
argument_list|(
name|kidObject
argument_list|)
expr_stmt|;
name|numberOfPages
operator|+=
name|checkPagesDictionary
argument_list|(
name|kidDictionary
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|COSName
operator|.
name|PAGE
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|// count pages
name|numberOfPages
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// fix counter
name|pagesDict
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|COUNT
argument_list|,
name|numberOfPages
argument_list|)
expr_stmt|;
return|return
name|numberOfPages
return|;
block|}
comment|/**      * Tell if the dictionary is a PDF catalog. Override this for an FDF catalog.      *       * @param dictionary      * @return true if the given dictionary is a root dictionary      */
specifier|protected
name|boolean
name|isCatalog
parameter_list|(
name|COSDictionary
name|dictionary
parameter_list|)
block|{
return|return
name|COSName
operator|.
name|CATALOG
operator|.
name|equals
argument_list|(
name|dictionary
operator|.
name|getCOSName
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Tell if the dictionary is an info dictionary.      *       * @param dictionary      * @return true if the given dictionary is an info dictionary      */
specifier|private
name|boolean
name|isInfo
parameter_list|(
name|COSDictionary
name|dictionary
parameter_list|)
block|{
if|if
condition|(
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|PARENT
argument_list|)
operator|||
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|A
argument_list|)
operator|||
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|DEST
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|MOD_DATE
argument_list|)
operator|&&
operator|!
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|TITLE
argument_list|)
operator|&&
operator|!
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|AUTHOR
argument_list|)
operator|&&
operator|!
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|SUBJECT
argument_list|)
operator|&&
operator|!
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|KEYWORDS
argument_list|)
operator|&&
operator|!
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|CREATOR
argument_list|)
operator|&&
operator|!
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|PRODUCER
argument_list|)
operator|&&
operator|!
name|dictionary
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|CREATION_DATE
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * This will parse the startxref section from the stream. The startxref value is ignored.      *      * @return the startxref value or -1 on parsing error      * @throws IOException If an IO error occurs.      */
specifier|private
name|long
name|parseStartXref
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|startXref
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|isString
argument_list|(
name|STARTXREF
argument_list|)
condition|)
block|{
name|readString
argument_list|()
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
comment|// This integer is the byte offset of the first object referenced by the xref or xref stream
name|startXref
operator|=
name|readLong
argument_list|()
expr_stmt|;
block|}
return|return
name|startXref
return|;
block|}
comment|/**      * Checks if the given string can be found at the current offset.      *       * @param string the bytes of the string to look for      * @return true if the bytes are in place, false if not      * @throws IOException if something went wrong      */
specifier|private
name|boolean
name|isString
parameter_list|(
name|byte
index|[]
name|string
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|bytesMatching
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|==
name|string
index|[
literal|0
index|]
condition|)
block|{
name|int
name|length
init|=
name|string
operator|.
name|length
decl_stmt|;
name|byte
index|[]
name|bytesRead
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|int
name|numberOfBytes
init|=
name|source
operator|.
name|read
argument_list|(
name|bytesRead
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|numberOfBytes
operator|<
name|length
condition|)
block|{
name|int
name|readMore
init|=
name|source
operator|.
name|read
argument_list|(
name|bytesRead
argument_list|,
name|numberOfBytes
argument_list|,
name|length
operator|-
name|numberOfBytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|readMore
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|numberOfBytes
operator|+=
name|readMore
expr_stmt|;
block|}
name|bytesMatching
operator|=
name|Arrays
operator|.
name|equals
argument_list|(
name|string
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
name|source
operator|.
name|rewind
argument_list|(
name|numberOfBytes
argument_list|)
expr_stmt|;
block|}
return|return
name|bytesMatching
return|;
block|}
comment|/**      * Checks if the given string can be found at the current offset.      *       * @param string the bytes of the string to look for      * @return true if the bytes are in place, false if not      * @throws IOException if something went wrong      */
specifier|private
name|boolean
name|isString
parameter_list|(
name|char
index|[]
name|string
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|bytesMatching
init|=
literal|true
decl_stmt|;
name|long
name|originOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|string
control|)
block|{
if|if
condition|(
name|source
operator|.
name|read
argument_list|()
operator|!=
name|c
condition|)
block|{
name|bytesMatching
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
name|source
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
return|return
name|bytesMatching
return|;
block|}
comment|/**      * This will parse the trailer from the stream and add it to the state.      *      * @return false on parsing error      * @throws IOException If an IO error occurs.      */
specifier|private
name|boolean
name|parseTrailer
parameter_list|()
throws|throws
name|IOException
block|{
comment|// parse the last trailer.
name|long
name|trailerOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|// PDFBOX-1739 skip extra xref entries in RegisSTAR documents
if|if
condition|(
name|isLenient
condition|)
block|{
name|int
name|nextCharacter
init|=
name|source
operator|.
name|peek
argument_list|()
decl_stmt|;
while|while
condition|(
name|nextCharacter
operator|!=
literal|'t'
operator|&&
name|isDigit
argument_list|(
name|nextCharacter
argument_list|)
condition|)
block|{
if|if
condition|(
name|source
operator|.
name|getPosition
argument_list|()
operator|==
name|trailerOffset
condition|)
block|{
comment|// warn only the first time
name|LOG
operator|.
name|warn
argument_list|(
literal|"Expected trailer object at offset "
operator|+
name|trailerOffset
operator|+
literal|", keep trying"
argument_list|)
expr_stmt|;
block|}
name|readLine
argument_list|()
expr_stmt|;
name|nextCharacter
operator|=
name|source
operator|.
name|peek
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|!=
literal|'t'
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//read "trailer"
name|long
name|currentOffset
init|=
name|source
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|String
name|nextLine
init|=
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nextLine
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|"trailer"
argument_list|)
condition|)
block|{
comment|// in some cases the EOL is missing and the trailer immediately
comment|// continues with "<<" or with a blank character
comment|// even if this does not comply with PDF reference we want to support as many PDFs as possible
comment|// Acrobat reader can also deal with this.
if|if
condition|(
name|nextLine
operator|.
name|startsWith
argument_list|(
literal|"trailer"
argument_list|)
condition|)
block|{
comment|// we can't just unread a portion of the read data as we don't know if the EOL consist of 1 or 2 bytes
name|int
name|len
init|=
literal|"trailer"
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// jump back right after "trailer"
name|source
operator|.
name|seek
argument_list|(
name|currentOffset
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// in some cases the EOL is missing and the trailer continues with "<<"
comment|// even if this does not comply with PDF reference we want to support as many PDFs as possible
comment|// Acrobat reader can also deal with this.
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSDictionary
name|parsedTrailer
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
name|xrefTrailerResolver
operator|.
name|setTrailer
argument_list|(
name|parsedTrailer
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Parse the header of a pdf.      *       * @return true if a PDF header was found      * @throws IOException if something went wrong      */
specifier|protected
name|boolean
name|parsePDFHeader
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|parseHeader
argument_list|(
name|PDF_HEADER
argument_list|,
name|PDF_DEFAULT_VERSION
argument_list|)
return|;
block|}
comment|/**      * Parse the header of a fdf.      *       * @return true if a FDF header was found      * @throws IOException if something went wrong      */
specifier|protected
name|boolean
name|parseFDFHeader
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|parseHeader
argument_list|(
name|FDF_HEADER
argument_list|,
name|FDF_DEFAULT_VERSION
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|parseHeader
parameter_list|(
name|String
name|headerMarker
parameter_list|,
name|String
name|defaultVersion
parameter_list|)
throws|throws
name|IOException
block|{
comment|// read first line
name|String
name|header
init|=
name|readLine
argument_list|()
decl_stmt|;
comment|// some pdf-documents are broken and the pdf-version is in one of the following lines
if|if
condition|(
operator|!
name|header
operator|.
name|contains
argument_list|(
name|headerMarker
argument_list|)
condition|)
block|{
name|header
operator|=
name|readLine
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|header
operator|.
name|contains
argument_list|(
name|headerMarker
argument_list|)
condition|)
block|{
comment|// if a line starts with a digit, it has to be the first one with data in it
if|if
condition|(
operator|(
name|header
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|Character
operator|.
name|isDigit
argument_list|(
name|header
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
name|header
operator|=
name|readLine
argument_list|()
expr_stmt|;
block|}
block|}
comment|// nothing found
if|if
condition|(
operator|!
name|header
operator|.
name|contains
argument_list|(
name|headerMarker
argument_list|)
condition|)
block|{
name|source
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|//sometimes there is some garbage in the header before the header
comment|//actually starts, so lets try to find the header first.
name|int
name|headerStart
init|=
name|header
operator|.
name|indexOf
argument_list|(
name|headerMarker
argument_list|)
decl_stmt|;
comment|// greater than zero because if it is zero then there is no point of trimming
if|if
condition|(
name|headerStart
operator|>
literal|0
condition|)
block|{
comment|//trim off any leading characters
name|header
operator|=
name|header
operator|.
name|substring
argument_list|(
name|headerStart
argument_list|,
name|header
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// This is used if there is garbage after the header on the same line
if|if
condition|(
name|header
operator|.
name|startsWith
argument_list|(
name|headerMarker
argument_list|)
operator|&&
operator|!
name|header
operator|.
name|matches
argument_list|(
name|headerMarker
operator|+
literal|"\\d.\\d"
argument_list|)
condition|)
block|{
if|if
condition|(
name|header
operator|.
name|length
argument_list|()
operator|<
name|headerMarker
operator|.
name|length
argument_list|()
operator|+
literal|3
condition|)
block|{
comment|// No version number at all, set to 1.4 as default
name|header
operator|=
name|headerMarker
operator|+
name|defaultVersion
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"No version found, set to "
operator|+
name|defaultVersion
operator|+
literal|" as default."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|headerGarbage
init|=
name|header
operator|.
name|substring
argument_list|(
name|headerMarker
operator|.
name|length
argument_list|()
operator|+
literal|3
argument_list|,
name|header
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|"\n"
decl_stmt|;
name|header
operator|=
name|header
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|headerMarker
operator|.
name|length
argument_list|()
operator|+
literal|3
argument_list|)
expr_stmt|;
name|source
operator|.
name|rewind
argument_list|(
name|headerGarbage
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|ISO_8859_1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
name|float
name|headerVersion
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|String
index|[]
name|headerParts
init|=
name|header
operator|.
name|split
argument_list|(
literal|"-"
argument_list|)
decl_stmt|;
if|if
condition|(
name|headerParts
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|headerVersion
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|headerParts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Can't parse the header version."
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|headerVersion
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|headerVersion
operator|=
literal|1.7f
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error getting header version: "
operator|+
name|header
argument_list|)
throw|;
block|}
block|}
name|document
operator|.
name|setVersion
argument_list|(
name|headerVersion
argument_list|)
expr_stmt|;
comment|// rewind
name|source
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * This will parse the xref table from the stream and add it to the state      * The XrefTable contents are ignored.      * @param startByteOffset the offset to start at      * @return false on parsing error      * @throws IOException If an IO error occurs.      */
specifier|protected
name|boolean
name|parseXrefTable
parameter_list|(
name|long
name|startByteOffset
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|!=
literal|'x'
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|xref
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|xref
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|"xref"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check for trailer after xref
name|String
name|str
init|=
name|readString
argument_list|()
decl_stmt|;
name|byte
index|[]
name|b
init|=
name|str
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|ISO_8859_1
argument_list|)
decl_stmt|;
name|source
operator|.
name|rewind
argument_list|(
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// signal start of new XRef
name|xrefTrailerResolver
operator|.
name|nextXrefObj
argument_list|(
name|startByteOffset
argument_list|,
name|XRefType
operator|.
name|TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
literal|"trailer"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"skipping empty xref table"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Xref tables can have multiple sections. Each starts with a starting object id and a count.
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|currentLine
init|=
name|readLine
argument_list|()
decl_stmt|;
name|String
index|[]
name|splitString
init|=
name|currentLine
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|;
if|if
condition|(
name|splitString
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected XRefTable Entry: "
operator|+
name|currentLine
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// first obj id
name|long
name|currObjID
decl_stmt|;
try|try
block|{
name|currObjID
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|splitString
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"XRefTable: invalid ID for the first object: "
operator|+
name|currentLine
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// the number of objects in the xref table
name|int
name|count
init|=
literal|0
decl_stmt|;
try|try
block|{
name|count
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|splitString
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"XRefTable: invalid number of objects: "
operator|+
name|currentLine
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|source
operator|.
name|isEOF
argument_list|()
operator|||
name|isEndOfName
argument_list|(
operator|(
name|char
operator|)
name|source
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|source
operator|.
name|peek
argument_list|()
operator|==
literal|'t'
condition|)
block|{
break|break;
block|}
comment|//Ignore table contents
name|currentLine
operator|=
name|readLine
argument_list|()
expr_stmt|;
name|splitString
operator|=
name|currentLine
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|splitString
operator|.
name|length
operator|<
literal|3
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"invalid xref line: "
operator|+
name|currentLine
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* This supports the corrupt table as reported in                  * PDFBOX-474 (XXXX XXX XX n) */
if|if
condition|(
name|splitString
index|[
name|splitString
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|equals
argument_list|(
literal|"n"
argument_list|)
condition|)
block|{
try|try
block|{
name|long
name|currOffset
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|splitString
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|currGenID
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|splitString
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|currObjID
argument_list|,
name|currGenID
argument_list|)
decl_stmt|;
name|xrefTrailerResolver
operator|.
name|setXRef
argument_list|(
name|objKey
argument_list|,
name|currOffset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|splitString
index|[
literal|2
index|]
operator|.
name|equals
argument_list|(
literal|"f"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupt XRefTable Entry - ObjID:"
operator|+
name|currObjID
argument_list|)
throw|;
block|}
name|currObjID
operator|++
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isDigit
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Fills XRefTrailerResolver with data of given stream.      * Stream must be of type XRef.      * @param stream the stream to be read      * @param objByteOffset the offset to start at      * @param isStandalone should be set to true if the stream is not part of a hybrid xref table      * @throws IOException if there is an error parsing the stream      */
specifier|private
name|void
name|parseXrefStream
parameter_list|(
name|COSStream
name|stream
parameter_list|,
name|long
name|objByteOffset
parameter_list|,
name|boolean
name|isStandalone
parameter_list|)
throws|throws
name|IOException
block|{
comment|// the cross reference stream of a hybrid xref table will be added to the existing one
comment|// and we must not override the offset and the trailer
if|if
condition|(
name|isStandalone
condition|)
block|{
name|xrefTrailerResolver
operator|.
name|nextXrefObj
argument_list|(
name|objByteOffset
argument_list|,
name|XRefType
operator|.
name|STREAM
argument_list|)
expr_stmt|;
name|xrefTrailerResolver
operator|.
name|setTrailer
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
name|PDFXrefStreamParser
name|parser
init|=
operator|new
name|PDFXrefStreamParser
argument_list|(
name|stream
argument_list|,
name|document
argument_list|,
name|xrefTrailerResolver
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
block|}
comment|/**      * This will get the encryption dictionary. The document must be parsed before this is called.      *      * @return The encryption dictionary of the document that was parsed.      *      * @throws IOException If there is an error getting the document.      */
specifier|public
name|PDEncryption
name|getEncryption
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|document
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"You must parse the document first before calling getEncryption()"
argument_list|)
throw|;
block|}
return|return
name|encryption
return|;
block|}
comment|/**      * This will get the AccessPermission. The document must be parsed before this is called.      *      * @return The access permission of document that was parsed.      *      * @throws IOException If there is an error getting the document.      */
specifier|public
name|AccessPermission
name|getAccessPermission
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|document
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"You must parse the document first before calling getAccessPermission()"
argument_list|)
throw|;
block|}
return|return
name|accessPermission
return|;
block|}
comment|/**      * Prepare for decryption.      *       * @throws InvalidPasswordException If the password is incorrect.      * @throws IOException if something went wrong      */
specifier|private
name|void
name|prepareDecryption
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|encryption
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|COSBase
name|trailerEncryptItem
init|=
name|document
operator|.
name|getTrailer
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailerEncryptItem
operator|==
literal|null
operator|||
name|trailerEncryptItem
operator|instanceof
name|COSNull
condition|)
block|{
return|return;
block|}
try|try
block|{
name|encryption
operator|=
operator|new
name|PDEncryption
argument_list|(
name|document
operator|.
name|getEncryptionDictionary
argument_list|()
argument_list|)
expr_stmt|;
name|DecryptionMaterial
name|decryptionMaterial
decl_stmt|;
if|if
condition|(
name|keyStoreInputStream
operator|!=
literal|null
condition|)
block|{
name|KeyStore
name|ks
init|=
name|KeyStore
operator|.
name|getInstance
argument_list|(
literal|"PKCS12"
argument_list|)
decl_stmt|;
name|ks
operator|.
name|load
argument_list|(
name|keyStoreInputStream
argument_list|,
name|password
operator|.
name|toCharArray
argument_list|()
argument_list|)
expr_stmt|;
name|decryptionMaterial
operator|=
operator|new
name|PublicKeyDecryptionMaterial
argument_list|(
name|ks
argument_list|,
name|keyAlias
argument_list|,
name|password
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decryptionMaterial
operator|=
operator|new
name|StandardDecryptionMaterial
argument_list|(
name|password
argument_list|)
expr_stmt|;
block|}
name|securityHandler
operator|=
name|encryption
operator|.
name|getSecurityHandler
argument_list|()
expr_stmt|;
name|securityHandler
operator|.
name|prepareForDecryption
argument_list|(
name|encryption
argument_list|,
name|document
operator|.
name|getDocumentID
argument_list|()
argument_list|,
name|decryptionMaterial
argument_list|)
expr_stmt|;
name|accessPermission
operator|=
name|securityHandler
operator|.
name|getCurrentAccessPermission
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error ("
operator|+
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|") while creating security handler for decryption"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|keyStoreInputStream
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|keyStoreInputStream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

