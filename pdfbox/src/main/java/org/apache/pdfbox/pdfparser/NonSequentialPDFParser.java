begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|KeyStore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|CryptographyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|PushBackInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessBufferedFileInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
operator|.
name|XrefTrailerResolver
operator|.
name|XRefType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDPage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|AccessPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|DecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|PDEncryptionDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|PublicKeyDecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|SecurityHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|SecurityHandlerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|StandardDecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|persistence
operator|.
name|util
operator|.
name|COSObjectKey
import|;
end_import

begin_comment
comment|/**  * PDFParser which first reads startxref and xref tables in order to know valid  * objects and parse only these objects. Thus it is closer to a conforming  * parser than the sequential reading of {@link PDFParser}.  *   * This class can be used as a {@link PDFParser} replacement. First  * {@link #parse()} must be called before page objects can be retrieved, e.g.  * {@link #getPDDocument()}.  *   * This class is a much enhanced version of<code>QuickParser</code> presented  * in<a  * href="https://issues.apache.org/jira/browse/PDFBOX-1104">PDFBOX-1104</a> by  * Jeremy Villalobos.  */
end_comment

begin_class
specifier|public
class|class
name|NonSequentialPDFParser
extends|extends
name|PDFParser
block|{
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|XREF
init|=
operator|new
name|byte
index|[]
block|{
literal|'x'
block|,
literal|'r'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|E
init|=
literal|'e'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|N
init|=
literal|'n'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|X
init|=
literal|'x'
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_PARSEMINIMAL
init|=
literal|"org.apache.pdfbox.pdfparser.nonSequentialPDFParser.parseMinimal"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_EOFLOOKUPRANGE
init|=
literal|"org.apache.pdfbox.pdfparser.nonSequentialPDFParser.eofLookupRange"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|InputStream
name|EMPTY_INPUT_STREAM
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_TRAIL_BYTECOUNT
init|=
literal|2048
decl_stmt|;
comment|/**      * EOF-marker.      */
specifier|protected
specifier|static
specifier|final
name|char
index|[]
name|EOF_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'%'
block|,
literal|'%'
block|,
literal|'E'
block|,
literal|'O'
block|,
literal|'F'
block|}
decl_stmt|;
comment|/**      * StartXRef-marker.      */
specifier|protected
specifier|static
specifier|final
name|char
index|[]
name|STARTXREF_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'s'
block|,
literal|'t'
block|,
literal|'a'
block|,
literal|'r'
block|,
literal|'t'
block|,
literal|'x'
block|,
literal|'r'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
comment|/**      * obj-marker.      */
specifier|protected
specifier|static
specifier|final
name|char
index|[]
name|OBJ_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'o'
block|,
literal|'b'
block|,
literal|'j'
block|}
decl_stmt|;
specifier|private
specifier|final
name|File
name|pdfFile
decl_stmt|;
specifier|private
name|long
name|fileLen
decl_stmt|;
specifier|private
specifier|final
name|RandomAccessBufferedFileInputStream
name|raStream
decl_stmt|;
comment|/**      * is parser using auto healing capacity ?      */
specifier|private
name|boolean
name|isLenient
init|=
literal|true
decl_stmt|;
comment|/**      * The security handler.      */
specifier|protected
name|SecurityHandler
name|securityHandler
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|keyStoreFilename
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|alias
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|password
init|=
literal|""
decl_stmt|;
specifier|private
name|int
name|readTrailBytes
init|=
name|DEFAULT_TRAIL_BYTECOUNT
decl_stmt|;
comment|// how many trailing
comment|// bytes to read for
comment|// EOF marker
comment|/**      * If<code>true</code> object references in catalog are not followed; pro:      * page objects will be only parsed when needed; cons: some information of      * catalog might not be available (e.g. outline). Catalog parsing without      * pages is not an option since a number of entries will also refer to page      * objects (like OpenAction).      */
specifier|private
name|boolean
name|parseMinimalCatalog
init|=
literal|"true"
operator|.
name|equals
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|SYSPROP_PARSEMINIMAL
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
name|boolean
name|initialParseDone
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|allPagesParsed
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|NonSequentialPDFParser
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      *<code>true</code> if the NonSequentialPDFParser is initialized by a      * InputStream, in this case a temporary file is created. At the end of the      * {@linkplain #parse()} method,the temporary file will be deleted.      */
specifier|private
name|boolean
name|isTmpPDFFile
init|=
literal|false
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TMP_FILE_PREFIX
init|=
literal|"tmpPDF"
decl_stmt|;
comment|// ------------------------------------------------------------------------
comment|/**      * Constructs parser for given file using memory buffer.      *       * @param filename the filename of the pdf to be parsed      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs parser for given file using given buffer for temporary      * storage.      *       * @param file the pdf to be parsed      * @param raBuf the buffer to be used for parsing      *       * @throws IOException If something went wrong.      */
comment|/**      * Constructs parser for given file using given buffer for temporary      * storage.      *       * @param file the pdf to be parsed      * @param raBuf the buffer to be used for parsing      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|File
name|file
parameter_list|,
name|RandomAccess
name|raBuf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|file
argument_list|,
name|raBuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs parser for given file using given buffer for temporary      * storage.      *       * @param file the pdf to be parsed      * @param raBuf the buffer to be used for parsing      *       * @throws IOException If something went wrong.      */
comment|/**      * Constructs parser for given file using given buffer for temporary      * storage.      *       * @param file the pdf to be parsed      * @param raBuf the buffer to be used for parsing      * @param decryptionPassword password to be used for decryption      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|File
name|file
parameter_list|,
name|RandomAccess
name|raBuf
parameter_list|,
name|String
name|decryptionPassword
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|EMPTY_INPUT_STREAM
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|pdfFile
operator|=
name|file
expr_stmt|;
name|raStream
operator|=
operator|new
name|RandomAccessBufferedFileInputStream
argument_list|(
name|pdfFile
argument_list|)
expr_stmt|;
name|init
argument_list|(
name|file
argument_list|,
name|raBuf
argument_list|,
name|decryptionPassword
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|init
parameter_list|(
name|File
name|file
parameter_list|,
name|RandomAccess
name|raBuf
parameter_list|,
name|String
name|decryptionPassword
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|eofLookupRangeStr
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|SYSPROP_EOFLOOKUPRANGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|eofLookupRangeStr
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|setEOFLookupRange
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|eofLookupRangeStr
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"System property "
operator|+
name|SYSPROP_EOFLOOKUPRANGE
operator|+
literal|" does not contain an integer value, but: '"
operator|+
name|eofLookupRangeStr
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
name|setDocument
argument_list|(
operator|(
name|raBuf
operator|==
literal|null
operator|)
condition|?
operator|new
name|COSDocument
argument_list|(
operator|new
name|RandomAccessBuffer
argument_list|()
argument_list|,
literal|false
argument_list|)
else|:
operator|new
name|COSDocument
argument_list|(
name|raBuf
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|pdfSource
operator|=
operator|new
name|PushBackInputStream
argument_list|(
name|raStream
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|password
operator|=
name|decryptionPassword
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param input input stream representing the pdf.      * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|input
argument_list|,
literal|null
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param input input stream representing the pdf.      * @param raBuf the buffer to be used for parsing      * @param decryptionPassword password to be used for decryption.      * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|RandomAccess
name|raBuf
parameter_list|,
name|String
name|decryptionPassword
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|EMPTY_INPUT_STREAM
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|pdfFile
operator|=
name|createTmpFile
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|raStream
operator|=
operator|new
name|RandomAccessBufferedFileInputStream
argument_list|(
name|pdfFile
argument_list|)
expr_stmt|;
name|init
argument_list|(
name|pdfFile
argument_list|,
name|raBuf
argument_list|,
name|decryptionPassword
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a temporary file with the input stream. If the creation succeed,      * the {@linkplain #isTmpPDFFile} is set to true. This Temporary file will      * be deleted at end of the parse method      *       * @param input      * @return      * @throws IOException If something went wrong.      */
specifier|private
name|File
name|createTmpFile
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|tmpFile
init|=
literal|null
decl_stmt|;
name|FileOutputStream
name|fos
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tmpFile
operator|=
name|File
operator|.
name|createTempFile
argument_list|(
name|TMP_FILE_PREFIX
argument_list|,
literal|".pdf"
argument_list|)
expr_stmt|;
name|fos
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|tmpFile
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|input
argument_list|,
name|fos
argument_list|)
expr_stmt|;
name|isTmpPDFFile
operator|=
literal|true
expr_stmt|;
return|return
name|tmpFile
return|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|fos
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * Sets how many trailing bytes of PDF file are searched for EOF marker and      * 'startxref' marker. If not set we use default value      * {@link #DEFAULT_TRAIL_BYTECOUNT}.      *       *<p<We check that new value is at least 16. However for practical use      * cases this value should not be lower than 1000; even 2000 was found to      * not be enough in some cases where some trailing garbage like HTML      * snippets followed the EOF marker.</p>      *       *<p>In case system property {@link #SYSPROP_EOFLOOKUPRANGE} is defined      * this value will be set on initialization but can be overwritten      * later.</p>      *       * @param byteCount number of trailing bytes      */
specifier|public
name|void
name|setEOFLookupRange
parameter_list|(
name|int
name|byteCount
parameter_list|)
block|{
if|if
condition|(
name|byteCount
operator|>
literal|15
condition|)
block|{
name|readTrailBytes
operator|=
name|byteCount
expr_stmt|;
block|}
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * The initial parse will first parse only the trailer, the xrefstart and      * all xref tables to have a pointer (offset) to all the pdf's objects. It      * can handle linearized pdfs, which will have an xref at the end pointing      * to an xref at the beginning of the file. Last the root object is parsed.      *       * @throws IOException If something went wrong.      */
specifier|protected
name|void
name|initialParse
parameter_list|()
throws|throws
name|IOException
block|{
comment|// ---- parse startxref
name|setPdfSource
argument_list|(
name|getStartxrefOffset
argument_list|()
argument_list|)
expr_stmt|;
name|parseStartXref
argument_list|()
expr_stmt|;
name|long
name|startXrefOffset
init|=
name|document
operator|.
name|getStartXref
argument_list|()
decl_stmt|;
comment|// check the startxref offset
if|if
condition|(
name|isLenient
condition|)
block|{
name|startXrefOffset
operator|-=
name|calculateFixingOffset
argument_list|(
name|startXrefOffset
argument_list|)
expr_stmt|;
name|document
operator|.
name|setStartXref
argument_list|(
name|startXrefOffset
argument_list|)
expr_stmt|;
block|}
name|long
name|prev
init|=
name|startXrefOffset
decl_stmt|;
comment|// ---- parse whole chain of xref tables/object streams using PREV
comment|// reference
while|while
condition|(
name|prev
operator|>
operator|-
literal|1
condition|)
block|{
comment|// seek to xref table
name|setPdfSource
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|// skip white spaces
name|skipSpaces
argument_list|()
expr_stmt|;
comment|// -- parse xref
if|if
condition|(
name|pdfSource
operator|.
name|peek
argument_list|()
operator|==
name|X
condition|)
block|{
comment|// xref table and trailer
comment|// use existing parser to parse xref table
name|parseXrefTable
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|// parse the last trailer.
if|if
condition|(
operator|!
name|parseTrailer
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected trailer object at position: "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getCurrentTrailer
argument_list|()
decl_stmt|;
name|prev
operator|=
name|trailer
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLenient
operator|&&
name|prev
operator|>
operator|-
literal|1
condition|)
block|{
comment|// check the xref table reference
name|long
name|fixingOffset
init|=
name|calculateFixingOffset
argument_list|(
name|prev
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixingOffset
operator|!=
literal|0
condition|)
block|{
name|prev
operator|-=
name|fixingOffset
expr_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// parse xref stream
name|prev
operator|=
name|parseXrefObjStream
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLenient
operator|&&
name|prev
operator|>
operator|-
literal|1
condition|)
block|{
comment|// check the xref table reference
name|long
name|fixingOffset
init|=
name|calculateFixingOffset
argument_list|(
name|prev
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixingOffset
operator|!=
literal|0
condition|)
block|{
name|prev
operator|-=
name|fixingOffset
expr_stmt|;
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getCurrentTrailer
argument_list|()
decl_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// ---- build valid xrefs out of the xref chain
name|xrefTrailerResolver
operator|.
name|setStartxref
argument_list|(
name|startXrefOffset
argument_list|)
expr_stmt|;
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|document
operator|.
name|setTrailer
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
name|document
operator|.
name|setIsXRefStream
argument_list|(
name|XRefType
operator|.
name|STREAM
operator|==
name|xrefTrailerResolver
operator|.
name|getXrefType
argument_list|()
argument_list|)
expr_stmt|;
comment|// check the offsets of all referenced objects
if|if
condition|(
name|isLenient
condition|)
block|{
name|checkXrefOffsets
argument_list|()
expr_stmt|;
block|}
comment|// ---- prepare encryption if necessary
name|COSBase
name|trailerEncryptItem
init|=
name|document
operator|.
name|getTrailer
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailerEncryptItem
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|trailerEncryptItem
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|trailerEncryptObj
init|=
operator|(
name|COSObject
operator|)
name|trailerEncryptItem
decl_stmt|;
name|parseObjectDynamically
argument_list|(
name|trailerEncryptObj
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|PDEncryptionDictionary
name|encParameters
init|=
operator|new
name|PDEncryptionDictionary
argument_list|(
name|document
operator|.
name|getEncryptionDictionary
argument_list|()
argument_list|)
decl_stmt|;
name|DecryptionMaterial
name|decryptionMaterial
decl_stmt|;
if|if
condition|(
name|keyStoreFilename
operator|!=
literal|null
condition|)
block|{
name|KeyStore
name|ks
init|=
name|KeyStore
operator|.
name|getInstance
argument_list|(
literal|"PKCS12"
argument_list|)
decl_stmt|;
name|ks
operator|.
name|load
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|keyStoreFilename
argument_list|)
argument_list|,
name|password
operator|.
name|toCharArray
argument_list|()
argument_list|)
expr_stmt|;
name|decryptionMaterial
operator|=
operator|new
name|PublicKeyDecryptionMaterial
argument_list|(
name|ks
argument_list|,
name|alias
argument_list|,
name|password
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decryptionMaterial
operator|=
operator|new
name|StandardDecryptionMaterial
argument_list|(
name|password
argument_list|)
expr_stmt|;
block|}
name|securityHandler
operator|=
name|SecurityHandlerFactory
operator|.
name|INSTANCE
operator|.
name|newSecurityHandler
argument_list|(
name|encParameters
operator|.
name|getFilter
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|securityHandler
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No security handler for filter "
operator|+
name|encParameters
operator|.
name|getFilter
argument_list|()
argument_list|)
throw|;
block|}
name|securityHandler
operator|.
name|prepareForDecryption
argument_list|(
name|encParameters
argument_list|,
name|document
operator|.
name|getDocumentID
argument_list|()
argument_list|,
name|decryptionMaterial
argument_list|)
expr_stmt|;
name|AccessPermission
name|permission
init|=
name|securityHandler
operator|.
name|getCurrentAccessPermission
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|permission
operator|.
name|canExtractContent
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"PDF file '"
operator|+
name|pdfFile
operator|.
name|getPath
argument_list|()
operator|+
literal|"' does not allow extracting content."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error ("
operator|+
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|") while creating security handler for decryption: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
comment|/*                                                                                                  * , e TODO: remove                                                                                                  * remark with Java 1.6                                                                                                  */
argument_list|)
throw|;
block|}
block|}
comment|// PDFBOX-1557 - ensure that all COSObject are loaded in the trailer
comment|// PDFBOX-1606 - after securityHandler has been instantiated
for|for
control|(
name|COSBase
name|trailerEntry
range|:
name|trailer
operator|.
name|getValues
argument_list|()
control|)
block|{
if|if
condition|(
name|trailerEntry
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|tmpObj
init|=
operator|(
name|COSObject
operator|)
name|trailerEntry
decl_stmt|;
name|parseObjectDynamically
argument_list|(
name|tmpObj
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ---- parse catalog or root object
name|COSObject
name|root
init|=
operator|(
name|COSObject
operator|)
name|xrefTrailerResolver
operator|.
name|getTrailer
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing root object specification in trailer."
argument_list|)
throw|;
block|}
name|parseObjectDynamically
argument_list|(
name|root
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// ---- resolve all objects (including pages)
if|if
condition|(
operator|!
name|parseMinimalCatalog
condition|)
block|{
name|COSObject
name|catalogObj
init|=
name|document
operator|.
name|getCatalog
argument_list|()
decl_stmt|;
if|if
condition|(
name|catalogObj
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|catalogObj
operator|.
name|getObject
argument_list|()
operator|instanceof
name|COSDictionary
condition|)
block|{
name|parseDictObjects
argument_list|(
operator|(
name|COSDictionary
operator|)
name|catalogObj
operator|.
name|getObject
argument_list|()
argument_list|,
operator|(
name|COSName
index|[]
operator|)
literal|null
argument_list|)
expr_stmt|;
name|allPagesParsed
operator|=
literal|true
expr_stmt|;
name|document
operator|.
name|setDecrypted
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|initialParseDone
operator|=
literal|true
expr_stmt|;
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * Parses an xref object stream starting with indirect object id.      *       * @return value of PREV item in dictionary or<code>-1</code> if no such      *         item exists      */
specifier|private
name|long
name|parseXrefObjStream
parameter_list|(
name|long
name|objByteOffset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- parse indirect object head
name|readObjectNumber
argument_list|()
expr_stmt|;
name|readGenerationNumber
argument_list|()
expr_stmt|;
name|readPattern
argument_list|(
name|OBJ_MARKER
argument_list|)
expr_stmt|;
name|COSDictionary
name|dict
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
name|COSStream
name|xrefStream
init|=
name|parseCOSStream
argument_list|(
name|dict
argument_list|,
name|getDocument
argument_list|()
operator|.
name|getScratchFile
argument_list|()
argument_list|)
decl_stmt|;
name|parseXrefStream
argument_list|(
name|xrefStream
argument_list|,
operator|(
name|int
operator|)
name|objByteOffset
argument_list|)
expr_stmt|;
return|return
name|dict
operator|.
name|getLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** Get current offset in file at which next byte would be read. */
specifier|private
specifier|final
name|long
name|getPdfSourceOffset
parameter_list|()
block|{
return|return
name|pdfSource
operator|.
name|getOffset
argument_list|()
return|;
block|}
comment|/**      * Sets {@link #pdfSource} to start next parsing at given file offset.      *       * @param fileOffset file offset      * @throws IOException If something went wrong.      */
specifier|protected
specifier|final
name|void
name|setPdfSource
parameter_list|(
name|long
name|fileOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
name|fileOffset
argument_list|)
expr_stmt|;
comment|// alternative using 'old fashioned' input stream
comment|// if ( pdfSource != null )
comment|// pdfSource.close();
comment|//
comment|// pdfSource = new PushBackInputStream(
comment|// new BufferedInputStream(
comment|// new FileInputStream( file ), 16384), 4096);
comment|// pdfSource.skip( _fileOffset );
block|}
comment|/**      * Enable handling of alternative pdfSource implementation.      * @throws IOException If something went wrong.      */
specifier|protected
specifier|final
name|void
name|releasePdfSourceInputStream
parameter_list|()
throws|throws
name|IOException
block|{
comment|// if ( pdfSource != null )
comment|// pdfSource.close();
block|}
specifier|private
specifier|final
name|void
name|closeFileStream
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pdfSource
operator|!=
literal|null
condition|)
block|{
name|pdfSource
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * Looks for and parses startxref. We first look for last '%%EOF' marker      * (within last {@link #DEFAULT_TRAIL_BYTECOUNT} bytes (or range set via      * {@link #setEOFLookupRange(int)}) and go back to find      *<code>startxref</code>.      *       * @return the offset of StartXref       * @throws IOException If something went wrong.      */
specifier|protected
specifier|final
name|long
name|getStartxrefOffset
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|buf
decl_stmt|;
name|long
name|skipBytes
decl_stmt|;
comment|// ---- read trailing bytes into buffer
name|fileLen
operator|=
name|pdfFile
operator|.
name|length
argument_list|()
expr_stmt|;
name|FileInputStream
name|fIn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fIn
operator|=
operator|new
name|FileInputStream
argument_list|(
name|pdfFile
argument_list|)
expr_stmt|;
specifier|final
name|int
name|trailByteCount
init|=
operator|(
name|fileLen
operator|<
name|readTrailBytes
operator|)
condition|?
operator|(
name|int
operator|)
name|fileLen
else|:
name|readTrailBytes
decl_stmt|;
name|buf
operator|=
operator|new
name|byte
index|[
name|trailByteCount
index|]
expr_stmt|;
name|fIn
operator|.
name|skip
argument_list|(
name|skipBytes
operator|=
name|fileLen
operator|-
name|trailByteCount
argument_list|)
expr_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|readBytes
decl_stmt|;
while|while
condition|(
name|off
operator|<
name|trailByteCount
condition|)
block|{
name|readBytes
operator|=
name|fIn
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|trailByteCount
operator|-
name|off
argument_list|)
expr_stmt|;
comment|// in order to not get stuck in a loop we check readBytes (this
comment|// should never happen)
if|if
condition|(
name|readBytes
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No more bytes to read for trailing buffer, but expected: "
operator|+
operator|(
name|trailByteCount
operator|-
name|off
operator|)
argument_list|)
throw|;
block|}
name|off
operator|+=
name|readBytes
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|fIn
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|fIn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{                 }
block|}
block|}
comment|// ---- find last '%%EOF'
name|int
name|bufOff
init|=
name|lastIndexOf
argument_list|(
name|EOF_MARKER
argument_list|,
name|buf
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufOff
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing end of file marker '"
operator|+
operator|(
operator|new
name|String
argument_list|(
name|EOF_MARKER
argument_list|)
operator|)
operator|+
literal|"'"
argument_list|)
throw|;
block|}
comment|// ---- find last startxref preceding EOF marker
name|bufOff
operator|=
name|lastIndexOf
argument_list|(
name|STARTXREF_MARKER
argument_list|,
name|buf
argument_list|,
name|bufOff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufOff
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing 'startxref' marker."
argument_list|)
throw|;
block|}
return|return
name|skipBytes
operator|+
name|bufOff
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * Searches last appearance of pattern within buffer. Lookup before _lastOff      * and goes back until 0.      *       * @param pattern pattern to search for      * @param buf buffer to search pattern in      * @param endOff offset (exclusive) where lookup starts at      *       * @return start offset of pattern within buffer or<code>-1</code> if      *         pattern could not be found      */
specifier|protected
name|int
name|lastIndexOf
parameter_list|(
specifier|final
name|char
index|[]
name|pattern
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|endOff
parameter_list|)
block|{
specifier|final
name|int
name|lastPatternChOff
init|=
name|pattern
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|bufOff
init|=
name|endOff
decl_stmt|;
name|int
name|patOff
init|=
name|lastPatternChOff
decl_stmt|;
name|char
name|lookupCh
init|=
name|pattern
index|[
name|patOff
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|bufOff
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|bufOff
index|]
operator|==
name|lookupCh
condition|)
block|{
if|if
condition|(
operator|--
name|patOff
operator|<
literal|0
condition|)
block|{
comment|// whole pattern matched
return|return
name|bufOff
return|;
block|}
comment|// matched current char, advance to preceding one
name|lookupCh
operator|=
name|pattern
index|[
name|patOff
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|patOff
operator|<
name|lastPatternChOff
condition|)
block|{
comment|// no char match but already matched some chars; reset
name|lookupCh
operator|=
name|pattern
index|[
name|patOff
operator|=
name|lastPatternChOff
index|]
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * Reads given pattern from {@link #pdfSource}. Skipping whitespace at start      * and end.      *       * @param pattern pattern to be skipped      * @throws IOException if pattern could not be read      */
specifier|protected
specifier|final
name|void
name|readPattern
parameter_list|(
specifier|final
name|char
index|[]
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
for|for
control|(
name|char
name|c
range|:
name|pattern
control|)
block|{
if|if
condition|(
name|pdfSource
operator|.
name|read
argument_list|()
operator|!=
name|c
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected pattern '"
operator|+
operator|new
name|String
argument_list|(
name|pattern
argument_list|)
operator|+
literal|" but missed at character '"
operator|+
name|c
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
comment|// ------------------------------------------------------------------------
specifier|private
name|COSDictionary
name|pagesDictionary
init|=
literal|null
decl_stmt|;
comment|/**      * Returns PAGES {@link COSDictionary} object or throws {@link IOException}      * if PAGES dictionary does not exist.      */
specifier|private
name|COSDictionary
name|getPagesObject
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pagesDictionary
operator|!=
literal|null
condition|)
block|{
return|return
name|pagesDictionary
return|;
block|}
name|COSObject
name|pages
init|=
operator|(
name|COSObject
operator|)
name|document
operator|.
name|getCatalog
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|PAGES
argument_list|)
decl_stmt|;
if|if
condition|(
name|pages
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing PAGES entry in document catalog."
argument_list|)
throw|;
block|}
name|COSBase
name|object
init|=
name|parseObjectDynamically
argument_list|(
name|pages
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|object
operator|instanceof
name|COSDictionary
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"PAGES not a dictionary object, but: "
operator|+
name|object
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
name|pagesDictionary
operator|=
operator|(
name|COSDictionary
operator|)
name|object
expr_stmt|;
return|return
name|pagesDictionary
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** Parses all objects needed by pages and closes input stream. */
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
specifier|public
name|void
name|parse
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|exceptionOccurred
init|=
literal|true
decl_stmt|;
comment|// set to false if all is processed
try|try
block|{
if|if
condition|(
operator|!
name|initialParseDone
condition|)
block|{
name|initialParse
argument_list|()
expr_stmt|;
block|}
specifier|final
name|int
name|pageCount
init|=
name|getPageNumber
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|allPagesParsed
condition|)
block|{
for|for
control|(
name|int
name|pNr
init|=
literal|0
init|;
name|pNr
operator|<
name|pageCount
condition|;
name|pNr
operator|++
control|)
block|{
name|getPage
argument_list|(
name|pNr
argument_list|)
expr_stmt|;
block|}
name|allPagesParsed
operator|=
literal|true
expr_stmt|;
name|document
operator|.
name|setDecrypted
argument_list|()
expr_stmt|;
block|}
name|exceptionOccurred
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|closeFileStream
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{             }
name|deleteTempFile
argument_list|()
expr_stmt|;
if|if
condition|(
name|exceptionOccurred
operator|&&
operator|(
name|document
operator|!=
literal|null
operator|)
condition|)
block|{
try|try
block|{
name|document
operator|.
name|close
argument_list|()
expr_stmt|;
name|document
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{                 }
block|}
block|}
block|}
comment|/**      * Return the pdf file.      *       * @return the pdf file      */
specifier|protected
name|File
name|getPdfFile
parameter_list|()
block|{
return|return
name|this
operator|.
name|pdfFile
return|;
block|}
comment|/**      * Return true if parser is lenient. Meaning auto healing capacity of the parser are used.      *      * @return true if parser is lenient      */
specifier|public
name|boolean
name|isLenient
parameter_list|()
block|{
return|return
name|isLenient
return|;
block|}
comment|/**      * Change the parser leniency flag.      *      * This method can only be called before the parsing of the file.      *      * @param lenient      *      * @throws IllegalArgumentException if the method is called after parsing.      */
specifier|public
name|void
name|setLenient
parameter_list|(
name|boolean
name|lenient
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|initialParseDone
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot change leniency after parsing"
argument_list|)
throw|;
block|}
name|this
operator|.
name|isLenient
operator|=
name|lenient
expr_stmt|;
block|}
comment|/**      * Remove the temporary file. A temporary file is created if this class is      * instantiated with an InputStream      */
specifier|protected
name|void
name|deleteTempFile
parameter_list|()
block|{
if|if
condition|(
name|isTmpPDFFile
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|pdfFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Temporary file '"
operator|+
name|pdfFile
operator|.
name|getName
argument_list|()
operator|+
literal|"' can't be deleted"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Temporary file '"
operator|+
name|pdfFile
operator|.
name|getName
argument_list|()
operator|+
literal|"' can't be deleted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * Returns security handler of the document or<code>null</code> if document      * is not encrypted or {@link #parse()} wasn't called before.      *       * @return the security handler.      */
specifier|public
name|SecurityHandler
name|getSecurityHandler
parameter_list|()
block|{
return|return
name|securityHandler
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * This will get the PD document that was parsed. When you are done with      * this document you must call close() on it to release resources.      *       * Overwriting super method was necessary in order to set security handler.      *       * @return The document at the PD layer.      *       * @throws IOException If there is an error getting the document.      */
annotation|@
name|Override
specifier|public
name|PDDocument
name|getPDDocument
parameter_list|()
throws|throws
name|IOException
block|{
name|PDDocument
name|pdDocument
init|=
name|super
operator|.
name|getPDDocument
argument_list|()
decl_stmt|;
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
name|pdDocument
operator|.
name|setSecurityHandler
argument_list|(
name|securityHandler
argument_list|)
expr_stmt|;
block|}
return|return
name|pdDocument
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * Returns the number of pages in a document.      *       * @return the number of pages.      *       * @throws IOException if PAGES or other needed object is missing      */
specifier|public
name|int
name|getPageNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|pageCount
init|=
name|getPagesObject
argument_list|()
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|COUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageCount
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No page number specified."
argument_list|)
throw|;
block|}
return|return
name|pageCount
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * Returns the page requested with all the objects loaded into it.      *       * @param pageNr starts from 0 to the number of pages.      * @return the page with the given pagenumber.      * @throws IOException If something went wrong.      */
specifier|public
name|PDPage
name|getPage
parameter_list|(
name|int
name|pageNr
parameter_list|)
throws|throws
name|IOException
block|{
name|getPagesObject
argument_list|()
expr_stmt|;
comment|// ---- get list of top level pages
name|COSArray
name|kids
init|=
operator|(
name|COSArray
operator|)
name|pagesDictionary
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|KIDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|kids
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing 'Kids' entry in pages dictionary."
argument_list|)
throw|;
block|}
comment|// ---- get page we are looking for (possibly going recursively into
comment|// subpages)
name|COSObject
name|pageObj
init|=
name|getPageObject
argument_list|(
name|pageNr
argument_list|,
name|kids
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageObj
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Page "
operator|+
name|pageNr
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
comment|// ---- parse all objects necessary to load page.
name|COSDictionary
name|pageDict
init|=
operator|(
name|COSDictionary
operator|)
name|pageObj
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|parseMinimalCatalog
operator|&&
operator|(
operator|!
name|allPagesParsed
operator|)
condition|)
block|{
comment|// parse page resources since we did not do this on start
name|COSDictionary
name|resDict
init|=
operator|(
name|COSDictionary
operator|)
name|pageDict
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|RESOURCES
argument_list|)
decl_stmt|;
name|parseDictObjects
argument_list|(
name|resDict
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|PDPage
argument_list|(
name|pageDict
argument_list|)
return|;
block|}
comment|/**      * Returns the object for a specific page. The page tree is made up of kids.      * The kids have COSArray with COSObjects inside of them. The COSObject can      * be parsed using the dynamic parsing method We want to only parse the      * minimum COSObjects and still return a complete page. ready to be used.      *       * @param num the requested page number; numbering starts with 0      * @param startKids Kids array to start with looking up page number      * @param startPageCount      *       * @return page object or<code>null</code> if no such page exists      *       * @throws IOException      */
specifier|private
name|COSObject
name|getPageObject
parameter_list|(
name|int
name|num
parameter_list|,
name|COSArray
name|startKids
parameter_list|,
name|int
name|startPageCount
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|curPageCount
init|=
name|startPageCount
decl_stmt|;
name|Iterator
argument_list|<
name|COSBase
argument_list|>
name|kidsIter
init|=
name|startKids
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|kidsIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|COSObject
name|obj
init|=
operator|(
name|COSObject
operator|)
name|kidsIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|COSBase
name|base
init|=
name|obj
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|base
operator|==
literal|null
condition|)
block|{
name|base
operator|=
name|parseObjectDynamically
argument_list|(
name|obj
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|obj
operator|.
name|setObject
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
name|COSDictionary
name|dic
init|=
operator|(
name|COSDictionary
operator|)
name|base
decl_stmt|;
name|int
name|count
init|=
name|dic
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|COUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
block|{
comment|// skip this branch if requested page comes later
if|if
condition|(
operator|(
name|curPageCount
operator|+
name|count
operator|)
operator|<=
name|num
condition|)
block|{
name|curPageCount
operator|+=
name|count
expr_stmt|;
continue|continue;
block|}
block|}
name|COSArray
name|kids
init|=
operator|(
name|COSArray
operator|)
name|dic
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|KIDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|kids
operator|!=
literal|null
condition|)
block|{
comment|// recursively scan subpages
name|COSObject
name|ans
init|=
name|getPageObject
argument_list|(
name|num
argument_list|,
name|kids
argument_list|,
name|curPageCount
argument_list|)
decl_stmt|;
comment|// if ans is not null, we got what we were looking for
if|if
condition|(
name|ans
operator|!=
literal|null
condition|)
block|{
return|return
name|ans
return|;
block|}
block|}
else|else
block|{
comment|// found page?
if|if
condition|(
name|curPageCount
operator|==
name|num
condition|)
block|{
return|return
name|obj
return|;
block|}
comment|// page has no kids and it is not the page we are looking for
name|curPageCount
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Creates a unique object id using object number and object generation      * number. (requires object number< 2^31))      */
specifier|private
specifier|final
name|long
name|getObjectId
parameter_list|(
specifier|final
name|COSObject
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
operator|.
name|longValue
argument_list|()
operator|<<
literal|32
operator|)
operator||
name|obj
operator|.
name|getGenerationNumber
argument_list|()
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/**      * Adds all from newObjects to toBeParsedList if it is not an COSObject or      * we didn't add this COSObject already (checked via addedObjects).      */
specifier|private
specifier|final
name|void
name|addNewToList
parameter_list|(
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|COSBase
argument_list|>
name|newObjects
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
parameter_list|)
block|{
for|for
control|(
name|COSBase
name|newObject
range|:
name|newObjects
control|)
block|{
if|if
condition|(
name|newObject
operator|instanceof
name|COSObject
condition|)
block|{
specifier|final
name|long
name|objId
init|=
name|getObjectId
argument_list|(
operator|(
name|COSObject
operator|)
name|newObject
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|addedObjects
operator|.
name|add
argument_list|(
name|objId
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
name|toBeParsedList
operator|.
name|add
argument_list|(
name|newObject
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds newObject to toBeParsedList if it is not an COSObject or we didn't      * add this COSObject already (checked via addedObjects).      */
specifier|private
specifier|final
name|void
name|addNewToList
parameter_list|(
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
parameter_list|,
specifier|final
name|COSBase
name|newObject
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
parameter_list|)
block|{
if|if
condition|(
name|newObject
operator|instanceof
name|COSObject
condition|)
block|{
specifier|final
name|long
name|objId
init|=
name|getObjectId
argument_list|(
operator|(
name|COSObject
operator|)
name|newObject
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|addedObjects
operator|.
name|add
argument_list|(
name|objId
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|toBeParsedList
operator|.
name|add
argument_list|(
name|newObject
argument_list|)
expr_stmt|;
block|}
comment|/**      * Will parse every object necessary to load a single page from the pdf      * document. We try our best to order objects according to offset in file      * before reading to minimize seek operations.      *       * @param dict the COSObject from the parent pages.      * @param excludeObjects dictionary object reference entries with these      *            names will not be parsed      *       * @throws IOException      */
specifier|private
name|void
name|parseDictObjects
parameter_list|(
name|COSDictionary
name|dict
parameter_list|,
name|COSName
modifier|...
name|excludeObjects
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- create queue for objects waiting for further parsing
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
init|=
operator|new
name|LinkedList
argument_list|<
name|COSBase
argument_list|>
argument_list|()
decl_stmt|;
comment|// offset ordered object map
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|COSObject
argument_list|>
argument_list|>
name|objToBeParsed
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|COSObject
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// in case of compressed objects offset points to stmObj
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|parsedObjects
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
comment|// ---- add objects not to be parsed to list of already parsed objects
if|if
condition|(
name|excludeObjects
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|COSName
name|objName
range|:
name|excludeObjects
control|)
block|{
name|COSBase
name|baseObj
init|=
name|dict
operator|.
name|getItem
argument_list|(
name|objName
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|parsedObjects
operator|.
name|add
argument_list|(
name|getObjectId
argument_list|(
operator|(
name|COSObject
operator|)
name|baseObj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|dict
operator|.
name|getValues
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
comment|// ---- go through objects to be parsed
while|while
condition|(
operator|!
operator|(
name|toBeParsedList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|objToBeParsed
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
comment|// -- first get all COSObject from other kind of objects and
comment|// put them in objToBeParsed; afterwards toBeParsedList is empty
name|COSBase
name|baseObj
decl_stmt|;
while|while
condition|(
operator|(
name|baseObj
operator|=
name|toBeParsedList
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|baseObj
operator|instanceof
name|COSStream
condition|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
operator|(
operator|(
name|COSStream
operator|)
name|baseObj
operator|)
operator|.
name|getValues
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseObj
operator|instanceof
name|COSDictionary
condition|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
operator|(
operator|(
name|COSDictionary
operator|)
name|baseObj
operator|)
operator|.
name|getValues
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseObj
operator|instanceof
name|COSArray
condition|)
block|{
specifier|final
name|Iterator
argument_list|<
name|COSBase
argument_list|>
name|arrIter
init|=
operator|(
operator|(
name|COSArray
operator|)
name|baseObj
operator|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|arrIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|arrIter
operator|.
name|next
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|baseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|obj
init|=
operator|(
name|COSObject
operator|)
name|baseObj
decl_stmt|;
name|long
name|objId
init|=
name|getObjectId
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|obj
operator|.
name|getGenerationNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|parsedObjects
operator|.
name|contains
argument_list|(
name|objId
argument_list|)
comment|/*                                                          * || document.hasObjectInPool ( objKey )                                                          */
operator|)
condition|)
block|{
name|Long
name|fileOffset
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
comment|// it is allowed that object references point to null,
comment|// thus we have to test
if|if
condition|(
name|fileOffset
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|fileOffset
operator|>
literal|0
condition|)
block|{
name|objToBeParsed
operator|.
name|put
argument_list|(
name|fileOffset
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// negative offset means we have a compressed
comment|// object within object stream;
comment|// get offset of object stream
name|fileOffset
operator|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
operator|new
name|COSObjectKey
argument_list|(
operator|-
name|fileOffset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fileOffset
operator|==
literal|null
operator|)
operator|||
operator|(
name|fileOffset
operator|<=
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid object stream xref object reference: "
operator|+
name|fileOffset
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|COSObject
argument_list|>
name|stmObjects
init|=
name|objToBeParsed
operator|.
name|get
argument_list|(
name|fileOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmObjects
operator|==
literal|null
condition|)
block|{
name|objToBeParsed
operator|.
name|put
argument_list|(
name|fileOffset
argument_list|,
name|stmObjects
operator|=
operator|new
name|ArrayList
argument_list|<
name|COSObject
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|stmObjects
operator|.
name|add
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// NULL object
name|COSObject
name|pdfObject
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
name|pdfObject
operator|.
name|setObject
argument_list|(
name|COSNull
operator|.
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// ---- read first COSObject with smallest offset;
comment|// resulting object will be added to toBeParsedList
if|if
condition|(
name|objToBeParsed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
for|for
control|(
name|COSObject
name|obj
range|:
name|objToBeParsed
operator|.
name|remove
argument_list|(
name|objToBeParsed
operator|.
name|firstKey
argument_list|()
argument_list|)
control|)
block|{
name|COSBase
name|parsedObj
init|=
name|parseObjectDynamically
argument_list|(
name|obj
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|obj
operator|.
name|setObject
argument_list|(
name|parsedObj
argument_list|)
expr_stmt|;
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|parsedObj
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
name|parsedObjects
operator|.
name|add
argument_list|(
name|getObjectId
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This will parse the next object from the stream and add it to the local      * state. This is taken from {@link PDFParser} and reduced to parsing an      * indirect object.      *       * @param obj object to be parsed (we only take object number and generation      *            number for lookup start offset)      * @param requireExistingNotCompressedObj if<code>true</code> object to be      *            parsed must not be contained within compressed stream      * @return the parsed object (which is also added to document object)      *       * @throws IOException If an IO error occurs.      */
specifier|protected
specifier|final
name|COSBase
name|parseObjectDynamically
parameter_list|(
name|COSObject
name|obj
parameter_list|,
name|boolean
name|requireExistingNotCompressedObj
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|parseObjectDynamically
argument_list|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|obj
operator|.
name|getGenerationNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|requireExistingNotCompressedObj
argument_list|)
return|;
block|}
comment|/**      * This will parse the next object from the stream and add it to the local      * state. This is taken from {@link PDFParser} and reduced to parsing an      * indirect object.      *       * @param objNr object number of object to be parsed      * @param objGenNr object generation number of object to be parsed      * @param requireExistingNotCompressedObj if<code>true</code> the object to      *            be parsed must be defined in xref (comment: null objects may      *            be missing from xref) and it must not be a compressed object      *            within object stream (this is used to circumvent being stuck      *            in a loop in a malicious PDF)      *       * @return the parsed object (which is also added to document object)      *       * @throws IOException If an IO error occurs.      */
specifier|protected
name|COSBase
name|parseObjectDynamically
parameter_list|(
name|int
name|objNr
parameter_list|,
name|int
name|objGenNr
parameter_list|,
name|boolean
name|requireExistingNotCompressedObj
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- create object key and get object (container) from pool
specifier|final
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|objNr
argument_list|,
name|objGenNr
argument_list|)
decl_stmt|;
specifier|final
name|COSObject
name|pdfObject
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|pdfObject
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// not previously parsed
comment|// ---- read offset or object stream object number from xref table
name|Long
name|offsetOrObjstmObNr
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
comment|// sanity test to circumvent loops with broken documents
if|if
condition|(
name|requireExistingNotCompressedObj
operator|&&
operator|(
operator|(
name|offsetOrObjstmObNr
operator|==
literal|null
operator|)
operator|||
operator|(
name|offsetOrObjstmObNr
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object must be defined and must not be compressed object: "
operator|+
name|objKey
operator|.
name|getNumber
argument_list|()
operator|+
literal|":"
operator|+
name|objKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|offsetOrObjstmObNr
operator|==
literal|null
condition|)
block|{
comment|// not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)
name|pdfObject
operator|.
name|setObject
argument_list|(
name|COSNull
operator|.
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsetOrObjstmObNr
operator|>
literal|0
condition|)
block|{
comment|// offset of indirect object in file
comment|// ---- go to object start
name|setPdfSource
argument_list|(
name|offsetOrObjstmObNr
argument_list|)
expr_stmt|;
comment|// ---- we must have an indirect object
specifier|final
name|long
name|readObjNr
init|=
name|readObjectNumber
argument_list|()
decl_stmt|;
specifier|final
name|long
name|readObjGen
init|=
name|readGenerationNumber
argument_list|()
decl_stmt|;
name|readPattern
argument_list|(
name|OBJ_MARKER
argument_list|)
expr_stmt|;
comment|// ---- consistency check
if|if
condition|(
operator|(
name|readObjNr
operator|!=
name|objKey
operator|.
name|getNumber
argument_list|()
operator|)
operator|||
operator|(
name|readObjGen
operator|!=
name|objKey
operator|.
name|getGeneration
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"XREF for "
operator|+
name|objKey
operator|.
name|getNumber
argument_list|()
operator|+
literal|":"
operator|+
name|objKey
operator|.
name|getGeneration
argument_list|()
operator|+
literal|" points to wrong object: "
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSBase
name|pb
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|String
name|endObjectKey
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
name|endObjectKey
operator|.
name|equals
argument_list|(
literal|"stream"
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|endObjectKey
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSStream
name|stream
init|=
name|parseCOSStream
argument_list|(
operator|(
name|COSDictionary
operator|)
name|pb
argument_list|,
name|getDocument
argument_list|()
operator|.
name|getScratchFile
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|securityHandler
operator|.
name|decryptStream
argument_list|(
name|stream
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CryptographyException
name|ce
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error decrypting stream object "
operator|+
name|objNr
operator|+
literal|": "
operator|+
name|ce
operator|.
name|getMessage
argument_list|()
comment|/* , ce // TODO: remove remark with Java 1.6 */
argument_list|)
throw|;
block|}
block|}
name|pb
operator|=
name|stream
expr_stmt|;
block|}
else|else
block|{
comment|// this is not legal
comment|// the combination of a dict and the stream/endstream
comment|// forms a complete stream object
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream not preceded by dictionary (offset: "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|")."
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|endObjectKey
operator|=
name|readLine
argument_list|()
expr_stmt|;
comment|// we have case with a second 'endstream' before endobj
if|if
condition|(
operator|!
name|endObjectKey
operator|.
name|startsWith
argument_list|(
literal|"endobj"
argument_list|)
condition|)
block|{
if|if
condition|(
name|endObjectKey
operator|.
name|startsWith
argument_list|(
literal|"endstream"
argument_list|)
condition|)
block|{
name|endObjectKey
operator|=
name|endObjectKey
operator|.
name|substring
argument_list|(
literal|9
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|endObjectKey
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// no other characters in extra endstream line
name|endObjectKey
operator|=
name|readLine
argument_list|()
expr_stmt|;
comment|// read next line
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
comment|// decrypt
if|if
condition|(
name|pb
operator|instanceof
name|COSString
condition|)
block|{
name|decrypt
argument_list|(
operator|(
name|COSString
operator|)
name|pb
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pb
operator|instanceof
name|COSDictionary
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|COSName
argument_list|,
name|COSBase
argument_list|>
name|entry
range|:
operator|(
operator|(
name|COSDictionary
operator|)
name|pb
operator|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// TODO: specially handle 'Contents' entry of
comment|// signature dictionary like in
comment|// SecurityHandler#decryptDictionary
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|instanceof
name|COSString
condition|)
block|{
name|decrypt
argument_list|(
operator|(
name|COSString
operator|)
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|pb
operator|instanceof
name|COSArray
condition|)
block|{
specifier|final
name|COSArray
name|array
init|=
operator|(
name|COSArray
operator|)
name|pb
decl_stmt|;
for|for
control|(
name|int
name|aIdx
init|=
literal|0
init|,
name|len
init|=
name|array
operator|.
name|size
argument_list|()
init|;
name|aIdx
operator|<
name|len
condition|;
name|aIdx
operator|++
control|)
block|{
if|if
condition|(
name|array
operator|.
name|get
argument_list|(
name|aIdx
argument_list|)
operator|instanceof
name|COSString
condition|)
block|{
name|decrypt
argument_list|(
operator|(
name|COSString
operator|)
name|array
operator|.
name|get
argument_list|(
name|aIdx
argument_list|)
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|pdfObject
operator|.
name|setObject
argument_list|(
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endObjectKey
operator|.
name|startsWith
argument_list|(
literal|"endobj"
argument_list|)
condition|)
block|{
if|if
condition|(
name|endObjectKey
operator|.
name|endsWith
argument_list|(
literal|" obj"
argument_list|)
operator|&&
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Object ("
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
operator|+
literal|") at offset "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|" does not end with 'endobj' but with '"
operator|+
name|endObjectKey
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object ("
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
operator|+
literal|") at offset "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|" does not end with 'endobj' but with '"
operator|+
name|endObjectKey
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
name|releasePdfSourceInputStream
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// xref value is object nr of object stream containing object to
comment|// be parsed;
comment|// since our object was not found it means object stream was not
comment|// parsed so far
specifier|final
name|int
name|objstmObjNr
init|=
call|(
name|int
call|)
argument_list|(
operator|-
name|offsetOrObjstmObNr
argument_list|)
decl_stmt|;
specifier|final
name|COSBase
name|objstmBaseObj
init|=
name|parseObjectDynamically
argument_list|(
name|objstmObjNr
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|objstmBaseObj
operator|instanceof
name|COSStream
condition|)
block|{
comment|// parse object stream
name|PDFObjectStreamParser
name|parser
init|=
operator|new
name|PDFObjectStreamParser
argument_list|(
operator|(
name|COSStream
operator|)
name|objstmBaseObj
argument_list|,
name|document
argument_list|,
name|forceParsing
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
comment|// get set of object numbers referenced for this object
comment|// stream
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|refObjNrs
init|=
name|xrefTrailerResolver
operator|.
name|getContainedObjectNumbers
argument_list|(
name|objstmObjNr
argument_list|)
decl_stmt|;
comment|// register all objects which are referenced to be contained
comment|// in object stream
for|for
control|(
name|COSObject
name|next
range|:
name|parser
operator|.
name|getObjects
argument_list|()
control|)
block|{
name|COSObjectKey
name|stmObjKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|refObjNrs
operator|.
name|contains
argument_list|(
name|stmObjKey
operator|.
name|getNumber
argument_list|()
argument_list|)
condition|)
block|{
name|COSObject
name|stmObj
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|stmObjKey
argument_list|)
decl_stmt|;
name|stmObj
operator|.
name|setObject
argument_list|(
name|next
operator|.
name|getObject
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|pdfObject
operator|.
name|getObject
argument_list|()
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/**      * Decrypts given COSString.      *       * @param str the string to be decrypted      * @param objNr the object number      * @param objGenNr the object generation number      * @throws IOException ff something went wrong      */
specifier|protected
specifier|final
name|void
name|decrypt
parameter_list|(
name|COSString
name|str
parameter_list|,
name|long
name|objNr
parameter_list|,
name|long
name|objGenNr
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|securityHandler
operator|.
name|decryptString
argument_list|(
name|str
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CryptographyException
name|ce
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error decrypting string: "
operator|+
name|ce
operator|.
name|getMessage
argument_list|()
comment|/* , ce // TODO: remove remark with Java 1.6 */
argument_list|)
throw|;
block|}
block|}
comment|// ------------------------------------------------------------------------
specifier|private
name|boolean
name|inGetLength
init|=
literal|false
decl_stmt|;
comment|/** Returns length value referred to or defined in given object. */
specifier|private
name|COSNumber
name|getLength
parameter_list|(
specifier|final
name|COSBase
name|lengthBaseObj
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|lengthBaseObj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|inGetLength
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Loop while reading length from "
operator|+
name|lengthBaseObj
argument_list|)
throw|;
block|}
name|COSNumber
name|retVal
init|=
literal|null
decl_stmt|;
try|try
block|{
name|inGetLength
operator|=
literal|true
expr_stmt|;
comment|// ---- maybe length was given directly
if|if
condition|(
name|lengthBaseObj
operator|instanceof
name|COSNumber
condition|)
block|{
name|retVal
operator|=
operator|(
name|COSNumber
operator|)
name|lengthBaseObj
expr_stmt|;
block|}
comment|// ---- length in referenced object
elseif|else
if|if
condition|(
name|lengthBaseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|lengthObj
init|=
operator|(
name|COSObject
operator|)
name|lengthBaseObj
decl_stmt|;
if|if
condition|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// not read so far
comment|// keep current stream position
specifier|final
name|long
name|curFileOffset
init|=
name|getPdfSourceOffset
argument_list|()
decl_stmt|;
name|releasePdfSourceInputStream
argument_list|()
expr_stmt|;
name|parseObjectDynamically
argument_list|(
name|lengthObj
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// reset current stream position
name|setPdfSource
argument_list|(
name|curFileOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Length object content was not read."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|instanceof
name|COSNumber
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong type of referenced length object "
operator|+
name|lengthObj
operator|+
literal|": "
operator|+
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
name|retVal
operator|=
operator|(
name|COSNumber
operator|)
name|lengthObj
operator|.
name|getObject
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong type of length object: "
operator|+
name|lengthBaseObj
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|inGetLength
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|retVal
return|;
block|}
comment|// ------------------------------------------------------------------------
specifier|private
specifier|final
name|int
name|streamCopyBufLen
init|=
literal|8192
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|streamCopyBuf
init|=
operator|new
name|byte
index|[
name|streamCopyBufLen
index|]
decl_stmt|;
comment|/**      * This will read a COSStream from the input stream using length attribute      * within dictionary. If length attribute is a indirect reference it is      * first resolved to get the stream length. This means we copy stream data      * without testing for 'endstream' or 'endobj' and thus it is no problem if      * these keywords occur within stream. We require 'endstream' to be found      * after stream data is read.      *       * @param dic dictionary that goes with this stream.      * @param file file to write the stream to when reading.      *       * @return parsed pdf stream.      *       * @throws IOException if an error occurred reading the stream, like      *             problems with reading length attribute, stream does not end      *             with 'endstream' after data read, stream too short etc.      */
annotation|@
name|Override
specifier|protected
name|COSStream
name|parseCOSStream
parameter_list|(
name|COSDictionary
name|dic
parameter_list|,
name|RandomAccess
name|file
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|COSStream
name|stream
init|=
operator|new
name|COSStream
argument_list|(
name|dic
argument_list|,
name|file
argument_list|)
decl_stmt|;
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|readString
argument_list|()
expr_stmt|;
comment|// read 'stream'; this was already tested in
comment|// parseObjectsDynamically()
comment|// ---- skip whitespaces before start of data
comment|// PDF Ref 1.7, chap. 3.2.7:
comment|// 'stream' should be followed by either a CRLF (0x0d 0x0a) or LF
comment|// but nothing else.
block|{
name|int
name|whitespace
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// see brother_scan_cover.pdf, it adds whitespaces
comment|// after the stream but before the start of the
comment|// data, so just read those first
while|while
condition|(
name|whitespace
operator|==
literal|0x20
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|whitespace
operator|==
literal|0x0D
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|whitespace
operator|!=
literal|0x0A
condition|)
block|{
comment|// the spec says this is invalid but it happens in the
comment|// real
comment|// world so we must support it
name|pdfSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|whitespace
operator|!=
literal|0x0A
condition|)
block|{
comment|// no whitespace after 'stream'; PDF ref. says 'should' so
comment|// that is ok
name|pdfSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*              * This needs to be dic.getItem because when we are parsing, the underlying object might still be null.              */
name|COSNumber
name|streamLengthObj
init|=
name|getLength
argument_list|(
name|dic
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|streamLengthObj
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing length for stream."
argument_list|)
throw|;
block|}
name|boolean
name|useReadUntilEnd
init|=
literal|false
decl_stmt|;
comment|// ---- get output stream to copy data to
if|if
condition|(
name|validateStreamLength
argument_list|(
name|streamLengthObj
operator|.
name|longValue
argument_list|()
argument_list|)
condition|)
block|{
name|out
operator|=
name|stream
operator|.
name|createFilteredStream
argument_list|(
name|streamLengthObj
argument_list|)
expr_stmt|;
name|long
name|remainBytes
init|=
name|streamLengthObj
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|remainBytes
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|readBytes
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
operator|(
name|remainBytes
operator|>
name|streamCopyBufLen
operator|)
condition|?
name|streamCopyBufLen
else|:
operator|(
name|int
operator|)
name|remainBytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBytes
operator|<=
literal|0
condition|)
block|{
name|useReadUntilEnd
operator|=
literal|true
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
name|bytesRead
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
operator|.
name|write
argument_list|(
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
name|readBytes
argument_list|)
expr_stmt|;
name|remainBytes
operator|-=
name|readBytes
expr_stmt|;
name|bytesRead
operator|+=
name|readBytes
expr_stmt|;
block|}
block|}
else|else
block|{
name|useReadUntilEnd
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|useReadUntilEnd
condition|)
block|{
name|out
operator|=
name|stream
operator|.
name|createFilteredStream
argument_list|(
name|streamLengthObj
argument_list|)
expr_stmt|;
name|readUntilEndStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|String
name|endStream
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|endStream
operator|.
name|equals
argument_list|(
literal|"endstream"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error reading stream using length value. Expected='endstream' actual='"
operator|+
name|endStream
operator|+
literal|"' "
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|stream
return|;
block|}
specifier|private
name|boolean
name|validateStreamLength
parameter_list|(
name|long
name|streamLength
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|streamLengthIsValid
init|=
literal|true
decl_stmt|;
name|long
name|originOffset
init|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|long
name|expectedEndOfStream
init|=
name|originOffset
operator|+
name|streamLength
decl_stmt|;
if|if
condition|(
name|expectedEndOfStream
operator|>
name|fileLen
condition|)
block|{
name|streamLengthIsValid
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"The end of the stream is out of range, using workaround to read the stream"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
name|expectedEndOfStream
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|checkBytesAtOffset
argument_list|(
literal|"endstream"
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
condition|)
block|{
name|streamLengthIsValid
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"The end of the stream doesn't point to the correct offset, using workaround to read the stream"
argument_list|)
expr_stmt|;
block|}
name|pdfSource
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
return|return
name|streamLengthIsValid
return|;
block|}
specifier|private
name|void
name|readUntilEndStream
parameter_list|(
specifier|final
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|bufSize
decl_stmt|;
name|int
name|charMatchCount
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|keyw
init|=
name|ENDSTREAM
decl_stmt|;
specifier|final
name|int
name|quickTestOffset
init|=
literal|5
decl_stmt|;
comment|// last character position of shortest
comment|// keyword ('endobj')
comment|// read next chunk into buffer; already matched chars are added to
comment|// beginning of buffer
while|while
condition|(
operator|(
name|bufSize
operator|=
name|pdfSource
operator|.
name|read
argument_list|(
name|streamCopyBuf
argument_list|,
name|charMatchCount
argument_list|,
name|streamCopyBufLen
operator|-
name|charMatchCount
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|// number of already matching chars
name|int
name|startingMatchCount
init|=
name|charMatchCount
decl_stmt|;
name|int
name|bIdx
init|=
name|charMatchCount
decl_stmt|;
name|int
name|quickTestIdx
decl_stmt|;
comment|// iterate over buffer, trying to find keyword match
for|for
control|(
name|int
name|maxQuicktestIdx
init|=
name|bufSize
operator|-
name|quickTestOffset
init|;
name|bIdx
operator|<
name|bufSize
condition|;
name|bIdx
operator|++
control|)
block|{
comment|// reduce compare operations by first test last character we
comment|// would have to
comment|// match if current one matches; if it is not a character from
comment|// keywords
comment|// we can move behind the test character;
comment|// this shortcut is inspired by BoyerMoore string search
comment|// algorithm
comment|// and can reduce parsing time by approx. 20%
if|if
condition|(
operator|(
name|charMatchCount
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|quickTestIdx
operator|=
name|bIdx
operator|+
name|quickTestOffset
operator|)
operator|<
name|maxQuicktestIdx
operator|)
condition|)
block|{
specifier|final
name|byte
name|ch
init|=
name|streamCopyBuf
index|[
name|quickTestIdx
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>
literal|'t'
operator|)
operator|||
operator|(
name|ch
operator|<
literal|'a'
operator|)
condition|)
block|{
comment|// last character we would have to match if current
comment|// character would match
comment|// is not a character from keywords -> jump behind and
comment|// start over
name|bIdx
operator|=
name|quickTestIdx
expr_stmt|;
continue|continue;
block|}
block|}
specifier|final
name|byte
name|ch
init|=
name|streamCopyBuf
index|[
name|bIdx
index|]
decl_stmt|;
comment|// could be negative - but
comment|// we only compare to ASCII
if|if
condition|(
name|ch
operator|==
name|keyw
index|[
name|charMatchCount
index|]
condition|)
block|{
if|if
condition|(
operator|++
name|charMatchCount
operator|==
name|keyw
operator|.
name|length
condition|)
block|{
comment|// match found
name|bIdx
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|charMatchCount
operator|==
literal|3
operator|)
operator|&&
operator|(
name|ch
operator|==
name|ENDOBJ
index|[
name|charMatchCount
index|]
operator|)
condition|)
block|{
comment|// maybe ENDSTREAM is missing but we could have ENDOBJ
name|keyw
operator|=
name|ENDOBJ
expr_stmt|;
name|charMatchCount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|// no match; incrementing match start by 1 would be dumb
comment|// since we already know matched chars
comment|// depending on current char read we may already have
comment|// beginning of a new match:
comment|// 'e': first char matched;
comment|// 'n': if we are at match position idx 7 we already
comment|// read 'e' thus 2 chars matched
comment|// for each other char we have to start matching first
comment|// keyword char beginning with next
comment|// read position
name|charMatchCount
operator|=
operator|(
name|ch
operator|==
name|E
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|ch
operator|==
name|N
operator|)
operator|&&
operator|(
name|charMatchCount
operator|==
literal|7
operator|)
operator|)
condition|?
literal|2
else|:
literal|0
expr_stmt|;
comment|// search again for 'endstream'
name|keyw
operator|=
name|ENDSTREAM
expr_stmt|;
block|}
block|}
block|}
comment|// for
name|int
name|contentBytes
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|bIdx
operator|-
name|charMatchCount
argument_list|)
decl_stmt|;
comment|// write buffer content until first matched char to output stream
if|if
condition|(
name|contentBytes
operator|>
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
name|contentBytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|charMatchCount
operator|==
name|keyw
operator|.
name|length
condition|)
block|{
comment|// keyword matched;
comment|// unread matched keyword (endstream/endobj) and following buffered content
name|pdfSource
operator|.
name|unread
argument_list|(
name|streamCopyBuf
argument_list|,
name|contentBytes
argument_list|,
name|bufSize
operator|-
name|contentBytes
operator|-
name|keyw
operator|.
name|length
operator|+
name|startingMatchCount
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// copy matched chars at start of buffer
name|System
operator|.
name|arraycopy
argument_list|(
name|keyw
argument_list|,
literal|0
argument_list|,
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
name|charMatchCount
argument_list|)
expr_stmt|;
block|}
block|}
comment|// while
block|}
comment|/**      *       * @param startXRefOffset      * @return      * @throws IOException      */
specifier|private
name|long
name|calculateFixingOffset
parameter_list|(
name|long
name|startXRefOffset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO check offset for XRef stream objects
name|setPdfSource
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdfSource
operator|.
name|peek
argument_list|()
operator|==
name|X
operator|&&
name|calculateFixingOffset
argument_list|(
name|startXRefOffset
argument_list|,
name|XREF
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|long
name|fixingOffset
init|=
name|calculateFixingOffset
argument_list|(
name|startXRefOffset
argument_list|,
name|XREF
argument_list|)
decl_stmt|;
return|return
name|fixingOffset
return|;
block|}
comment|/**      * Try to dereference the given object at the given offset and calculate a new      * offset if necessary.      *       * @param objectOffset the offset where to look at      * @param objectID the object ID      * @param genID the generation number      * @return the difference to the origin offset      * @throws IOException if something went wrong      */
specifier|private
name|long
name|calculateFixingOffset
parameter_list|(
name|long
name|objectOffset
parameter_list|,
name|long
name|objectID
parameter_list|,
name|long
name|genID
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|objString
init|=
name|Long
operator|.
name|toString
argument_list|(
name|objectID
argument_list|)
operator|+
literal|" "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|genID
argument_list|)
operator|+
literal|" obj"
decl_stmt|;
return|return
name|calculateFixingOffset
argument_list|(
name|objectOffset
argument_list|,
name|objString
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Check if the given bytes can be found at the current offset.      *       * @param string the bytes to look for      * @return true if the bytes are in place, false if not      * @throws IOException if something went wrong      */
specifier|private
name|boolean
name|checkBytesAtOffset
parameter_list|(
name|byte
index|[]
name|string
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|bytesMatching
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|pdfSource
operator|.
name|peek
argument_list|()
operator|==
name|string
index|[
literal|0
index|]
condition|)
block|{
name|int
name|length
init|=
name|string
operator|.
name|length
decl_stmt|;
name|byte
index|[]
name|bytesRead
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|int
name|numberOfBytes
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|bytesRead
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|numberOfBytes
operator|<
name|length
condition|)
block|{
name|int
name|readMore
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|bytesRead
argument_list|,
name|numberOfBytes
argument_list|,
name|length
operator|-
name|numberOfBytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|readMore
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|numberOfBytes
operator|+=
name|readMore
expr_stmt|;
block|}
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|string
argument_list|,
name|bytesRead
argument_list|)
condition|)
block|{
name|bytesMatching
operator|=
literal|true
expr_stmt|;
block|}
name|pdfSource
operator|.
name|unread
argument_list|(
name|bytesRead
argument_list|,
literal|0
argument_list|,
name|numberOfBytes
argument_list|)
expr_stmt|;
block|}
return|return
name|bytesMatching
return|;
block|}
comment|/**      * Check if the given bytes can be found at the given offset.      * The method seeks 200 bytes backward/forward if the given string      * can't be found at the given offset and returns the difference       * of the new offset to the origin one.      *       * @param objectOffset the given offset where to look at      * @param string the bytes to look for      * @return the difference to the origin one      * @throws IOException if something went wrong      */
specifier|private
name|long
name|calculateFixingOffset
parameter_list|(
name|long
name|objectOffset
parameter_list|,
name|byte
index|[]
name|string
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|objectOffset
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid object offset "
operator|+
name|objectOffset
operator|+
literal|" for object "
operator|+
operator|new
name|String
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|long
name|originOffset
init|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|pdfSource
operator|.
name|seek
argument_list|(
name|objectOffset
argument_list|)
expr_stmt|;
comment|// most likely the object can be found at the given offset
if|if
condition|(
name|checkBytesAtOffset
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// the offset seems to be wrong -> seek backward to find the object we are looking for
name|long
name|currentOffset
init|=
name|objectOffset
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|currentOffset
operator|=
name|objectOffset
operator|-
operator|(
name|i
operator|*
literal|10
operator|)
expr_stmt|;
if|if
condition|(
name|currentOffset
operator|>
literal|0
condition|)
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|checkBytesAtOffset
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fixed reference for object "
operator|+
operator|new
name|String
argument_list|(
name|string
argument_list|)
operator|+
literal|" "
operator|+
name|objectOffset
operator|+
literal|" -> "
operator|+
operator|(
name|objectOffset
operator|-
name|currentOffset
operator|)
argument_list|)
expr_stmt|;
return|return
name|objectOffset
operator|-
name|currentOffset
return|;
block|}
else|else
block|{
name|currentOffset
operator|++
expr_stmt|;
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// no luck by seeking backward -> seek forward to find the object we are looking for
name|pdfSource
operator|.
name|seek
argument_list|(
name|objectOffset
argument_list|)
expr_stmt|;
name|currentOffset
operator|=
name|objectOffset
expr_stmt|;
do|do
block|{
if|if
condition|(
name|checkBytesAtOffset
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentOffset
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fixed reference for object "
operator|+
operator|new
name|String
argument_list|(
name|string
argument_list|)
operator|+
literal|" "
operator|+
name|objectOffset
operator|+
literal|" -> "
operator|+
operator|(
name|objectOffset
operator|-
name|currentOffset
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|objectOffset
operator|-
name|currentOffset
return|;
block|}
else|else
block|{
comment|// next byte
name|currentOffset
operator|++
expr_stmt|;
if|if
condition|(
name|pdfSource
operator|.
name|read
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Premature end of file while dereferencing object "
operator|+
operator|new
name|String
argument_list|(
name|string
argument_list|)
operator|+
literal|" at offset "
operator|+
name|objectOffset
argument_list|)
throw|;
block|}
block|}
block|}
do|while
condition|(
name|currentOffset
operator|<
name|objectOffset
operator|+
literal|200
condition|)
do|;
name|pdfSource
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't find the object "
operator|+
operator|new
name|String
argument_list|(
name|string
argument_list|)
operator|+
literal|" at offset "
operator|+
name|objectOffset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/**      * Check the XRef table by dereferencing all objects and fixing       * the offset if necessary.      *       * @throws IOException if something went wrong.      */
specifier|private
name|void
name|checkXrefOffsets
parameter_list|()
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|xrefOffset
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|xrefOffset
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|COSObjectKey
name|objectKey
range|:
name|xrefOffset
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Long
name|objectOffset
init|=
name|xrefOffset
operator|.
name|get
argument_list|(
name|objectKey
argument_list|)
decl_stmt|;
comment|// a negative offset number represents a object number itself
comment|// see type 2 entry in xref stream
if|if
condition|(
name|objectOffset
operator|!=
literal|null
operator|&&
name|objectOffset
operator|>
literal|0
condition|)
block|{
name|long
name|objectNr
init|=
name|objectKey
operator|.
name|getNumber
argument_list|()
decl_stmt|;
name|long
name|objectGen
init|=
name|objectKey
operator|.
name|getGeneration
argument_list|()
decl_stmt|;
name|long
name|fixingOffset
init|=
name|calculateFixingOffset
argument_list|(
name|objectOffset
argument_list|,
name|objectNr
argument_list|,
name|objectGen
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixingOffset
operator|!=
literal|0
condition|)
block|{
name|long
name|newOffset
init|=
name|objectOffset
operator|-
name|fixingOffset
decl_stmt|;
name|xrefOffset
operator|.
name|put
argument_list|(
name|objectKey
argument_list|,
name|newOffset
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fixed reference for object "
operator|+
name|objectNr
operator|+
literal|" "
operator|+
name|objectGen
operator|+
literal|" "
operator|+
name|objectOffset
operator|+
literal|" -> "
operator|+
name|newOffset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

