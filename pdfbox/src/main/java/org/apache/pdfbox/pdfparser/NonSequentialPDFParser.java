begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|KeyStore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|PushBackInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessBufferedFileInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
operator|.
name|XrefTrailerResolver
operator|.
name|XRefType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDPage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|AccessPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|DecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|PDEncryption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|PublicKeyDecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|SecurityHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|StandardDecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|fdf
operator|.
name|FDFDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|persistence
operator|.
name|util
operator|.
name|COSObjectKey
import|;
end_import

begin_comment
comment|/**  * PDF-Parser which first reads startxref and xref tables in order to know valid objects and parse only these objects.  * Thus it is closer to a conforming parser than the sequential reading of {@link PDFParser}.  *   * First {@link #parse()} must be called before page objects  * can be retrieved, e.g. {@link #getPDDocument()}.  *   * This class is a much enhanced version of<code>QuickParser</code> presented in<a  * href="https://issues.apache.org/jira/browse/PDFBOX-1104">PDFBOX-1104</a> by Jeremy Villalobos.  */
end_comment

begin_class
specifier|public
class|class
name|NonSequentialPDFParser
extends|extends
name|BaseParser
block|{
specifier|private
specifier|static
specifier|final
name|String
name|PDF_HEADER
init|=
literal|"%PDF-"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|FDF_HEADER
init|=
literal|"%FDF-"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|PDF_DEFAULT_VERSION
init|=
literal|"1.4"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|FDF_DEFAULT_VERSION
init|=
literal|"1.0"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|XREF_TABLE
init|=
operator|new
name|char
index|[]
block|{
literal|'x'
block|,
literal|'r'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|XREF_STREAM
init|=
operator|new
name|char
index|[]
block|{
literal|'/'
block|,
literal|'X'
block|,
literal|'R'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|STARTXREF
init|=
operator|new
name|char
index|[]
block|{
literal|'s'
block|,
literal|'t'
block|,
literal|'a'
block|,
literal|'r'
block|,
literal|'t'
block|,
literal|'x'
block|,
literal|'r'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|MINIMUM_SEARCH_OFFSET
init|=
literal|6
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|X
init|=
literal|'x'
decl_stmt|;
comment|/**      * Only parse the PDF file minimally allowing access to basic information.      */
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_PARSEMINIMAL
init|=
literal|"org.apache.pdfbox.pdfparser.nonSequentialPDFParser.parseMinimal"
decl_stmt|;
comment|/**      * The range within the %%EOF marker will be searched.      * Useful if there are additional characters after %%EOF within the PDF.       */
specifier|public
specifier|static
specifier|final
name|String
name|SYSPROP_EOFLOOKUPRANGE
init|=
literal|"org.apache.pdfbox.pdfparser.nonSequentialPDFParser.eofLookupRange"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|InputStream
name|EMPTY_INPUT_STREAM
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/**      * How many trailing bytes to read for EOF marker.      */
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_TRAIL_BYTECOUNT
init|=
literal|2048
decl_stmt|;
comment|/**      * EOF-marker.      */
specifier|protected
specifier|static
specifier|final
name|char
index|[]
name|EOF_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'%'
block|,
literal|'%'
block|,
literal|'E'
block|,
literal|'O'
block|,
literal|'F'
block|}
decl_stmt|;
comment|/**      * StartXRef-marker.      */
specifier|protected
specifier|static
specifier|final
name|char
index|[]
name|STARTXREF_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'s'
block|,
literal|'t'
block|,
literal|'a'
block|,
literal|'r'
block|,
literal|'t'
block|,
literal|'x'
block|,
literal|'r'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
comment|/**      * obj-marker.      */
specifier|protected
specifier|static
specifier|final
name|char
index|[]
name|OBJ_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'o'
block|,
literal|'b'
block|,
literal|'j'
block|}
decl_stmt|;
comment|/**      * trailer-marker.      */
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|TRAILER_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'t'
block|,
literal|'r'
block|,
literal|'a'
block|,
literal|'i'
block|,
literal|'l'
block|,
literal|'e'
block|,
literal|'r'
block|}
decl_stmt|;
specifier|private
name|long
name|trailerOffset
decl_stmt|;
specifier|private
specifier|final
name|File
name|pdfFile
decl_stmt|;
specifier|private
name|long
name|fileLen
decl_stmt|;
specifier|private
specifier|final
name|RandomAccessBufferedFileInputStream
name|raStream
decl_stmt|;
comment|/**      * is parser using auto healing capacity ?      */
specifier|private
name|boolean
name|isLenient
init|=
literal|true
decl_stmt|;
comment|/**      * Contains all found objects of a brute force search.      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|bfSearchObjectOffsets
init|=
literal|null
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|bfSearchCOSObjectKeyOffsets
init|=
literal|null
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Long
argument_list|>
name|bfSearchXRefOffsets
init|=
literal|null
decl_stmt|;
comment|/**      * The security handler.      */
specifier|protected
name|SecurityHandler
name|securityHandler
init|=
literal|null
decl_stmt|;
specifier|private
name|AccessPermission
name|accessPermission
decl_stmt|;
specifier|private
name|InputStream
name|keyStoreInputStream
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|keyAlias
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|password
init|=
literal|""
decl_stmt|;
specifier|private
name|int
name|readTrailBytes
init|=
name|DEFAULT_TRAIL_BYTECOUNT
decl_stmt|;
comment|// how many trailing
comment|// bytes to read for
comment|// EOF marker
comment|/**      * If<code>true</code> object references in catalog are not followed; pro: page objects will be only parsed when      * needed; cons: some information of catalog might not be available (e.g. outline). Catalog parsing without pages is      * not an option since a number of entries will also refer to page objects (like OpenAction).      */
specifier|private
specifier|final
name|boolean
name|parseMinimalCatalog
init|=
literal|"true"
operator|.
name|equals
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|SYSPROP_PARSEMINIMAL
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
name|boolean
name|initialParseDone
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|allPagesParsed
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|NonSequentialPDFParser
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|boolean
name|isFDFDocment
init|=
literal|false
decl_stmt|;
comment|/**       * Collects all Xref/trailer objects and resolves them into single      * object using startxref reference.       */
specifier|protected
name|XrefTrailerResolver
name|xrefTrailerResolver
init|=
operator|new
name|XrefTrailerResolver
argument_list|()
decl_stmt|;
comment|/**      *<code>true</code> if the NonSequentialPDFParser is initialized by a InputStream, in this case a temporary file is      * created. At the end of the {@linkplain #parse()} method,the temporary file will be deleted.      */
specifier|private
name|boolean
name|isTmpPDFFile
init|=
literal|false
decl_stmt|;
comment|/**      * The prefix for the temp file being used.       */
specifier|public
specifier|static
specifier|final
name|String
name|TMP_FILE_PREFIX
init|=
literal|"tmpPDF"
decl_stmt|;
comment|/**      * Constructs parser for given file using memory buffer.      *       * @param filename the filename of the pdf to be parsed      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs parser for given file using memory buffer.      *       * @param filename the filename of the pdf to be parsed.      * @param useScratchFiles use a buffer for temporary storage.      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|String
name|filename
parameter_list|,
name|boolean
name|useScratchFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|null
argument_list|,
name|useScratchFiles
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs parser for given file using given buffer for temporary      * storage.      *       * @param file the pdf to be parsed      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|file
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs parser for given file using given buffer for temporary      * storage.      *       * @param file the pdf to be parsed      * @param useScratchFiles use a buffer for temporary storage.      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|File
name|file
parameter_list|,
name|boolean
name|useScratchFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|file
argument_list|,
literal|""
argument_list|,
name|useScratchFiles
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs parser for given file using given buffer for temporary storage.      *       * @param file the pdf to be parsed      * @param decryptionPassword password to be used for decryption      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|decryptionPassword
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|file
argument_list|,
name|decryptionPassword
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs parser for given file using given buffer for temporary storage.      *       * @param file the pdf to be parsed.      * @param decryptionPassword password to be used for decryption.      * @param useScratchFiles use a buffer for temporary storage.      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|decryptionPassword
parameter_list|,
name|boolean
name|useScratchFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|file
argument_list|,
name|decryptionPassword
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|useScratchFiles
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs parser for given file using given buffer for temporary storage.      *       * @param file the pdf to be parsed.      * @param decryptionPassword password to be used for decryption.      * @param keyStore key store to be used for decryption when using public key security       * @param alias alias to be used for decryption when using public key security      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|decryptionPassword
parameter_list|,
name|InputStream
name|keyStore
parameter_list|,
name|String
name|alias
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|file
argument_list|,
name|decryptionPassword
argument_list|,
name|keyStore
argument_list|,
name|alias
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs parser for given file using given buffer for temporary storage.      *       * @param file the pdf to be parsed.      * @param decryptionPassword password to be used for decryption.      * @param keyStore key store to be used for decryption when using public key security       * @param alias alias to be used for decryption when using public key security      * @param useScratchFiles use a buffer for temporary storage.      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|decryptionPassword
parameter_list|,
name|InputStream
name|keyStore
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|useScratchFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|EMPTY_INPUT_STREAM
argument_list|)
expr_stmt|;
name|pdfFile
operator|=
name|file
expr_stmt|;
name|raStream
operator|=
operator|new
name|RandomAccessBufferedFileInputStream
argument_list|(
name|pdfFile
argument_list|)
expr_stmt|;
name|password
operator|=
name|decryptionPassword
expr_stmt|;
name|keyStoreInputStream
operator|=
name|keyStore
expr_stmt|;
name|keyAlias
operator|=
name|alias
expr_stmt|;
name|init
argument_list|(
name|useScratchFiles
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|init
parameter_list|(
name|boolean
name|useScratchFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|eofLookupRangeStr
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|SYSPROP_EOFLOOKUPRANGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|eofLookupRangeStr
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|setEOFLookupRange
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|eofLookupRangeStr
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"System property "
operator|+
name|SYSPROP_EOFLOOKUPRANGE
operator|+
literal|" does not contain an integer value, but: '"
operator|+
name|eofLookupRangeStr
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
name|document
operator|=
operator|new
name|COSDocument
argument_list|(
name|useScratchFiles
argument_list|)
expr_stmt|;
name|pdfSource
operator|=
operator|new
name|PushBackInputStream
argument_list|(
name|raStream
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param input input stream representing the pdf.      * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|input
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param input input stream representing the pdf.      * @param useScratchFiles use a buffer for temporary storage.      *       * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|boolean
name|useScratchFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|input
argument_list|,
literal|""
argument_list|,
name|useScratchFiles
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param input input stream representing the pdf.      * @param decryptionPassword password to be used for decryption.      * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|String
name|decryptionPassword
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|input
argument_list|,
name|decryptionPassword
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param input input stream representing the pdf.      * @param decryptionPassword password to be used for decryption.      * @param useScratchFiles use a buffer for temporary storage.      *      * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|String
name|decryptionPassword
parameter_list|,
name|boolean
name|useScratchFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|input
argument_list|,
name|decryptionPassword
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|useScratchFiles
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param input input stream representing the pdf.      * @param decryptionPassword password to be used for decryption.      * @param keyStore key store to be used for decryption when using public key security       * @param alias alias to be used for decryption when using public key security      *      * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|String
name|decryptionPassword
parameter_list|,
name|InputStream
name|keyStore
parameter_list|,
name|String
name|alias
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|input
argument_list|,
name|decryptionPassword
argument_list|,
name|keyStore
argument_list|,
name|alias
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param input input stream representing the pdf.      * @param decryptionPassword password to be used for decryption.      * @param keyStore key store to be used for decryption when using public key security       * @param alias alias to be used for decryption when using public key security      * @param useScratchFiles use a buffer for temporary storage.      *      * @throws IOException If something went wrong.      */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|String
name|decryptionPassword
parameter_list|,
name|InputStream
name|keyStore
parameter_list|,
name|String
name|alias
parameter_list|,
name|boolean
name|useScratchFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|EMPTY_INPUT_STREAM
argument_list|)
expr_stmt|;
name|pdfFile
operator|=
name|createTmpFile
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|raStream
operator|=
operator|new
name|RandomAccessBufferedFileInputStream
argument_list|(
name|pdfFile
argument_list|)
expr_stmt|;
name|password
operator|=
name|decryptionPassword
expr_stmt|;
name|keyStoreInputStream
operator|=
name|keyStore
expr_stmt|;
name|keyAlias
operator|=
name|alias
expr_stmt|;
name|init
argument_list|(
name|useScratchFiles
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a temporary file with the input stream. If the creation succeed, the {@linkplain #isTmpPDFFile} is set to      * true. This Temporary file will be deleted at end of the parse method      *       * @param input      * @return the temporary file      * @throws IOException If something went wrong.      */
specifier|private
name|File
name|createTmpFile
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|FileOutputStream
name|fos
init|=
literal|null
decl_stmt|;
try|try
block|{
name|File
name|tmpFile
init|=
name|File
operator|.
name|createTempFile
argument_list|(
name|TMP_FILE_PREFIX
argument_list|,
literal|".pdf"
argument_list|)
decl_stmt|;
name|fos
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|tmpFile
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|input
argument_list|,
name|fos
argument_list|)
expr_stmt|;
name|isTmpPDFFile
operator|=
literal|true
expr_stmt|;
return|return
name|tmpFile
return|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|fos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This will get the PD document that was parsed.  When you are done with      * this document you must call close() on it to release resources.      *      * @return The document at the PD layer.      *      * @throws IOException If there is an error getting the document.      */
specifier|public
name|PDDocument
name|getPDDocument
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|PDDocument
argument_list|(
name|getDocument
argument_list|()
argument_list|,
name|this
argument_list|,
name|accessPermission
argument_list|)
return|;
block|}
comment|/**      * Sets how many trailing bytes of PDF file are searched for EOF marker and 'startxref' marker. If not set we use      * default value {@link #DEFAULT_TRAIL_BYTECOUNT}.      *       *<p>We check that new value is at least 16. However for practical use cases this value should not be lower than      * 1000; even 2000 was found to not be enough in some cases where some trailing garbage like HTML snippets followed      * the EOF marker.</p>      *       *<p>      * In case system property {@link #SYSPROP_EOFLOOKUPRANGE} is defined this value will be set on initialization but      * can be overwritten later.      *</p>      *       * @param byteCount number of trailing bytes      */
specifier|public
name|void
name|setEOFLookupRange
parameter_list|(
name|int
name|byteCount
parameter_list|)
block|{
if|if
condition|(
name|byteCount
operator|>
literal|15
condition|)
block|{
name|readTrailBytes
operator|=
name|byteCount
expr_stmt|;
block|}
block|}
comment|/**      * The initial parse will first parse only the trailer, the xrefstart and all xref tables to have a pointer (offset)      * to all the pdf's objects. It can handle linearized pdfs, which will have an xref at the end pointing to an xref      * at the beginning of the file. Last the root object is parsed.      *       * @throws IOException If something went wrong.      */
specifier|protected
name|void
name|initialParse
parameter_list|()
throws|throws
name|IOException
block|{
name|COSDictionary
name|trailer
init|=
literal|null
decl_stmt|;
comment|// parse startxref
name|long
name|startXRefOffset
init|=
name|getStartxrefOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|startXRefOffset
operator|>
literal|0
condition|)
block|{
name|trailer
operator|=
name|parseXref
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isFDFDocment
operator|||
name|isLenient
condition|)
block|{
comment|// signal start of new XRef
name|xrefTrailerResolver
operator|.
name|nextXrefObj
argument_list|(
name|startXRefOffset
argument_list|,
name|XRefType
operator|.
name|TABLE
argument_list|)
expr_stmt|;
name|bfSearchForObjects
argument_list|()
expr_stmt|;
for|for
control|(
name|COSObjectKey
name|objectKey
range|:
name|bfSearchCOSObjectKeyOffsets
operator|.
name|keySet
argument_list|()
control|)
block|{
name|xrefTrailerResolver
operator|.
name|setXRef
argument_list|(
name|objectKey
argument_list|,
name|bfSearchCOSObjectKeyOffsets
operator|.
name|get
argument_list|(
name|objectKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// parse the last trailer.
name|pdfSource
operator|.
name|seek
argument_list|(
name|trailerOffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parseTrailer
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected trailer object at position: "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
name|xrefTrailerResolver
operator|.
name|setStartxref
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
name|trailer
operator|=
name|xrefTrailerResolver
operator|.
name|getCurrentTrailer
argument_list|()
expr_stmt|;
name|document
operator|.
name|setTrailer
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
name|document
operator|.
name|setIsXRefStream
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// ---- prepare decryption if necessary
name|prepareDecryption
argument_list|()
expr_stmt|;
comment|// PDFBOX-1557 - ensure that all COSObject are loaded in the trailer
comment|// PDFBOX-1606 - after securityHandler has been instantiated
for|for
control|(
name|COSBase
name|trailerEntry
range|:
name|trailer
operator|.
name|getValues
argument_list|()
control|)
block|{
if|if
condition|(
name|trailerEntry
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|tmpObj
init|=
operator|(
name|COSObject
operator|)
name|trailerEntry
decl_stmt|;
name|parseObjectDynamically
argument_list|(
name|tmpObj
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// parse catalog or root object
name|COSObject
name|root
init|=
operator|(
name|COSObject
operator|)
name|xrefTrailerResolver
operator|.
name|getTrailer
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing root object specification in trailer."
argument_list|)
throw|;
block|}
name|COSBase
name|rootObject
init|=
name|parseObjectDynamically
argument_list|(
name|root
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// ---- resolve all objects
if|if
condition|(
name|isFDFDocment
condition|)
block|{
comment|// A FDF doesn't have a catalog, all FDF fields are within the root object
if|if
condition|(
name|rootObject
operator|instanceof
name|COSDictionary
condition|)
block|{
name|parseDictObjects
argument_list|(
operator|(
name|COSDictionary
operator|)
name|rootObject
argument_list|,
operator|(
name|COSName
index|[]
operator|)
literal|null
argument_list|)
expr_stmt|;
name|allPagesParsed
operator|=
literal|true
expr_stmt|;
name|document
operator|.
name|setDecrypted
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|parseMinimalCatalog
condition|)
block|{
name|COSObject
name|catalogObj
init|=
name|document
operator|.
name|getCatalog
argument_list|()
decl_stmt|;
if|if
condition|(
name|catalogObj
operator|!=
literal|null
operator|&&
name|catalogObj
operator|.
name|getObject
argument_list|()
operator|instanceof
name|COSDictionary
condition|)
block|{
name|parseDictObjects
argument_list|(
operator|(
name|COSDictionary
operator|)
name|catalogObj
operator|.
name|getObject
argument_list|()
argument_list|,
operator|(
name|COSName
index|[]
operator|)
literal|null
argument_list|)
expr_stmt|;
name|allPagesParsed
operator|=
literal|true
expr_stmt|;
name|document
operator|.
name|setDecrypted
argument_list|()
expr_stmt|;
block|}
block|}
comment|// PDFBOX-1922: read the version again now that all objects have been resolved
name|readVersionInTrailer
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
name|getDocument
argument_list|()
operator|.
name|addXRefTable
argument_list|(
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
argument_list|)
expr_stmt|;
name|initialParseDone
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Resolves all not already parsed objects of a dictionary recursively.      *       * @param dictionaryObject dictionary to be parsed      * @throws IOException if something went wrong      *       */
specifier|private
name|void
name|parseDictionaryRecursive
parameter_list|(
name|COSObject
name|dictionaryObject
parameter_list|)
throws|throws
name|IOException
block|{
name|parseObjectDynamically
argument_list|(
name|dictionaryObject
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|COSDictionary
name|dictionary
init|=
operator|(
name|COSDictionary
operator|)
name|dictionaryObject
operator|.
name|getObject
argument_list|()
decl_stmt|;
for|for
control|(
name|COSBase
name|value
range|:
name|dictionary
operator|.
name|getValues
argument_list|()
control|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|object
init|=
operator|(
name|COSObject
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|object
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
name|parseDictionaryRecursive
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Prepare for decryption.      *       * @throws IOException if something went wrong      */
specifier|private
name|void
name|prepareDecryption
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBase
name|trailerEncryptItem
init|=
name|document
operator|.
name|getTrailer
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailerEncryptItem
operator|!=
literal|null
operator|&&
operator|!
operator|(
name|trailerEncryptItem
operator|instanceof
name|COSNull
operator|)
condition|)
block|{
if|if
condition|(
name|trailerEncryptItem
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|trailerEncryptObj
init|=
operator|(
name|COSObject
operator|)
name|trailerEncryptItem
decl_stmt|;
name|parseDictionaryRecursive
argument_list|(
name|trailerEncryptObj
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|PDEncryption
name|encryption
init|=
operator|new
name|PDEncryption
argument_list|(
name|document
operator|.
name|getEncryptionDictionary
argument_list|()
argument_list|)
decl_stmt|;
name|DecryptionMaterial
name|decryptionMaterial
decl_stmt|;
if|if
condition|(
name|keyStoreInputStream
operator|!=
literal|null
condition|)
block|{
name|KeyStore
name|ks
init|=
name|KeyStore
operator|.
name|getInstance
argument_list|(
literal|"PKCS12"
argument_list|)
decl_stmt|;
name|ks
operator|.
name|load
argument_list|(
name|keyStoreInputStream
argument_list|,
name|password
operator|.
name|toCharArray
argument_list|()
argument_list|)
expr_stmt|;
name|decryptionMaterial
operator|=
operator|new
name|PublicKeyDecryptionMaterial
argument_list|(
name|ks
argument_list|,
name|keyAlias
argument_list|,
name|password
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decryptionMaterial
operator|=
operator|new
name|StandardDecryptionMaterial
argument_list|(
name|password
argument_list|)
expr_stmt|;
block|}
name|securityHandler
operator|=
name|encryption
operator|.
name|getSecurityHandler
argument_list|()
expr_stmt|;
name|securityHandler
operator|.
name|prepareForDecryption
argument_list|(
name|encryption
argument_list|,
name|document
operator|.
name|getDocumentID
argument_list|()
argument_list|,
name|decryptionMaterial
argument_list|)
expr_stmt|;
name|accessPermission
operator|=
name|securityHandler
operator|.
name|getCurrentAccessPermission
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error ("
operator|+
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|") while creating security handler for decryption"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Parses cross reference tables.      *       * @param startXRefOffset start offset of the first table      * @return the trailer dictionary      * @throws IOException if something went wrong      */
specifier|private
name|COSDictionary
name|parseXref
parameter_list|(
name|long
name|startXRefOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
name|long
name|startXrefOffset
init|=
name|parseStartXref
argument_list|()
decl_stmt|;
comment|// check the startxref offset
name|long
name|fixedOffset
init|=
name|checkXRefOffset
argument_list|(
name|startXrefOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
condition|)
block|{
name|startXrefOffset
operator|=
name|fixedOffset
expr_stmt|;
block|}
name|document
operator|.
name|setStartXref
argument_list|(
name|startXrefOffset
argument_list|)
expr_stmt|;
name|long
name|prev
init|=
name|startXrefOffset
decl_stmt|;
comment|// ---- parse whole chain of xref tables/object streams using PREV reference
while|while
condition|(
name|prev
operator|>
operator|-
literal|1
condition|)
block|{
comment|// seek to xref table
name|pdfSource
operator|.
name|seek
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|// skip white spaces
name|skipSpaces
argument_list|()
expr_stmt|;
comment|// -- parse xref
if|if
condition|(
name|pdfSource
operator|.
name|peek
argument_list|()
operator|==
name|X
condition|)
block|{
comment|// xref table and trailer
comment|// use existing parser to parse xref table
name|parseXrefTable
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|// parse the last trailer.
name|trailerOffset
operator|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
expr_stmt|;
comment|// PDFBOX-1739 skip extra xref entries in RegisSTAR documents
while|while
condition|(
name|isLenient
operator|&&
name|pdfSource
operator|.
name|peek
argument_list|()
operator|!=
literal|'t'
condition|)
block|{
if|if
condition|(
name|pdfSource
operator|.
name|getOffset
argument_list|()
operator|==
name|trailerOffset
condition|)
block|{
comment|// warn only the first time
name|LOG
operator|.
name|warn
argument_list|(
literal|"Expected trailer object at position "
operator|+
name|trailerOffset
operator|+
literal|", keep trying"
argument_list|)
expr_stmt|;
block|}
name|readLine
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parseTrailer
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected trailer object at position: "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getCurrentTrailer
argument_list|()
decl_stmt|;
comment|// check for a XRef stream, it may contain some object ids of compressed objects
if|if
condition|(
name|trailer
operator|.
name|containsKey
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|)
condition|)
block|{
name|int
name|streamOffset
init|=
name|trailer
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|)
decl_stmt|;
comment|// check the xref stream reference
name|fixedOffset
operator|=
name|checkXRefOffset
argument_list|(
name|streamOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
operator|&&
name|fixedOffset
operator|!=
name|streamOffset
condition|)
block|{
name|streamOffset
operator|=
operator|(
name|int
operator|)
name|fixedOffset
expr_stmt|;
name|trailer
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|,
name|streamOffset
argument_list|)
expr_stmt|;
block|}
name|pdfSource
operator|.
name|seek
argument_list|(
name|streamOffset
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|parseXrefObjStream
argument_list|(
name|prev
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|trailer
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|>
operator|-
literal|1
condition|)
block|{
comment|// check the xref table reference
name|fixedOffset
operator|=
name|checkXRefOffset
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
operator|&&
name|fixedOffset
operator|!=
name|prev
condition|)
block|{
name|prev
operator|=
name|fixedOffset
expr_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// parse xref stream
name|prev
operator|=
name|parseXrefObjStream
argument_list|(
name|prev
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|>
operator|-
literal|1
condition|)
block|{
comment|// check the xref table reference
name|fixedOffset
operator|=
name|checkXRefOffset
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixedOffset
operator|>
operator|-
literal|1
operator|&&
name|fixedOffset
operator|!=
name|prev
condition|)
block|{
name|prev
operator|=
name|fixedOffset
expr_stmt|;
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getCurrentTrailer
argument_list|()
decl_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// ---- build valid xrefs out of the xref chain
name|xrefTrailerResolver
operator|.
name|setStartxref
argument_list|(
name|startXrefOffset
argument_list|)
expr_stmt|;
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|document
operator|.
name|setTrailer
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
name|document
operator|.
name|setIsXRefStream
argument_list|(
name|XRefType
operator|.
name|STREAM
operator|==
name|xrefTrailerResolver
operator|.
name|getXrefType
argument_list|()
argument_list|)
expr_stmt|;
comment|// check the offsets of all referenced objects
name|checkXrefOffsets
argument_list|()
expr_stmt|;
return|return
name|trailer
return|;
block|}
comment|/**      * Parses an xref object stream starting with indirect object id.      *       * @return value of PREV item in dictionary or<code>-1</code> if no such item exists      */
specifier|private
name|long
name|parseXrefObjStream
parameter_list|(
name|long
name|objByteOffset
parameter_list|,
name|boolean
name|isStandalone
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- parse indirect object head
name|readObjectNumber
argument_list|()
expr_stmt|;
name|readGenerationNumber
argument_list|()
expr_stmt|;
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|COSDictionary
name|dict
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
name|COSStream
name|xrefStream
init|=
name|parseCOSStream
argument_list|(
name|dict
argument_list|)
decl_stmt|;
name|parseXrefStream
argument_list|(
name|xrefStream
argument_list|,
operator|(
name|int
operator|)
name|objByteOffset
argument_list|,
name|isStandalone
argument_list|)
expr_stmt|;
return|return
name|dict
operator|.
name|getLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
return|;
block|}
comment|/**      * Looks for and parses startxref. We first look for last '%%EOF' marker (within last      * {@link #DEFAULT_TRAIL_BYTECOUNT} bytes (or range set via {@link #setEOFLookupRange(int)}) and go back to find      *<code>startxref</code>.      *       * @return the offset of StartXref      * @throws IOException If something went wrong.      */
specifier|protected
specifier|final
name|long
name|getStartxrefOffset
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|buf
decl_stmt|;
name|long
name|skipBytes
decl_stmt|;
comment|// read trailing bytes into buffer
name|fileLen
operator|=
name|pdfFile
operator|.
name|length
argument_list|()
expr_stmt|;
name|FileInputStream
name|fileInputstream
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fileInputstream
operator|=
operator|new
name|FileInputStream
argument_list|(
name|pdfFile
argument_list|)
expr_stmt|;
specifier|final
name|int
name|trailByteCount
init|=
operator|(
name|fileLen
operator|<
name|readTrailBytes
operator|)
condition|?
operator|(
name|int
operator|)
name|fileLen
else|:
name|readTrailBytes
decl_stmt|;
name|buf
operator|=
operator|new
name|byte
index|[
name|trailByteCount
index|]
expr_stmt|;
name|fileInputstream
operator|.
name|skip
argument_list|(
name|skipBytes
operator|=
name|fileLen
operator|-
name|trailByteCount
argument_list|)
expr_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|readBytes
decl_stmt|;
while|while
condition|(
name|off
operator|<
name|trailByteCount
condition|)
block|{
name|readBytes
operator|=
name|fileInputstream
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|trailByteCount
operator|-
name|off
argument_list|)
expr_stmt|;
comment|// in order to not get stuck in a loop we check readBytes (this
comment|// should never happen)
if|if
condition|(
name|readBytes
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No more bytes to read for trailing buffer, but expected: "
operator|+
operator|(
name|trailByteCount
operator|-
name|off
operator|)
argument_list|)
throw|;
block|}
name|off
operator|+=
name|readBytes
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|fileInputstream
argument_list|)
expr_stmt|;
block|}
comment|// find last '%%EOF'
name|int
name|bufOff
init|=
name|lastIndexOf
argument_list|(
name|EOF_MARKER
argument_list|,
name|buf
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufOff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
comment|// in lenient mode the '%%EOF' isn't needed
name|bufOff
operator|=
name|buf
operator|.
name|length
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Missing end of file marker '"
operator|+
operator|new
name|String
argument_list|(
name|EOF_MARKER
argument_list|)
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing end of file marker '"
operator|+
operator|new
name|String
argument_list|(
name|EOF_MARKER
argument_list|)
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
comment|// find last startxref preceding EOF marker
name|bufOff
operator|=
name|lastIndexOf
argument_list|(
name|STARTXREF_MARKER
argument_list|,
name|buf
argument_list|,
name|bufOff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufOff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|trailerOffset
operator|=
name|lastIndexOf
argument_list|(
name|TRAILER_MARKER
argument_list|,
name|buf
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|trailerOffset
operator|>
literal|0
condition|)
block|{
name|trailerOffset
operator|+=
name|skipBytes
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing 'startxref' marker."
argument_list|)
throw|;
block|}
block|}
return|return
name|skipBytes
operator|+
name|bufOff
return|;
block|}
comment|/**      * Searches last appearance of pattern within buffer. Lookup before _lastOff and goes back until 0.      *       * @param pattern pattern to search for      * @param buf buffer to search pattern in      * @param endOff offset (exclusive) where lookup starts at      *       * @return start offset of pattern within buffer or<code>-1</code> if pattern could not be found      */
specifier|protected
name|int
name|lastIndexOf
parameter_list|(
specifier|final
name|char
index|[]
name|pattern
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|endOff
parameter_list|)
block|{
specifier|final
name|int
name|lastPatternChOff
init|=
name|pattern
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|bufOff
init|=
name|endOff
decl_stmt|;
name|int
name|patOff
init|=
name|lastPatternChOff
decl_stmt|;
name|char
name|lookupCh
init|=
name|pattern
index|[
name|patOff
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|bufOff
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|bufOff
index|]
operator|==
name|lookupCh
condition|)
block|{
if|if
condition|(
operator|--
name|patOff
operator|<
literal|0
condition|)
block|{
comment|// whole pattern matched
return|return
name|bufOff
return|;
block|}
comment|// matched current char, advance to preceding one
name|lookupCh
operator|=
name|pattern
index|[
name|patOff
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|patOff
operator|<
name|lastPatternChOff
condition|)
block|{
comment|// no char match but already matched some chars; reset
name|patOff
operator|=
name|lastPatternChOff
expr_stmt|;
name|lookupCh
operator|=
name|pattern
index|[
name|patOff
index|]
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|private
name|COSDictionary
name|pagesDictionary
init|=
literal|null
decl_stmt|;
comment|/**      * Returns PAGES {@link COSDictionary} object or throws {@link IOException} if PAGES dictionary does not exist.      */
specifier|private
name|COSDictionary
name|getPagesObject
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pagesDictionary
operator|!=
literal|null
condition|)
block|{
return|return
name|pagesDictionary
return|;
block|}
name|COSObject
name|pages
init|=
operator|(
name|COSObject
operator|)
name|document
operator|.
name|getCatalog
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|PAGES
argument_list|)
decl_stmt|;
if|if
condition|(
name|pages
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing PAGES entry in document catalog."
argument_list|)
throw|;
block|}
name|COSBase
name|object
init|=
name|parseObjectDynamically
argument_list|(
name|pages
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|object
operator|instanceof
name|COSDictionary
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"PAGES not a dictionary object, but: "
operator|+
name|object
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
name|pagesDictionary
operator|=
operator|(
name|COSDictionary
operator|)
name|object
expr_stmt|;
return|return
name|pagesDictionary
return|;
block|}
comment|/**      * This will parse the stream and populate the COSDocument object.  This will close      * the stream when it is done parsing.      *      * @throws IOException If there is an error reading from the stream or corrupt data      * is found.      */
specifier|public
name|void
name|parse
parameter_list|()
throws|throws
name|IOException
block|{
comment|// set to false if all is processed
name|boolean
name|exceptionOccurred
init|=
literal|true
decl_stmt|;
try|try
block|{
comment|// PDFBOX-1922 read the version header and rewind
if|if
condition|(
operator|!
name|parseHeader
argument_list|(
name|PDF_HEADER
argument_list|,
name|PDF_DEFAULT_VERSION
argument_list|)
operator|&&
operator|!
name|parseHeader
argument_list|(
name|FDF_HEADER
argument_list|,
name|FDF_DEFAULT_VERSION
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Header doesn't contain versioninfo"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|initialParseDone
condition|)
block|{
name|initialParse
argument_list|()
expr_stmt|;
block|}
comment|// a FDF doesn't have any pages
if|if
condition|(
operator|!
name|isFDFDocment
condition|)
block|{
if|if
condition|(
operator|!
name|allPagesParsed
condition|)
block|{
specifier|final
name|int
name|pageCount
init|=
name|getPageNumber
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pNr
init|=
literal|0
init|;
name|pNr
operator|<
name|pageCount
condition|;
name|pNr
operator|++
control|)
block|{
name|getPage
argument_list|(
name|pNr
argument_list|)
expr_stmt|;
block|}
name|allPagesParsed
operator|=
literal|true
expr_stmt|;
name|document
operator|.
name|setDecrypted
argument_list|()
expr_stmt|;
block|}
block|}
name|exceptionOccurred
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|pdfSource
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|keyStoreInputStream
argument_list|)
expr_stmt|;
name|deleteTempFile
argument_list|()
expr_stmt|;
if|if
condition|(
name|exceptionOccurred
operator|&&
name|document
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|document
operator|.
name|close
argument_list|()
expr_stmt|;
name|document
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{                 }
block|}
block|}
block|}
comment|/**      * Return the pdf file.      *       * @return the pdf file      */
specifier|protected
name|File
name|getPdfFile
parameter_list|()
block|{
return|return
name|this
operator|.
name|pdfFile
return|;
block|}
comment|/**      * Return true if parser is lenient. Meaning auto healing capacity of the parser are used.      *      * @return true if parser is lenient      */
specifier|public
name|boolean
name|isLenient
parameter_list|()
block|{
return|return
name|isLenient
return|;
block|}
comment|/**      * Change the parser leniency flag.      *      * This method can only be called before the parsing of the file.      *      * @param lenient try to handle malformed PDFs.      *      */
specifier|public
name|void
name|setLenient
parameter_list|(
name|boolean
name|lenient
parameter_list|)
block|{
if|if
condition|(
name|initialParseDone
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot change leniency after parsing"
argument_list|)
throw|;
block|}
name|this
operator|.
name|isLenient
operator|=
name|lenient
expr_stmt|;
block|}
comment|/**      * Remove the temporary file. A temporary file is created if this class is instantiated with an InputStream      */
specifier|private
name|void
name|deleteTempFile
parameter_list|()
block|{
if|if
condition|(
name|isTmpPDFFile
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|pdfFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Temporary file '"
operator|+
name|pdfFile
operator|.
name|getName
argument_list|()
operator|+
literal|"' can't be deleted"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Temporary file '"
operator|+
name|pdfFile
operator|.
name|getName
argument_list|()
operator|+
literal|"' can't be deleted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Returns the number of pages in a document.      *       * @return the number of pages.      *       * @throws IOException if PAGES or other needed object is missing      */
specifier|public
name|int
name|getPageNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|pageCount
init|=
name|getPagesObject
argument_list|()
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|COUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageCount
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No page number specified."
argument_list|)
throw|;
block|}
return|return
name|pageCount
return|;
block|}
comment|/**      * Returns the page requested with all the objects loaded into it.      *       * @param pageNr starts from 0 to the number of pages.      * @return the page with the given pagenumber.      * @throws IOException If something went wrong.      */
specifier|public
name|PDPage
name|getPage
parameter_list|(
name|int
name|pageNr
parameter_list|)
throws|throws
name|IOException
block|{
name|getPagesObject
argument_list|()
expr_stmt|;
comment|// get list of top level pages
name|COSArray
name|kids
init|=
operator|(
name|COSArray
operator|)
name|pagesDictionary
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|KIDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|kids
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing 'Kids' entry in pages dictionary."
argument_list|)
throw|;
block|}
comment|// get page we are looking for (possibly going recursively into subpages)
name|COSObject
name|pageObj
init|=
name|getPageObject
argument_list|(
name|pageNr
argument_list|,
name|kids
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageObj
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Page "
operator|+
name|pageNr
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
comment|// parse all objects necessary to load page.
name|COSDictionary
name|pageDict
init|=
operator|(
name|COSDictionary
operator|)
name|pageObj
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|parseMinimalCatalog
operator|&&
operator|(
operator|!
name|allPagesParsed
operator|)
condition|)
block|{
comment|// parse page resources since we did not do this on start
name|COSDictionary
name|resDict
init|=
operator|(
name|COSDictionary
operator|)
name|pageDict
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|RESOURCES
argument_list|)
decl_stmt|;
name|parseDictObjects
argument_list|(
name|resDict
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|PDPage
argument_list|(
name|pageDict
argument_list|)
return|;
block|}
comment|/**      * Returns the object for a specific page. The page tree is made up of kids. The kids have COSArray with COSObjects      * inside of them. The COSObject can be parsed using the dynamic parsing method We want to only parse the minimum      * COSObjects and still return a complete page. ready to be used.      *       * @param num the requested page number; numbering starts with 0      * @param startKids Kids array to start with looking up page number      * @param startPageCount      *       * @return page object or<code>null</code> if no such page exists      *       * @throws IOException      */
specifier|private
name|COSObject
name|getPageObject
parameter_list|(
name|int
name|num
parameter_list|,
name|COSArray
name|startKids
parameter_list|,
name|int
name|startPageCount
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|curPageCount
init|=
name|startPageCount
decl_stmt|;
name|Iterator
argument_list|<
name|COSBase
argument_list|>
name|kidsIter
init|=
name|startKids
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|kidsIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|COSObject
name|obj
init|=
operator|(
name|COSObject
operator|)
name|kidsIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|COSBase
name|base
init|=
name|obj
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|base
operator|==
literal|null
condition|)
block|{
name|base
operator|=
name|parseObjectDynamically
argument_list|(
name|obj
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|obj
operator|.
name|setObject
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
name|COSDictionary
name|dic
init|=
operator|(
name|COSDictionary
operator|)
name|base
decl_stmt|;
name|int
name|count
init|=
name|dic
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|COUNT
argument_list|)
decl_stmt|;
comment|// skip this branch if requested page comes later
if|if
condition|(
name|count
operator|>=
literal|0
operator|&&
operator|(
name|curPageCount
operator|+
name|count
operator|)
operator|<=
name|num
condition|)
block|{
name|curPageCount
operator|+=
name|count
expr_stmt|;
continue|continue;
block|}
name|COSArray
name|kids
init|=
operator|(
name|COSArray
operator|)
name|dic
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|KIDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|kids
operator|!=
literal|null
condition|)
block|{
comment|// recursively scan subpages
name|COSObject
name|ans
init|=
name|getPageObject
argument_list|(
name|num
argument_list|,
name|kids
argument_list|,
name|curPageCount
argument_list|)
decl_stmt|;
comment|// if ans is not null, we got what we were looking for
if|if
condition|(
name|ans
operator|!=
literal|null
condition|)
block|{
return|return
name|ans
return|;
block|}
block|}
else|else
block|{
comment|// found page?
if|if
condition|(
name|curPageCount
operator|==
name|num
condition|)
block|{
return|return
name|obj
return|;
block|}
comment|// page has no kids and it is not the page we are looking for
name|curPageCount
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Creates a unique object id using object number and object generation      * number. (requires object number&lt; 2^31))      */
specifier|private
name|long
name|getObjectId
parameter_list|(
specifier|final
name|COSObject
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
operator|.
name|longValue
argument_list|()
operator|<<
literal|32
operator|)
operator||
name|obj
operator|.
name|getGenerationNumber
argument_list|()
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/**      * Adds all from newObjects to toBeParsedList if it is not an COSObject or      * we didn't add this COSObject already (checked via addedObjects).      */
specifier|private
name|void
name|addNewToList
parameter_list|(
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|COSBase
argument_list|>
name|newObjects
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
parameter_list|)
block|{
for|for
control|(
name|COSBase
name|newObject
range|:
name|newObjects
control|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|newObject
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds newObject to toBeParsedList if it is not an COSObject or we didn't      * add this COSObject already (checked via addedObjects).      */
specifier|private
name|void
name|addNewToList
parameter_list|(
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
parameter_list|,
specifier|final
name|COSBase
name|newObject
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
parameter_list|)
block|{
if|if
condition|(
name|newObject
operator|instanceof
name|COSObject
condition|)
block|{
specifier|final
name|long
name|objId
init|=
name|getObjectId
argument_list|(
operator|(
name|COSObject
operator|)
name|newObject
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|addedObjects
operator|.
name|add
argument_list|(
name|objId
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|toBeParsedList
operator|.
name|add
argument_list|(
name|newObject
argument_list|)
expr_stmt|;
block|}
comment|/**      * Will parse every object necessary to load a single page from the pdf document. We try our best to order objects      * according to offset in file before reading to minimize seek operations.      *       * @param dict the COSObject from the parent pages.      * @param excludeObjects dictionary object reference entries with these names will not be parsed      *       * @throws IOException      */
specifier|private
name|void
name|parseDictObjects
parameter_list|(
name|COSDictionary
name|dict
parameter_list|,
name|COSName
modifier|...
name|excludeObjects
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- create queue for objects waiting for further parsing
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
init|=
operator|new
name|LinkedList
argument_list|<
name|COSBase
argument_list|>
argument_list|()
decl_stmt|;
comment|// offset ordered object map
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|COSObject
argument_list|>
argument_list|>
name|objToBeParsed
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|COSObject
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// in case of compressed objects offset points to stmObj
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|parsedObjects
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|addExcludedToList
argument_list|(
name|excludeObjects
argument_list|,
name|dict
argument_list|,
name|parsedObjects
argument_list|)
expr_stmt|;
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|dict
operator|.
name|getValues
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
comment|// ---- go through objects to be parsed
while|while
condition|(
operator|!
operator|(
name|toBeParsedList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|objToBeParsed
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
comment|// -- first get all COSObject from other kind of objects and
comment|// put them in objToBeParsed; afterwards toBeParsedList is empty
name|COSBase
name|baseObj
decl_stmt|;
while|while
condition|(
operator|(
name|baseObj
operator|=
name|toBeParsedList
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|baseObj
operator|instanceof
name|COSDictionary
condition|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
operator|(
operator|(
name|COSDictionary
operator|)
name|baseObj
operator|)
operator|.
name|getValues
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseObj
operator|instanceof
name|COSArray
condition|)
block|{
specifier|final
name|Iterator
argument_list|<
name|COSBase
argument_list|>
name|arrIter
init|=
operator|(
operator|(
name|COSArray
operator|)
name|baseObj
operator|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|arrIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|arrIter
operator|.
name|next
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|baseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|obj
init|=
operator|(
name|COSObject
operator|)
name|baseObj
decl_stmt|;
name|long
name|objId
init|=
name|getObjectId
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|obj
operator|.
name|getGenerationNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|parsedObjects
operator|.
name|contains
argument_list|(
name|objId
argument_list|)
comment|/*                                                          * || document.hasObjectInPool ( objKey )                                                          */
operator|)
condition|)
block|{
name|Long
name|fileOffset
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
comment|// it is allowed that object references point to null,
comment|// thus we have to test
if|if
condition|(
name|fileOffset
operator|!=
literal|null
operator|&&
name|fileOffset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fileOffset
operator|>
literal|0
condition|)
block|{
name|objToBeParsed
operator|.
name|put
argument_list|(
name|fileOffset
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// negative offset means we have a compressed
comment|// object within object stream;
comment|// get offset of object stream
name|fileOffset
operator|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
operator|new
name|COSObjectKey
argument_list|(
operator|-
name|fileOffset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fileOffset
operator|==
literal|null
operator|)
operator|||
operator|(
name|fileOffset
operator|<=
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid object stream xref object reference for key '"
operator|+
name|objKey
operator|+
literal|"': "
operator|+
name|fileOffset
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|COSObject
argument_list|>
name|stmObjects
init|=
name|objToBeParsed
operator|.
name|get
argument_list|(
name|fileOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmObjects
operator|==
literal|null
condition|)
block|{
name|stmObjects
operator|=
operator|new
name|ArrayList
argument_list|<
name|COSObject
argument_list|>
argument_list|()
expr_stmt|;
name|objToBeParsed
operator|.
name|put
argument_list|(
name|fileOffset
argument_list|,
name|stmObjects
argument_list|)
expr_stmt|;
block|}
name|stmObjects
operator|.
name|add
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// NULL object
name|COSObject
name|pdfObject
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
name|pdfObject
operator|.
name|setObject
argument_list|(
name|COSNull
operator|.
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// ---- read first COSObject with smallest offset;
comment|// resulting object will be added to toBeParsedList
if|if
condition|(
name|objToBeParsed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
for|for
control|(
name|COSObject
name|obj
range|:
name|objToBeParsed
operator|.
name|remove
argument_list|(
name|objToBeParsed
operator|.
name|firstKey
argument_list|()
argument_list|)
control|)
block|{
name|COSBase
name|parsedObj
init|=
name|parseObjectDynamically
argument_list|(
name|obj
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|obj
operator|.
name|setObject
argument_list|(
name|parsedObj
argument_list|)
expr_stmt|;
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|parsedObj
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
name|parsedObjects
operator|.
name|add
argument_list|(
name|getObjectId
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// add objects not to be parsed to list of already parsed objects
specifier|private
name|void
name|addExcludedToList
parameter_list|(
name|COSName
index|[]
name|excludeObjects
parameter_list|,
name|COSDictionary
name|dict
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|parsedObjects
parameter_list|)
block|{
if|if
condition|(
name|excludeObjects
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|COSName
name|objName
range|:
name|excludeObjects
control|)
block|{
name|COSBase
name|baseObj
init|=
name|dict
operator|.
name|getItem
argument_list|(
name|objName
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|parsedObjects
operator|.
name|add
argument_list|(
name|getObjectId
argument_list|(
operator|(
name|COSObject
operator|)
name|baseObj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * This will parse the next object from the stream and add it to the local state. This is taken from      * {@link PDFParser} and reduced to parsing an indirect object.      *       * @param obj object to be parsed (we only take object number and generation number for lookup start offset)      * @param requireExistingNotCompressedObj if<code>true</code> object to be parsed must not be contained within      * compressed stream      * @return the parsed object (which is also added to document object)      *       * @throws IOException If an IO error occurs.      */
specifier|protected
specifier|final
name|COSBase
name|parseObjectDynamically
parameter_list|(
name|COSObject
name|obj
parameter_list|,
name|boolean
name|requireExistingNotCompressedObj
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|parseObjectDynamically
argument_list|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|obj
operator|.
name|getGenerationNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|requireExistingNotCompressedObj
argument_list|)
return|;
block|}
comment|/**      * This will parse the next object from the stream and add it to the local state.       * It's reduced to parsing an indirect object.      *       * @param objNr object number of object to be parsed      * @param objGenNr object generation number of object to be parsed      * @param requireExistingNotCompressedObj if<code>true</code> the object to be parsed must be defined in xref      * (comment: null objects may be missing from xref) and it must not be a compressed object within object stream      * (this is used to circumvent being stuck in a loop in a malicious PDF)      *       * @return the parsed object (which is also added to document object)      *       * @throws IOException If an IO error occurs.      */
specifier|protected
name|COSBase
name|parseObjectDynamically
parameter_list|(
name|int
name|objNr
parameter_list|,
name|int
name|objGenNr
parameter_list|,
name|boolean
name|requireExistingNotCompressedObj
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- create object key and get object (container) from pool
specifier|final
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|objNr
argument_list|,
name|objGenNr
argument_list|)
decl_stmt|;
specifier|final
name|COSObject
name|pdfObject
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|pdfObject
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// not previously parsed
comment|// ---- read offset or object stream object number from xref table
name|Long
name|offsetOrObjstmObNr
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
comment|// sanity test to circumvent loops with broken documents
if|if
condition|(
name|requireExistingNotCompressedObj
operator|&&
operator|(
operator|(
name|offsetOrObjstmObNr
operator|==
literal|null
operator|)
operator|||
operator|(
name|offsetOrObjstmObNr
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object must be defined and must not be compressed object: "
operator|+
name|objKey
operator|.
name|getNumber
argument_list|()
operator|+
literal|":"
operator|+
name|objKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|offsetOrObjstmObNr
operator|==
literal|null
condition|)
block|{
comment|// not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)
name|pdfObject
operator|.
name|setObject
argument_list|(
name|COSNull
operator|.
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsetOrObjstmObNr
operator|>
literal|0
condition|)
block|{
comment|// offset of indirect object in file
comment|// ---- go to object start
name|pdfSource
operator|.
name|seek
argument_list|(
name|offsetOrObjstmObNr
argument_list|)
expr_stmt|;
comment|// ---- we must have an indirect object
specifier|final
name|long
name|readObjNr
init|=
name|readObjectNumber
argument_list|()
decl_stmt|;
specifier|final
name|long
name|readObjGen
init|=
name|readGenerationNumber
argument_list|()
decl_stmt|;
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// ---- consistency check
if|if
condition|(
operator|(
name|readObjNr
operator|!=
name|objKey
operator|.
name|getNumber
argument_list|()
operator|)
operator|||
operator|(
name|readObjGen
operator|!=
name|objKey
operator|.
name|getGeneration
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"XREF for "
operator|+
name|objKey
operator|.
name|getNumber
argument_list|()
operator|+
literal|":"
operator|+
name|objKey
operator|.
name|getGeneration
argument_list|()
operator|+
literal|" points to wrong object: "
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSBase
name|pb
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|String
name|endObjectKey
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
name|endObjectKey
operator|.
name|equals
argument_list|(
name|STREAM_STRING
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|endObjectKey
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSStream
name|stream
init|=
name|parseCOSStream
argument_list|(
operator|(
name|COSDictionary
operator|)
name|pb
argument_list|)
decl_stmt|;
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
name|securityHandler
operator|.
name|decryptStream
argument_list|(
name|stream
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
name|pb
operator|=
name|stream
expr_stmt|;
block|}
else|else
block|{
comment|// this is not legal
comment|// the combination of a dict and the stream/endstream
comment|// forms a complete stream object
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream not preceded by dictionary (offset: "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|")."
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|endObjectKey
operator|=
name|readLine
argument_list|()
expr_stmt|;
comment|// we have case with a second 'endstream' before endobj
if|if
condition|(
operator|!
name|endObjectKey
operator|.
name|startsWith
argument_list|(
name|ENDOBJ_STRING
argument_list|)
operator|&&
name|endObjectKey
operator|.
name|startsWith
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
condition|)
block|{
name|endObjectKey
operator|=
name|endObjectKey
operator|.
name|substring
argument_list|(
literal|9
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|endObjectKey
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// no other characters in extra endstream line
name|endObjectKey
operator|=
name|readLine
argument_list|()
expr_stmt|;
comment|// read next line
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
name|securityHandler
operator|.
name|decrypt
argument_list|(
name|pb
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
name|pdfObject
operator|.
name|setObject
argument_list|(
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endObjectKey
operator|.
name|startsWith
argument_list|(
name|ENDOBJ_STRING
argument_list|)
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Object ("
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
operator|+
literal|") at offset "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|" does not end with 'endobj' but with '"
operator|+
name|endObjectKey
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object ("
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
operator|+
literal|") at offset "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|" does not end with 'endobj' but with '"
operator|+
name|endObjectKey
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
comment|// xref value is object nr of object stream containing object to
comment|// be parsed;
comment|// since our object was not found it means object stream was not
comment|// parsed so far
specifier|final
name|int
name|objstmObjNr
init|=
call|(
name|int
call|)
argument_list|(
operator|-
name|offsetOrObjstmObNr
argument_list|)
decl_stmt|;
specifier|final
name|COSBase
name|objstmBaseObj
init|=
name|parseObjectDynamically
argument_list|(
name|objstmObjNr
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|objstmBaseObj
operator|instanceof
name|COSStream
condition|)
block|{
comment|// parse object stream
name|PDFObjectStreamParser
name|parser
init|=
operator|new
name|PDFObjectStreamParser
argument_list|(
operator|(
name|COSStream
operator|)
name|objstmBaseObj
argument_list|,
name|document
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
comment|// get set of object numbers referenced for this object
comment|// stream
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|refObjNrs
init|=
name|xrefTrailerResolver
operator|.
name|getContainedObjectNumbers
argument_list|(
name|objstmObjNr
argument_list|)
decl_stmt|;
comment|// register all objects which are referenced to be contained
comment|// in object stream
for|for
control|(
name|COSObject
name|next
range|:
name|parser
operator|.
name|getObjects
argument_list|()
control|)
block|{
name|COSObjectKey
name|stmObjKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|refObjNrs
operator|.
name|contains
argument_list|(
name|stmObjKey
operator|.
name|getNumber
argument_list|()
argument_list|)
condition|)
block|{
name|COSObject
name|stmObj
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|stmObjKey
argument_list|)
decl_stmt|;
name|stmObj
operator|.
name|setObject
argument_list|(
name|next
operator|.
name|getObject
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|pdfObject
operator|.
name|getObject
argument_list|()
return|;
block|}
specifier|private
name|boolean
name|inGetLength
init|=
literal|false
decl_stmt|;
comment|/** Returns length value referred to or defined in given object. */
specifier|private
name|COSNumber
name|getLength
parameter_list|(
specifier|final
name|COSBase
name|lengthBaseObj
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|lengthBaseObj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|inGetLength
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Loop while reading length from "
operator|+
name|lengthBaseObj
argument_list|)
throw|;
block|}
name|COSNumber
name|retVal
init|=
literal|null
decl_stmt|;
try|try
block|{
name|inGetLength
operator|=
literal|true
expr_stmt|;
comment|// ---- maybe length was given directly
if|if
condition|(
name|lengthBaseObj
operator|instanceof
name|COSNumber
condition|)
block|{
name|retVal
operator|=
operator|(
name|COSNumber
operator|)
name|lengthBaseObj
expr_stmt|;
block|}
comment|// ---- length in referenced object
elseif|else
if|if
condition|(
name|lengthBaseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|lengthObj
init|=
operator|(
name|COSObject
operator|)
name|lengthBaseObj
decl_stmt|;
if|if
condition|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// not read so far
comment|// keep current stream position
specifier|final
name|long
name|curFileOffset
init|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|parseObjectDynamically
argument_list|(
name|lengthObj
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// reset current stream position
name|pdfSource
operator|.
name|seek
argument_list|(
name|curFileOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Length object content was not read."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|instanceof
name|COSNumber
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong type of referenced length object "
operator|+
name|lengthObj
operator|+
literal|": "
operator|+
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
name|retVal
operator|=
operator|(
name|COSNumber
operator|)
name|lengthObj
operator|.
name|getObject
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong type of length object: "
operator|+
name|lengthBaseObj
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|inGetLength
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|retVal
return|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|STREAMCOPYBUFLEN
init|=
literal|8192
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|streamCopyBuf
init|=
operator|new
name|byte
index|[
name|STREAMCOPYBUFLEN
index|]
decl_stmt|;
comment|/**      * This will read a COSStream from the input stream using length attribute within dictionary. If length attribute is      * a indirect reference it is first resolved to get the stream length. This means we copy stream data without      * testing for 'endstream' or 'endobj' and thus it is no problem if these keywords occur within stream. We require      * 'endstream' to be found after stream data is read.      *       * @param dic dictionary that goes with this stream.      *       * @return parsed pdf stream.      *       * @throws IOException if an error occurred reading the stream, like problems with reading length attribute, stream      * does not end with 'endstream' after data read, stream too short etc.      */
annotation|@
name|Override
specifier|protected
name|COSStream
name|parseCOSStream
parameter_list|(
name|COSDictionary
name|dic
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|COSStream
name|stream
init|=
name|createCOSStream
argument_list|(
name|dic
argument_list|)
decl_stmt|;
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|readString
argument_list|()
expr_stmt|;
comment|// read 'stream'; this was already tested in
comment|// parseObjectsDynamically()
comment|// ---- skip whitespaces before start of data
comment|// PDF Ref 1.7, chap. 3.2.7:
comment|// 'stream' should be followed by either a CRLF (0x0d 0x0a) or LF
comment|// but nothing else.
name|int
name|whitespace
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// see brother_scan_cover.pdf, it adds whitespaces
comment|// after the stream but before the start of the
comment|// data, so just read those first
while|while
condition|(
name|whitespace
operator|==
literal|0x20
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|whitespace
operator|==
literal|0x0D
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|whitespace
operator|!=
literal|0x0A
condition|)
block|{
comment|// the spec says this is invalid but it happens in the
comment|// real world so we must support it
name|pdfSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|whitespace
operator|!=
literal|0x0A
condition|)
block|{
comment|// no whitespace after 'stream'; PDF ref. says 'should' so
comment|// that is ok
name|pdfSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
block|}
comment|/*              * This needs to be dic.getItem because when we are parsing, the underlying object might still be null.              */
name|COSNumber
name|streamLengthObj
init|=
name|getLength
argument_list|(
name|dic
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|streamLengthObj
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The stream doesn't provide any stream length, using fallback readUntilEnd"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing length for stream."
argument_list|)
throw|;
block|}
block|}
name|boolean
name|useReadUntilEnd
init|=
literal|false
decl_stmt|;
comment|// ---- get output stream to copy data to
if|if
condition|(
name|streamLengthObj
operator|!=
literal|null
operator|&&
name|validateStreamLength
argument_list|(
name|streamLengthObj
operator|.
name|longValue
argument_list|()
argument_list|)
condition|)
block|{
name|out
operator|=
name|stream
operator|.
name|createFilteredStream
argument_list|(
name|streamLengthObj
argument_list|)
expr_stmt|;
name|long
name|remainBytes
init|=
name|streamLengthObj
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|remainBytes
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|readBytes
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
operator|(
name|remainBytes
operator|>
name|STREAMCOPYBUFLEN
operator|)
condition|?
name|STREAMCOPYBUFLEN
else|:
operator|(
name|int
operator|)
name|remainBytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBytes
operator|<=
literal|0
condition|)
block|{
name|useReadUntilEnd
operator|=
literal|true
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
name|bytesRead
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
operator|.
name|write
argument_list|(
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
name|readBytes
argument_list|)
expr_stmt|;
name|remainBytes
operator|-=
name|readBytes
expr_stmt|;
name|bytesRead
operator|+=
name|readBytes
expr_stmt|;
block|}
block|}
else|else
block|{
name|useReadUntilEnd
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|useReadUntilEnd
condition|)
block|{
name|out
operator|=
name|stream
operator|.
name|createFilteredStream
argument_list|()
expr_stmt|;
name|readUntilEndStream
argument_list|(
operator|new
name|EndstreamOutputStream
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|endStream
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
name|endStream
operator|.
name|equals
argument_list|(
literal|"endobj"
argument_list|)
operator|&&
name|isLenient
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"stream ends with 'endobj' instead of 'endstream' at offset "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
comment|// avoid follow-up warning about missing endobj
name|pdfSource
operator|.
name|unread
argument_list|(
name|ENDOBJ
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endStream
operator|.
name|length
argument_list|()
operator|>
literal|9
operator|&&
name|isLenient
operator|&&
name|endStream
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|9
argument_list|)
operator|.
name|equals
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"stream ends with '"
operator|+
name|endStream
operator|+
literal|"' instead of 'endstream' at offset "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
comment|// unread the "extra" bytes
name|pdfSource
operator|.
name|unread
argument_list|(
name|endStream
operator|.
name|substring
argument_list|(
literal|9
argument_list|)
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|endStream
operator|.
name|equals
argument_list|(
name|ENDSTREAM_STRING
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error reading stream, expected='endstream' actual='"
operator|+
name|endStream
operator|+
literal|"' at offset "
operator|+
name|pdfSource
operator|.
name|getOffset
argument_list|()
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|stream
return|;
block|}
specifier|private
name|boolean
name|validateStreamLength
parameter_list|(
name|long
name|streamLength
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|streamLengthIsValid
init|=
literal|true
decl_stmt|;
name|long
name|originOffset
init|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|long
name|expectedEndOfStream
init|=
name|originOffset
operator|+
name|streamLength
decl_stmt|;
if|if
condition|(
name|expectedEndOfStream
operator|>
name|fileLen
condition|)
block|{
name|streamLengthIsValid
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"The end of the stream is out of range, using workaround to read the stream"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Stream start offset: "
operator|+
name|originOffset
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Expected endofstream offset: "
operator|+
name|expectedEndOfStream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
name|expectedEndOfStream
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isString
argument_list|(
name|ENDSTREAM
argument_list|)
condition|)
block|{
name|streamLengthIsValid
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"The end of the stream doesn't point to the correct offset, using workaround to read the stream"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Stream start offset: "
operator|+
name|originOffset
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Expected endofstream offset: "
operator|+
name|expectedEndOfStream
argument_list|)
expr_stmt|;
block|}
name|pdfSource
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
return|return
name|streamLengthIsValid
return|;
block|}
comment|/**      * Check if the cross reference table/stream can be found at the current offset.      *       * @param startXRefOffset      * @return the revised offset      * @throws IOException      */
specifier|private
name|long
name|checkXRefOffset
parameter_list|(
name|long
name|startXRefOffset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// repair mode isn't available in non-lenient mode
if|if
condition|(
operator|!
name|isLenient
condition|)
block|{
return|return
name|startXRefOffset
return|;
block|}
name|pdfSource
operator|.
name|seek
argument_list|(
name|startXRefOffset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// save the previous character
name|int
name|previous
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|pdfSource
operator|.
name|peek
argument_list|()
operator|==
name|X
operator|&&
name|isString
argument_list|(
name|XREF_TABLE
argument_list|)
condition|)
block|{
return|return
name|startXRefOffset
return|;
block|}
comment|// the previous character has to be a whitespace
if|if
condition|(
name|isWhitespace
argument_list|(
name|previous
argument_list|)
condition|)
block|{
name|int
name|nextValue
init|=
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// maybe there isn't a xref table but a xref stream
comment|// is the next character a digit?
if|if
condition|(
name|nextValue
operator|>
literal|47
operator|&&
name|nextValue
operator|<
literal|58
condition|)
block|{
try|try
block|{
comment|// Maybe it's a XRef stream
name|readObjectNumber
argument_list|()
expr_stmt|;
name|readGenerationNumber
argument_list|()
expr_stmt|;
name|readExpectedString
argument_list|(
name|OBJ_MARKER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|pdfSource
operator|.
name|seek
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
return|return
name|startXRefOffset
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
comment|// there wasn't an object of a xref stream
comment|// try to repair the offset
name|pdfSource
operator|.
name|seek
argument_list|(
name|startXRefOffset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// try to find a fixed offset
return|return
name|calculateXRefFixedOffset
argument_list|(
name|startXRefOffset
argument_list|)
return|;
block|}
comment|/**      * Try to find a fixed offset for the given xref table/stream.      *       * @param objectOffset the given offset where to look at      * @return the fixed offset      *       * @throws IOException if something went wrong      */
specifier|private
name|long
name|calculateXRefFixedOffset
parameter_list|(
name|long
name|objectOffset
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|objectOffset
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid object offset "
operator|+
name|objectOffset
operator|+
literal|" when searching for a xref table/stream"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// start a brute force search for all xref tables and try to find the offset we are looking for
name|long
name|newOffset
init|=
name|bfSearchForXRef
argument_list|(
name|objectOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|newOffset
operator|>
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fixed reference for xref table/stream "
operator|+
name|objectOffset
operator|+
literal|" -> "
operator|+
name|newOffset
argument_list|)
expr_stmt|;
return|return
name|newOffset
return|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't find the object axref table/stream at offset "
operator|+
name|objectOffset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/**      * Check the XRef table by dereferencing all objects and fixing the offset if necessary.      *       * @throws IOException if something went wrong.      */
specifier|private
name|void
name|checkXrefOffsets
parameter_list|()
throws|throws
name|IOException
block|{
comment|// repair mode isn't available in non-lenient mode
if|if
condition|(
operator|!
name|isLenient
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|xrefOffset
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|xrefOffset
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|objectEntry
range|:
name|xrefOffset
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|COSObjectKey
name|objectKey
init|=
name|objectEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Long
name|objectOffset
init|=
name|objectEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// a negative offset number represents a object number itself
comment|// see type 2 entry in xref stream
if|if
condition|(
name|objectOffset
operator|!=
literal|null
operator|&&
name|objectOffset
operator|>=
literal|0
condition|)
block|{
name|long
name|objectNr
init|=
name|objectKey
operator|.
name|getNumber
argument_list|()
decl_stmt|;
name|long
name|objectGen
init|=
name|objectKey
operator|.
name|getGeneration
argument_list|()
decl_stmt|;
name|String
name|objectString
init|=
name|createObjectString
argument_list|(
name|objectNr
argument_list|,
name|objectGen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|checkObjectId
argument_list|(
name|objectString
argument_list|,
name|objectOffset
argument_list|)
condition|)
block|{
name|long
name|newOffset
init|=
name|bfSearchForObject
argument_list|(
name|objectString
argument_list|)
decl_stmt|;
if|if
condition|(
name|newOffset
operator|>
operator|-
literal|1
condition|)
block|{
name|xrefOffset
operator|.
name|put
argument_list|(
name|objectKey
argument_list|,
name|newOffset
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fixed reference for object "
operator|+
name|objectNr
operator|+
literal|" "
operator|+
name|objectGen
operator|+
literal|" "
operator|+
name|objectOffset
operator|+
literal|" -> "
operator|+
name|newOffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't find the object "
operator|+
name|objectNr
operator|+
literal|" "
operator|+
name|objectGen
operator|+
literal|" (origin offset "
operator|+
name|objectOffset
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**      * Check if the given string can be found at the given offset.      *       * @param objectString the string we are looking for      * @param offset the given where to look      * @return returns true if the given string can be found at the givwen offset      * @throws IOException if something went wrong      */
specifier|private
name|boolean
name|checkObjectId
parameter_list|(
name|String
name|objectString
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|originOffset
init|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|pdfSource
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|boolean
name|objectFound
init|=
name|isString
argument_list|(
name|objectString
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
decl_stmt|;
name|pdfSource
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
return|return
name|objectFound
return|;
block|}
comment|/**      * Create a string for the given object id.      *       * @param objectID the object id      * @param genID the generation id      * @return the generated string      */
specifier|private
name|String
name|createObjectString
parameter_list|(
name|long
name|objectID
parameter_list|,
name|long
name|genID
parameter_list|)
block|{
return|return
name|Long
operator|.
name|toString
argument_list|(
name|objectID
argument_list|)
operator|+
literal|" "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|genID
argument_list|)
operator|+
literal|" obj"
return|;
block|}
comment|/**      * Search for the offset of the given object among the objects found by a brute force search.      *       * @param objectString the object we are looking for      * @return the offset of the object      * @throws IOException if something went wrong      */
specifier|private
name|long
name|bfSearchForObject
parameter_list|(
name|String
name|objectString
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|newOffset
init|=
operator|-
literal|1
decl_stmt|;
name|bfSearchForObjects
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfSearchObjectOffsets
operator|.
name|containsKey
argument_list|(
name|objectString
argument_list|)
condition|)
block|{
name|newOffset
operator|=
name|bfSearchObjectOffsets
operator|.
name|get
argument_list|(
name|objectString
argument_list|)
expr_stmt|;
block|}
return|return
name|newOffset
return|;
block|}
comment|/**      * Brute force search for every object in the pdf.      *         * @throws IOException if something went wrong      */
specifier|private
name|void
name|bfSearchForObjects
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bfSearchObjectOffsets
operator|==
literal|null
condition|)
block|{
name|bfSearchObjectOffsets
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
expr_stmt|;
name|bfSearchCOSObjectKeyOffsets
operator|=
operator|new
name|HashMap
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
argument_list|()
expr_stmt|;
name|long
name|originOffset
init|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|long
name|currentOffset
init|=
name|MINIMUM_SEARCH_OFFSET
decl_stmt|;
name|String
name|objString
init|=
literal|" obj"
decl_stmt|;
name|char
index|[]
name|string
init|=
name|objString
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
do|do
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isString
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|long
name|tempOffset
init|=
name|currentOffset
operator|-
literal|1
decl_stmt|;
name|pdfSource
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
name|int
name|genID
init|=
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// is the next char a digit?
if|if
condition|(
name|genID
operator|>
literal|47
operator|&&
name|genID
operator|<
literal|58
condition|)
block|{
name|genID
operator|-=
literal|48
expr_stmt|;
name|tempOffset
operator|--
expr_stmt|;
name|pdfSource
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSpace
argument_list|()
condition|)
block|{
while|while
condition|(
name|tempOffset
operator|>
name|MINIMUM_SEARCH_OFFSET
operator|&&
name|isSpace
argument_list|()
condition|)
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
block|}
name|int
name|length
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|tempOffset
operator|>
name|MINIMUM_SEARCH_OFFSET
operator|&&
name|isDigit
argument_list|()
condition|)
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|byte
index|[]
name|objIDBytes
init|=
name|pdfSource
operator|.
name|readFully
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|String
name|objIdString
init|=
operator|new
name|String
argument_list|(
name|objIDBytes
argument_list|,
literal|0
argument_list|,
name|objIDBytes
operator|.
name|length
argument_list|,
name|ISO_8859_1
argument_list|)
decl_stmt|;
name|Long
name|objectID
decl_stmt|;
try|try
block|{
name|objectID
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|objIdString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
name|objectID
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|objectID
operator|!=
literal|null
condition|)
block|{
name|bfSearchObjectOffsets
operator|.
name|put
argument_list|(
name|createObjectString
argument_list|(
name|objectID
argument_list|,
name|genID
argument_list|)
argument_list|,
operator|++
name|tempOffset
argument_list|)
expr_stmt|;
name|bfSearchCOSObjectKeyOffsets
operator|.
name|put
argument_list|(
operator|new
name|COSObjectKey
argument_list|(
name|objectID
argument_list|,
name|genID
argument_list|)
argument_list|,
name|tempOffset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|currentOffset
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|pdfSource
operator|.
name|isEOF
argument_list|()
condition|)
do|;
comment|// reestablish origin position
name|pdfSource
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Search for the offset of the given xref table/stream among those found by a brute force search.      *       * @return the offset of the xref entry      * @throws IOException if something went wrong      */
specifier|private
name|long
name|bfSearchForXRef
parameter_list|(
name|long
name|xrefOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|newOffset
init|=
operator|-
literal|1
decl_stmt|;
name|bfSearchForXRefs
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfSearchXRefOffsets
operator|!=
literal|null
condition|)
block|{
name|long
name|currentDifference
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|currentOffsetIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|numberOfOffsets
init|=
name|bfSearchXRefOffsets
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// find the most likely value
comment|// TODO to be optimized, this won't work in every case
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfOffsets
condition|;
name|i
operator|++
control|)
block|{
name|long
name|newDifference
init|=
name|xrefOffset
operator|-
name|bfSearchXRefOffsets
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// find the nearest offset
if|if
condition|(
name|currentDifference
operator|==
operator|-
literal|1
operator|||
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|currentDifference
argument_list|)
operator|>
name|Math
operator|.
name|abs
argument_list|(
name|newDifference
argument_list|)
operator|)
condition|)
block|{
name|currentDifference
operator|=
name|newDifference
expr_stmt|;
name|currentOffsetIndex
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|currentOffsetIndex
operator|>
operator|-
literal|1
condition|)
block|{
name|newOffset
operator|=
name|bfSearchXRefOffsets
operator|.
name|remove
argument_list|(
name|currentOffsetIndex
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newOffset
return|;
block|}
comment|/**      * Brute force search for all xref entries.      *       * @throws IOException if something went wrong      */
specifier|private
name|void
name|bfSearchForXRefs
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bfSearchXRefOffsets
operator|==
literal|null
condition|)
block|{
comment|// a pdf may contain more than one xref entry
name|bfSearchXRefOffsets
operator|=
operator|new
name|Vector
argument_list|<
name|Long
argument_list|>
argument_list|()
expr_stmt|;
name|long
name|originOffset
init|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|pdfSource
operator|.
name|seek
argument_list|(
name|MINIMUM_SEARCH_OFFSET
argument_list|)
expr_stmt|;
comment|// search for xref tables
while|while
condition|(
operator|!
name|pdfSource
operator|.
name|isEOF
argument_list|()
condition|)
block|{
if|if
condition|(
name|isString
argument_list|(
name|XREF_TABLE
argument_list|)
condition|)
block|{
name|long
name|newOffset
init|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|pdfSource
operator|.
name|seek
argument_list|(
name|newOffset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// ensure that we don't read "startxref" instead of "xref"
if|if
condition|(
name|isWhitespace
argument_list|()
condition|)
block|{
name|bfSearchXRefOffsets
operator|.
name|add
argument_list|(
name|newOffset
argument_list|)
expr_stmt|;
block|}
name|pdfSource
operator|.
name|seek
argument_list|(
name|newOffset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|pdfSource
operator|.
name|seek
argument_list|(
name|MINIMUM_SEARCH_OFFSET
argument_list|)
expr_stmt|;
comment|// search for XRef streams
name|String
name|objString
init|=
literal|" obj"
decl_stmt|;
name|char
index|[]
name|string
init|=
name|objString
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|pdfSource
operator|.
name|isEOF
argument_list|()
condition|)
block|{
if|if
condition|(
name|isString
argument_list|(
name|XREF_STREAM
argument_list|)
condition|)
block|{
comment|// search backwards for the beginning of the stream
name|long
name|newOffset
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|xrefOffset
init|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|boolean
name|objFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|30
operator|&&
operator|!
name|objFound
condition|;
name|i
operator|++
control|)
block|{
name|long
name|currentOffset
init|=
name|xrefOffset
operator|-
operator|(
name|i
operator|*
literal|10
operator|)
decl_stmt|;
if|if
condition|(
name|currentOffset
operator|>
literal|0
condition|)
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
name|currentOffset
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|isString
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|long
name|tempOffset
init|=
name|currentOffset
operator|-
literal|1
decl_stmt|;
name|pdfSource
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
name|int
name|genID
init|=
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// is the next char a digit?
if|if
condition|(
name|isDigit
argument_list|(
name|genID
argument_list|)
condition|)
block|{
name|genID
operator|-=
literal|48
expr_stmt|;
name|tempOffset
operator|--
expr_stmt|;
name|pdfSource
operator|.
name|seek
argument_list|(
name|tempOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSpace
argument_list|()
condition|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
name|pdfSource
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
while|while
condition|(
name|tempOffset
operator|>
name|MINIMUM_SEARCH_OFFSET
operator|&&
name|isDigit
argument_list|()
condition|)
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
operator|--
name|tempOffset
argument_list|)
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|newOffset
operator|=
name|pdfSource
operator|.
name|getOffset
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fixed reference for xref stream "
operator|+
name|xrefOffset
operator|+
literal|" -> "
operator|+
name|newOffset
argument_list|)
expr_stmt|;
name|objFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|currentOffset
operator|++
expr_stmt|;
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|newOffset
operator|>
operator|-
literal|1
condition|)
block|{
name|bfSearchXRefOffsets
operator|.
name|add
argument_list|(
name|newOffset
argument_list|)
expr_stmt|;
block|}
name|pdfSource
operator|.
name|seek
argument_list|(
name|xrefOffset
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|pdfSource
operator|.
name|seek
argument_list|(
name|originOffset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This will parse the startxref section from the stream.      * The startxref value is ignored.      *      * @return the startxref value or -1 on parsing error      * @throws IOException If an IO error occurs.      */
specifier|private
name|long
name|parseStartXref
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|startXref
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|isString
argument_list|(
name|STARTXREF
argument_list|)
condition|)
block|{
name|readString
argument_list|()
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
comment|// This integer is the byte offset of the first object referenced by the xref or xref stream
name|startXref
operator|=
name|readLong
argument_list|()
expr_stmt|;
block|}
return|return
name|startXref
return|;
block|}
comment|/**      * This will parse the trailer from the stream and add it to the state.      *      * @return false on parsing error      * @throws IOException If an IO error occurs.      */
specifier|private
name|boolean
name|parseTrailer
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pdfSource
operator|.
name|peek
argument_list|()
operator|!=
literal|'t'
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//read "trailer"
name|String
name|nextLine
init|=
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nextLine
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|"trailer"
argument_list|)
condition|)
block|{
comment|// in some cases the EOL is missing and the trailer immediately
comment|// continues with "<<" or with a blank character
comment|// even if this does not comply with PDF reference we want to support as many PDFs as possible
comment|// Acrobat reader can also deal with this.
if|if
condition|(
name|nextLine
operator|.
name|startsWith
argument_list|(
literal|"trailer"
argument_list|)
condition|)
block|{
name|byte
index|[]
name|b
init|=
name|nextLine
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
decl_stmt|;
name|int
name|len
init|=
literal|"trailer"
operator|.
name|length
argument_list|()
decl_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
name|b
argument_list|,
name|len
argument_list|,
name|b
operator|.
name|length
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// in some cases the EOL is missing and the trailer continues with "<<"
comment|// even if this does not comply with PDF reference we want to support as many PDFs as possible
comment|// Acrobat reader can also deal with this.
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSDictionary
name|parsedTrailer
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
name|xrefTrailerResolver
operator|.
name|setTrailer
argument_list|(
name|parsedTrailer
argument_list|)
expr_stmt|;
comment|// The version can also be specified within the document /Catalog
name|readVersionInTrailer
argument_list|(
name|parsedTrailer
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|parseHeader
parameter_list|(
name|String
name|headerMarker
parameter_list|,
name|String
name|defaultVersion
parameter_list|)
throws|throws
name|IOException
block|{
comment|// read first line
name|String
name|header
init|=
name|readLine
argument_list|()
decl_stmt|;
comment|// some pdf-documents are broken and the pdf-version is in one of the following lines
if|if
condition|(
operator|!
name|header
operator|.
name|contains
argument_list|(
name|headerMarker
argument_list|)
condition|)
block|{
name|header
operator|=
name|readLine
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|header
operator|.
name|contains
argument_list|(
name|headerMarker
argument_list|)
condition|)
block|{
comment|// if a line starts with a digit, it has to be the first one with data in it
if|if
condition|(
operator|(
name|header
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|Character
operator|.
name|isDigit
argument_list|(
name|header
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
name|header
operator|=
name|readLine
argument_list|()
expr_stmt|;
block|}
block|}
comment|// nothing found
if|if
condition|(
operator|!
name|header
operator|.
name|contains
argument_list|(
name|headerMarker
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|//sometimes there is some garbage in the header before the header
comment|//actually starts, so lets try to find the header first.
name|int
name|headerStart
init|=
name|header
operator|.
name|indexOf
argument_list|(
name|headerMarker
argument_list|)
decl_stmt|;
comment|// greater than zero because if it is zero then there is no point of trimming
if|if
condition|(
name|headerStart
operator|>
literal|0
condition|)
block|{
comment|//trim off any leading characters
name|header
operator|=
name|header
operator|.
name|substring
argument_list|(
name|headerStart
argument_list|,
name|header
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// This is used if there is garbage after the header on the same line
if|if
condition|(
name|header
operator|.
name|startsWith
argument_list|(
name|headerMarker
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|header
operator|.
name|matches
argument_list|(
name|headerMarker
operator|+
literal|"\\d.\\d"
argument_list|)
condition|)
block|{
if|if
condition|(
name|header
operator|.
name|length
argument_list|()
operator|<
name|headerMarker
operator|.
name|length
argument_list|()
operator|+
literal|3
condition|)
block|{
comment|// No version number at all, set to 1.4 as default
name|header
operator|=
name|headerMarker
operator|+
name|defaultVersion
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"No version found, set to "
operator|+
name|defaultVersion
operator|+
literal|" as default."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|headerGarbage
init|=
name|header
operator|.
name|substring
argument_list|(
name|headerMarker
operator|.
name|length
argument_list|()
operator|+
literal|3
argument_list|,
name|header
operator|.
name|length
argument_list|()
argument_list|)
operator|+
literal|"\n"
decl_stmt|;
name|header
operator|=
name|header
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|headerMarker
operator|.
name|length
argument_list|()
operator|+
literal|3
argument_list|)
expr_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
name|headerGarbage
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|document
operator|.
name|setHeaderString
argument_list|(
name|header
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|header
operator|.
name|startsWith
argument_list|(
name|headerMarker
argument_list|)
condition|)
block|{
name|float
name|pdfVersion
init|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|header
operator|.
name|substring
argument_list|(
name|headerMarker
operator|.
name|length
argument_list|()
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|header
operator|.
name|length
argument_list|()
argument_list|,
name|headerMarker
operator|.
name|length
argument_list|()
operator|+
literal|3
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|document
operator|.
name|setVersion
argument_list|(
name|pdfVersion
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error getting version: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// rewind
name|pdfSource
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|isFDFDocment
operator|=
name|FDF_HEADER
operator|.
name|equals
argument_list|(
name|headerMarker
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * The document catalog can also have a /Version parameter which overrides the version specified      * in the header if, and only if it is greater.      *      * @param parsedTrailer the parsed catalog in the trailer      */
specifier|private
name|void
name|readVersionInTrailer
parameter_list|(
name|COSDictionary
name|parsedTrailer
parameter_list|)
block|{
name|COSObject
name|root
init|=
operator|(
name|COSObject
operator|)
name|parsedTrailer
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
name|COSBase
name|item
init|=
name|root
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|instanceof
name|COSName
condition|)
block|{
name|COSName
name|version
init|=
operator|(
name|COSName
operator|)
name|item
decl_stmt|;
name|float
name|trailerVersion
init|=
name|Float
operator|.
name|valueOf
argument_list|(
name|version
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailerVersion
operator|>
name|document
operator|.
name|getVersion
argument_list|()
condition|)
block|{
name|document
operator|.
name|setVersion
argument_list|(
name|trailerVersion
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|item
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Incorrect /Version entry is ignored: "
operator|+
name|item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This will parse the xref table from the stream and add it to the state      * The XrefTable contents are ignored.      * @param startByteOffset the offset to start at      * @return false on parsing error      * @throws IOException If an IO error occurs.      */
specifier|protected
name|boolean
name|parseXrefTable
parameter_list|(
name|long
name|startByteOffset
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pdfSource
operator|.
name|peek
argument_list|()
operator|!=
literal|'x'
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|xref
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|xref
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|"xref"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check for trailer after xref
name|String
name|str
init|=
name|readString
argument_list|()
decl_stmt|;
name|byte
index|[]
name|b
init|=
name|str
operator|.
name|getBytes
argument_list|(
name|ISO_8859_1
argument_list|)
decl_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// signal start of new XRef
name|xrefTrailerResolver
operator|.
name|nextXrefObj
argument_list|(
name|startByteOffset
argument_list|,
name|XRefType
operator|.
name|TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
literal|"trailer"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"skipping empty xref table"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/**          * Xref tables can have multiple sections.          * Each starts with a starting object id and a count.          */
while|while
condition|(
literal|true
condition|)
block|{
name|long
name|currObjID
init|=
name|readObjectNumber
argument_list|()
decl_stmt|;
comment|// first obj id
name|long
name|count
init|=
name|readLong
argument_list|()
decl_stmt|;
comment|// the number of objects in the xref table
name|skipSpaces
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pdfSource
operator|.
name|isEOF
argument_list|()
operator|||
name|isEndOfName
argument_list|(
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|pdfSource
operator|.
name|peek
argument_list|()
operator|==
literal|'t'
condition|)
block|{
break|break;
block|}
comment|//Ignore table contents
name|String
name|currentLine
init|=
name|readLine
argument_list|()
decl_stmt|;
name|String
index|[]
name|splitString
init|=
name|currentLine
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|;
if|if
condition|(
name|splitString
operator|.
name|length
operator|<
literal|3
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"invalid xref line: "
operator|+
name|currentLine
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* This supports the corrupt table as reported in                  * PDFBOX-474 (XXXX XXX XX n) */
if|if
condition|(
name|splitString
index|[
name|splitString
operator|.
name|length
operator|-
literal|1
index|]
operator|.
name|equals
argument_list|(
literal|"n"
argument_list|)
condition|)
block|{
try|try
block|{
name|long
name|currOffset
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|splitString
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|currGenID
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|splitString
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|currObjID
argument_list|,
name|currGenID
argument_list|)
decl_stmt|;
name|xrefTrailerResolver
operator|.
name|setXRef
argument_list|(
name|objKey
argument_list|,
name|currOffset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|splitString
index|[
literal|2
index|]
operator|.
name|equals
argument_list|(
literal|"f"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupt XRefTable Entry - ObjID:"
operator|+
name|currObjID
argument_list|)
throw|;
block|}
name|currObjID
operator|++
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
argument_list|<
literal|'0'
operator|||
name|c
argument_list|>
literal|'9'
condition|)
block|{
break|break;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Fills XRefTrailerResolver with data of given stream.      * Stream must be of type XRef.      * @param stream the stream to be read      * @param objByteOffset the offset to start at      * @param isStandalone should be set to true if the stream is not part of a hybrid xref table      * @throws IOException if there is an error parsing the stream      */
specifier|private
name|void
name|parseXrefStream
parameter_list|(
name|COSStream
name|stream
parameter_list|,
name|long
name|objByteOffset
parameter_list|,
name|boolean
name|isStandalone
parameter_list|)
throws|throws
name|IOException
block|{
comment|// the cross reference stream of a hybrid xref table will be added to the existing one
comment|// and we must not override the offset and the trailer
if|if
condition|(
name|isStandalone
condition|)
block|{
name|xrefTrailerResolver
operator|.
name|nextXrefObj
argument_list|(
name|objByteOffset
argument_list|,
name|XRefType
operator|.
name|STREAM
argument_list|)
expr_stmt|;
name|xrefTrailerResolver
operator|.
name|setTrailer
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
name|PDFXrefStreamParser
name|parser
init|=
operator|new
name|PDFXrefStreamParser
argument_list|(
name|stream
argument_list|,
name|document
argument_list|,
name|xrefTrailerResolver
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
block|}
comment|/**      * This will get the document that was parsed.  parse() must be called before this is called.      * When you are done with this document you must call close() on it to release      * resources.      *      * @return The document that was parsed.      *      * @throws IOException If there is an error getting the document.      */
specifier|public
name|COSDocument
name|getDocument
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|document
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"You must call parse() before calling getDocument()"
argument_list|)
throw|;
block|}
return|return
name|document
return|;
block|}
comment|/**      * This will get the FDF document that was parsed.  When you are done with      * this document you must call close() on it to release resources.      *      * @return The document at the PD layer.      *      * @throws IOException If there is an error getting the document.      */
specifier|public
name|FDFDocument
name|getFDFDocument
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|FDFDocument
argument_list|(
name|getDocument
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

