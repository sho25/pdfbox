begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|KeyStore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|CryptographyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|PushBackInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessBufferedFileInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDPage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|AccessPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|DecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|PDEncryptionDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|PublicKeyDecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|SecurityHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|SecurityHandlersManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|StandardDecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|persistence
operator|.
name|util
operator|.
name|COSObjectKey
import|;
end_import

begin_comment
comment|/**  * PDFParser which first reads startxref and xref tables in order to know valid  * objects and parse only these objects. Thus it is closer to a conforming parser  * than the sequential reading of {@link PDFParser}.  *   * This class can be used as a {@link PDFParser} replacement. First {@link #parse()}  * must be called before page objects can be retrieved, e.g. {@link #getPDDocument()}.  *   * This class is a much enhanced version of<code>QuickParser</code> presented in   *<a href="https://issues.apache.org/jira/browse/PDFBOX-1104">PDFBOX-1104</a>  * by Jeremy Villalobos.  */
end_comment

begin_class
specifier|public
class|class
name|NonSequentialPDFParser
extends|extends
name|PDFParser
block|{
specifier|public
specifier|final
specifier|static
name|String
name|SYSPROP_PARSEMINIMAL
init|=
literal|"org.apache.pdfbox.pdfparser.nonSequentialPDFParser.parseMinimal"
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|String
name|SYSPROP_EOFLOOKUPRANGE
init|=
literal|"org.apache.pdfbox.pdfparser.nonSequentialPDFParser.eofLookupRange"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|InputStream
name|EMPTY_INPUT_STREAM
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_TRAIL_BYTECOUNT
init|=
literal|2048
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|char
index|[]
name|EOF_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'%'
block|,
literal|'%'
block|,
literal|'E'
block|,
literal|'O'
block|,
literal|'F'
block|}
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|char
index|[]
name|STARTXREF_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'s'
block|,
literal|'t'
block|,
literal|'a'
block|,
literal|'r'
block|,
literal|'t'
block|,
literal|'x'
block|,
literal|'r'
block|,
literal|'e'
block|,
literal|'f'
block|}
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|char
index|[]
name|OBJ_MARKER
init|=
operator|new
name|char
index|[]
block|{
literal|'o'
block|,
literal|'b'
block|,
literal|'j'
block|}
decl_stmt|;
specifier|private
specifier|final
name|File
name|file
decl_stmt|;
specifier|private
specifier|final
name|RandomAccessBufferedFileInputStream
name|raStream
decl_stmt|;
specifier|private
name|SecurityHandler
name|securityHandler
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|keyStoreFilename
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|alias
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|password
init|=
literal|""
decl_stmt|;
specifier|private
name|int
name|readTrailBytes
init|=
name|DEFAULT_TRAIL_BYTECOUNT
decl_stmt|;
comment|// how many trailing bytes to read for EOF marker
comment|/** If<code>true</code> object references in catalog are not followed; 		 *  pro: page objects will be only parsed when needed; cons: some information of catalog 		 *  might not be available (e.g. outline). 		 *  Catalog parsing without pages is not an option since a number of entries will 		 *  also refer to page objects (like OpenAction). 		 */
specifier|private
name|boolean
name|parseMinimalCatalog
init|=
literal|"true"
operator|.
name|equals
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|SYSPROP_PARSEMINIMAL
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
name|boolean
name|initialParseDone
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|allPagesParsed
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|NonSequentialPDFParser
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// ------------------------------------------------------------------------
comment|/** Constructs parser for given file using memory buffer. */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
name|this
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Constructs parser for given file using given buffer for temporary storage. */
specifier|public
name|NonSequentialPDFParser
parameter_list|(
name|File
name|pdfFile
parameter_list|,
name|RandomAccess
name|raBuf
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
name|super
argument_list|(
name|EMPTY_INPUT_STREAM
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|String
name|eofLookupRangeStr
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|SYSPROP_EOFLOOKUPRANGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|eofLookupRangeStr
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|setEOFLookupRange
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|eofLookupRangeStr
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"System property "
operator|+
name|SYSPROP_EOFLOOKUPRANGE
operator|+
literal|" does not contain an integer value, but: '"
operator|+
name|eofLookupRangeStr
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
name|file
operator|=
name|pdfFile
expr_stmt|;
name|raStream
operator|=
operator|new
name|RandomAccessBufferedFileInputStream
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|setDocument
argument_list|(
operator|(
name|raBuf
operator|==
literal|null
operator|)
condition|?
operator|new
name|COSDocument
argument_list|(
operator|new
name|RandomAccessBuffer
argument_list|()
argument_list|,
literal|false
argument_list|)
else|:
operator|new
name|COSDocument
argument_list|(
name|raBuf
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|pdfSource
operator|=
operator|new
name|PushBackInputStream
argument_list|(
name|raStream
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** Sets how many trailing bytes of PDF file are searched for 		 *  EOF marker and 'startxref' marker. 		 *  If not set we use default value {@link #DEFAULT_TRAIL_BYTECOUNT}. 		 *   		 *<p<We check that new value is at least 16. However for practical use 		 *  cases this value should not be lower than 1000; even 2000 		 *  was found to not be enough in some cases where some trailing 		 *  garbage like HTML snippets followed the EOF marker.</p> 		 *   		 *<p>In case system property {@link #SYSPROP_EOFLOOKUPRANGE} is defined 		 *  this value will be set on initialization but can be overwritten later.</p> 		 */
specifier|public
name|void
name|setEOFLookupRange
parameter_list|(
name|int
name|byteCount
parameter_list|)
block|{
if|if
condition|(
name|byteCount
operator|>
literal|15
condition|)
name|readTrailBytes
operator|=
name|byteCount
expr_stmt|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** 		 * The initial parse will first parse only the trailer, the xrefstart and  		 * all xref tables to have a pointer (offset) to all the pdf's objects. 		 * It can handle linearized pdfs, which will have an xref at the  		 * end pointing to an xref at the beginning of the file. 		 * Last the root object is parsed. 		 *  		 * @throws IOException 		 */
specifier|private
name|void
name|initialParse
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|long
name|startxrefOff
init|=
name|getStartxrefOffset
argument_list|()
decl_stmt|;
comment|// ---- parse startxref
name|setPdfSource
argument_list|(
name|startxrefOff
argument_list|)
expr_stmt|;
name|parseStartXref
argument_list|()
expr_stmt|;
specifier|final
name|long
name|xrefOffset
init|=
name|document
operator|.
name|getStartXref
argument_list|()
decl_stmt|;
name|long
name|prev
init|=
name|xrefOffset
decl_stmt|;
comment|// ---- parse whole chain of xref tables/object streams using PREV reference
while|while
condition|(
name|prev
operator|>
operator|-
literal|1
condition|)
block|{
comment|// seek to xref table
name|setPdfSource
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|// -- parse xref
if|if
condition|(
name|pdfSource
operator|.
name|peek
argument_list|()
operator|==
literal|'x'
condition|)
block|{
comment|// xref table and trailer
comment|// use existing parser to parse xref table
name|parseXrefTable
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|// parse the last trailer.
name|parseTrailer
argument_list|()
expr_stmt|;
name|COSDictionary
name|trailer
init|=
name|xrefTrailerResolver
operator|.
name|getCurrentTrailer
argument_list|()
decl_stmt|;
name|prev
operator|=
name|trailer
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// xref stream
name|prev
operator|=
name|parseXrefObjStream
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ---- build valid xrefs out of the xref chain
name|xrefTrailerResolver
operator|.
name|setStartxref
argument_list|(
name|xrefOffset
argument_list|)
expr_stmt|;
name|document
operator|.
name|setTrailer
argument_list|(
name|xrefTrailerResolver
operator|.
name|getTrailer
argument_list|()
argument_list|)
expr_stmt|;
comment|// ---- prepare encryption if necessary
name|COSBase
name|trailerEncryptItem
init|=
name|document
operator|.
name|getTrailer
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
decl_stmt|;
if|if
condition|(
name|trailerEncryptItem
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|trailerEncryptItem
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|trailerEncryptObj
init|=
operator|(
name|COSObject
operator|)
name|trailerEncryptItem
decl_stmt|;
name|parseObjectDynamically
argument_list|(
name|trailerEncryptObj
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|PDEncryptionDictionary
name|encParameters
init|=
operator|new
name|PDEncryptionDictionary
argument_list|(
name|document
operator|.
name|getEncryptionDictionary
argument_list|()
argument_list|)
decl_stmt|;
name|DecryptionMaterial
name|decryptionMaterial
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|keyStoreFilename
operator|!=
literal|null
condition|)
block|{
name|KeyStore
name|ks
init|=
name|KeyStore
operator|.
name|getInstance
argument_list|(
literal|"PKCS12"
argument_list|)
decl_stmt|;
name|ks
operator|.
name|load
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|keyStoreFilename
argument_list|)
argument_list|,
name|password
operator|.
name|toCharArray
argument_list|()
argument_list|)
expr_stmt|;
name|decryptionMaterial
operator|=
operator|new
name|PublicKeyDecryptionMaterial
argument_list|(
name|ks
argument_list|,
name|alias
argument_list|,
name|password
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decryptionMaterial
operator|=
operator|new
name|StandardDecryptionMaterial
argument_list|(
name|password
argument_list|)
expr_stmt|;
block|}
name|securityHandler
operator|=
name|SecurityHandlersManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getSecurityHandler
argument_list|(
name|encParameters
operator|.
name|getFilter
argument_list|()
argument_list|)
expr_stmt|;
name|securityHandler
operator|.
name|prepareForDecryption
argument_list|(
name|encParameters
argument_list|,
name|document
operator|.
name|getDocumentID
argument_list|()
argument_list|,
name|decryptionMaterial
argument_list|)
expr_stmt|;
name|AccessPermission
name|permission
init|=
name|securityHandler
operator|.
name|getCurrentAccessPermission
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|permission
operator|.
name|canExtractContent
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"PDF file '"
operator|+
name|file
operator|.
name|getPath
argument_list|()
operator|+
literal|"' does not allow extracting content."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"PDF file '"
operator|+
name|file
operator|.
name|getPath
argument_list|()
operator|+
literal|"' allows content extraction."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error ("
operator|+
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|") while creating security handler for decryption: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|// ---- parse catalog or root object
name|COSObject
name|root
init|=
operator|(
name|COSObject
operator|)
name|xrefTrailerResolver
operator|.
name|getTrailer
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing root object specification in trailer."
argument_list|)
throw|;
name|parseObjectDynamically
argument_list|(
name|root
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// ---- resolve all objects (including pages)
if|if
condition|(
operator|!
name|parseMinimalCatalog
condition|)
block|{
name|COSObject
name|catalogObj
init|=
name|document
operator|.
name|getCatalog
argument_list|()
decl_stmt|;
if|if
condition|(
name|catalogObj
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|catalogObj
operator|.
name|getObject
argument_list|()
operator|instanceof
name|COSDictionary
condition|)
block|{
name|parseDictObjects
argument_list|(
operator|(
name|COSDictionary
operator|)
name|catalogObj
operator|.
name|getObject
argument_list|()
argument_list|,
operator|(
name|COSName
index|[]
operator|)
literal|null
argument_list|)
expr_stmt|;
name|allPagesParsed
operator|=
literal|true
expr_stmt|;
name|document
operator|.
name|setDecrypted
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|initialParseDone
operator|=
literal|true
expr_stmt|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** Parses an xref object stream starting with indirect object id. 		 *   		 *  @return value of PREV item in dictionary or<code>-1</code> if no such item exists 		 */
specifier|private
name|long
name|parseXrefObjStream
parameter_list|(
name|long
name|objByteOffset
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- parse indirect object head
name|readInt
argument_list|()
expr_stmt|;
name|readInt
argument_list|()
expr_stmt|;
name|readPattern
argument_list|(
name|OBJ_MARKER
argument_list|)
expr_stmt|;
name|COSDictionary
name|dict
init|=
name|parseCOSDictionary
argument_list|()
decl_stmt|;
name|COSStream
name|xrefStream
init|=
name|parseCOSStream
argument_list|(
name|dict
argument_list|,
name|getDocument
argument_list|()
operator|.
name|getScratchFile
argument_list|()
argument_list|)
decl_stmt|;
name|parseXrefStream
argument_list|(
name|xrefStream
argument_list|,
operator|(
name|int
operator|)
name|objByteOffset
argument_list|)
expr_stmt|;
return|return
name|dict
operator|.
name|getLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** Get current offset in file at which next byte would be read. */
specifier|private
specifier|final
name|long
name|getPdfSourceOffset
parameter_list|()
block|{
return|return
name|pdfSource
operator|.
name|getOffset
argument_list|()
return|;
block|}
comment|/** Sets {@link #pdfSource} to start next parsing at given file offset. */
specifier|private
specifier|final
name|void
name|setPdfSource
parameter_list|(
name|long
name|fileOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|pdfSource
operator|.
name|seek
argument_list|(
name|fileOffset
argument_list|)
expr_stmt|;
comment|// alternative using 'old fashioned' input stream
comment|//		if ( pdfSource != null )
comment|//			pdfSource.close();
comment|//
comment|//		pdfSource = new PushBackInputStream(
comment|//        					new BufferedInputStream(
comment|//        						new FileInputStream( file ), 16384),  4096);
comment|//		pdfSource.skip( _fileOffset );
block|}
comment|/** Enable handling of alternative pdfSource implementation. */
specifier|private
specifier|final
name|void
name|releasePdfSourceInputStream
parameter_list|()
throws|throws
name|IOException
block|{
comment|//		if ( pdfSource != null )
comment|//			pdfSource.close();
block|}
specifier|private
specifier|final
name|void
name|closeFileStream
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pdfSource
operator|!=
literal|null
condition|)
name|pdfSource
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** Looks for and parses startxref. We first look for last '%%EOF' marker 		 *  (within last {@link #DEFAULT_TRAIL_BYTECOUNT} bytes (or range set via 		 *  {@link #setEOFLookupRange(int)}) and go back to find<code>startxref</code>. */
specifier|private
specifier|final
name|long
name|getStartxrefOffset
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|buf
decl_stmt|;
name|long
name|skipBytes
decl_stmt|;
comment|// ---- read trailing bytes into buffer
specifier|final
name|long
name|fileLen
init|=
name|file
operator|.
name|length
argument_list|()
decl_stmt|;
name|FileInputStream
name|fIn
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fIn
operator|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
expr_stmt|;
specifier|final
name|int
name|trailByteCount
init|=
operator|(
name|fileLen
operator|<
name|readTrailBytes
operator|)
condition|?
operator|(
name|int
operator|)
name|fileLen
else|:
name|readTrailBytes
decl_stmt|;
name|buf
operator|=
operator|new
name|byte
index|[
name|trailByteCount
index|]
expr_stmt|;
name|fIn
operator|.
name|skip
argument_list|(
name|skipBytes
operator|=
name|fileLen
operator|-
name|trailByteCount
argument_list|)
expr_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|readBytes
decl_stmt|;
while|while
condition|(
name|off
operator|<
name|trailByteCount
condition|)
block|{
name|readBytes
operator|=
name|fIn
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|trailByteCount
operator|-
name|off
argument_list|)
expr_stmt|;
comment|// in order to not get stuck in a loop we check readBytes (this should never happen)
if|if
condition|(
name|readBytes
operator|<
literal|1
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No more bytes to read for trailing buffer, but expected: "
operator|+
operator|(
name|trailByteCount
operator|-
name|off
operator|)
argument_list|)
throw|;
name|off
operator|+=
name|readBytes
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|fIn
operator|!=
literal|null
condition|)
try|try
block|{
name|fIn
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
block|}
comment|// ---- find last '%%EOF'
name|int
name|bufOff
init|=
name|lastIndexOf
argument_list|(
name|EOF_MARKER
argument_list|,
name|buf
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufOff
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing end of file marker '"
operator|+
operator|(
operator|new
name|String
argument_list|(
name|EOF_MARKER
argument_list|)
operator|)
operator|+
literal|"'"
argument_list|)
throw|;
comment|// ---- find last startxref preceding EOF marker
name|bufOff
operator|=
name|lastIndexOf
argument_list|(
name|STARTXREF_MARKER
argument_list|,
name|buf
argument_list|,
name|bufOff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufOff
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing 'startxref' marker."
argument_list|)
throw|;
return|return
name|skipBytes
operator|+
name|bufOff
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** Searches last appearance of pattern within buffer. Lookup before _lastOff 		 *  and goes back until 0. 		 *   		 *  @param pattern  pattern to search for 		 *  @param buf      buffer to search pattern in 		 *  @param endOff   offset (exclusive) where lookup starts at 		 *   		 *  @return  start offset of pattern within buffer or<code>-1</code> if pattern could not be found  		 */
specifier|private
specifier|final
name|int
name|lastIndexOf
parameter_list|(
specifier|final
name|char
index|[]
name|pattern
parameter_list|,
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
specifier|final
name|int
name|endOff
parameter_list|)
block|{
specifier|final
name|int
name|lastPatternChOff
init|=
name|pattern
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|bufOff
init|=
name|endOff
decl_stmt|;
name|int
name|patOff
init|=
name|lastPatternChOff
decl_stmt|;
name|char
name|lookupCh
init|=
name|pattern
index|[
name|patOff
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|bufOff
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|bufOff
index|]
operator|==
name|lookupCh
condition|)
block|{
if|if
condition|(
operator|--
name|patOff
operator|<
literal|0
condition|)
comment|// whole pattern matched
return|return
name|bufOff
return|;
comment|// matched current char, advance to preceding one
name|lookupCh
operator|=
name|pattern
index|[
name|patOff
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|patOff
operator|<
name|lastPatternChOff
condition|)
block|{
comment|// no char match but already matched some chars; reset
name|lookupCh
operator|=
name|pattern
index|[
name|patOff
operator|=
name|lastPatternChOff
index|]
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** Reads given pattern from {@link #pdfSource}. Skipping whitespace at start and end. 		 *  		 * @throws IOException if pattern could not be read 		 */
specifier|private
specifier|final
name|void
name|readPattern
parameter_list|(
specifier|final
name|char
index|[]
name|pattern
parameter_list|)
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
for|for
control|(
name|char
name|c
range|:
name|pattern
control|)
block|{
if|if
condition|(
name|pdfSource
operator|.
name|read
argument_list|()
operator|!=
name|c
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected pattern '"
operator|+
operator|new
name|String
argument_list|(
name|pattern
argument_list|)
operator|+
literal|" but missed at character '"
operator|+
name|c
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
comment|// ------------------------------------------------------------------------
specifier|private
name|COSDictionary
name|pagesDictionary
init|=
literal|null
decl_stmt|;
comment|/** Returns PAGES {@link COSDictionary} object or throws {@link IOException} 		 *  if PAGES dictionary does not exist. */
specifier|private
name|COSDictionary
name|getPagesObject
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pagesDictionary
operator|!=
literal|null
condition|)
return|return
name|pagesDictionary
return|;
name|COSObject
name|pages
init|=
operator|(
name|COSObject
operator|)
name|document
operator|.
name|getCatalog
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|PAGES
argument_list|)
decl_stmt|;
if|if
condition|(
name|pages
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing PAGES entry in document catalog."
argument_list|)
throw|;
name|COSBase
name|object
init|=
name|parseObjectDynamically
argument_list|(
name|pages
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|object
operator|instanceof
name|COSDictionary
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"PAGES not a dictionary object, but: "
operator|+
name|object
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
name|pagesDictionary
operator|=
operator|(
name|COSDictionary
operator|)
name|object
expr_stmt|;
return|return
name|pagesDictionary
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** Parses all objects needed by pages and closes input stream. */
annotation|@
name|Override
specifier|public
name|void
name|parse
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|exceptionOccurred
init|=
literal|true
decl_stmt|;
comment|// set to false if all is processed
try|try
block|{
if|if
condition|(
operator|!
name|initialParseDone
condition|)
name|initialParse
argument_list|()
expr_stmt|;
specifier|final
name|int
name|pageCount
init|=
name|getPageNumber
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|allPagesParsed
condition|)
block|{
for|for
control|(
name|int
name|pNr
init|=
literal|0
init|;
name|pNr
operator|<
name|pageCount
condition|;
name|pNr
operator|++
control|)
block|{
name|getPage
argument_list|(
name|pNr
argument_list|)
expr_stmt|;
block|}
name|allPagesParsed
operator|=
literal|true
expr_stmt|;
name|document
operator|.
name|setDecrypted
argument_list|()
expr_stmt|;
block|}
name|exceptionOccurred
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|closeFileStream
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
if|if
condition|(
name|exceptionOccurred
operator|&&
operator|(
name|document
operator|!=
literal|null
operator|)
condition|)
try|try
block|{
name|document
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{}
block|}
block|}
comment|// ------------------------------------------------------------------------
comment|/** Returns security handler of the document or<code>null</code> if document 		 *  is not encrypted or {@link #parse()} wasn't called before. */
specifier|public
name|SecurityHandler
name|getSecurityHandler
parameter_list|()
block|{
return|return
name|securityHandler
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** 		 * Returns the number of pages in a document. 		 *  		 * @throws IOException  if PAGES or other needed object is missing  		 */
specifier|public
name|int
name|getPageNumber
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|pageCount
init|=
name|getPagesObject
argument_list|()
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|COUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageCount
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No page number specified."
argument_list|)
throw|;
return|return
name|pageCount
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** 		 * Returns the page requested with all the objects loaded into it. 		 *  		 * @param num starts from 0 to the number of pages. 		 * @return 		 * @throws IOException  		 */
specifier|public
name|PDPage
name|getPage
parameter_list|(
name|int
name|pageNr
parameter_list|)
throws|throws
name|IOException
block|{
name|getPagesObject
argument_list|()
expr_stmt|;
comment|// ---- get list of top level pages
name|COSArray
name|kids
init|=
operator|(
name|COSArray
operator|)
name|pagesDictionary
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|KIDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|kids
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing 'Kids' entry in pages dictionary."
argument_list|)
throw|;
comment|// ---- get page we are looking for (possibly going recursively into subpages)
name|COSObject
name|pageObj
init|=
name|getPageObject
argument_list|(
name|pageNr
argument_list|,
name|kids
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageObj
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Page "
operator|+
name|pageNr
operator|+
literal|" not found."
argument_list|)
throw|;
comment|// ---- parse all objects necessary to load page.
name|COSDictionary
name|pageDict
init|=
operator|(
name|COSDictionary
operator|)
name|pageObj
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|parseMinimalCatalog
operator|&&
operator|(
operator|!
name|allPagesParsed
operator|)
condition|)
block|{
comment|// parse page resources since we did not do this on start
name|COSDictionary
name|resDict
init|=
operator|(
name|COSDictionary
operator|)
name|pageDict
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|RESOURCES
argument_list|)
decl_stmt|;
name|parseDictObjects
argument_list|(
name|resDict
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|PDPage
argument_list|(
name|pageDict
argument_list|)
return|;
block|}
comment|/** 		 * Returns the object for a specific page. 		 * The page tree is made up of kids.  The kids have COSArray with COSObjects 		 * inside of them. The COSObject can be parsed using the dynamic parsing method 		 * We want to only parse the minimum COSObjects and still return a complete page. 		 * ready to be used. 		 *  		 * @param num  the requested page number; numbering starts with 0 		 * @param startKids Kids array to start with looking up page number 		 * @param startPageCount 		 *  		 * @return  page object or<code>null</code> if no such page exists 		 *  		 * @throws IOException 		 */
specifier|private
name|COSObject
name|getPageObject
parameter_list|(
name|int
name|num
parameter_list|,
name|COSArray
name|startKids
parameter_list|,
name|int
name|startPageCount
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|curPageCount
init|=
name|startPageCount
decl_stmt|;
name|Iterator
argument_list|<
name|COSBase
argument_list|>
name|kidsIter
init|=
name|startKids
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|kidsIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|COSObject
name|obj
init|=
operator|(
name|COSObject
operator|)
name|kidsIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|COSBase
name|base
init|=
name|obj
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|base
operator|==
literal|null
condition|)
block|{
name|base
operator|=
name|parseObjectDynamically
argument_list|(
name|obj
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|obj
operator|.
name|setObject
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
name|COSDictionary
name|dic
init|=
operator|(
name|COSDictionary
operator|)
name|base
decl_stmt|;
name|int
name|count
init|=
name|dic
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|COUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
block|{
comment|// skip this branch if requested page comes later
if|if
condition|(
operator|(
name|curPageCount
operator|+
name|count
operator|)
operator|<=
name|num
condition|)
block|{
name|curPageCount
operator|+=
name|count
expr_stmt|;
continue|continue;
block|}
block|}
name|COSArray
name|kids
init|=
operator|(
name|COSArray
operator|)
name|dic
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|KIDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|kids
operator|!=
literal|null
condition|)
block|{
comment|// recursively scan subpages
name|COSObject
name|ans
init|=
name|getPageObject
argument_list|(
name|num
argument_list|,
name|kids
argument_list|,
name|curPageCount
argument_list|)
decl_stmt|;
comment|// if ans is not null, we got what we were looking for
if|if
condition|(
name|ans
operator|!=
literal|null
condition|)
block|{
return|return
name|ans
return|;
block|}
block|}
else|else
block|{
comment|// found page?
if|if
condition|(
name|curPageCount
operator|==
name|num
condition|)
block|{
return|return
name|obj
return|;
block|}
comment|// page has no kids and it is not the page we are looking for
name|curPageCount
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** Creates a unique object id using object number and object generation number.  		 *  (requires object number< 2^31)) */
specifier|private
specifier|final
name|long
name|getObjectId
parameter_list|(
specifier|final
name|COSObject
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
operator|.
name|longValue
argument_list|()
operator|<<
literal|32
operator|)
operator||
name|obj
operator|.
name|getGenerationNumber
argument_list|()
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/** Adds all from newObjects to toBeParsedList if it is not an COSObject 		 *  or we didn't add this COSObject already (checked via addedObjects). */
specifier|private
specifier|final
name|void
name|addNewToList
parameter_list|(
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
parameter_list|,
specifier|final
name|Collection
argument_list|<
name|COSBase
argument_list|>
name|newObjects
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
parameter_list|)
block|{
for|for
control|(
name|COSBase
name|newObject
range|:
name|newObjects
control|)
block|{
if|if
condition|(
name|newObject
operator|instanceof
name|COSObject
condition|)
block|{
specifier|final
name|long
name|objId
init|=
name|getObjectId
argument_list|(
operator|(
name|COSObject
operator|)
name|newObject
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|addedObjects
operator|.
name|add
argument_list|(
name|objId
argument_list|)
condition|)
continue|continue;
block|}
name|toBeParsedList
operator|.
name|add
argument_list|(
name|newObject
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Adds newObject to toBeParsedList if it is not an COSObject 		 *  or we didn't add this COSObject already (checked via addedObjects). */
specifier|private
specifier|final
name|void
name|addNewToList
parameter_list|(
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
parameter_list|,
specifier|final
name|COSBase
name|newObject
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
parameter_list|)
block|{
if|if
condition|(
name|newObject
operator|instanceof
name|COSObject
condition|)
block|{
specifier|final
name|long
name|objId
init|=
name|getObjectId
argument_list|(
operator|(
name|COSObject
operator|)
name|newObject
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|addedObjects
operator|.
name|add
argument_list|(
name|objId
argument_list|)
condition|)
return|return;
block|}
name|toBeParsedList
operator|.
name|add
argument_list|(
name|newObject
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * Will parse every object necessary to load a single page from the pdf document. 		 * We try our best to order objects according to offset in file before reading 		 * to minimize seek operations. 		 *  		 * @param dict the COSObject from the parent pages. 		 * @param excludeObjects dictionary object reference entries with these names will not be parsed 		 *  		 * @throws IOException 		 */
specifier|private
name|void
name|parseDictObjects
parameter_list|(
name|COSDictionary
name|dict
parameter_list|,
name|COSName
modifier|...
name|excludeObjects
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- create queue for objects waiting for further parsing
specifier|final
name|Queue
argument_list|<
name|COSBase
argument_list|>
name|toBeParsedList
init|=
operator|new
name|LinkedList
argument_list|<
name|COSBase
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|COSObject
argument_list|>
argument_list|>
name|objToBeParsed
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|List
argument_list|<
name|COSObject
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// offset ordered object map
comment|// in case of compressed objects offset points to stmObj
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|parsedObjects
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|addedObjects
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
comment|// ---- add objects not to be parsed to list of already parsed objects
if|if
condition|(
name|excludeObjects
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|COSName
name|objName
range|:
name|excludeObjects
control|)
block|{
name|COSBase
name|baseObj
init|=
name|dict
operator|.
name|getItem
argument_list|(
name|objName
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|parsedObjects
operator|.
name|add
argument_list|(
name|getObjectId
argument_list|(
operator|(
name|COSObject
operator|)
name|baseObj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|dict
operator|.
name|getValues
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
comment|// ---- go through objects to be parsed
while|while
condition|(
operator|!
operator|(
name|toBeParsedList
operator|.
name|isEmpty
argument_list|()
operator|&&
name|objToBeParsed
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
comment|// -- first get all COSObject from other kind of objects and
comment|//    put them in objToBeParsed; afterwards toBeParsedList is empty
name|COSBase
name|baseObj
decl_stmt|;
while|while
condition|(
operator|(
name|baseObj
operator|=
name|toBeParsedList
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|baseObj
operator|instanceof
name|COSStream
condition|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
operator|(
operator|(
name|COSStream
operator|)
name|baseObj
operator|)
operator|.
name|getValues
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseObj
operator|instanceof
name|COSDictionary
condition|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
operator|(
operator|(
name|COSDictionary
operator|)
name|baseObj
operator|)
operator|.
name|getValues
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseObj
operator|instanceof
name|COSArray
condition|)
block|{
specifier|final
name|Iterator
argument_list|<
name|COSBase
argument_list|>
name|arrIter
init|=
operator|(
operator|(
name|COSArray
operator|)
name|baseObj
operator|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|arrIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|arrIter
operator|.
name|next
argument_list|()
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|baseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|obj
init|=
operator|(
name|COSObject
operator|)
name|baseObj
decl_stmt|;
name|long
name|objId
init|=
name|getObjectId
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|obj
operator|.
name|getGenerationNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|parsedObjects
operator|.
name|contains
argument_list|(
name|objId
argument_list|)
comment|/*|| document.hasObjectInPool( objKey ) */
operator|)
condition|)
block|{
name|Long
name|fileOffset
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileOffset
operator|!=
literal|null
condition|)
comment|// it is allowed that object references point to null, thus we have to test
block|{
if|if
condition|(
name|fileOffset
operator|>
literal|0
condition|)
block|{
name|objToBeParsed
operator|.
name|put
argument_list|(
name|fileOffset
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// negative offset means we have a compressed object within object stream;
comment|// get offset of object stream
name|fileOffset
operator|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
operator|new
name|COSObjectKey
argument_list|(
operator|-
name|fileOffset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fileOffset
operator|==
literal|null
operator|)
operator|||
operator|(
name|fileOffset
operator|<=
literal|0
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid object stream xref object reference: "
operator|+
name|fileOffset
argument_list|)
throw|;
name|List
argument_list|<
name|COSObject
argument_list|>
name|stmObjects
init|=
name|objToBeParsed
operator|.
name|get
argument_list|(
name|fileOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmObjects
operator|==
literal|null
condition|)
name|objToBeParsed
operator|.
name|put
argument_list|(
name|fileOffset
argument_list|,
name|stmObjects
operator|=
operator|new
name|ArrayList
argument_list|<
name|COSObject
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|stmObjects
operator|.
name|add
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// NULL object
name|COSObject
name|pdfObject
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
name|pdfObject
operator|.
name|setObject
argument_list|(
name|COSNull
operator|.
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// ---- read first COSObject with smallest offset;
comment|//      resulting object will be added to toBeParsedList
if|if
condition|(
name|objToBeParsed
operator|.
name|isEmpty
argument_list|()
condition|)
break|break;
for|for
control|(
name|COSObject
name|obj
range|:
name|objToBeParsed
operator|.
name|remove
argument_list|(
name|objToBeParsed
operator|.
name|firstKey
argument_list|()
argument_list|)
control|)
block|{
name|COSBase
name|parsedObj
init|=
name|parseObjectDynamically
argument_list|(
name|obj
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|obj
operator|.
name|setObject
argument_list|(
name|parsedObj
argument_list|)
expr_stmt|;
name|addNewToList
argument_list|(
name|toBeParsedList
argument_list|,
name|parsedObj
argument_list|,
name|addedObjects
argument_list|)
expr_stmt|;
name|parsedObjects
operator|.
name|add
argument_list|(
name|getObjectId
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** 	   * This will parse the next object from the stream and add it to  	   * the local state.  	   * This is taken from {@link PDFParser} and reduced to parsing 	   * an indirect object. 	   * 	   * @param  obj object to be parsed (we only take object number and generation number for lookup start offset) 	   * @param  requireExistingNotCompressedObj  if<code>true</code> object to be parsed must not be contained within compressed stream 	   * @return  the parsed object (which is also added to document object) 	   *  	   * @throws IOException If an IO error occurs. 	   */
specifier|private
name|COSBase
name|parseObjectDynamically
parameter_list|(
name|COSObject
name|obj
parameter_list|,
name|boolean
name|requireExistingNotCompressedObj
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|parseObjectDynamically
argument_list|(
name|obj
operator|.
name|getObjectNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|obj
operator|.
name|getGenerationNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|requireExistingNotCompressedObj
argument_list|)
return|;
block|}
comment|/** 	   * This will parse the next object from the stream and add it to  	   * the local state.  	   * This is taken from {@link PDFParser} and reduced to parsing 	   * an indirect object. 	   * 	   * @param  objNr object number of object to be parsed 	   * @param  objGenNr object generation number of object to be parsed 	   * @param requireExistingNotCompressedObj  if<code>true</code> the object to be parsed must be defined 	   *                                          in xref (comment: null objects may be missing from xref) and 	   *                                          it must not be a compressed object within object stream 	   *                                          (this is used to circumvent being stuck in a loop in a malicious PDF)  	   *  	   * @return  the parsed object (which is also added to document object) 	   *  	   * @throws IOException If an IO error occurs. 	   */
specifier|private
name|COSBase
name|parseObjectDynamically
parameter_list|(
name|int
name|objNr
parameter_list|,
name|int
name|objGenNr
parameter_list|,
name|boolean
name|requireExistingNotCompressedObj
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ---- create object key and get object (container) from pool
specifier|final
name|COSObjectKey
name|objKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|objNr
argument_list|,
name|objGenNr
argument_list|)
decl_stmt|;
specifier|final
name|COSObject
name|pdfObject
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|pdfObject
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// not previously parsed
comment|// ---- read offset or object stream object number from xref table
name|Long
name|offsetOrObjstmObNr
init|=
name|xrefTrailerResolver
operator|.
name|getXrefTable
argument_list|()
operator|.
name|get
argument_list|(
name|objKey
argument_list|)
decl_stmt|;
comment|// sanity test to circumvent loops with broken documents
if|if
condition|(
name|requireExistingNotCompressedObj
operator|&&
operator|(
operator|(
name|offsetOrObjstmObNr
operator|==
literal|null
operator|)
operator|||
operator|(
name|offsetOrObjstmObNr
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object must be defined and must not be compressed object: "
operator|+
name|objKey
operator|.
name|getNumber
argument_list|()
operator|+
literal|":"
operator|+
name|objKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|offsetOrObjstmObNr
operator|==
literal|null
condition|)
block|{
comment|// not defined object -> NULL object (Spec. 1.7, chap. 3.2.9)
name|pdfObject
operator|.
name|setObject
argument_list|(
name|COSNull
operator|.
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsetOrObjstmObNr
operator|>
literal|0
condition|)
block|{
comment|// offset of indirect object in file
comment|// ---- go to object start
name|setPdfSource
argument_list|(
name|offsetOrObjstmObNr
argument_list|)
expr_stmt|;
comment|// ---- we must have an indirect object
specifier|final
name|int
name|readObjNr
init|=
name|readInt
argument_list|()
decl_stmt|;
specifier|final
name|int
name|readObjGen
init|=
name|readInt
argument_list|()
decl_stmt|;
name|readPattern
argument_list|(
name|OBJ_MARKER
argument_list|)
expr_stmt|;
comment|// ---- consistency check
if|if
condition|(
operator|(
name|readObjNr
operator|!=
name|objKey
operator|.
name|getNumber
argument_list|()
operator|)
operator|||
operator|(
name|readObjGen
operator|!=
name|objKey
operator|.
name|getGeneration
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"XREF for "
operator|+
name|objKey
operator|.
name|getNumber
argument_list|()
operator|+
literal|":"
operator|+
name|objKey
operator|.
name|getGeneration
argument_list|()
operator|+
literal|" points to wrong object: "
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSBase
name|pb
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|String
name|endObjectKey
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
name|endObjectKey
operator|.
name|equals
argument_list|(
literal|"stream"
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|endObjectKey
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSStream
name|stream
init|=
name|parseCOSStream
argument_list|(
operator|(
name|COSDictionary
operator|)
name|pb
argument_list|,
name|getDocument
argument_list|()
operator|.
name|getScratchFile
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|securityHandler
operator|.
name|decryptStream
argument_list|(
name|stream
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CryptographyException
name|ce
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error decrypting stream object "
operator|+
name|objNr
operator|+
literal|": "
operator|+
name|ce
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ce
argument_list|)
throw|;
block|}
block|}
name|pb
operator|=
name|stream
expr_stmt|;
block|}
else|else
block|{
comment|// this is not legal
comment|// the combination of a dict and the stream/endstream forms a complete stream object
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream not preceded by dictionary (offset: "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|")."
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|endObjectKey
operator|=
name|readLine
argument_list|()
expr_stmt|;
comment|// we have case with a second 'endstream' before endobj
if|if
condition|(
operator|!
name|endObjectKey
operator|.
name|startsWith
argument_list|(
literal|"endobj"
argument_list|)
condition|)
block|{
if|if
condition|(
name|endObjectKey
operator|.
name|startsWith
argument_list|(
literal|"endstream"
argument_list|)
condition|)
block|{
name|endObjectKey
operator|=
name|endObjectKey
operator|.
name|substring
argument_list|(
literal|9
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|endObjectKey
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// no other characters in extra endstream line
name|endObjectKey
operator|=
name|readLine
argument_list|()
expr_stmt|;
comment|// read next line
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
comment|// decrypt
if|if
condition|(
name|pb
operator|instanceof
name|COSString
condition|)
block|{
name|decrypt
argument_list|(
operator|(
name|COSString
operator|)
name|pb
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pb
operator|instanceof
name|COSDictionary
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|COSName
argument_list|,
name|COSBase
argument_list|>
name|entry
range|:
operator|(
operator|(
name|COSDictionary
operator|)
name|pb
operator|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// TODO: specially handle 'Contents' entry of signature dictionary like in SecurityHandler#decryptDictionary
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|instanceof
name|COSString
condition|)
block|{
name|decrypt
argument_list|(
operator|(
name|COSString
operator|)
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|pb
operator|instanceof
name|COSArray
condition|)
block|{
specifier|final
name|COSArray
name|array
init|=
operator|(
name|COSArray
operator|)
name|pb
decl_stmt|;
for|for
control|(
name|int
name|aIdx
init|=
literal|0
init|,
name|len
init|=
name|array
operator|.
name|size
argument_list|()
init|;
name|aIdx
operator|<
name|len
condition|;
name|aIdx
operator|++
control|)
block|{
if|if
condition|(
name|array
operator|.
name|get
argument_list|(
name|aIdx
argument_list|)
operator|instanceof
name|COSString
condition|)
block|{
name|decrypt
argument_list|(
operator|(
name|COSString
operator|)
name|array
operator|.
name|get
argument_list|(
name|aIdx
argument_list|)
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|pdfObject
operator|.
name|setObject
argument_list|(
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endObjectKey
operator|.
name|startsWith
argument_list|(
literal|"endobj"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Object ("
operator|+
name|readObjNr
operator|+
literal|":"
operator|+
name|readObjGen
operator|+
literal|") at offset "
operator|+
name|offsetOrObjstmObNr
operator|+
literal|" does not end with 'endobj'."
argument_list|)
throw|;
block|}
name|releasePdfSourceInputStream
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// xref value is object nr of object stream containing object to be parsed;
comment|// since our object was not found it means object stream was not parsed so far
specifier|final
name|int
name|objstmObjNr
init|=
call|(
name|int
call|)
argument_list|(
operator|-
name|offsetOrObjstmObNr
argument_list|)
decl_stmt|;
specifier|final
name|COSBase
name|objstmBaseObj
init|=
name|parseObjectDynamically
argument_list|(
name|objstmObjNr
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|objstmBaseObj
operator|instanceof
name|COSStream
condition|)
block|{
comment|// parse object stream
name|PDFObjectStreamParser
name|parser
init|=
operator|new
name|PDFObjectStreamParser
argument_list|(
operator|(
name|COSStream
operator|)
name|objstmBaseObj
argument_list|,
name|document
argument_list|,
name|forceParsing
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
comment|// get set of object numbers referenced for this object stream
specifier|final
name|Set
argument_list|<
name|Long
argument_list|>
name|refObjNrs
init|=
name|xrefTrailerResolver
operator|.
name|getContainedObjectNumbers
argument_list|(
name|objstmObjNr
argument_list|)
decl_stmt|;
comment|// register all objects which are referenced to be contained in object stream
for|for
control|(
name|COSObject
name|next
range|:
name|parser
operator|.
name|getObjects
argument_list|()
control|)
block|{
name|COSObjectKey
name|stmObjKey
init|=
operator|new
name|COSObjectKey
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|refObjNrs
operator|.
name|contains
argument_list|(
name|stmObjKey
operator|.
name|getNumber
argument_list|()
argument_list|)
condition|)
block|{
name|COSObject
name|stmObj
init|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|stmObjKey
argument_list|)
decl_stmt|;
name|stmObj
operator|.
name|setObject
argument_list|(
name|next
operator|.
name|getObject
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|pdfObject
operator|.
name|getObject
argument_list|()
return|;
block|}
comment|// ------------------------------------------------------------------------
comment|/** Decrypts given COSString. */
specifier|private
specifier|final
name|void
name|decrypt
parameter_list|(
name|COSString
name|str
parameter_list|,
name|long
name|objNr
parameter_list|,
name|long
name|objGenNr
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|securityHandler
operator|.
name|decryptString
argument_list|(
name|str
argument_list|,
name|objNr
argument_list|,
name|objGenNr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CryptographyException
name|ce
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error decrypting string: "
operator|+
name|ce
operator|.
name|getMessage
argument_list|()
argument_list|,
name|ce
argument_list|)
throw|;
block|}
block|}
comment|// ------------------------------------------------------------------------
specifier|private
name|boolean
name|inGetLength
init|=
literal|false
decl_stmt|;
comment|/** Returns length value referred to or defined in given object. */
specifier|private
name|COSNumber
name|getLength
parameter_list|(
specifier|final
name|COSBase
name|lengthBaseObj
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|lengthBaseObj
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|inGetLength
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Loop while reading length from "
operator|+
name|lengthBaseObj
argument_list|)
throw|;
name|COSNumber
name|retVal
init|=
literal|null
decl_stmt|;
try|try
block|{
name|inGetLength
operator|=
literal|true
expr_stmt|;
comment|// ---- maybe length was given directly
if|if
condition|(
name|lengthBaseObj
operator|instanceof
name|COSNumber
condition|)
block|{
name|retVal
operator|=
operator|(
name|COSNumber
operator|)
name|lengthBaseObj
expr_stmt|;
block|}
comment|// ---- length in referenced object
elseif|else
if|if
condition|(
name|lengthBaseObj
operator|instanceof
name|COSObject
condition|)
block|{
name|COSObject
name|lengthObj
init|=
operator|(
name|COSObject
operator|)
name|lengthBaseObj
decl_stmt|;
if|if
condition|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// not read so far
comment|// keep current stream position
specifier|final
name|long
name|curFileOffset
init|=
name|getPdfSourceOffset
argument_list|()
decl_stmt|;
name|releasePdfSourceInputStream
argument_list|()
expr_stmt|;
name|parseObjectDynamically
argument_list|(
name|lengthObj
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// reset current stream position
name|setPdfSource
argument_list|(
name|curFileOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Length object content was not read."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|instanceof
name|COSNumber
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong type of referenced length object "
operator|+
name|lengthObj
operator|+
literal|": "
operator|+
name|lengthObj
operator|.
name|getObject
argument_list|()
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
name|retVal
operator|=
operator|(
name|COSNumber
operator|)
name|lengthObj
operator|.
name|getObject
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong type of length object: "
operator|+
name|lengthBaseObj
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|inGetLength
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|retVal
return|;
block|}
comment|// ------------------------------------------------------------------------
specifier|private
specifier|final
name|int
name|streamCopyBufLen
init|=
literal|8192
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|streamCopyBuf
init|=
operator|new
name|byte
index|[
name|streamCopyBufLen
index|]
decl_stmt|;
comment|/** 	   * This will read a COSStream from the input stream using length attribute 	   * within dictionary. 	   * If length attribute is a indirect reference it is first resolved to get 	   * the stream length. This means we copy stream data without testing for 	   * 'endstream' or 'endobj' and thus it is no problem if these keywords 	   * occur within stream. 	   * We require 'endstream' to be found after stream data is read.  	   * 	   * @param dic  dictionary that goes with this stream. 	   * @param file  file to write the stream to when reading. 	   * 	   * @return parsed pdf stream. 	   * 	   * @throws IOException if an error occurred reading the stream, like problems 	   *         with reading length attribute, stream does not end with 'endstream' 	   *         after data read, stream too short etc. 	   */
annotation|@
name|Override
specifier|protected
name|COSStream
name|parseCOSStream
parameter_list|(
name|COSDictionary
name|dic
parameter_list|,
name|RandomAccess
name|file
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|COSStream
name|stream
init|=
operator|new
name|COSStream
argument_list|(
name|dic
argument_list|,
name|file
argument_list|)
decl_stmt|;
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|readString
argument_list|()
expr_stmt|;
comment|// read 'stream'; this was already tested in parseObjectsDynamically()
comment|// ---- skip whitespaces before start of data
comment|//      PDF Ref 1.7, chap. 3.2.7:
comment|//      'stream' should be followed by either a CRLF (0x0d 0x0a) or LF but nothing else.
block|{
name|int
name|whitespace
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//see brother_scan_cover.pdf, it adds whitespaces
comment|//after the stream but before the start of the
comment|//data, so just read those first
while|while
condition|(
name|whitespace
operator|==
literal|0x20
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|whitespace
operator|==
literal|0x0D
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|whitespace
operator|!=
literal|0x0A
condition|)
block|{
comment|// the spec says this is invalid but it happens in the real
comment|// world so we must support it
name|pdfSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|whitespace
operator|!=
literal|0x0A
condition|)
block|{
comment|// no whitespace after 'stream'; PDF ref. says 'should' so that is ok
name|pdfSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*This needs to be dic.getItem because when we are parsing, the underlying object 	           * might still be null. 	           */
name|COSNumber
name|streamLengthObj
init|=
name|getLength
argument_list|(
name|dic
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|streamLengthObj
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing length for stream."
argument_list|)
throw|;
comment|// ---- get output stream to copy data to
name|out
operator|=
name|stream
operator|.
name|createFilteredStream
argument_list|(
name|streamLengthObj
argument_list|)
expr_stmt|;
name|long
name|remainBytes
init|=
name|streamLengthObj
operator|.
name|longValue
argument_list|()
decl_stmt|;
while|while
condition|(
name|remainBytes
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|readBytes
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
operator|(
name|remainBytes
operator|>
name|streamCopyBufLen
operator|)
condition|?
name|streamCopyBufLen
else|:
operator|(
name|int
operator|)
name|remainBytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBytes
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No more bytes from stream but expected: "
operator|+
name|remainBytes
argument_list|)
throw|;
name|out
operator|.
name|write
argument_list|(
name|streamCopyBuf
argument_list|,
literal|0
argument_list|,
name|readBytes
argument_list|)
expr_stmt|;
name|remainBytes
operator|-=
name|readBytes
expr_stmt|;
block|}
name|String
name|endStream
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|endStream
operator|.
name|equals
argument_list|(
literal|"endstream"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error reading stream using length value. Expected='endstream' actual='"
operator|+
name|endStream
operator|+
literal|"' "
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|stream
return|;
block|}
block|}
end_class

end_unit

