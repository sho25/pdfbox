begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|text
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|LineNumberReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|Bidi
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|Normalizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDPage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDPageTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRectangle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|documentnavigation
operator|.
name|outline
operator|.
name|PDOutlineItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|pagenavigation
operator|.
name|PDThreadBead
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|QuickSort
import|;
end_import

begin_comment
comment|/**  * This class will take a pdf document and strip out all of the text and ignore the formatting and such. Please note; it  * is up to clients of this class to verify that a specific user has the correct permissions to extract text from the  * PDF document.  *   * The basic flow of this process is that we get a document and use a series of processXXX() functions that work on  * smaller and smaller chunks of the page. Eventually, we fully process each page and then print it.  *  * @author Ben Litchfield  */
end_comment

begin_class
specifier|public
class|class
name|PDFTextStripper
extends|extends
name|LegacyPDFStreamEngine
block|{
specifier|private
specifier|static
name|float
name|defaultIndentThreshold
init|=
literal|2.0f
decl_stmt|;
specifier|private
specifier|static
name|float
name|defaultDropThreshold
init|=
literal|2.5f
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|useCustomQuickSort
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PDFTextStripper
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// enable the ability to set the default indent/drop thresholds
comment|// with -D system properties:
comment|// pdftextstripper.indent
comment|// pdftextstripper.drop
static|static
block|{
name|String
name|strDrop
init|=
literal|null
decl_stmt|,
name|strIndent
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|className
init|=
name|PDFTextStripper
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|prop
init|=
name|className
operator|+
literal|".indent"
decl_stmt|;
name|strIndent
operator|=
name|System
operator|.
name|getProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
name|prop
operator|=
name|className
operator|+
literal|".drop"
expr_stmt|;
name|strDrop
operator|=
name|System
operator|.
name|getProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
comment|// PDFBOX-1946 when run in an applet
comment|// ignore and use default
block|}
if|if
condition|(
name|strIndent
operator|!=
literal|null
operator|&&
name|strIndent
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|defaultIndentThreshold
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|strIndent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
comment|// ignore and use default
block|}
block|}
if|if
condition|(
name|strDrop
operator|!=
literal|null
operator|&&
name|strDrop
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|defaultDropThreshold
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|strDrop
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
comment|// ignore and use default
block|}
block|}
block|}
static|static
block|{
comment|// check if we need to use the custom quicksort algorithm as a
comment|// workaround to the PDFBOX-1512 transitivity issue of TextPositionComparator:
name|boolean
name|is16orLess
init|=
literal|false
decl_stmt|;
try|try
block|{
name|String
name|version
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.specification.version"
argument_list|)
decl_stmt|;
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|version
argument_list|,
literal|"."
argument_list|)
decl_stmt|;
name|int
name|majorVersion
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|minorVersion
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|minorVersion
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|is16orLess
operator|=
name|majorVersion
operator|==
literal|1
operator|&&
name|minorVersion
operator|<=
literal|6
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|x
parameter_list|)
block|{
comment|// when run in an applet ignore and use default
comment|// assume 1.7 or higher so that quicksort is used
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
comment|// should never happen, but if it does,
comment|// assume 1.7 or higher so that quicksort is used
block|}
name|useCustomQuickSort
operator|=
operator|!
name|is16orLess
expr_stmt|;
block|}
comment|/**      * The platform's line separator.      */
specifier|protected
specifier|final
name|String
name|LINE_SEPARATOR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
specifier|private
name|String
name|lineSeparator
init|=
name|LINE_SEPARATOR
decl_stmt|;
specifier|private
name|String
name|wordSeparator
init|=
literal|" "
decl_stmt|;
specifier|private
name|String
name|paragraphStart
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|paragraphEnd
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|pageStart
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|pageEnd
init|=
name|LINE_SEPARATOR
decl_stmt|;
specifier|private
name|String
name|articleStart
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|articleEnd
init|=
literal|""
decl_stmt|;
specifier|private
name|int
name|currentPageNo
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|startPage
init|=
literal|1
decl_stmt|;
specifier|private
name|int
name|endPage
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
name|PDOutlineItem
name|startBookmark
init|=
literal|null
decl_stmt|;
comment|// 1-based bookmark pages
specifier|private
name|int
name|startBookmarkPageNumber
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|endBookmarkPageNumber
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|PDOutlineItem
name|endBookmark
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|suppressDuplicateOverlappingText
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|shouldSeparateByBeads
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|sortByPosition
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|addMoreFormatting
init|=
literal|false
decl_stmt|;
specifier|private
name|float
name|indentThreshold
init|=
name|defaultIndentThreshold
decl_stmt|;
specifier|private
name|float
name|dropThreshold
init|=
name|defaultDropThreshold
decl_stmt|;
comment|// we will need to estimate where to add spaces, these are used to help guess
specifier|private
name|float
name|spacingTolerance
init|=
literal|.5f
decl_stmt|;
specifier|private
name|float
name|averageCharTolerance
init|=
literal|.3f
decl_stmt|;
specifier|private
name|List
argument_list|<
name|PDRectangle
argument_list|>
name|beadRectangles
init|=
literal|null
decl_stmt|;
comment|/**      * The charactersByArticle is used to extract text by article divisions. For example a PDF that has two columns like      * a newspaper, we want to extract the first column and then the second column. In this example the PDF would have 2      * beads(or articles), one for each column. The size of the charactersByArticle would be 5, because not all text on      * the screen will fall into one of the articles. The five divisions are shown below      *      * Text before first article      * first article text      * text between first article and second article      * second article text      * text after second article      *      * Most PDFs won't have any beads, so charactersByArticle will contain a single entry.      */
specifier|protected
name|ArrayList
argument_list|<
name|List
argument_list|<
name|TextPosition
argument_list|>
argument_list|>
name|charactersByArticle
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|TextPosition
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|TreeMap
argument_list|<
name|Float
argument_list|,
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|>
argument_list|>
name|characterListMapping
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|TreeMap
argument_list|<
name|Float
argument_list|,
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
name|PDDocument
name|document
decl_stmt|;
specifier|protected
name|Writer
name|output
decl_stmt|;
comment|/**      * True if we started a paragraph but haven't ended it yet.      */
specifier|private
name|boolean
name|inParagraph
decl_stmt|;
comment|/**      * Instantiate a new PDFTextStripper object.      *      * @throws IOException If there is an error loading the properties.      */
specifier|public
name|PDFTextStripper
parameter_list|()
throws|throws
name|IOException
block|{     }
comment|/**      * This will return the text of a document. See writeText.<br>      * NOTE: The document must not be encrypted when coming into this method.      *      * @param doc The document to get the text from.      * @return The text of the PDF document.      * @throws IOException if the doc state is invalid or it is encrypted.      */
specifier|public
name|String
name|getText
parameter_list|(
name|PDDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|StringWriter
name|outputStream
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|writeText
argument_list|(
name|doc
argument_list|,
name|outputStream
argument_list|)
expr_stmt|;
return|return
name|outputStream
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|void
name|resetEngine
parameter_list|()
block|{
name|currentPageNo
operator|=
literal|0
expr_stmt|;
name|document
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|charactersByArticle
operator|!=
literal|null
condition|)
block|{
name|charactersByArticle
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|characterListMapping
operator|!=
literal|null
condition|)
block|{
name|characterListMapping
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This will take a PDDocument and write the text of that document to the print writer.      *      * @param doc The document to get the data from.      * @param outputStream The location to put the text.      *      * @throws IOException If the doc is in an invalid state.      */
specifier|public
name|void
name|writeText
parameter_list|(
name|PDDocument
name|doc
parameter_list|,
name|Writer
name|outputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|resetEngine
argument_list|()
expr_stmt|;
name|document
operator|=
name|doc
expr_stmt|;
name|output
operator|=
name|outputStream
expr_stmt|;
if|if
condition|(
name|getAddMoreFormatting
argument_list|()
condition|)
block|{
name|paragraphEnd
operator|=
name|lineSeparator
expr_stmt|;
name|pageStart
operator|=
name|lineSeparator
expr_stmt|;
name|articleStart
operator|=
name|lineSeparator
expr_stmt|;
name|articleEnd
operator|=
name|lineSeparator
expr_stmt|;
block|}
name|startDocument
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|processPages
argument_list|(
name|document
operator|.
name|getPages
argument_list|()
argument_list|)
expr_stmt|;
name|endDocument
argument_list|(
name|document
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will process all of the pages and the text that is in them.      *      * @param pages The pages object in the document.      *      * @throws IOException If there is an error parsing the text.      */
specifier|protected
name|void
name|processPages
parameter_list|(
name|PDPageTree
name|pages
parameter_list|)
throws|throws
name|IOException
block|{
name|PDPage
name|startBookmarkPage
init|=
name|startBookmark
operator|==
literal|null
condition|?
literal|null
else|:
name|startBookmark
operator|.
name|findDestinationPage
argument_list|(
name|document
argument_list|)
decl_stmt|;
if|if
condition|(
name|startBookmarkPage
operator|!=
literal|null
condition|)
block|{
name|startBookmarkPageNumber
operator|=
name|pages
operator|.
name|indexOf
argument_list|(
name|startBookmarkPage
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// -1 = undefined
name|startBookmarkPageNumber
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|PDPage
name|endBookmarkPage
init|=
name|endBookmark
operator|==
literal|null
condition|?
literal|null
else|:
name|endBookmark
operator|.
name|findDestinationPage
argument_list|(
name|document
argument_list|)
decl_stmt|;
if|if
condition|(
name|endBookmarkPage
operator|!=
literal|null
condition|)
block|{
name|endBookmarkPageNumber
operator|=
name|pages
operator|.
name|indexOf
argument_list|(
name|endBookmarkPage
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// -1 = undefined
name|endBookmarkPageNumber
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|startBookmarkPageNumber
operator|==
operator|-
literal|1
operator|&&
name|startBookmark
operator|!=
literal|null
operator|&&
name|endBookmarkPageNumber
operator|==
operator|-
literal|1
operator|&&
name|endBookmark
operator|!=
literal|null
operator|&&
name|startBookmark
operator|.
name|getCOSObject
argument_list|()
operator|==
name|endBookmark
operator|.
name|getCOSObject
argument_list|()
condition|)
block|{
comment|// this is a special case where both the start and end bookmark
comment|// are the same but point to nothing. In this case
comment|// we will not extract any text.
name|startBookmarkPageNumber
operator|=
literal|0
expr_stmt|;
name|endBookmarkPageNumber
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|PDPage
name|page
range|:
name|pages
control|)
block|{
name|currentPageNo
operator|++
expr_stmt|;
if|if
condition|(
name|page
operator|.
name|hasContents
argument_list|()
condition|)
block|{
name|processPage
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This method is available for subclasses of this class. It will be called before processing of the document start.      *      * @param document The PDF document that is being processed.      * @throws IOException If an IO error occurs.      */
specifier|protected
name|void
name|startDocument
parameter_list|(
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
comment|// no default implementation, but available for subclasses
block|}
comment|/**      * This method is available for subclasses of this class. It will be called after processing of the document      * finishes.      *      * @param document The PDF document that is being processed.      * @throws IOException If an IO error occurs.      */
specifier|protected
name|void
name|endDocument
parameter_list|(
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
comment|// no default implementation, but available for subclasses
block|}
comment|/**      * This will process the contents of a page.      *      * @param page The page to process.      *      * @throws IOException If there is an error processing the page.      */
annotation|@
name|Override
specifier|public
name|void
name|processPage
parameter_list|(
name|PDPage
name|page
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentPageNo
operator|>=
name|startPage
operator|&&
name|currentPageNo
operator|<=
name|endPage
operator|&&
operator|(
name|startBookmarkPageNumber
operator|==
operator|-
literal|1
operator|||
name|currentPageNo
operator|>=
name|startBookmarkPageNumber
operator|)
operator|&&
operator|(
name|endBookmarkPageNumber
operator|==
operator|-
literal|1
operator|||
name|currentPageNo
operator|<=
name|endBookmarkPageNumber
operator|)
condition|)
block|{
name|startPage
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|int
name|numberOfArticleSections
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|shouldSeparateByBeads
condition|)
block|{
name|fillBeadRectangles
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|numberOfArticleSections
operator|+=
name|beadRectangles
operator|.
name|size
argument_list|()
operator|*
literal|2
expr_stmt|;
block|}
name|int
name|originalSize
init|=
name|charactersByArticle
operator|.
name|size
argument_list|()
decl_stmt|;
name|charactersByArticle
operator|.
name|ensureCapacity
argument_list|(
name|numberOfArticleSections
argument_list|)
expr_stmt|;
name|int
name|lastIndex
init|=
name|Math
operator|.
name|max
argument_list|(
name|numberOfArticleSections
argument_list|,
name|originalSize
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lastIndex
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|originalSize
condition|)
block|{
name|charactersByArticle
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|numberOfArticleSections
operator|<
name|originalSize
condition|)
block|{
name|charactersByArticle
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|charactersByArticle
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|TextPosition
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|characterListMapping
operator|.
name|clear
argument_list|()
expr_stmt|;
name|super
operator|.
name|processPage
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|writePage
argument_list|()
expr_stmt|;
name|endPage
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|fillBeadRectangles
parameter_list|(
name|PDPage
name|page
parameter_list|)
block|{
name|beadRectangles
operator|=
operator|new
name|ArrayList
argument_list|<
name|PDRectangle
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|PDThreadBead
name|bead
range|:
name|page
operator|.
name|getThreadBeads
argument_list|()
control|)
block|{
if|if
condition|(
name|bead
operator|==
literal|null
condition|)
block|{
comment|// can't skip, because of null entry handling in processTextPosition()
name|beadRectangles
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|PDRectangle
name|rect
init|=
name|bead
operator|.
name|getRectangle
argument_list|()
decl_stmt|;
comment|// bead rectangle is in PDF coordinates (y=0 is bottom),
comment|// glyphs are in image coordinates (y=0 is top),
comment|// so we must flip
name|PDRectangle
name|mediaBox
init|=
name|page
operator|.
name|getMediaBox
argument_list|()
decl_stmt|;
name|float
name|upperRightY
init|=
name|mediaBox
operator|.
name|getUpperRightY
argument_list|()
operator|-
name|rect
operator|.
name|getLowerLeftY
argument_list|()
decl_stmt|;
name|float
name|lowerLeftY
init|=
name|mediaBox
operator|.
name|getUpperRightY
argument_list|()
operator|-
name|rect
operator|.
name|getUpperRightY
argument_list|()
decl_stmt|;
name|rect
operator|.
name|setLowerLeftY
argument_list|(
name|lowerLeftY
argument_list|)
expr_stmt|;
name|rect
operator|.
name|setUpperRightY
argument_list|(
name|upperRightY
argument_list|)
expr_stmt|;
comment|// adjust for cropbox
name|PDRectangle
name|cropBox
init|=
name|page
operator|.
name|getCropBox
argument_list|()
decl_stmt|;
if|if
condition|(
name|cropBox
operator|.
name|getLowerLeftX
argument_list|()
operator|!=
literal|0
operator|||
name|cropBox
operator|.
name|getLowerLeftY
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|rect
operator|.
name|setLowerLeftX
argument_list|(
name|rect
operator|.
name|getLowerLeftX
argument_list|()
operator|-
name|cropBox
operator|.
name|getLowerLeftX
argument_list|()
argument_list|)
expr_stmt|;
name|rect
operator|.
name|setLowerLeftY
argument_list|(
name|rect
operator|.
name|getLowerLeftY
argument_list|()
operator|-
name|cropBox
operator|.
name|getLowerLeftY
argument_list|()
argument_list|)
expr_stmt|;
name|rect
operator|.
name|setUpperRightX
argument_list|(
name|rect
operator|.
name|getUpperRightX
argument_list|()
operator|-
name|cropBox
operator|.
name|getLowerLeftX
argument_list|()
argument_list|)
expr_stmt|;
name|rect
operator|.
name|setUpperRightY
argument_list|(
name|rect
operator|.
name|getUpperRightY
argument_list|()
operator|-
name|cropBox
operator|.
name|getLowerLeftY
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|beadRectangles
operator|.
name|add
argument_list|(
name|rect
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Start a new article, which is typically defined as a column on a single page (also referred to as a bead). This      * assumes that the primary direction of text is left to right. Default implementation is to do nothing. Subclasses      * may provide additional information.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|startArticle
parameter_list|()
throws|throws
name|IOException
block|{
name|startArticle
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Start a new article, which is typically defined as a column on a single page (also referred to as a bead).      * Default implementation is to do nothing. Subclasses may provide additional information.      *      * @param isLTR true if primary direction of text is left to right.      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|startArticle
parameter_list|(
name|boolean
name|isLTR
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getArticleStart
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * End an article. Default implementation is to do nothing. Subclasses may provide additional information.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|endArticle
parameter_list|()
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getArticleEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Start a new page. Default implementation is to do nothing. Subclasses may provide additional information.      *      * @param page The page we are about to process.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|startPage
parameter_list|(
name|PDPage
name|page
parameter_list|)
throws|throws
name|IOException
block|{
comment|// default is to do nothing
block|}
comment|/**      * End a page. Default implementation is to do nothing. Subclasses may provide additional information.      *      * @param page The page we are about to process.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|endPage
parameter_list|(
name|PDPage
name|page
parameter_list|)
throws|throws
name|IOException
block|{
comment|// default is to do nothing
block|}
specifier|private
specifier|static
specifier|final
name|float
name|END_OF_LAST_TEXT_X_RESET_VALUE
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|MAX_Y_FOR_LINE_RESET_VALUE
init|=
operator|-
name|Float
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE
init|=
operator|-
name|Float
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|MAX_HEIGHT_FOR_LINE_RESET_VALUE
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|MIN_Y_TOP_FOR_LINE_RESET_VALUE
init|=
name|Float
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|LAST_WORD_SPACING_RESET_VALUE
init|=
operator|-
literal|1
decl_stmt|;
comment|/**      * This will print the text of the processed page to "output". It will estimate, based on the coordinates of the      * text, where newlines and word spacings should be placed. The text will be sorted only if that feature was      * enabled.      *      * @throws IOException If there is an error writing the text.      */
specifier|protected
name|void
name|writePage
parameter_list|()
throws|throws
name|IOException
block|{
name|float
name|maxYForLine
init|=
name|MAX_Y_FOR_LINE_RESET_VALUE
decl_stmt|;
name|float
name|minYTopForLine
init|=
name|MIN_Y_TOP_FOR_LINE_RESET_VALUE
decl_stmt|;
name|float
name|endOfLastTextX
init|=
name|END_OF_LAST_TEXT_X_RESET_VALUE
decl_stmt|;
name|float
name|lastWordSpacing
init|=
name|LAST_WORD_SPACING_RESET_VALUE
decl_stmt|;
name|float
name|maxHeightForLine
init|=
name|MAX_HEIGHT_FOR_LINE_RESET_VALUE
decl_stmt|;
name|PositionWrapper
name|lastPosition
init|=
literal|null
decl_stmt|;
name|PositionWrapper
name|lastLineStartPosition
init|=
literal|null
decl_stmt|;
name|boolean
name|startOfPage
init|=
literal|true
decl_stmt|;
comment|// flag to indicate start of page
name|boolean
name|startOfArticle
decl_stmt|;
if|if
condition|(
name|charactersByArticle
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|writePageStart
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|List
argument_list|<
name|TextPosition
argument_list|>
name|textList
range|:
name|charactersByArticle
control|)
block|{
if|if
condition|(
name|getSortByPosition
argument_list|()
condition|)
block|{
name|TextPositionComparator
name|comparator
init|=
operator|new
name|TextPositionComparator
argument_list|()
decl_stmt|;
comment|// because the TextPositionComparator is not transitive, but
comment|// JDK7+ enforces transitivity on comparators, we need to use
comment|// a custom quicksort implementation (which is slower, unfortunately).
if|if
condition|(
name|useCustomQuickSort
condition|)
block|{
name|QuickSort
operator|.
name|sort
argument_list|(
name|textList
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|textList
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|TextPosition
argument_list|>
name|textIter
init|=
name|textList
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|startArticle
argument_list|()
expr_stmt|;
name|startOfArticle
operator|=
literal|true
expr_stmt|;
comment|// Now cycle through to print the text.
comment|// We queue up a line at a time before we print so that we can convert
comment|// the line from presentation form to logical form (if needed).
name|List
argument_list|<
name|LineItem
argument_list|>
name|line
init|=
operator|new
name|ArrayList
argument_list|<
name|LineItem
argument_list|>
argument_list|()
decl_stmt|;
name|textIter
operator|=
name|textList
operator|.
name|iterator
argument_list|()
expr_stmt|;
comment|// start from the beginning again
comment|// PDF files don't always store spaces. We will need to guess where we should add
comment|// spaces based on the distances between TextPositions. Historically, this was done
comment|// based on the size of the space character provided by the font. In general, this
comment|// worked but there were cases where it did not work. Calculating the average character
comment|// width and using that as a metric works better in some cases but fails in some cases
comment|// where the spacing worked. So we use both. NOTE: Adobe reader also fails on some of
comment|// these examples.
comment|// Keeps track of the previous average character width
name|float
name|previousAveCharWidth
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|textIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|TextPosition
name|position
init|=
name|textIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|PositionWrapper
name|current
init|=
operator|new
name|PositionWrapper
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|String
name|characterValue
init|=
name|position
operator|.
name|getUnicode
argument_list|()
decl_stmt|;
comment|// Resets the average character width when we see a change in font
comment|// or a change in the font size
if|if
condition|(
name|lastPosition
operator|!=
literal|null
operator|&&
operator|(
name|position
operator|.
name|getFont
argument_list|()
operator|!=
name|lastPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getFont
argument_list|()
operator|||
name|position
operator|.
name|getFontSize
argument_list|()
operator|!=
name|lastPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getFontSize
argument_list|()
operator|)
condition|)
block|{
name|previousAveCharWidth
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|float
name|positionX
decl_stmt|;
name|float
name|positionY
decl_stmt|;
name|float
name|positionWidth
decl_stmt|;
name|float
name|positionHeight
decl_stmt|;
comment|// If we are sorting, then we need to use the text direction
comment|// adjusted coordinates, because they were used in the sorting.
if|if
condition|(
name|getSortByPosition
argument_list|()
condition|)
block|{
name|positionX
operator|=
name|position
operator|.
name|getXDirAdj
argument_list|()
expr_stmt|;
name|positionY
operator|=
name|position
operator|.
name|getYDirAdj
argument_list|()
expr_stmt|;
name|positionWidth
operator|=
name|position
operator|.
name|getWidthDirAdj
argument_list|()
expr_stmt|;
name|positionHeight
operator|=
name|position
operator|.
name|getHeightDir
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|positionX
operator|=
name|position
operator|.
name|getX
argument_list|()
expr_stmt|;
name|positionY
operator|=
name|position
operator|.
name|getY
argument_list|()
expr_stmt|;
name|positionWidth
operator|=
name|position
operator|.
name|getWidth
argument_list|()
expr_stmt|;
name|positionHeight
operator|=
name|position
operator|.
name|getHeight
argument_list|()
expr_stmt|;
block|}
comment|// The current amount of characters in a word
name|int
name|wordCharCount
init|=
name|position
operator|.
name|getIndividualWidths
argument_list|()
operator|.
name|length
decl_stmt|;
comment|// Estimate the expected width of the space based on the
comment|// space character with some margin.
name|float
name|wordSpacing
init|=
name|position
operator|.
name|getWidthOfSpace
argument_list|()
decl_stmt|;
name|float
name|deltaSpace
decl_stmt|;
if|if
condition|(
name|wordSpacing
operator|==
literal|0
operator|||
name|Float
operator|.
name|isNaN
argument_list|(
name|wordSpacing
argument_list|)
condition|)
block|{
name|deltaSpace
operator|=
name|Float
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lastWordSpacing
operator|<
literal|0
condition|)
block|{
name|deltaSpace
operator|=
name|wordSpacing
operator|*
name|getSpacingTolerance
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|deltaSpace
operator|=
operator|(
name|wordSpacing
operator|+
name|lastWordSpacing
operator|)
operator|/
literal|2f
operator|*
name|getSpacingTolerance
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Estimate the expected width of the space based on the average character width
comment|// with some margin. This calculation does not make a true average (average of
comment|// averages) but we found that it gave the best results after numerous experiments.
comment|// Based on experiments we also found that .3 worked well.
name|float
name|averageCharWidth
decl_stmt|;
if|if
condition|(
name|previousAveCharWidth
operator|<
literal|0
condition|)
block|{
name|averageCharWidth
operator|=
name|positionWidth
operator|/
name|wordCharCount
expr_stmt|;
block|}
else|else
block|{
name|averageCharWidth
operator|=
operator|(
name|previousAveCharWidth
operator|+
name|positionWidth
operator|/
name|wordCharCount
operator|)
operator|/
literal|2f
expr_stmt|;
block|}
name|float
name|deltaCharWidth
init|=
name|averageCharWidth
operator|*
name|getAverageCharTolerance
argument_list|()
decl_stmt|;
comment|// Compares the values obtained by the average method and the wordSpacing method
comment|// and picks the smaller number.
name|float
name|expectedStartOfNextWordX
init|=
name|EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE
decl_stmt|;
if|if
condition|(
name|endOfLastTextX
operator|!=
name|END_OF_LAST_TEXT_X_RESET_VALUE
condition|)
block|{
if|if
condition|(
name|deltaCharWidth
operator|>
name|deltaSpace
condition|)
block|{
name|expectedStartOfNextWordX
operator|=
name|endOfLastTextX
operator|+
name|deltaSpace
expr_stmt|;
block|}
else|else
block|{
name|expectedStartOfNextWordX
operator|=
name|endOfLastTextX
operator|+
name|deltaCharWidth
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lastPosition
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|startOfArticle
condition|)
block|{
name|lastPosition
operator|.
name|setArticleStart
argument_list|()
expr_stmt|;
name|startOfArticle
operator|=
literal|false
expr_stmt|;
block|}
comment|// RDD - Here we determine whether this text object is on the current
comment|// line. We use the lastBaselineFontSize to handle the superscript
comment|// case, and the size of the current font to handle the subscript case.
comment|// Text must overlap with the last rendered baseline text by at least
comment|// a small amount in order to be considered as being on the same line.
comment|// XXX BC: In theory, this check should really check if the next char is in
comment|// full range seen in this line. This is what I tried to do with minYTopForLine,
comment|// but this caused a lot of regression test failures. So, I'm leaving it be for
comment|// now
if|if
condition|(
operator|!
name|overlap
argument_list|(
name|positionY
argument_list|,
name|positionHeight
argument_list|,
name|maxYForLine
argument_list|,
name|maxHeightForLine
argument_list|)
condition|)
block|{
name|writeLine
argument_list|(
name|normalize
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|.
name|clear
argument_list|()
expr_stmt|;
name|lastLineStartPosition
operator|=
name|handleLineSeparation
argument_list|(
name|current
argument_list|,
name|lastPosition
argument_list|,
name|lastLineStartPosition
argument_list|,
name|maxHeightForLine
argument_list|)
expr_stmt|;
name|expectedStartOfNextWordX
operator|=
name|EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE
expr_stmt|;
name|maxYForLine
operator|=
name|MAX_Y_FOR_LINE_RESET_VALUE
expr_stmt|;
name|maxHeightForLine
operator|=
name|MAX_HEIGHT_FOR_LINE_RESET_VALUE
expr_stmt|;
name|minYTopForLine
operator|=
name|MIN_Y_TOP_FOR_LINE_RESET_VALUE
expr_stmt|;
block|}
comment|// test if our TextPosition starts after a new word would be expected to start
if|if
condition|(
name|expectedStartOfNextWordX
operator|!=
name|EXPECTED_START_OF_NEXT_WORD_X_RESET_VALUE
operator|&&
name|expectedStartOfNextWordX
operator|<
name|positionX
operator|&&
comment|// only bother adding a space if the last character was not a space
name|lastPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getUnicode
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|lastPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getUnicode
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|" "
argument_list|)
condition|)
block|{
name|line
operator|.
name|add
argument_list|(
name|LineItem
operator|.
name|getWordSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|positionY
operator|>=
name|maxYForLine
condition|)
block|{
name|maxYForLine
operator|=
name|positionY
expr_stmt|;
block|}
comment|// RDD - endX is what PDF considers to be the x coordinate of the
comment|// end position of the text. We use it in computing our metrics below.
name|endOfLastTextX
operator|=
name|positionX
operator|+
name|positionWidth
expr_stmt|;
comment|// add it to the list
if|if
condition|(
name|characterValue
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|startOfPage
operator|&&
name|lastPosition
operator|==
literal|null
condition|)
block|{
name|writeParagraphStart
argument_list|()
expr_stmt|;
comment|// not sure this is correct for RTL?
block|}
name|line
operator|.
name|add
argument_list|(
operator|new
name|LineItem
argument_list|(
name|position
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|maxHeightForLine
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxHeightForLine
argument_list|,
name|positionHeight
argument_list|)
expr_stmt|;
name|minYTopForLine
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minYTopForLine
argument_list|,
name|positionY
operator|-
name|positionHeight
argument_list|)
expr_stmt|;
name|lastPosition
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|startOfPage
condition|)
block|{
name|lastPosition
operator|.
name|setParagraphStart
argument_list|()
expr_stmt|;
name|lastPosition
operator|.
name|setLineStart
argument_list|()
expr_stmt|;
name|lastLineStartPosition
operator|=
name|lastPosition
expr_stmt|;
name|startOfPage
operator|=
literal|false
expr_stmt|;
block|}
name|lastWordSpacing
operator|=
name|wordSpacing
expr_stmt|;
name|previousAveCharWidth
operator|=
name|averageCharWidth
expr_stmt|;
block|}
comment|// print the final line
if|if
condition|(
name|line
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|writeLine
argument_list|(
name|normalize
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|writeParagraphEnd
argument_list|()
expr_stmt|;
block|}
name|endArticle
argument_list|()
expr_stmt|;
block|}
name|writePageEnd
argument_list|()
expr_stmt|;
block|}
specifier|private
name|boolean
name|overlap
parameter_list|(
name|float
name|y1
parameter_list|,
name|float
name|height1
parameter_list|,
name|float
name|y2
parameter_list|,
name|float
name|height2
parameter_list|)
block|{
return|return
name|within
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|,
literal|.1f
argument_list|)
operator|||
name|y2
operator|<=
name|y1
operator|&&
name|y2
operator|>=
name|y1
operator|-
name|height1
operator|||
name|y1
operator|<=
name|y2
operator|&&
name|y1
operator|>=
name|y2
operator|-
name|height2
return|;
block|}
comment|/**      * Write the line separator value to the output stream.      *       * @throws IOException If there is a problem writing out the lineseparator to the document.      */
specifier|protected
name|void
name|writeLineSeparator
parameter_list|()
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getLineSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the word separator value to the output stream.      *       * @throws IOException If there is a problem writing out the wordseparator to the document.      */
specifier|protected
name|void
name|writeWordSeparator
parameter_list|()
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getWordSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the string in TextPosition to the output stream.      *      * @param text The text to write to the stream.      * @throws IOException If there is an error when writing the text.      */
specifier|protected
name|void
name|writeCharacters
parameter_list|(
name|TextPosition
name|text
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|text
operator|.
name|getUnicode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write a Java string to the output stream. The default implementation will ignore the<code>textPositions</code>      * and just calls {@link #writeString(String)}.      *      * @param text The text to write to the stream.      * @param textPositions The TextPositions belonging to the text.      * @throws IOException If there is an error when writing the text.      */
specifier|protected
name|void
name|writeString
parameter_list|(
name|String
name|text
parameter_list|,
name|List
argument_list|<
name|TextPosition
argument_list|>
name|textPositions
parameter_list|)
throws|throws
name|IOException
block|{
name|writeString
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write a Java string to the output stream.      *      * @param text The text to write to the stream.      * @throws IOException If there is an error when writing the text.      */
specifier|protected
name|void
name|writeString
parameter_list|(
name|String
name|text
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will determine of two floating point numbers are within a specified variance.      *      * @param first The first number to compare to.      * @param second The second number to compare to.      * @param variance The allowed variance.      */
specifier|private
name|boolean
name|within
parameter_list|(
name|float
name|first
parameter_list|,
name|float
name|second
parameter_list|,
name|float
name|variance
parameter_list|)
block|{
return|return
name|second
argument_list|<
name|first
operator|+
name|variance
operator|&&
name|second
argument_list|>
name|first
operator|-
name|variance
return|;
block|}
comment|/**      * This will process a TextPosition object and add the text to the list of characters on a page. It takes care of      * overlapping text.      *      * @param text The text to process.      */
annotation|@
name|Override
specifier|protected
name|void
name|processTextPosition
parameter_list|(
name|TextPosition
name|text
parameter_list|)
block|{
name|boolean
name|showCharacter
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|suppressDuplicateOverlappingText
condition|)
block|{
name|showCharacter
operator|=
literal|false
expr_stmt|;
name|String
name|textCharacter
init|=
name|text
operator|.
name|getUnicode
argument_list|()
decl_stmt|;
name|float
name|textX
init|=
name|text
operator|.
name|getX
argument_list|()
decl_stmt|;
name|float
name|textY
init|=
name|text
operator|.
name|getY
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Float
argument_list|,
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|>
name|sameTextCharacters
init|=
name|characterListMapping
operator|.
name|get
argument_list|(
name|textCharacter
argument_list|)
decl_stmt|;
if|if
condition|(
name|sameTextCharacters
operator|==
literal|null
condition|)
block|{
name|sameTextCharacters
operator|=
operator|new
name|TreeMap
argument_list|<
name|Float
argument_list|,
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|characterListMapping
operator|.
name|put
argument_list|(
name|textCharacter
argument_list|,
name|sameTextCharacters
argument_list|)
expr_stmt|;
block|}
comment|// RDD - Here we compute the value that represents the end of the rendered
comment|// text. This value is used to determine whether subsequent text rendered
comment|// on the same line overwrites the current text.
comment|//
comment|// We subtract any positive padding to handle cases where extreme amounts
comment|// of padding are applied, then backed off (not sure why this is done, but there
comment|// are cases where the padding is on the order of 10x the character width, and
comment|// the TJ just backs up to compensate after each character). Also, we subtract
comment|// an amount to allow for kerning (a percentage of the width of the last
comment|// character).
name|boolean
name|suppressCharacter
init|=
literal|false
decl_stmt|;
name|float
name|tolerance
init|=
name|text
operator|.
name|getWidth
argument_list|()
operator|/
name|textCharacter
operator|.
name|length
argument_list|()
operator|/
literal|3.0f
decl_stmt|;
name|SortedMap
argument_list|<
name|Float
argument_list|,
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|>
name|xMatches
init|=
name|sameTextCharacters
operator|.
name|subMap
argument_list|(
name|textX
operator|-
name|tolerance
argument_list|,
name|textX
operator|+
name|tolerance
argument_list|)
decl_stmt|;
for|for
control|(
name|TreeSet
argument_list|<
name|Float
argument_list|>
name|xMatch
range|:
name|xMatches
operator|.
name|values
argument_list|()
control|)
block|{
name|SortedSet
argument_list|<
name|Float
argument_list|>
name|yMatches
init|=
name|xMatch
operator|.
name|subSet
argument_list|(
name|textY
operator|-
name|tolerance
argument_list|,
name|textY
operator|+
name|tolerance
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|yMatches
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|suppressCharacter
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|suppressCharacter
condition|)
block|{
name|TreeSet
argument_list|<
name|Float
argument_list|>
name|ySet
init|=
name|sameTextCharacters
operator|.
name|get
argument_list|(
name|textX
argument_list|)
decl_stmt|;
if|if
condition|(
name|ySet
operator|==
literal|null
condition|)
block|{
name|ySet
operator|=
operator|new
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|()
expr_stmt|;
name|sameTextCharacters
operator|.
name|put
argument_list|(
name|textX
argument_list|,
name|ySet
argument_list|)
expr_stmt|;
block|}
name|ySet
operator|.
name|add
argument_list|(
name|textY
argument_list|)
expr_stmt|;
name|showCharacter
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|showCharacter
condition|)
block|{
comment|// if we are showing the character then we need to determine which article it belongs to
name|int
name|foundArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|notFoundButFirstLeftArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|notFoundButFirstAboveArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|float
name|x
init|=
name|text
operator|.
name|getX
argument_list|()
decl_stmt|;
name|float
name|y
init|=
name|text
operator|.
name|getY
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldSeparateByBeads
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|beadRectangles
operator|.
name|size
argument_list|()
operator|&&
name|foundArticleDivisionIndex
operator|==
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|PDRectangle
name|rect
init|=
name|beadRectangles
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|rect
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|rect
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|foundArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|<
name|rect
operator|.
name|getLowerLeftX
argument_list|()
operator|||
name|y
operator|<
name|rect
operator|.
name|getUpperRightY
argument_list|()
operator|)
operator|&&
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
name|rect
operator|.
name|getLowerLeftX
argument_list|()
operator|&&
name|notFoundButFirstLeftArticleDivisionIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|notFoundButFirstLeftArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|<
name|rect
operator|.
name|getUpperRightY
argument_list|()
operator|&&
name|notFoundButFirstAboveArticleDivisionIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|notFoundButFirstAboveArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|foundArticleDivisionIndex
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|foundArticleDivisionIndex
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|articleDivisionIndex
decl_stmt|;
if|if
condition|(
name|foundArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|foundArticleDivisionIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notFoundButFirstLeftArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|notFoundButFirstLeftArticleDivisionIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notFoundButFirstAboveArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|notFoundButFirstAboveArticleDivisionIndex
expr_stmt|;
block|}
else|else
block|{
name|articleDivisionIndex
operator|=
name|charactersByArticle
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
name|List
argument_list|<
name|TextPosition
argument_list|>
name|textList
init|=
name|charactersByArticle
operator|.
name|get
argument_list|(
name|articleDivisionIndex
argument_list|)
decl_stmt|;
comment|// In the wild, some PDF encoded documents put diacritics (accents on
comment|// top of characters) into a separate Tj element. When displaying them
comment|// graphically, the two chunks get overlayed. With text output though,
comment|// we need to do the overlay. This code recombines the diacritic with
comment|// its associated character if the two are consecutive.
if|if
condition|(
name|textList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|textList
operator|.
name|add
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// test if we overlap the previous entry.
comment|// Note that we are making an assumption that we need to only look back
comment|// one TextPosition to find what we are overlapping.
comment|// This may not always be true. */
name|TextPosition
name|previousTextPosition
init|=
name|textList
operator|.
name|get
argument_list|(
name|textList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|isDiacritic
argument_list|()
operator|&&
name|previousTextPosition
operator|.
name|contains
argument_list|(
name|text
argument_list|)
condition|)
block|{
name|previousTextPosition
operator|.
name|mergeDiacritic
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
comment|// If the previous TextPosition was the diacritic, merge it into this
comment|// one and remove it from the list.
elseif|else
if|if
condition|(
name|previousTextPosition
operator|.
name|isDiacritic
argument_list|()
operator|&&
name|text
operator|.
name|contains
argument_list|(
name|previousTextPosition
argument_list|)
condition|)
block|{
name|text
operator|.
name|mergeDiacritic
argument_list|(
name|previousTextPosition
argument_list|)
expr_stmt|;
name|textList
operator|.
name|remove
argument_list|(
name|textList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|textList
operator|.
name|add
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|textList
operator|.
name|add
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * This is the page that the text extraction will start on. The pages start at page 1. For example in a 5 page PDF      * document, if the start page is 1 then all pages will be extracted. If the start page is 4 then pages 4 and 5 will      * be extracted. The default value is 1.      *      * @return Value of property startPage.      */
specifier|public
name|int
name|getStartPage
parameter_list|()
block|{
return|return
name|startPage
return|;
block|}
comment|/**      * This will set the first page to be extracted by this class.      *      * @param startPageValue New value of 1-based startPage property.      */
specifier|public
name|void
name|setStartPage
parameter_list|(
name|int
name|startPageValue
parameter_list|)
block|{
name|startPage
operator|=
name|startPageValue
expr_stmt|;
block|}
comment|/**      * This will get the last page that will be extracted. This is inclusive, for example if a 5 page PDF an endPage      * value of 5 would extract the entire document, an end page of 2 would extract pages 1 and 2. This defaults to      * Integer.MAX_VALUE such that all pages of the pdf will be extracted.      *      * @return Value of property endPage.      */
specifier|public
name|int
name|getEndPage
parameter_list|()
block|{
return|return
name|endPage
return|;
block|}
comment|/**      * This will set the last page to be extracted by this class.      *      * @param endPageValue New value of 1-based endPage property.      */
specifier|public
name|void
name|setEndPage
parameter_list|(
name|int
name|endPageValue
parameter_list|)
block|{
name|endPage
operator|=
name|endPageValue
expr_stmt|;
block|}
comment|/**      * Set the desired line separator for output text. The line.separator system property is used if the line separator      * preference is not set explicitly using this method.      *      * @param separator The desired line separator string.      */
specifier|public
name|void
name|setLineSeparator
parameter_list|(
name|String
name|separator
parameter_list|)
block|{
name|lineSeparator
operator|=
name|separator
expr_stmt|;
block|}
comment|/**      * This will get the line separator.      *      * @return The desired line separator string.      */
specifier|public
name|String
name|getLineSeparator
parameter_list|()
block|{
return|return
name|lineSeparator
return|;
block|}
comment|/**      * This will get the word separator.      *      * @return The desired word separator string.      */
specifier|public
name|String
name|getWordSeparator
parameter_list|()
block|{
return|return
name|wordSeparator
return|;
block|}
comment|/**      * Set the desired word separator for output text. The PDFBox text extraction algorithm will output a space      * character if there is enough space between two words. By default a space character is used. If you need and      * accurate count of characters that are found in a PDF document then you might want to set the word separator to      * the empty string.      *      * @param separator The desired page separator string.      */
specifier|public
name|void
name|setWordSeparator
parameter_list|(
name|String
name|separator
parameter_list|)
block|{
name|wordSeparator
operator|=
name|separator
expr_stmt|;
block|}
comment|/**      * @return Returns the suppressDuplicateOverlappingText.      */
specifier|public
name|boolean
name|getSuppressDuplicateOverlappingText
parameter_list|()
block|{
return|return
name|suppressDuplicateOverlappingText
return|;
block|}
comment|/**      * Get the current page number that is being processed.      *      * @return A 1 based number representing the current page.      */
specifier|protected
name|int
name|getCurrentPageNo
parameter_list|()
block|{
return|return
name|currentPageNo
return|;
block|}
comment|/**      * The output stream that is being written to.      *      * @return The stream that output is being written to.      */
specifier|protected
name|Writer
name|getOutput
parameter_list|()
block|{
return|return
name|output
return|;
block|}
comment|/**      * Character strings are grouped by articles. It is quite common that there will only be a single article. This      * returns a List that contains List objects, the inner lists will contain TextPosition objects.      *      * @return A double List of TextPositions for all text strings on the page.      */
specifier|protected
name|List
argument_list|<
name|List
argument_list|<
name|TextPosition
argument_list|>
argument_list|>
name|getCharactersByArticle
parameter_list|()
block|{
return|return
name|charactersByArticle
return|;
block|}
comment|/**      * By default the text stripper will attempt to remove text that overlapps each other. Word paints the same      * character several times in order to make it look bold. By setting this to false all text will be extracted, which      * means that certain sections will be duplicated, but better performance will be noticed.      *      * @param suppressDuplicateOverlappingTextValue The suppressDuplicateOverlappingText to set.      */
specifier|public
name|void
name|setSuppressDuplicateOverlappingText
parameter_list|(
name|boolean
name|suppressDuplicateOverlappingTextValue
parameter_list|)
block|{
name|suppressDuplicateOverlappingText
operator|=
name|suppressDuplicateOverlappingTextValue
expr_stmt|;
block|}
comment|/**      * This will tell if the text stripper should separate by beads.      *      * @return If the text will be grouped by beads.      */
specifier|public
name|boolean
name|getSeparateByBeads
parameter_list|()
block|{
return|return
name|shouldSeparateByBeads
return|;
block|}
comment|/**      * Set if the text stripper should group the text output by a list of beads. The default value is true!      *      * @param aShouldSeparateByBeads The new grouping of beads.      */
specifier|public
name|void
name|setShouldSeparateByBeads
parameter_list|(
name|boolean
name|aShouldSeparateByBeads
parameter_list|)
block|{
name|shouldSeparateByBeads
operator|=
name|aShouldSeparateByBeads
expr_stmt|;
block|}
comment|/**      * Get the bookmark where text extraction should end, inclusive. Default is null.      *      * @return The ending bookmark.      */
specifier|public
name|PDOutlineItem
name|getEndBookmark
parameter_list|()
block|{
return|return
name|endBookmark
return|;
block|}
comment|/**      * Set the bookmark where the text extraction should stop.      *      * @param aEndBookmark The ending bookmark.      */
specifier|public
name|void
name|setEndBookmark
parameter_list|(
name|PDOutlineItem
name|aEndBookmark
parameter_list|)
block|{
name|endBookmark
operator|=
name|aEndBookmark
expr_stmt|;
block|}
comment|/**      * Get the bookmark where text extraction should start, inclusive. Default is null.      *      * @return The starting bookmark.      */
specifier|public
name|PDOutlineItem
name|getStartBookmark
parameter_list|()
block|{
return|return
name|startBookmark
return|;
block|}
comment|/**      * Set the bookmark where text extraction should start, inclusive.      *      * @param aStartBookmark The starting bookmark.      */
specifier|public
name|void
name|setStartBookmark
parameter_list|(
name|PDOutlineItem
name|aStartBookmark
parameter_list|)
block|{
name|startBookmark
operator|=
name|aStartBookmark
expr_stmt|;
block|}
comment|/**      * This will tell if the text stripper should add some more text formatting.      *       * @return true if some more text formatting will be added      */
specifier|public
name|boolean
name|getAddMoreFormatting
parameter_list|()
block|{
return|return
name|addMoreFormatting
return|;
block|}
comment|/**      * There will some additional text formatting be added if addMoreFormatting is set to true. Default is false.      *       * @param newAddMoreFormatting Tell PDFBox to add some more text formatting      */
specifier|public
name|void
name|setAddMoreFormatting
parameter_list|(
name|boolean
name|newAddMoreFormatting
parameter_list|)
block|{
name|addMoreFormatting
operator|=
name|newAddMoreFormatting
expr_stmt|;
block|}
comment|/**      * This will tell if the text stripper should sort the text tokens before writing to the stream.      *      * @return true If the text tokens will be sorted before being written.      */
specifier|public
name|boolean
name|getSortByPosition
parameter_list|()
block|{
return|return
name|sortByPosition
return|;
block|}
comment|/**      * The order of the text tokens in a PDF file may not be in the same as they appear visually on the screen. For      * example, a PDF writer may write out all text by font, so all bold or larger text, then make a second pass and      * write out the normal text.<br>      * The default is to<b>not</b> sort by position.<br>      *<br>      * A PDF writer could choose to write each character in a different order. By default PDFBox does<b>not</b> sort      * the text tokens before processing them due to performance reasons.      *      * @param newSortByPosition Tell PDFBox to sort the text positions.      */
specifier|public
name|void
name|setSortByPosition
parameter_list|(
name|boolean
name|newSortByPosition
parameter_list|)
block|{
name|sortByPosition
operator|=
name|newSortByPosition
expr_stmt|;
block|}
comment|/**      * Get the current space width-based tolerance value that is being used to estimate where spaces in text should be      * added. Note that the default value for this has been determined from trial and error.      *       * @return The current tolerance / scaling factor      */
specifier|public
name|float
name|getSpacingTolerance
parameter_list|()
block|{
return|return
name|spacingTolerance
return|;
block|}
comment|/**      * Set the space width-based tolerance value that is used to estimate where spaces in text should be added. Note      * that the default value for this has been determined from trial and error. Setting this value larger will reduce      * the number of spaces added.      *       * @param spacingToleranceValue tolerance / scaling factor to use      */
specifier|public
name|void
name|setSpacingTolerance
parameter_list|(
name|float
name|spacingToleranceValue
parameter_list|)
block|{
name|spacingTolerance
operator|=
name|spacingToleranceValue
expr_stmt|;
block|}
comment|/**      * Get the current character width-based tolerance value that is being used to estimate where spaces in text should      * be added. Note that the default value for this has been determined from trial and error.      *       * @return The current tolerance / scaling factor      */
specifier|public
name|float
name|getAverageCharTolerance
parameter_list|()
block|{
return|return
name|averageCharTolerance
return|;
block|}
comment|/**      * Set the character width-based tolerance value that is used to estimate where spaces in text should be added. Note      * that the default value for this has been determined from trial and error. Setting this value larger will reduce      * the number of spaces added.      *       * @param averageCharToleranceValue average tolerance / scaling factor to use      */
specifier|public
name|void
name|setAverageCharTolerance
parameter_list|(
name|float
name|averageCharToleranceValue
parameter_list|)
block|{
name|averageCharTolerance
operator|=
name|averageCharToleranceValue
expr_stmt|;
block|}
comment|/**      * returns the multiple of whitespace character widths for the current text which the current line start can be      * indented from the previous line start beyond which the current line start is considered to be a paragraph start.      *       * @return the number of whitespace character widths to use when detecting paragraph indents.      */
specifier|public
name|float
name|getIndentThreshold
parameter_list|()
block|{
return|return
name|indentThreshold
return|;
block|}
comment|/**      * sets the multiple of whitespace character widths for the current text which the current line start can be      * indented from the previous line start beyond which the current line start is considered to be a paragraph start.      * The default value is 2.0.      *      * @param indentThresholdValue the number of whitespace character widths to use when detecting paragraph indents.      */
specifier|public
name|void
name|setIndentThreshold
parameter_list|(
name|float
name|indentThresholdValue
parameter_list|)
block|{
name|indentThreshold
operator|=
name|indentThresholdValue
expr_stmt|;
block|}
comment|/**      * the minimum whitespace, as a multiple of the max height of the current characters beyond which the current line      * start is considered to be a paragraph start.      *       * @return the character height multiple for max allowed whitespace between lines in the same paragraph.      */
specifier|public
name|float
name|getDropThreshold
parameter_list|()
block|{
return|return
name|dropThreshold
return|;
block|}
comment|/**      * sets the minimum whitespace, as a multiple of the max height of the current characters beyond which the current      * line start is considered to be a paragraph start. The default value is 2.5.      *      * @param dropThresholdValue the character height multiple for max allowed whitespace between lines in the same      * paragraph.      */
specifier|public
name|void
name|setDropThreshold
parameter_list|(
name|float
name|dropThresholdValue
parameter_list|)
block|{
name|dropThreshold
operator|=
name|dropThresholdValue
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the beginning of a paragraph.      *       * @return the paragraph start string      */
specifier|public
name|String
name|getParagraphStart
parameter_list|()
block|{
return|return
name|paragraphStart
return|;
block|}
comment|/**      * Sets the string which will be used at the beginning of a paragraph.      *       * @param s the paragraph start string      */
specifier|public
name|void
name|setParagraphStart
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|paragraphStart
operator|=
name|s
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the end of a paragraph.      *       * @return the paragraph end string      */
specifier|public
name|String
name|getParagraphEnd
parameter_list|()
block|{
return|return
name|paragraphEnd
return|;
block|}
comment|/**      * Sets the string which will be used at the end of a paragraph.      *       * @param s the paragraph end string      */
specifier|public
name|void
name|setParagraphEnd
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|paragraphEnd
operator|=
name|s
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the beginning of a page.      *       * @return the page start string      */
specifier|public
name|String
name|getPageStart
parameter_list|()
block|{
return|return
name|pageStart
return|;
block|}
comment|/**      * Sets the string which will be used at the beginning of a page.      *       * @param pageStartValue the page start string      */
specifier|public
name|void
name|setPageStart
parameter_list|(
name|String
name|pageStartValue
parameter_list|)
block|{
name|pageStart
operator|=
name|pageStartValue
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the end of a page.      *       * @return the page end string      */
specifier|public
name|String
name|getPageEnd
parameter_list|()
block|{
return|return
name|pageEnd
return|;
block|}
comment|/**      * Sets the string which will be used at the end of a page.      *       * @param pageEndValue the page end string      */
specifier|public
name|void
name|setPageEnd
parameter_list|(
name|String
name|pageEndValue
parameter_list|)
block|{
name|pageEnd
operator|=
name|pageEndValue
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the beginning of an article.      *       * @return the article start string      */
specifier|public
name|String
name|getArticleStart
parameter_list|()
block|{
return|return
name|articleStart
return|;
block|}
comment|/**      * Sets the string which will be used at the beginning of an article.      *       * @param articleStartValue the article start string      */
specifier|public
name|void
name|setArticleStart
parameter_list|(
name|String
name|articleStartValue
parameter_list|)
block|{
name|articleStart
operator|=
name|articleStartValue
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the end of an article.      *       * @return the article end string      */
specifier|public
name|String
name|getArticleEnd
parameter_list|()
block|{
return|return
name|articleEnd
return|;
block|}
comment|/**      * Sets the string which will be used at the end of an article.      *       * @param articleEndValue the article end string      */
specifier|public
name|void
name|setArticleEnd
parameter_list|(
name|String
name|articleEndValue
parameter_list|)
block|{
name|articleEnd
operator|=
name|articleEndValue
expr_stmt|;
block|}
comment|/**      * handles the line separator for a new line given the specified current and previous TextPositions.      *       * @param current the current text position      * @param lastPosition the previous text position      * @param lastLineStartPosition the last text position that followed a line separator.      * @param maxHeightForLine max height for positions since lastLineStartPosition      * @return start position of the last line      * @throws IOException if something went wrong      */
specifier|private
name|PositionWrapper
name|handleLineSeparation
parameter_list|(
name|PositionWrapper
name|current
parameter_list|,
name|PositionWrapper
name|lastPosition
parameter_list|,
name|PositionWrapper
name|lastLineStartPosition
parameter_list|,
name|float
name|maxHeightForLine
parameter_list|)
throws|throws
name|IOException
block|{
name|current
operator|.
name|setLineStart
argument_list|()
expr_stmt|;
name|isParagraphSeparation
argument_list|(
name|current
argument_list|,
name|lastPosition
argument_list|,
name|lastLineStartPosition
argument_list|,
name|maxHeightForLine
argument_list|)
expr_stmt|;
name|lastLineStartPosition
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|isParagraphStart
argument_list|()
condition|)
block|{
if|if
condition|(
name|lastPosition
operator|.
name|isArticleStart
argument_list|()
condition|)
block|{
if|if
condition|(
name|lastPosition
operator|.
name|isLineStart
argument_list|()
condition|)
block|{
name|writeLineSeparator
argument_list|()
expr_stmt|;
block|}
name|writeParagraphStart
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writeLineSeparator
argument_list|()
expr_stmt|;
name|writeParagraphSeparator
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|writeLineSeparator
argument_list|()
expr_stmt|;
block|}
return|return
name|lastLineStartPosition
return|;
block|}
comment|/**      * tests the relationship between the last text position, the current text position and the last text position that      * followed a line separator to decide if the gap represents a paragraph separation. This should<i>only</i> be      * called for consecutive text positions that first pass the line separation test.      *<p>      * This base implementation tests to see if the lastLineStartPosition is null OR if the current vertical position      * has dropped below the last text vertical position by at least 2.5 times the current text height OR if the current      * horizontal position is indented by at least 2 times the current width of a space character.      *</p>      *<p>      * This also attempts to identify text that is indented under a hanging indent.      *</p>      *<p>      * This method sets the isParagraphStart and isHangingIndent flags on the current position object.      *</p>      *      * @param position the current text position. This may have its isParagraphStart or isHangingIndent flags set upon      * return.      * @param lastPosition the previous text position (should not be null).      * @param lastLineStartPosition the last text position that followed a line separator, or null.      * @param maxHeightForLine max height for text positions since lasLineStartPosition.      */
specifier|private
name|void
name|isParagraphSeparation
parameter_list|(
name|PositionWrapper
name|position
parameter_list|,
name|PositionWrapper
name|lastPosition
parameter_list|,
name|PositionWrapper
name|lastLineStartPosition
parameter_list|,
name|float
name|maxHeightForLine
parameter_list|)
block|{
name|boolean
name|result
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|lastLineStartPosition
operator|==
literal|null
condition|)
block|{
name|result
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|float
name|yGap
init|=
name|Math
operator|.
name|abs
argument_list|(
name|position
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getYDirAdj
argument_list|()
operator|-
name|lastPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getYDirAdj
argument_list|()
argument_list|)
decl_stmt|;
name|float
name|newYVal
init|=
name|multiplyFloat
argument_list|(
name|getDropThreshold
argument_list|()
argument_list|,
name|maxHeightForLine
argument_list|)
decl_stmt|;
comment|// do we need to flip this for rtl?
name|float
name|xGap
init|=
name|position
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getXDirAdj
argument_list|()
operator|-
name|lastLineStartPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getXDirAdj
argument_list|()
decl_stmt|;
name|float
name|newXVal
init|=
name|multiplyFloat
argument_list|(
name|getIndentThreshold
argument_list|()
argument_list|,
name|position
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getWidthOfSpace
argument_list|()
argument_list|)
decl_stmt|;
name|float
name|positionWidth
init|=
name|multiplyFloat
argument_list|(
literal|0.25f
argument_list|,
name|position
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getWidth
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|yGap
operator|>
name|newYVal
condition|)
block|{
name|result
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xGap
operator|>
name|newXVal
condition|)
block|{
comment|// text is indented, but try to screen for hanging indent
if|if
condition|(
operator|!
name|lastLineStartPosition
operator|.
name|isParagraphStart
argument_list|()
condition|)
block|{
name|result
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|position
operator|.
name|setHangingIndent
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|xGap
operator|<
operator|-
name|position
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getWidthOfSpace
argument_list|()
condition|)
block|{
comment|// text is left of previous line. Was it a hanging indent?
if|if
condition|(
operator|!
name|lastLineStartPosition
operator|.
name|isParagraphStart
argument_list|()
condition|)
block|{
name|result
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|xGap
argument_list|)
operator|<
name|positionWidth
condition|)
block|{
comment|// current horizontal position is within 1/4 a char of the last
comment|// linestart. We'll treat them as lined up.
if|if
condition|(
name|lastLineStartPosition
operator|.
name|isHangingIndent
argument_list|()
condition|)
block|{
name|position
operator|.
name|setHangingIndent
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastLineStartPosition
operator|.
name|isParagraphStart
argument_list|()
condition|)
block|{
comment|// check to see if the previous line looks like
comment|// any of a number of standard list item formats
name|Pattern
name|liPattern
init|=
name|matchListItemPattern
argument_list|(
name|lastLineStartPosition
argument_list|)
decl_stmt|;
if|if
condition|(
name|liPattern
operator|!=
literal|null
condition|)
block|{
name|Pattern
name|currentPattern
init|=
name|matchListItemPattern
argument_list|(
name|position
argument_list|)
decl_stmt|;
if|if
condition|(
name|liPattern
operator|==
name|currentPattern
condition|)
block|{
name|result
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|result
condition|)
block|{
name|position
operator|.
name|setParagraphStart
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|float
name|multiplyFloat
parameter_list|(
name|float
name|value1
parameter_list|,
name|float
name|value2
parameter_list|)
block|{
comment|// multiply 2 floats and truncate the resulting value to 3 decimal places
comment|// to avoid wrong results when comparing with another float
return|return
name|Math
operator|.
name|round
argument_list|(
name|value1
operator|*
name|value2
operator|*
literal|1000
argument_list|)
operator|/
literal|1000f
return|;
block|}
comment|/**      * writes the paragraph separator string to the output.      *       * @throws IOException if something went wrong      */
specifier|protected
name|void
name|writeParagraphSeparator
parameter_list|()
throws|throws
name|IOException
block|{
name|writeParagraphEnd
argument_list|()
expr_stmt|;
name|writeParagraphStart
argument_list|()
expr_stmt|;
block|}
comment|/**      * Write something (if defined) at the start of a paragraph.      *       * @throws IOException if something went wrong      */
specifier|protected
name|void
name|writeParagraphStart
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inParagraph
condition|)
block|{
name|writeParagraphEnd
argument_list|()
expr_stmt|;
name|inParagraph
operator|=
literal|false
expr_stmt|;
block|}
name|output
operator|.
name|write
argument_list|(
name|getParagraphStart
argument_list|()
argument_list|)
expr_stmt|;
name|inParagraph
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Write something (if defined) at the end of a paragraph.      *       * @throws IOException if something went wrong      */
specifier|protected
name|void
name|writeParagraphEnd
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|inParagraph
condition|)
block|{
name|writeParagraphStart
argument_list|()
expr_stmt|;
block|}
name|output
operator|.
name|write
argument_list|(
name|getParagraphEnd
argument_list|()
argument_list|)
expr_stmt|;
name|inParagraph
operator|=
literal|false
expr_stmt|;
block|}
comment|/**      * Write something (if defined) at the start of a page.      *       * @throws IOException if something went wrong      */
specifier|protected
name|void
name|writePageStart
parameter_list|()
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getPageStart
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write something (if defined) at the end of a page.      *       * @throws IOException if something went wrong      */
specifier|protected
name|void
name|writePageEnd
parameter_list|()
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getPageEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * returns the list item Pattern object that matches the text at the specified PositionWrapper or null if the text      * does not match such a pattern. The list of Patterns tested against is given by the {@link #getListItemPatterns()}      * method. To add to the list, simply override that method (if sub-classing) or explicitly supply your own list      * using {@link #setListItemPatterns(List)}.      *       * @param pw position      * @return the matching pattern      */
specifier|private
name|Pattern
name|matchListItemPattern
parameter_list|(
name|PositionWrapper
name|pw
parameter_list|)
block|{
name|TextPosition
name|tp
init|=
name|pw
operator|.
name|getTextPosition
argument_list|()
decl_stmt|;
name|String
name|txt
init|=
name|tp
operator|.
name|getUnicode
argument_list|()
decl_stmt|;
return|return
name|matchPattern
argument_list|(
name|txt
argument_list|,
name|getListItemPatterns
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * a list of regular expressions that match commonly used list item formats, i.e. bullets, numbers, letters, Roman      * numerals, etc. Not meant to be comprehensive.      */
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|LIST_ITEM_EXPRESSIONS
init|=
block|{
literal|"\\."
block|,
literal|"\\d+\\."
block|,
literal|"\\[\\d+\\]"
block|,
literal|"\\d+\\)"
block|,
literal|"[A-Z]\\."
block|,
literal|"[a-z]\\."
block|,
literal|"[A-Z]\\)"
block|,
literal|"[a-z]\\)"
block|,
literal|"[IVXL]+\\."
block|,
literal|"[ivxl]+\\."
block|, }
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Pattern
argument_list|>
name|listOfPatterns
init|=
literal|null
decl_stmt|;
comment|/**      * use to supply a different set of regular expression patterns for matching list item starts.      *      * @param patterns list of patterns      */
specifier|protected
name|void
name|setListItemPatterns
parameter_list|(
name|List
argument_list|<
name|Pattern
argument_list|>
name|patterns
parameter_list|)
block|{
name|listOfPatterns
operator|=
name|patterns
expr_stmt|;
block|}
comment|/**      * returns a list of regular expression Patterns representing different common list item formats. For example      * numbered items of form:      *<ol>      *<li>some text</li>      *<li>more text</li>      *</ol>      * or      *<ul>      *<li>some text</li>      *<li>more text</li>      *</ul>      * etc., all begin with some character pattern. The pattern "\\d+\." (matches "1.", "2.", ...) or "\[\\d+\]"      * (matches "[1]", "[2]", ...).      *<p>      * This method returns a list of such regular expression Patterns.      *       * @return a list of Pattern objects.      */
specifier|protected
name|List
argument_list|<
name|Pattern
argument_list|>
name|getListItemPatterns
parameter_list|()
block|{
if|if
condition|(
name|listOfPatterns
operator|==
literal|null
condition|)
block|{
name|listOfPatterns
operator|=
operator|new
name|ArrayList
argument_list|<
name|Pattern
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|expression
range|:
name|LIST_ITEM_EXPRESSIONS
control|)
block|{
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|expression
argument_list|)
decl_stmt|;
name|listOfPatterns
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|listOfPatterns
return|;
block|}
comment|/**      * iterates over the specified list of Patterns until it finds one that matches the specified string. Then returns      * the Pattern.      *<p>      * Order of the supplied list of patterns is important as most common patterns should come first. Patterns should be      * strict in general, and all will be used with case sensitivity on.      *</p>      *       * @param string the string to be searched      * @param patterns list of patterns      * @return matching pattern      */
specifier|protected
specifier|static
name|Pattern
name|matchPattern
parameter_list|(
name|String
name|string
parameter_list|,
name|List
argument_list|<
name|Pattern
argument_list|>
name|patterns
parameter_list|)
block|{
for|for
control|(
name|Pattern
name|p
range|:
name|patterns
control|)
block|{
if|if
condition|(
name|p
operator|.
name|matcher
argument_list|(
name|string
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Write a list of string containing a whole line of a document.      *       * @param line a list with the words of the given line      * @throws IOException if something went wrong      */
specifier|private
name|void
name|writeLine
parameter_list|(
name|List
argument_list|<
name|WordWithTextPositions
argument_list|>
name|line
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|numberOfStrings
init|=
name|line
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfStrings
condition|;
name|i
operator|++
control|)
block|{
name|WordWithTextPositions
name|word
init|=
name|line
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|writeString
argument_list|(
name|word
operator|.
name|getText
argument_list|()
argument_list|,
name|word
operator|.
name|getTextPositions
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|numberOfStrings
operator|-
literal|1
condition|)
block|{
name|writeWordSeparator
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Normalize the given list of TextPositions.      *       * @param line list of TextPositions      * @return a list of strings, one string for every word      */
specifier|private
name|List
argument_list|<
name|WordWithTextPositions
argument_list|>
name|normalize
parameter_list|(
name|List
argument_list|<
name|LineItem
argument_list|>
name|line
parameter_list|)
block|{
name|List
argument_list|<
name|WordWithTextPositions
argument_list|>
name|normalized
init|=
operator|new
name|LinkedList
argument_list|<
name|WordWithTextPositions
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|lineBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TextPosition
argument_list|>
name|wordPositions
init|=
operator|new
name|ArrayList
argument_list|<
name|TextPosition
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|LineItem
name|item
range|:
name|line
control|)
block|{
name|lineBuilder
operator|=
name|normalizeAdd
argument_list|(
name|normalized
argument_list|,
name|lineBuilder
argument_list|,
name|wordPositions
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lineBuilder
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|normalized
operator|.
name|add
argument_list|(
name|createWord
argument_list|(
name|lineBuilder
operator|.
name|toString
argument_list|()
argument_list|,
name|wordPositions
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|normalized
return|;
block|}
comment|/**      * Handles the LTR and RTL direction of the given words. The whole implementation stands and falls with the given      * word. If the word is a full line, the results will be the best. If the word contains of single words or      * characters, the order of the characters in a word or words in a line may wrong, due to RTL and LTR marks and      * characters!      *       * Based on http://www.nesterovsky-bros.com/weblog/2013/07/28/VisualToLogicalConversionInJava.aspx      *       * @param word The word that shall be processed      * @return new word with the correct direction of the containing characters      */
specifier|private
name|String
name|handleDirection
parameter_list|(
name|String
name|word
parameter_list|)
block|{
name|Bidi
name|bidi
init|=
operator|new
name|Bidi
argument_list|(
name|word
argument_list|,
name|Bidi
operator|.
name|DIRECTION_DEFAULT_LEFT_TO_RIGHT
argument_list|)
decl_stmt|;
comment|// if there is pure LTR text no need to process further
if|if
condition|(
operator|!
name|bidi
operator|.
name|isMixed
argument_list|()
operator|&&
name|bidi
operator|.
name|getBaseLevel
argument_list|()
operator|==
name|Bidi
operator|.
name|DIRECTION_LEFT_TO_RIGHT
condition|)
block|{
return|return
name|word
return|;
block|}
comment|// collect individual bidi information
name|int
name|runCount
init|=
name|bidi
operator|.
name|getRunCount
argument_list|()
decl_stmt|;
name|byte
index|[]
name|levels
init|=
operator|new
name|byte
index|[
name|runCount
index|]
decl_stmt|;
name|Integer
index|[]
name|runs
init|=
operator|new
name|Integer
index|[
name|runCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|runCount
condition|;
name|i
operator|++
control|)
block|{
name|levels
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|bidi
operator|.
name|getRunLevel
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|runs
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|// reorder individual parts based on their levels
name|Bidi
operator|.
name|reorderVisually
argument_list|(
name|levels
argument_list|,
literal|0
argument_list|,
name|runs
argument_list|,
literal|0
argument_list|,
name|runCount
argument_list|)
expr_stmt|;
comment|// collect the parts based on the direction within the run
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|runCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
name|runs
index|[
name|i
index|]
decl_stmt|;
name|int
name|start
init|=
name|bidi
operator|.
name|getRunStart
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|bidi
operator|.
name|getRunLimit
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|int
name|level
init|=
name|levels
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|level
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
init|;
operator|--
name|end
operator|>=
name|start
condition|;
control|)
block|{
name|char
name|character
init|=
name|word
operator|.
name|charAt
argument_list|(
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isMirrored
argument_list|(
name|word
operator|.
name|codePointAt
argument_list|(
name|end
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|MIRRORING_CHAR_MAP
operator|.
name|containsKey
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|MIRRORING_CHAR_MAP
operator|.
name|get
argument_list|(
name|character
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
name|character
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
name|character
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|result
operator|.
name|append
argument_list|(
name|word
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|Map
argument_list|<
name|Character
argument_list|,
name|Character
argument_list|>
name|MIRRORING_CHAR_MAP
init|=
operator|new
name|HashMap
argument_list|<
name|Character
argument_list|,
name|Character
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|String
name|path
init|=
literal|"org/apache/pdfbox/resources/text/BidiMirroring.txt"
decl_stmt|;
name|InputStream
name|input
init|=
name|PDFTextStripper
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|path
argument_list|)
decl_stmt|;
try|try
block|{
name|parseBidiFile
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not parse BidiMirroring.txt, mirroring char map will be empty: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not close BidiMirroring.txt "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This method parses the bidi file provided as inputstream.      *       * @param inputStream - The bidi file as inputstream      * @throws IOException if any line could not be read by the LineNumberReader      */
specifier|private
specifier|static
name|void
name|parseBidiFile
parameter_list|(
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|LineNumberReader
name|rd
init|=
operator|new
name|LineNumberReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|inputStream
argument_list|)
argument_list|)
decl_stmt|;
do|do
block|{
name|String
name|s
init|=
name|rd
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|int
name|comment
init|=
name|s
operator|.
name|indexOf
argument_list|(
literal|'#'
argument_list|)
decl_stmt|;
comment|// ignore comments
if|if
condition|(
name|comment
operator|!=
operator|-
literal|1
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|comment
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|<
literal|2
condition|)
block|{
continue|continue;
block|}
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|s
argument_list|,
literal|";"
argument_list|)
decl_stmt|;
name|int
name|nFields
init|=
name|st
operator|.
name|countTokens
argument_list|()
decl_stmt|;
name|Character
index|[]
name|fields
init|=
operator|new
name|Character
index|[
name|nFields
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nFields
condition|;
name|i
operator|++
control|)
block|{
name|fields
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fields
operator|.
name|length
operator|==
literal|2
condition|)
block|{
comment|// initialize the MIRRORING_CHAR_MAP
name|MIRRORING_CHAR_MAP
operator|.
name|put
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|,
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
comment|/**      * Used within {@link #normalize(List)} to create a single {@link WordWithTextPositions} entry.      */
specifier|private
name|WordWithTextPositions
name|createWord
parameter_list|(
name|String
name|word
parameter_list|,
name|List
argument_list|<
name|TextPosition
argument_list|>
name|wordPositions
parameter_list|)
block|{
return|return
operator|new
name|WordWithTextPositions
argument_list|(
name|normalizeWord
argument_list|(
name|word
argument_list|)
argument_list|,
name|wordPositions
argument_list|)
return|;
block|}
comment|/**      * Normalize certain Unicode characters. For example, convert the single "fi" ligature to "f" and "i". Also      * normalises Arabic and Hebrew presentation forms.      *      * @param word Word to normalize      * @return Normalized word      */
specifier|private
name|String
name|normalizeWord
parameter_list|(
name|String
name|word
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
literal|null
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
name|int
name|q
init|=
literal|0
decl_stmt|;
name|int
name|strLength
init|=
name|word
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|q
operator|<
name|strLength
condition|;
name|q
operator|++
control|)
block|{
comment|// We only normalize if the codepoint is in a given range.
comment|// Otherwise, NFKC converts too many things that would cause
comment|// confusion. For example, it converts the micro symbol in
comment|// extended Latin to the value in the Greek script. We normalize
comment|// the Unicode Alphabetic and Arabic A&B Presentation forms.
name|char
name|c
init|=
name|word
operator|.
name|charAt
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0xFB00
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|0xFDFF
operator|||
literal|0xFE70
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|0xFEFF
condition|)
block|{
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|StringBuilder
argument_list|(
name|strLength
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|word
operator|.
name|substring
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
comment|// Some fonts map U+FDF2 differently than the Unicode spec.
comment|// They add an extra U+0627 character to compensate.
comment|// This removes the extra character for those fonts.
if|if
condition|(
name|c
operator|==
literal|0xFDF2
operator|&&
name|q
operator|>
literal|0
operator|&&
operator|(
name|word
operator|.
name|charAt
argument_list|(
name|q
operator|-
literal|1
argument_list|)
operator|==
literal|0x0627
operator|||
name|word
operator|.
name|charAt
argument_list|(
name|q
operator|-
literal|1
argument_list|)
operator|==
literal|0xFE8D
operator|)
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"\u0644\u0644\u0647"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Trim because some decompositions have an extra space, such as U+FC5E
name|builder
operator|.
name|append
argument_list|(
name|Normalizer
operator|.
name|normalize
argument_list|(
name|word
operator|.
name|substring
argument_list|(
name|q
argument_list|,
name|q
operator|+
literal|1
argument_list|)
argument_list|,
name|Normalizer
operator|.
name|Form
operator|.
name|NFKC
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
return|return
name|handleDirection
argument_list|(
name|word
argument_list|)
return|;
block|}
else|else
block|{
name|builder
operator|.
name|append
argument_list|(
name|word
operator|.
name|substring
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|handleDirection
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**      * Used within {@link #normalize(List)} to handle a {@link TextPosition}.      *       * @return The StringBuilder that must be used when calling this method.      */
specifier|private
name|StringBuilder
name|normalizeAdd
parameter_list|(
name|List
argument_list|<
name|WordWithTextPositions
argument_list|>
name|normalized
parameter_list|,
name|StringBuilder
name|lineBuilder
parameter_list|,
name|List
argument_list|<
name|TextPosition
argument_list|>
name|wordPositions
parameter_list|,
name|LineItem
name|item
parameter_list|)
block|{
if|if
condition|(
name|item
operator|.
name|isWordSeparator
argument_list|()
condition|)
block|{
name|normalized
operator|.
name|add
argument_list|(
name|createWord
argument_list|(
name|lineBuilder
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|TextPosition
argument_list|>
argument_list|(
name|wordPositions
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lineBuilder
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
name|wordPositions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|TextPosition
name|text
init|=
name|item
operator|.
name|getTextPosition
argument_list|()
decl_stmt|;
name|lineBuilder
operator|.
name|append
argument_list|(
name|text
operator|.
name|getUnicode
argument_list|()
argument_list|)
expr_stmt|;
name|wordPositions
operator|.
name|add
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
return|return
name|lineBuilder
return|;
block|}
comment|/**      * internal marker class. Used as a place holder in a line of TextPositions.      */
specifier|private
specifier|static
specifier|final
class|class
name|LineItem
block|{
specifier|public
specifier|static
name|LineItem
name|WORD_SEPARATOR
init|=
operator|new
name|LineItem
argument_list|()
decl_stmt|;
specifier|public
specifier|static
name|LineItem
name|getWordSeparator
parameter_list|()
block|{
return|return
name|WORD_SEPARATOR
return|;
block|}
specifier|private
specifier|final
name|TextPosition
name|textPosition
decl_stmt|;
specifier|private
name|LineItem
parameter_list|()
block|{
name|textPosition
operator|=
literal|null
expr_stmt|;
block|}
name|LineItem
parameter_list|(
name|TextPosition
name|textPosition
parameter_list|)
block|{
name|this
operator|.
name|textPosition
operator|=
name|textPosition
expr_stmt|;
block|}
specifier|public
name|TextPosition
name|getTextPosition
parameter_list|()
block|{
return|return
name|textPosition
return|;
block|}
specifier|public
name|boolean
name|isWordSeparator
parameter_list|()
block|{
return|return
name|textPosition
operator|==
literal|null
return|;
block|}
block|}
comment|/**      * Internal class that maps strings to lists of {@link TextPosition} arrays. Note that the number of entries in that      * list may differ from the number of characters in the string due to normalization.      *      * @author Axel Drfler      */
specifier|private
specifier|static
specifier|final
class|class
name|WordWithTextPositions
block|{
name|String
name|text
decl_stmt|;
name|List
argument_list|<
name|TextPosition
argument_list|>
name|textPositions
decl_stmt|;
name|WordWithTextPositions
parameter_list|(
name|String
name|word
parameter_list|,
name|List
argument_list|<
name|TextPosition
argument_list|>
name|positions
parameter_list|)
block|{
name|text
operator|=
name|word
expr_stmt|;
name|textPositions
operator|=
name|positions
expr_stmt|;
block|}
specifier|public
name|String
name|getText
parameter_list|()
block|{
return|return
name|text
return|;
block|}
specifier|public
name|List
argument_list|<
name|TextPosition
argument_list|>
name|getTextPositions
parameter_list|()
block|{
return|return
name|textPositions
return|;
block|}
block|}
comment|/**      * wrapper of TextPosition that adds flags to track status as linestart and paragraph start positions.      *<p>      * This is implemented as a wrapper since the TextPosition class doesn't provide complete access to its state fields      * to subclasses. Also, conceptually TextPosition is immutable while these flags need to be set post-creation so it      * makes sense to put these flags in this separate class.      *</p>      *       * @author m.martinez@ll.mit.edu      */
specifier|private
specifier|static
specifier|final
class|class
name|PositionWrapper
block|{
specifier|private
name|boolean
name|isLineStart
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|isParagraphStart
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|isPageBreak
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|isHangingIndent
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|isArticleStart
init|=
literal|false
decl_stmt|;
specifier|private
name|TextPosition
name|position
init|=
literal|null
decl_stmt|;
comment|/**          * Constructs a PositionWrapper around the specified TextPosition object.          *          * @param position the text position.          */
name|PositionWrapper
parameter_list|(
name|TextPosition
name|position
parameter_list|)
block|{
name|this
operator|.
name|position
operator|=
name|position
expr_stmt|;
block|}
comment|/**          * Returns the underlying TextPosition object.          *           * @return the text position          */
specifier|public
name|TextPosition
name|getTextPosition
parameter_list|()
block|{
return|return
name|position
return|;
block|}
specifier|public
name|boolean
name|isLineStart
parameter_list|()
block|{
return|return
name|isLineStart
return|;
block|}
comment|/**          * Sets the isLineStart() flag to true.          */
specifier|public
name|void
name|setLineStart
parameter_list|()
block|{
name|this
operator|.
name|isLineStart
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|boolean
name|isParagraphStart
parameter_list|()
block|{
return|return
name|isParagraphStart
return|;
block|}
comment|/**          * sets the isParagraphStart() flag to true.          */
specifier|public
name|void
name|setParagraphStart
parameter_list|()
block|{
name|this
operator|.
name|isParagraphStart
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|boolean
name|isArticleStart
parameter_list|()
block|{
return|return
name|isArticleStart
return|;
block|}
comment|/**          * Sets the isArticleStart() flag to true.          */
specifier|public
name|void
name|setArticleStart
parameter_list|()
block|{
name|this
operator|.
name|isArticleStart
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|boolean
name|isPageBreak
parameter_list|()
block|{
return|return
name|isPageBreak
return|;
block|}
comment|/**          * Sets the isPageBreak() flag to true.          */
specifier|public
name|void
name|setPageBreak
parameter_list|()
block|{
name|this
operator|.
name|isPageBreak
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|boolean
name|isHangingIndent
parameter_list|()
block|{
return|return
name|isHangingIndent
return|;
block|}
comment|/**          * Sets the isHangingIndent() flag to true.          */
specifier|public
name|void
name|setHangingIndent
parameter_list|()
block|{
name|this
operator|.
name|isHangingIndent
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

