begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * The "PDFDocEncoding" encoding. Note that this is *not* a Type 1 font encoding, it is used only  * within PDF "text strings".  */
end_comment

begin_class
specifier|final
class|class
name|PDFDocEncoding
block|{
specifier|private
specifier|static
specifier|final
name|char
name|REPLACEMENT_CHARACTER
init|=
literal|'\uFFFD'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|CODE_TO_UNI
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Character
argument_list|,
name|Integer
argument_list|>
name|UNI_TO_CODE
decl_stmt|;
static|static
block|{
name|CODE_TO_UNI
operator|=
operator|new
name|int
index|[
literal|256
index|]
expr_stmt|;
name|UNI_TO_CODE
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|256
argument_list|)
expr_stmt|;
comment|// initialize with basically ISO-8859-1
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|set
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
comment|// then do all deviations (based on the table in ISO 32000-1:2008)
comment|// block 1
name|set
argument_list|(
literal|0x18
argument_list|,
literal|'\u02D8'
argument_list|)
expr_stmt|;
comment|// BREVE
name|set
argument_list|(
literal|0x19
argument_list|,
literal|'\u02C7'
argument_list|)
expr_stmt|;
comment|// CARON
name|set
argument_list|(
literal|0x1A
argument_list|,
literal|'\u02C6'
argument_list|)
expr_stmt|;
comment|// MODIFIER LETTER CIRCUMFLEX ACCENT
name|set
argument_list|(
literal|0x1B
argument_list|,
literal|'\u02D9'
argument_list|)
expr_stmt|;
comment|// DOT ABOVE
name|set
argument_list|(
literal|0x1C
argument_list|,
literal|'\u02DD'
argument_list|)
expr_stmt|;
comment|// DOUBLE ACUTE ACCENT
name|set
argument_list|(
literal|0x1D
argument_list|,
literal|'\u02DB'
argument_list|)
expr_stmt|;
comment|// OGONEK
name|set
argument_list|(
literal|0x1E
argument_list|,
literal|'\u02DA'
argument_list|)
expr_stmt|;
comment|// RING ABOVE
name|set
argument_list|(
literal|0x1F
argument_list|,
literal|'\u02DC'
argument_list|)
expr_stmt|;
comment|// SMALL TILDE
comment|// block 2
name|set
argument_list|(
literal|0x7F
argument_list|,
name|REPLACEMENT_CHARACTER
argument_list|)
expr_stmt|;
comment|// undefined
name|set
argument_list|(
literal|0x80
argument_list|,
literal|'\u2022'
argument_list|)
expr_stmt|;
comment|// BULLET
name|set
argument_list|(
literal|0x81
argument_list|,
literal|'\u2020'
argument_list|)
expr_stmt|;
comment|// DAGGER
name|set
argument_list|(
literal|0x82
argument_list|,
literal|'\u2021'
argument_list|)
expr_stmt|;
comment|// DOUBLE DAGGER
name|set
argument_list|(
literal|0x83
argument_list|,
literal|'\u2026'
argument_list|)
expr_stmt|;
comment|// HORIZONTAL ELLIPSIS
name|set
argument_list|(
literal|0x84
argument_list|,
literal|'\u2014'
argument_list|)
expr_stmt|;
comment|// EM DASH
name|set
argument_list|(
literal|0x85
argument_list|,
literal|'\u2013'
argument_list|)
expr_stmt|;
comment|// EN DASH
name|set
argument_list|(
literal|0x86
argument_list|,
literal|'\u0192'
argument_list|)
expr_stmt|;
comment|// LATIN SMALL LETTER SCRIPT F
name|set
argument_list|(
literal|0x87
argument_list|,
literal|'\u2044'
argument_list|)
expr_stmt|;
comment|// FRACTION SLASH (solidus)
name|set
argument_list|(
literal|0x88
argument_list|,
literal|'\u2039'
argument_list|)
expr_stmt|;
comment|// SINGLE LEFT-POINTING ANGLE QUOTATION MARK
name|set
argument_list|(
literal|0x89
argument_list|,
literal|'\u203A'
argument_list|)
expr_stmt|;
comment|// SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
name|set
argument_list|(
literal|0x8A
argument_list|,
literal|'\u2212'
argument_list|)
expr_stmt|;
comment|// MINUS SIGN
name|set
argument_list|(
literal|0x8B
argument_list|,
literal|'\u2030'
argument_list|)
expr_stmt|;
comment|// PER MILLE SIGN
name|set
argument_list|(
literal|0x8C
argument_list|,
literal|'\u201E'
argument_list|)
expr_stmt|;
comment|// DOUBLE LOW-9 QUOTATION MARK (quotedblbase)
name|set
argument_list|(
literal|0x8D
argument_list|,
literal|'\u201C'
argument_list|)
expr_stmt|;
comment|// LEFT DOUBLE QUOTATION MARK (quotedblleft)
name|set
argument_list|(
literal|0x8E
argument_list|,
literal|'\u201D'
argument_list|)
expr_stmt|;
comment|// RIGHT DOUBLE QUOTATION MARK (quotedblright)
name|set
argument_list|(
literal|0x8F
argument_list|,
literal|'\u2018'
argument_list|)
expr_stmt|;
comment|// LEFT SINGLE QUOTATION MARK (quoteleft)
name|set
argument_list|(
literal|0x90
argument_list|,
literal|'\u2019'
argument_list|)
expr_stmt|;
comment|// RIGHT SINGLE QUOTATION MARK (quoteright)
name|set
argument_list|(
literal|0x91
argument_list|,
literal|'\u201A'
argument_list|)
expr_stmt|;
comment|// SINGLE LOW-9 QUOTATION MARK (quotesinglbase)
name|set
argument_list|(
literal|0x92
argument_list|,
literal|'\u2122'
argument_list|)
expr_stmt|;
comment|// TRADE MARK SIGN
name|set
argument_list|(
literal|0x93
argument_list|,
literal|'\uFB01'
argument_list|)
expr_stmt|;
comment|// LATIN SMALL LIGATURE FI
name|set
argument_list|(
literal|0x94
argument_list|,
literal|'\uFB02'
argument_list|)
expr_stmt|;
comment|// LATIN SMALL LIGATURE FL
name|set
argument_list|(
literal|0x95
argument_list|,
literal|'\u0141'
argument_list|)
expr_stmt|;
comment|// LATIN CAPITAL LETTER L WITH STROKE
name|set
argument_list|(
literal|0x96
argument_list|,
literal|'\u0152'
argument_list|)
expr_stmt|;
comment|// LATIN CAPITAL LIGATURE OE
name|set
argument_list|(
literal|0x97
argument_list|,
literal|'\u0160'
argument_list|)
expr_stmt|;
comment|// LATIN CAPITAL LETTER S WITH CARON
name|set
argument_list|(
literal|0x98
argument_list|,
literal|'\u0178'
argument_list|)
expr_stmt|;
comment|// LATIN CAPITAL LETTER Y WITH DIAERESIS
name|set
argument_list|(
literal|0x99
argument_list|,
literal|'\u017D'
argument_list|)
expr_stmt|;
comment|// LATIN CAPITAL LETTER Z WITH CARON
name|set
argument_list|(
literal|0x9A
argument_list|,
literal|'\u0131'
argument_list|)
expr_stmt|;
comment|// LATIN SMALL LETTER DOTLESS I
name|set
argument_list|(
literal|0x9B
argument_list|,
literal|'\u0142'
argument_list|)
expr_stmt|;
comment|// LATIN SMALL LETTER L WITH STROKE
name|set
argument_list|(
literal|0x9C
argument_list|,
literal|'\u0153'
argument_list|)
expr_stmt|;
comment|// LATIN SMALL LIGATURE OE
name|set
argument_list|(
literal|0x9D
argument_list|,
literal|'\u0161'
argument_list|)
expr_stmt|;
comment|// LATIN SMALL LETTER S WITH CARON
name|set
argument_list|(
literal|0x9E
argument_list|,
literal|'\u017E'
argument_list|)
expr_stmt|;
comment|// LATIN SMALL LETTER Z WITH CARON
name|set
argument_list|(
literal|0x9F
argument_list|,
name|REPLACEMENT_CHARACTER
argument_list|)
expr_stmt|;
comment|// undefined
name|set
argument_list|(
literal|0xA0
argument_list|,
literal|'\u20AC'
argument_list|)
expr_stmt|;
comment|// EURO SIGN
comment|// end of deviations
block|}
specifier|private
name|PDFDocEncoding
parameter_list|()
block|{     }
specifier|private
specifier|static
name|void
name|set
parameter_list|(
name|int
name|code
parameter_list|,
name|char
name|unicode
parameter_list|)
block|{
name|CODE_TO_UNI
index|[
name|code
index|]
operator|=
name|unicode
expr_stmt|;
name|UNI_TO_CODE
operator|.
name|put
argument_list|(
name|unicode
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the string representation of the given PDFDocEncoded bytes.      */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|byte
name|b
range|:
name|bytes
control|)
block|{
if|if
condition|(
operator|(
name|b
operator|&
literal|0xff
operator|)
operator|>=
name|CODE_TO_UNI
operator|.
name|length
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|CODE_TO_UNI
index|[
name|b
operator|&
literal|0xff
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns the given string encoded with PDFDocEncoding.      */
specifier|public
specifier|static
name|byte
index|[]
name|getBytes
parameter_list|(
name|String
name|text
parameter_list|)
block|{
name|ByteArrayOutputStream
name|out
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|text
operator|.
name|toCharArray
argument_list|()
control|)
block|{
name|Integer
name|code
init|=
name|UNI_TO_CODE
operator|.
name|get
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**      * Returns true if the given character is available in PDFDocEncoding.      *      * @param character UTF-16 character      */
specifier|public
specifier|static
name|boolean
name|containsChar
parameter_list|(
name|char
name|character
parameter_list|)
block|{
return|return
name|UNI_TO_CODE
operator|.
name|containsKey
argument_list|(
name|character
argument_list|)
return|;
block|}
block|}
end_class

end_unit

