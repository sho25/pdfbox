begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|ScratchFile
import|;
end_import

begin_comment
comment|/**  * This is the in-memory representation of the PDF document.  You need to call  * close() on this object when you are done using it!!  *  * @author Ben Litchfield  *   */
end_comment

begin_class
specifier|public
class|class
name|COSDocument
extends|extends
name|COSBase
implements|implements
name|Closeable
block|{
comment|/**      * Log instance.      */
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|COSDocument
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|float
name|version
init|=
literal|1.4f
decl_stmt|;
comment|/**      * Maps ObjectKeys to a COSObject. Note that references to these objects      * are also stored in COSDictionary objects that map a name to a specific object.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|COSObject
argument_list|>
name|objectPool
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Maps object and generation id to object byte offsets.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|xrefTable
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * List containing all streams which are created when creating a new pdf.       */
specifier|private
specifier|final
name|List
argument_list|<
name|COSStream
argument_list|>
name|streams
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * Document trailer dictionary.      */
specifier|private
name|COSDictionary
name|trailer
decl_stmt|;
specifier|private
name|boolean
name|warnMissingClose
init|=
literal|true
decl_stmt|;
comment|/**       * Signal that document is already decrypted.       */
specifier|private
name|boolean
name|isDecrypted
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|startXref
decl_stmt|;
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|isXRefStream
decl_stmt|;
specifier|private
name|ScratchFile
name|scratchFile
decl_stmt|;
comment|/**      * Used for incremental saving, to avoid XRef object numbers from being reused.      */
specifier|private
name|long
name|highestXRefObjectNumber
decl_stmt|;
specifier|private
name|ICOSParser
name|parser
decl_stmt|;
comment|/**      * Constructor. Uses main memory to buffer PDF streams.      */
specifier|public
name|COSDocument
parameter_list|()
block|{
name|this
argument_list|(
name|ScratchFile
operator|.
name|getMainMemoryOnlyInstance
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor. Uses main memory to buffer PDF streams.      *       * @param parser Parser to be used to parse the document on demand      */
specifier|public
name|COSDocument
parameter_list|(
name|ICOSParser
name|parser
parameter_list|)
block|{
name|this
argument_list|(
name|ScratchFile
operator|.
name|getMainMemoryOnlyInstance
argument_list|()
argument_list|,
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor that will use the provide memory handler for storage of the      * PDF streams.      *      * @param scratchFile memory handler for buffering of PDF streams      *       */
specifier|public
name|COSDocument
parameter_list|(
name|ScratchFile
name|scratchFile
parameter_list|)
block|{
name|this
argument_list|(
name|scratchFile
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor that will use the provide memory handler for storage of the PDF streams.      *      * @param scratchFile memory handler for buffering of PDF streams      * @param parser Parser to be used to parse the document on demand      *       */
specifier|public
name|COSDocument
parameter_list|(
name|ScratchFile
name|scratchFile
parameter_list|,
name|ICOSParser
name|parser
parameter_list|)
block|{
name|this
operator|.
name|scratchFile
operator|=
name|scratchFile
expr_stmt|;
name|this
operator|.
name|parser
operator|=
name|parser
expr_stmt|;
block|}
comment|/**      * Creates a new COSStream using the current configuration for scratch files.      *       * @return the new COSStream      */
specifier|public
name|COSStream
name|createCOSStream
parameter_list|()
block|{
name|COSStream
name|stream
init|=
operator|new
name|COSStream
argument_list|(
name|scratchFile
argument_list|)
decl_stmt|;
comment|// collect all COSStreams so that they can be closed when closing the COSDocument.
comment|// This is limited to newly created pdfs as all COSStreams of an existing pdf are
comment|// collected within the map objectPool
name|streams
operator|.
name|add
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
comment|/**      * Creates a new COSStream using the current configuration for scratch files.      * Not for public use. Only COSParser should call this method.      *      * @param dictionary the corresponding dictionary      * @return the new COSStream      */
specifier|public
name|COSStream
name|createCOSStream
parameter_list|(
name|COSDictionary
name|dictionary
parameter_list|)
block|{
name|COSStream
name|stream
init|=
operator|new
name|COSStream
argument_list|(
name|scratchFile
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|COSName
argument_list|,
name|COSBase
argument_list|>
name|entry
range|:
name|dictionary
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|stream
operator|.
name|setItem
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|stream
return|;
block|}
comment|/**      * Get the dictionary containing the linearization information if the pdf is linearized.      *       * @return the dictionary containing the linearization information      */
specifier|public
name|COSDictionary
name|getLinearizedDictionary
parameter_list|()
block|{
comment|// get all keys with a positive offset in ascending order, as the linearization dictionary shall be the first
comment|// within the pdf
name|List
argument_list|<
name|COSObjectKey
argument_list|>
name|objectKeys
init|=
name|xrefTable
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
comment|//
operator|.
name|filter
argument_list|(
name|e
lambda|->
name|e
operator|.
name|getValue
argument_list|()
operator|>
literal|0L
argument_list|)
comment|//
operator|.
name|sorted
argument_list|(
parameter_list|(
name|e1
parameter_list|,
name|e2
parameter_list|)
lambda|->
name|e1
operator|.
name|getValue
argument_list|()
operator|.
name|compareTo
argument_list|(
name|e2
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
comment|//
operator|.
name|map
argument_list|(
name|Entry
operator|::
name|getKey
argument_list|)
comment|//
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|COSObjectKey
name|objectKey
range|:
name|objectKeys
control|)
block|{
name|COSObject
name|objectFromPool
init|=
name|getObjectFromPool
argument_list|(
name|objectKey
argument_list|)
decl_stmt|;
name|COSBase
name|realObject
init|=
name|objectFromPool
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|realObject
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSDictionary
name|dic
init|=
operator|(
name|COSDictionary
operator|)
name|realObject
decl_stmt|;
if|if
condition|(
name|dic
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|LINEARIZED
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
name|dic
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * This will get all dictionaries objects by type.      *      * @param type The type of the object.      *      * @return This will return all objects with the specified type.      */
specifier|public
name|List
argument_list|<
name|COSObject
argument_list|>
name|getObjectsByType
parameter_list|(
name|COSName
name|type
parameter_list|)
block|{
return|return
name|getObjectsByType
argument_list|(
name|type
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * This will get all dictionaries objects by type.      *      * @param type1 The first possible type of the object, mandatory.      * @param type2 The second possible type of the object, usally an abreviation, optional.      *      * @return This will return all objects with the specified type(s).      */
specifier|public
name|List
argument_list|<
name|COSObject
argument_list|>
name|getObjectsByType
parameter_list|(
name|COSName
name|type1
parameter_list|,
name|COSName
name|type2
parameter_list|)
block|{
name|List
argument_list|<
name|COSObject
argument_list|>
name|retval
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|COSObjectKey
name|objectKey
range|:
name|xrefTable
operator|.
name|keySet
argument_list|()
control|)
block|{
name|COSObject
name|objectFromPool
init|=
name|getObjectFromPool
argument_list|(
name|objectKey
argument_list|)
decl_stmt|;
name|COSBase
name|realObject
init|=
name|objectFromPool
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|realObject
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSName
name|dictType
init|=
operator|(
operator|(
name|COSDictionary
operator|)
name|realObject
operator|)
operator|.
name|getCOSName
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|.
name|equals
argument_list|(
name|dictType
argument_list|)
operator|||
operator|(
name|type2
operator|!=
literal|null
operator|&&
name|type2
operator|.
name|equals
argument_list|(
name|dictType
argument_list|)
operator|)
condition|)
block|{
name|retval
operator|.
name|add
argument_list|(
name|objectFromPool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will set the header version of this PDF document.      *      * @param versionValue The version of the PDF document.      */
specifier|public
name|void
name|setVersion
parameter_list|(
name|float
name|versionValue
parameter_list|)
block|{
name|version
operator|=
name|versionValue
expr_stmt|;
block|}
comment|/**      * This will get the version extracted from the header of this PDF document.      *      * @return The header version.      */
specifier|public
name|float
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
comment|/**       * Signals that the document is decrypted completely.      */
specifier|public
name|void
name|setDecrypted
parameter_list|()
block|{
name|isDecrypted
operator|=
literal|true
expr_stmt|;
block|}
comment|/**       * Indicates if a encrypted pdf is already decrypted after parsing.      *       *  @return true indicates that the pdf is decrypted.      */
specifier|public
name|boolean
name|isDecrypted
parameter_list|()
block|{
return|return
name|isDecrypted
return|;
block|}
comment|/**      * This will tell if this is an encrypted document.      *      * @return true If this document is encrypted.      */
specifier|public
name|boolean
name|isEncrypted
parameter_list|()
block|{
name|boolean
name|encrypted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|trailer
operator|!=
literal|null
condition|)
block|{
name|encrypted
operator|=
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
operator|instanceof
name|COSDictionary
expr_stmt|;
block|}
return|return
name|encrypted
return|;
block|}
comment|/**      * This will get the encryption dictionary if the document is encrypted or null if the document      * is not encrypted.      *      * @return The encryption dictionary.      */
specifier|public
name|COSDictionary
name|getEncryptionDictionary
parameter_list|()
block|{
return|return
name|trailer
operator|.
name|getCOSDictionary
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
return|;
block|}
comment|/**      * This will set the encryption dictionary, this should only be called when      * encrypting the document.      *      * @param encDictionary The encryption dictionary.      */
specifier|public
name|void
name|setEncryptionDictionary
parameter_list|(
name|COSDictionary
name|encDictionary
parameter_list|)
block|{
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|,
name|encDictionary
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will get the document ID.      *      * @return The document id.      */
specifier|public
name|COSArray
name|getDocumentID
parameter_list|()
block|{
return|return
name|getTrailer
argument_list|()
operator|.
name|getCOSArray
argument_list|(
name|COSName
operator|.
name|ID
argument_list|)
return|;
block|}
comment|/**      * This will set the document ID.      *      * @param id The document id.      */
specifier|public
name|void
name|setDocumentID
parameter_list|(
name|COSArray
name|id
parameter_list|)
block|{
name|getTrailer
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ID
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will get the document trailer.      *      * @return the document trailer dict      */
specifier|public
name|COSDictionary
name|getTrailer
parameter_list|()
block|{
return|return
name|trailer
return|;
block|}
comment|/**      * // MIT added, maybe this should not be supported as trailer is a persistence construct.      * This will set the document trailer.      *      * @param newTrailer the document trailer dictionary      */
specifier|public
name|void
name|setTrailer
parameter_list|(
name|COSDictionary
name|newTrailer
parameter_list|)
block|{
name|trailer
operator|=
name|newTrailer
expr_stmt|;
block|}
comment|/**      * Internal PDFBox use only. Get the object number of the highest XRef stream. This is needed to      * avoid reusing such a number in incremental saving.      *      * @return The object number of the highest XRef stream, or 0 if there was no XRef stream.      */
specifier|public
name|long
name|getHighestXRefObjectNumber
parameter_list|()
block|{
return|return
name|highestXRefObjectNumber
return|;
block|}
comment|/**      * Internal PDFBox use only. Sets the object number of the highest XRef stream. This is needed      * to avoid reusing such a number in incremental saving.      *      * @param highestXRefObjectNumber The object number of the highest XRef stream.      */
specifier|public
name|void
name|setHighestXRefObjectNumber
parameter_list|(
name|long
name|highestXRefObjectNumber
parameter_list|)
block|{
name|this
operator|.
name|highestXRefObjectNumber
operator|=
name|highestXRefObjectNumber
expr_stmt|;
block|}
comment|/**      * visitor pattern double dispatch method.      *      * @param visitor The object to notify when visiting this object.      * @return any object, depending on the visitor implementation, or null      * @throws IOException If an error occurs while visiting this object.      */
annotation|@
name|Override
specifier|public
name|Object
name|accept
parameter_list|(
name|ICOSVisitor
name|visitor
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|visitor
operator|.
name|visitFromDocument
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * This will close all storage and delete the tmp files.      *      *  @throws IOException If there is an error close resources.      */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
comment|// Make sure that:
comment|// - first Exception is kept
comment|// - all COSStreams are closed
comment|// - ScratchFile is closed
comment|// - there's a way to see which errors occurred
name|IOException
name|firstException
init|=
literal|null
decl_stmt|;
comment|// close all open I/O streams
for|for
control|(
name|COSObject
name|object
range|:
name|objectPool
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|object
operator|.
name|isObjectNull
argument_list|()
condition|)
block|{
name|COSBase
name|cosObject
init|=
name|object
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|cosObject
operator|instanceof
name|COSStream
condition|)
block|{
name|firstException
operator|=
name|IOUtils
operator|.
name|closeAndLogException
argument_list|(
operator|(
name|COSStream
operator|)
name|cosObject
argument_list|,
name|LOG
argument_list|,
literal|"COSStream"
argument_list|,
name|firstException
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|COSStream
name|stream
range|:
name|streams
control|)
block|{
name|firstException
operator|=
name|IOUtils
operator|.
name|closeAndLogException
argument_list|(
name|stream
argument_list|,
name|LOG
argument_list|,
literal|"COSStream"
argument_list|,
name|firstException
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scratchFile
operator|!=
literal|null
condition|)
block|{
name|firstException
operator|=
name|IOUtils
operator|.
name|closeAndLogException
argument_list|(
name|scratchFile
argument_list|,
name|LOG
argument_list|,
literal|"ScratchFile"
argument_list|,
name|firstException
argument_list|)
expr_stmt|;
block|}
name|closed
operator|=
literal|true
expr_stmt|;
comment|// rethrow first exception to keep method contract
if|if
condition|(
name|firstException
operator|!=
literal|null
condition|)
block|{
throw|throw
name|firstException
throw|;
block|}
block|}
block|}
comment|/**      * Returns true if this document has been closed.      */
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|closed
return|;
block|}
comment|/**      * Warn the user in the finalizer if he didn't close the PDF document. The method also      * closes the document just in case, to avoid abandoned temporary files. It's still a good      * idea for the user to close the PDF document at the earliest possible to conserve resources.      * @throws IOException if an error occurs while closing the temporary files      */
annotation|@
name|Override
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
if|if
condition|(
name|warnMissingClose
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Warning: You did not close a PDF Document"
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Controls whether this instance shall issue a warning if the PDF document wasn't closed      * properly through a call to the {@link #close()} method. If the PDF document is held in      * a cache governed by soft references it is impossible to reliably close the document      * before the warning is raised. By default, the warning is enabled.      * @param warn true enables the warning, false disables it.      */
specifier|public
name|void
name|setWarnMissingClose
parameter_list|(
name|boolean
name|warn
parameter_list|)
block|{
name|this
operator|.
name|warnMissingClose
operator|=
name|warn
expr_stmt|;
block|}
comment|/**      * This will get an object from the pool.      *      * @param key The object key.      *      * @return The object in the pool or a new one if it has not been parsed yet.      */
specifier|public
name|COSObject
name|getObjectFromPool
parameter_list|(
name|COSObjectKey
name|key
parameter_list|)
block|{
name|COSObject
name|obj
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
comment|// make "proxy" object if this was a forward reference
name|obj
operator|=
name|objectPool
operator|.
name|computeIfAbsent
argument_list|(
name|key
argument_list|,
name|k
lambda|->
operator|new
name|COSObject
argument_list|(
name|k
argument_list|,
name|parser
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|obj
return|;
block|}
comment|/**      * Populate XRef HashMap with given values.      * Each entry maps ObjectKeys to byte offsets in the file.      * @param xrefTableValues  xref table entries to be added      */
specifier|public
name|void
name|addXRefTable
parameter_list|(
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|xrefTableValues
parameter_list|)
block|{
name|xrefTable
operator|.
name|putAll
argument_list|(
name|xrefTableValues
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the xrefTable which is a mapping of ObjectKeys      * to byte offsets in the file.      * @return mapping of ObjectsKeys to byte offsets      */
specifier|public
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|getXrefTable
parameter_list|()
block|{
return|return
name|xrefTable
return|;
block|}
comment|/**      * This method set the startxref value of the document. This will only       * be needed for incremental updates.      *       * @param startXrefValue the value for startXref      */
specifier|public
name|void
name|setStartXref
parameter_list|(
name|long
name|startXrefValue
parameter_list|)
block|{
name|startXref
operator|=
name|startXrefValue
expr_stmt|;
block|}
comment|/**      * Return the startXref Position of the parsed document. This will only be needed for incremental updates.      *       * @return a long with the old position of the startxref      */
specifier|public
name|long
name|getStartXref
parameter_list|()
block|{
return|return
name|startXref
return|;
block|}
comment|/**      * Determines if the trailer is a XRef stream or not.      *       * @return true if the trailer is a XRef stream      */
specifier|public
name|boolean
name|isXRefStream
parameter_list|()
block|{
return|return
name|isXRefStream
return|;
block|}
comment|/**      * Sets isXRefStream to the given value. You need to take care that the version of your PDF is      * 1.5 or higher.      *      * @param isXRefStreamValue the new value for isXRefStream      */
specifier|public
name|void
name|setIsXRefStream
parameter_list|(
name|boolean
name|isXRefStreamValue
parameter_list|)
block|{
name|isXRefStream
operator|=
name|isXRefStreamValue
expr_stmt|;
block|}
block|}
end_class

end_unit

