begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2014 The Apache Software Foundation.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|shading
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|Point2D
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * This class is used to describe a patch for type 6 shading. This was done as  * part of GSoC2014, Tilman Hausherr is the mentor.  *  * @author Shaola Ren  */
end_comment

begin_class
class|class
name|CoonsPatch
extends|extends
name|Patch
block|{
comment|/**      * Constructor of a patch for type 6 shading.      *      * @param points 12 control points      * @param color 4 corner colors      */
specifier|protected
name|CoonsPatch
parameter_list|(
name|Point2D
index|[]
name|points
parameter_list|,
name|float
index|[]
index|[]
name|color
parameter_list|)
block|{
name|super
argument_list|(
name|points
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|controlPoints
operator|=
name|reshapeControlPoints
argument_list|(
name|points
argument_list|)
expr_stmt|;
name|level
operator|=
name|calcLevel
argument_list|()
expr_stmt|;
name|listOfTriangles
operator|=
name|getTriangles
argument_list|()
expr_stmt|;
block|}
comment|// adjust the 12 control points to 4 groups, each group defines one edge of a patch
specifier|private
name|Point2D
index|[]
index|[]
name|reshapeControlPoints
parameter_list|(
name|Point2D
index|[]
name|points
parameter_list|)
block|{
name|Point2D
index|[]
index|[]
name|fourRows
init|=
operator|new
name|Point2D
index|[
literal|4
index|]
index|[
literal|4
index|]
decl_stmt|;
name|fourRows
index|[
literal|2
index|]
operator|=
operator|new
name|Point2D
index|[]
block|{
name|points
index|[
literal|0
index|]
block|,
name|points
index|[
literal|1
index|]
block|,
name|points
index|[
literal|2
index|]
block|,
name|points
index|[
literal|3
index|]
block|}
expr_stmt|;
comment|// d1
name|fourRows
index|[
literal|1
index|]
operator|=
operator|new
name|Point2D
index|[]
block|{
name|points
index|[
literal|3
index|]
block|,
name|points
index|[
literal|4
index|]
block|,
name|points
index|[
literal|5
index|]
block|,
name|points
index|[
literal|6
index|]
block|}
expr_stmt|;
comment|// c2
name|fourRows
index|[
literal|3
index|]
operator|=
operator|new
name|Point2D
index|[]
block|{
name|points
index|[
literal|9
index|]
block|,
name|points
index|[
literal|8
index|]
block|,
name|points
index|[
literal|7
index|]
block|,
name|points
index|[
literal|6
index|]
block|}
expr_stmt|;
comment|// d2
name|fourRows
index|[
literal|0
index|]
operator|=
operator|new
name|Point2D
index|[]
block|{
name|points
index|[
literal|0
index|]
block|,
name|points
index|[
literal|11
index|]
block|,
name|points
index|[
literal|10
index|]
block|,
name|points
index|[
literal|9
index|]
block|}
expr_stmt|;
comment|// c1
return|return
name|fourRows
return|;
block|}
comment|// calculate the dividing level from control points
specifier|private
name|int
index|[]
name|calcLevel
parameter_list|()
block|{
name|int
index|[]
name|l
init|=
block|{
literal|4
block|,
literal|4
block|}
decl_stmt|;
comment|// if two opposite edges are both lines, there is a possibility to reduce the dividing level
if|if
condition|(
name|isEdgeALine
argument_list|(
name|controlPoints
index|[
literal|0
index|]
argument_list|)
operator|&
name|isEdgeALine
argument_list|(
name|controlPoints
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|double
name|lc1
init|=
name|getLen
argument_list|(
name|controlPoints
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|controlPoints
index|[
literal|0
index|]
index|[
literal|3
index|]
argument_list|)
decl_stmt|,
name|lc2
init|=
name|getLen
argument_list|(
name|controlPoints
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|controlPoints
index|[
literal|1
index|]
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
comment|// determine the dividing level by the lengths of edges
if|if
condition|(
name|lc1
operator|>
literal|800
operator|||
name|lc2
operator|>
literal|800
condition|)
block|{             }
elseif|else
if|if
condition|(
name|lc1
operator|>
literal|400
operator|||
name|lc2
operator|>
literal|400
condition|)
block|{
name|l
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lc1
operator|>
literal|200
operator|||
name|lc2
operator|>
literal|200
condition|)
block|{
name|l
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|l
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|// the other two opposite edges
if|if
condition|(
name|isEdgeALine
argument_list|(
name|controlPoints
index|[
literal|2
index|]
argument_list|)
operator|&
name|isEdgeALine
argument_list|(
name|controlPoints
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|double
name|ld1
init|=
name|getLen
argument_list|(
name|controlPoints
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|controlPoints
index|[
literal|2
index|]
index|[
literal|3
index|]
argument_list|)
decl_stmt|,
name|ld2
init|=
name|getLen
argument_list|(
name|controlPoints
index|[
literal|3
index|]
index|[
literal|0
index|]
argument_list|,
name|controlPoints
index|[
literal|3
index|]
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|ld1
operator|>
literal|800
operator|||
name|ld2
operator|>
literal|800
condition|)
block|{             }
elseif|else
if|if
condition|(
name|ld1
operator|>
literal|400
operator|||
name|ld2
operator|>
literal|400
condition|)
block|{
name|l
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ld1
operator|>
literal|200
operator|||
name|ld2
operator|>
literal|200
condition|)
block|{
name|l
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|l
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|l
return|;
block|}
comment|// get a list of triangles which compose this coons patch
specifier|private
name|List
argument_list|<
name|ShadedTriangle
argument_list|>
name|getTriangles
parameter_list|()
block|{
comment|// 4 edges are 4 cubic Bezier curves
name|CubicBezierCurve
name|eC1
init|=
operator|new
name|CubicBezierCurve
argument_list|(
name|controlPoints
index|[
literal|0
index|]
argument_list|,
name|level
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|CubicBezierCurve
name|eC2
init|=
operator|new
name|CubicBezierCurve
argument_list|(
name|controlPoints
index|[
literal|1
index|]
argument_list|,
name|level
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|CubicBezierCurve
name|eD1
init|=
operator|new
name|CubicBezierCurve
argument_list|(
name|controlPoints
index|[
literal|2
index|]
argument_list|,
name|level
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|CubicBezierCurve
name|eD2
init|=
operator|new
name|CubicBezierCurve
argument_list|(
name|controlPoints
index|[
literal|3
index|]
argument_list|,
name|level
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|CoordinateColorPair
index|[]
index|[]
name|patchCC
init|=
name|getPatchCoordinatesColor
argument_list|(
name|eC1
argument_list|,
name|eC2
argument_list|,
name|eD1
argument_list|,
name|eD2
argument_list|)
decl_stmt|;
return|return
name|getShadedTriangles
argument_list|(
name|patchCC
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Point2D
index|[]
name|getFlag1Edge
parameter_list|()
block|{
return|return
name|controlPoints
index|[
literal|1
index|]
operator|.
name|clone
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Point2D
index|[]
name|getFlag2Edge
parameter_list|()
block|{
name|Point2D
index|[]
name|implicitEdge
init|=
operator|new
name|Point2D
index|[
literal|4
index|]
decl_stmt|;
name|implicitEdge
index|[
literal|0
index|]
operator|=
name|controlPoints
index|[
literal|3
index|]
index|[
literal|3
index|]
expr_stmt|;
name|implicitEdge
index|[
literal|1
index|]
operator|=
name|controlPoints
index|[
literal|3
index|]
index|[
literal|2
index|]
expr_stmt|;
name|implicitEdge
index|[
literal|2
index|]
operator|=
name|controlPoints
index|[
literal|3
index|]
index|[
literal|1
index|]
expr_stmt|;
name|implicitEdge
index|[
literal|3
index|]
operator|=
name|controlPoints
index|[
literal|3
index|]
index|[
literal|0
index|]
expr_stmt|;
return|return
name|implicitEdge
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Point2D
index|[]
name|getFlag3Edge
parameter_list|()
block|{
name|Point2D
index|[]
name|implicitEdge
init|=
operator|new
name|Point2D
index|[
literal|4
index|]
decl_stmt|;
name|implicitEdge
index|[
literal|0
index|]
operator|=
name|controlPoints
index|[
literal|0
index|]
index|[
literal|3
index|]
expr_stmt|;
name|implicitEdge
index|[
literal|1
index|]
operator|=
name|controlPoints
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|implicitEdge
index|[
literal|2
index|]
operator|=
name|controlPoints
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|implicitEdge
index|[
literal|3
index|]
operator|=
name|controlPoints
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
return|return
name|implicitEdge
return|;
block|}
comment|/*      dividing a patch into a grid, return a matrix of the coordinate and color at the crossing points of the grid,       the rule to calculate the coordinate is defined in page 195 of PDF32000_2008.pdf, the rule to calculate the       cooresponding color is bilinear interpolation      */
specifier|private
name|CoordinateColorPair
index|[]
index|[]
name|getPatchCoordinatesColor
parameter_list|(
name|CubicBezierCurve
name|C1
parameter_list|,
name|CubicBezierCurve
name|C2
parameter_list|,
name|CubicBezierCurve
name|D1
parameter_list|,
name|CubicBezierCurve
name|D2
parameter_list|)
block|{
name|Point2D
index|[]
name|curveC1
init|=
name|C1
operator|.
name|getCubicBezierCurve
argument_list|()
decl_stmt|;
name|Point2D
index|[]
name|curveC2
init|=
name|C2
operator|.
name|getCubicBezierCurve
argument_list|()
decl_stmt|;
name|Point2D
index|[]
name|curveD1
init|=
name|D1
operator|.
name|getCubicBezierCurve
argument_list|()
decl_stmt|;
name|Point2D
index|[]
name|curveD2
init|=
name|D2
operator|.
name|getCubicBezierCurve
argument_list|()
decl_stmt|;
name|int
name|numberOfColorComponents
init|=
name|cornerColor
index|[
literal|0
index|]
operator|.
name|length
decl_stmt|;
name|int
name|szV
init|=
name|curveD1
operator|.
name|length
decl_stmt|;
name|int
name|szU
init|=
name|curveC1
operator|.
name|length
decl_stmt|;
name|CoordinateColorPair
index|[]
index|[]
name|patchCC
init|=
operator|new
name|CoordinateColorPair
index|[
name|szV
index|]
index|[
name|szU
index|]
decl_stmt|;
name|double
name|stepV
init|=
operator|(
name|double
operator|)
literal|1
operator|/
operator|(
name|szV
operator|-
literal|1
operator|)
decl_stmt|;
name|double
name|stepU
init|=
operator|(
name|double
operator|)
literal|1
operator|/
operator|(
name|szU
operator|-
literal|1
operator|)
decl_stmt|;
name|double
name|v
init|=
operator|-
name|stepV
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|szV
condition|;
name|i
operator|++
control|)
block|{
comment|// v and u are the assistant parameters
name|v
operator|+=
name|stepV
expr_stmt|;
name|double
name|u
init|=
operator|-
name|stepU
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|szU
condition|;
name|j
operator|++
control|)
block|{
name|u
operator|+=
name|stepU
expr_stmt|;
name|double
name|scx
init|=
operator|(
literal|1
operator|-
name|v
operator|)
operator|*
name|curveC1
index|[
name|j
index|]
operator|.
name|getX
argument_list|()
operator|+
name|v
operator|*
name|curveC2
index|[
name|j
index|]
operator|.
name|getX
argument_list|()
decl_stmt|;
name|double
name|scy
init|=
operator|(
literal|1
operator|-
name|v
operator|)
operator|*
name|curveC1
index|[
name|j
index|]
operator|.
name|getY
argument_list|()
operator|+
name|v
operator|*
name|curveC2
index|[
name|j
index|]
operator|.
name|getY
argument_list|()
decl_stmt|;
name|double
name|sdx
init|=
operator|(
literal|1
operator|-
name|u
operator|)
operator|*
name|curveD1
index|[
name|i
index|]
operator|.
name|getX
argument_list|()
operator|+
name|u
operator|*
name|curveD2
index|[
name|i
index|]
operator|.
name|getX
argument_list|()
decl_stmt|;
name|double
name|sdy
init|=
operator|(
literal|1
operator|-
name|u
operator|)
operator|*
name|curveD1
index|[
name|i
index|]
operator|.
name|getY
argument_list|()
operator|+
name|u
operator|*
name|curveD2
index|[
name|i
index|]
operator|.
name|getY
argument_list|()
decl_stmt|;
name|double
name|sbx
init|=
operator|(
literal|1
operator|-
name|v
operator|)
operator|*
operator|(
operator|(
literal|1
operator|-
name|u
operator|)
operator|*
name|controlPoints
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getX
argument_list|()
operator|+
name|u
operator|*
name|controlPoints
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|.
name|getX
argument_list|()
operator|)
operator|+
name|v
operator|*
operator|(
operator|(
literal|1
operator|-
name|u
operator|)
operator|*
name|controlPoints
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|.
name|getX
argument_list|()
operator|+
name|u
operator|*
name|controlPoints
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|.
name|getX
argument_list|()
operator|)
decl_stmt|;
name|double
name|sby
init|=
operator|(
literal|1
operator|-
name|v
operator|)
operator|*
operator|(
operator|(
literal|1
operator|-
name|u
operator|)
operator|*
name|controlPoints
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|.
name|getY
argument_list|()
operator|+
name|u
operator|*
name|controlPoints
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|.
name|getY
argument_list|()
operator|)
operator|+
name|v
operator|*
operator|(
operator|(
literal|1
operator|-
name|u
operator|)
operator|*
name|controlPoints
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|.
name|getY
argument_list|()
operator|+
name|u
operator|*
name|controlPoints
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|.
name|getY
argument_list|()
operator|)
decl_stmt|;
name|double
name|sx
init|=
name|scx
operator|+
name|sdx
operator|-
name|sbx
decl_stmt|;
name|double
name|sy
init|=
name|scy
operator|+
name|sdy
operator|-
name|sby
decl_stmt|;
comment|// the above code in this for loop defines the patch surface (coordinates)
name|Point2D
name|tmpC
init|=
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|sx
argument_list|,
name|sy
argument_list|)
decl_stmt|;
name|float
index|[]
name|paramSC
init|=
operator|new
name|float
index|[
name|numberOfColorComponents
index|]
decl_stmt|;
for|for
control|(
name|int
name|ci
init|=
literal|0
init|;
name|ci
operator|<
name|numberOfColorComponents
condition|;
name|ci
operator|++
control|)
block|{
name|paramSC
index|[
name|ci
index|]
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
literal|1
operator|-
name|v
operator|)
operator|*
operator|(
operator|(
literal|1
operator|-
name|u
operator|)
operator|*
name|cornerColor
index|[
literal|0
index|]
index|[
name|ci
index|]
operator|+
name|u
operator|*
name|cornerColor
index|[
literal|3
index|]
index|[
name|ci
index|]
operator|)
operator|+
name|v
operator|*
operator|(
operator|(
literal|1
operator|-
name|u
operator|)
operator|*
name|cornerColor
index|[
literal|1
index|]
index|[
name|ci
index|]
operator|+
name|u
operator|*
name|cornerColor
index|[
literal|2
index|]
index|[
name|ci
index|]
operator|)
argument_list|)
expr_stmt|;
comment|// bilinear interpolation
block|}
name|patchCC
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|new
name|CoordinateColorPair
argument_list|(
name|tmpC
argument_list|,
name|paramSC
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|patchCC
return|;
block|}
block|}
end_class

end_unit

