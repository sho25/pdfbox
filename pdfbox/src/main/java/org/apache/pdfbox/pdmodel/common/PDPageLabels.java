begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_comment
comment|/**  * Represents the page label dictionary of a document.  *   * @author Igor Podolskiy  */
end_comment

begin_class
specifier|public
class|class
name|PDPageLabels
implements|implements
name|COSObjectable
block|{
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|PDPageLabelRange
argument_list|>
name|labels
decl_stmt|;
specifier|private
name|PDDocument
name|doc
decl_stmt|;
comment|/**      * Creates an empty page label dictionary for the given document.      *       *<p>      * Note that the page label dictionary won't be automatically added to the      * document; you will still need to do it manually (see      * {@link org.apache.pdfbox.pdmodel.PDDocumentCatalog#setPageLabels(PDPageLabels)}.      *</p>      *       * @param document      *            The document the page label dictionary is created for.      * @see org.apache.pdfbox.pdmodel.PDDocumentCatalog#setPageLabels(PDPageLabels)      */
specifier|public
name|PDPageLabels
parameter_list|(
name|PDDocument
name|document
parameter_list|)
block|{
name|labels
operator|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|doc
operator|=
name|document
expr_stmt|;
name|PDPageLabelRange
name|defaultRange
init|=
operator|new
name|PDPageLabelRange
argument_list|()
decl_stmt|;
name|defaultRange
operator|.
name|setStyle
argument_list|(
name|PDPageLabelRange
operator|.
name|STYLE_DECIMAL
argument_list|)
expr_stmt|;
name|labels
operator|.
name|put
argument_list|(
literal|0
argument_list|,
name|defaultRange
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates an page label dictionary for a document using the information in      * the given COS dictionary.      *       *<p>      * Note that the page label dictionary won't be automatically added to the      * document; you will still need to do it manually (see      * {@link org.apache.pdfbox.pdmodel.PDDocumentCatalog#setPageLabels(PDPageLabels)}.      *</p>      *       * @param document      *            The document the page label dictionary is created for.      * @param dict      *            an existing page label dictionary      * @see org.apache.pdfbox.pdmodel.PDDocumentCatalog#setPageLabels(PDPageLabels)      * @throws IOException      *             If something goes wrong during the number tree conversion.      */
specifier|public
name|PDPageLabels
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|COSDictionary
name|dict
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|PDNumberTreeNode
name|root
init|=
operator|new
name|PDNumberTreeNode
argument_list|(
name|dict
argument_list|,
name|PDPageLabelRange
operator|.
name|class
argument_list|)
decl_stmt|;
name|findLabels
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|findLabels
parameter_list|(
name|PDNumberTreeNode
name|node
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|node
operator|.
name|getKids
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|PDNumberTreeNode
argument_list|>
name|kids
init|=
name|node
operator|.
name|getKids
argument_list|()
decl_stmt|;
for|for
control|(
name|PDNumberTreeNode
name|kid
range|:
name|kids
control|)
block|{
name|findLabels
argument_list|(
name|kid
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|getNumbers
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|COSObjectable
argument_list|>
name|numbers
init|=
name|node
operator|.
name|getNumbers
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|COSObjectable
argument_list|>
name|i
range|:
name|numbers
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|i
operator|.
name|getKey
argument_list|()
operator|>=
literal|0
condition|)
block|{
name|labels
operator|.
name|put
argument_list|(
name|i
operator|.
name|getKey
argument_list|()
argument_list|,
operator|(
name|PDPageLabelRange
operator|)
name|i
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Returns the number of page label ranges.      *       *<p>      * This will be always&gt;= 1, as the required default entry for the page      * range starting at the first page is added automatically by this      * implementation (see PDF32000-1:2008, p. 375).      *</p>      *       * @return the number of page label ranges.      */
specifier|public
name|int
name|getPageRangeCount
parameter_list|()
block|{
return|return
name|labels
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns the page label range starting at the given page, or {@code null}      * if no such range is defined.      *       * @param startPage      *            the 0-based page index representing the start page of the page      *            range the item is defined for.      * @return the page label range or {@code null} if no label range is defined      *         for the given start page.      */
specifier|public
name|PDPageLabelRange
name|getPageLabelRange
parameter_list|(
name|int
name|startPage
parameter_list|)
block|{
return|return
name|labels
operator|.
name|get
argument_list|(
name|startPage
argument_list|)
return|;
block|}
comment|/**      * Sets the page label range beginning at the specified start page.      *       * @param startPage      *            the 0-based index of the page representing the start of the      *            page label range.      * @param item      *            the page label item to set.      * @throws IllegalArgumentException if the startPage parameter is&lt; 0.      */
specifier|public
name|void
name|setLabelItem
parameter_list|(
name|int
name|startPage
parameter_list|,
name|PDPageLabelRange
name|item
parameter_list|)
block|{
if|if
condition|(
name|startPage
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"startPage parameter of setLabelItem may not be< 0"
argument_list|)
throw|;
block|}
name|labels
operator|.
name|put
argument_list|(
name|startPage
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}       */
annotation|@
name|Override
specifier|public
name|COSBase
name|getCOSObject
parameter_list|()
block|{
name|COSDictionary
name|dict
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|COSArray
name|arr
init|=
operator|new
name|COSArray
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|PDPageLabelRange
argument_list|>
name|i
range|:
name|labels
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|arr
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|get
argument_list|(
name|i
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|arr
operator|.
name|add
argument_list|(
name|i
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dict
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|NUMS
argument_list|,
name|arr
argument_list|)
expr_stmt|;
return|return
name|dict
return|;
block|}
comment|/**      * Returns a mapping with computed page labels as keys and corresponding      * 0-based page indices as values. The returned map will contain at most as      * much entries as the document has pages.      *       *<p>      *<strong>NOTE:</strong> If the document contains duplicate page labels,      * the returned map will contain<em>less</em> entries than the document has      * pages. The page index returned in this case is the<em>highest</em> index      * among all pages sharing the same label.      *</p>      *       * @return a mapping from labels to 0-based page indices.      */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getPageIndicesByLabels
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|labelMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|doc
operator|.
name|getNumberOfPages
argument_list|()
argument_list|)
decl_stmt|;
name|computeLabels
argument_list|(
parameter_list|(
name|pageIndex
parameter_list|,
name|label
parameter_list|)
lambda|->
name|labelMap
operator|.
name|put
argument_list|(
name|label
argument_list|,
name|pageIndex
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|labelMap
return|;
block|}
comment|/**      * Returns a mapping with 0-based page indices as keys and corresponding      * page labels as values as an array. The array will have exactly as much      * entries as the document has pages.      *       * @return an array mapping from 0-based page indices to labels.      */
specifier|public
name|String
index|[]
name|getLabelsByPageIndices
parameter_list|()
block|{
specifier|final
name|String
index|[]
name|map
init|=
operator|new
name|String
index|[
name|doc
operator|.
name|getNumberOfPages
argument_list|()
index|]
decl_stmt|;
name|computeLabels
argument_list|(
parameter_list|(
name|pageIndex
parameter_list|,
name|label
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|pageIndex
operator|<
name|doc
operator|.
name|getNumberOfPages
argument_list|()
condition|)
block|{
name|map
index|[
name|pageIndex
index|]
operator|=
name|label
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
comment|/**      * Get an ordered set of page indices having a page label range.      *      * @return set of page indices.      */
specifier|public
name|NavigableSet
argument_list|<
name|Integer
argument_list|>
name|getPageIndices
parameter_list|()
block|{
return|return
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|labels
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Internal interface for the control flow support.      *       * @author Igor Podolskiy      */
specifier|private
interface|interface
name|LabelHandler
block|{
name|void
name|newLabel
parameter_list|(
name|int
name|pageIndex
parameter_list|,
name|String
name|label
parameter_list|)
function_decl|;
block|}
specifier|private
name|void
name|computeLabels
parameter_list|(
name|LabelHandler
name|handler
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|PDPageLabelRange
argument_list|>
argument_list|>
name|iterator
init|=
name|labels
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return;
block|}
name|int
name|pageIndex
init|=
literal|0
decl_stmt|;
name|Entry
argument_list|<
name|Integer
argument_list|,
name|PDPageLabelRange
argument_list|>
name|lastEntry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|Integer
argument_list|,
name|PDPageLabelRange
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|numPages
init|=
name|entry
operator|.
name|getKey
argument_list|()
operator|-
name|lastEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|LabelGenerator
name|gen
init|=
operator|new
name|LabelGenerator
argument_list|(
name|lastEntry
operator|.
name|getValue
argument_list|()
argument_list|,
name|numPages
argument_list|)
decl_stmt|;
while|while
condition|(
name|gen
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|handler
operator|.
name|newLabel
argument_list|(
name|pageIndex
argument_list|,
name|gen
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|pageIndex
operator|++
expr_stmt|;
block|}
name|lastEntry
operator|=
name|entry
expr_stmt|;
block|}
name|LabelGenerator
name|gen
init|=
operator|new
name|LabelGenerator
argument_list|(
name|lastEntry
operator|.
name|getValue
argument_list|()
argument_list|,
name|doc
operator|.
name|getNumberOfPages
argument_list|()
operator|-
name|lastEntry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|gen
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|handler
operator|.
name|newLabel
argument_list|(
name|pageIndex
argument_list|,
name|gen
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|pageIndex
operator|++
expr_stmt|;
block|}
block|}
comment|/**      * Generates the labels in a page range.      *       * @author Igor Podolskiy      *       */
specifier|private
specifier|static
class|class
name|LabelGenerator
implements|implements
name|Iterator
argument_list|<
name|String
argument_list|>
block|{
specifier|private
specifier|final
name|PDPageLabelRange
name|labelInfo
decl_stmt|;
specifier|private
specifier|final
name|int
name|numPages
decl_stmt|;
specifier|private
name|int
name|currentPage
decl_stmt|;
name|LabelGenerator
parameter_list|(
name|PDPageLabelRange
name|label
parameter_list|,
name|int
name|pages
parameter_list|)
block|{
name|this
operator|.
name|labelInfo
operator|=
name|label
expr_stmt|;
name|this
operator|.
name|numPages
operator|=
name|pages
expr_stmt|;
name|this
operator|.
name|currentPage
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|currentPage
operator|<
name|numPages
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|labelInfo
operator|.
name|getPrefix
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
name|label
init|=
name|labelInfo
operator|.
name|getPrefix
argument_list|()
decl_stmt|;
comment|// there may be some labels with some null bytes at the end
comment|// which will lead to an incomplete output, see PDFBOX-1047
while|while
condition|(
name|label
operator|.
name|lastIndexOf
argument_list|(
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|label
operator|=
name|label
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|label
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|labelInfo
operator|.
name|getStyle
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|getNumber
argument_list|(
name|labelInfo
operator|.
name|getStart
argument_list|()
operator|+
name|currentPage
argument_list|,
name|labelInfo
operator|.
name|getStyle
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|currentPage
operator|++
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|String
name|getNumber
parameter_list|(
name|int
name|pageIndex
parameter_list|,
name|String
name|style
parameter_list|)
block|{
if|if
condition|(
name|style
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|style
condition|)
block|{
case|case
name|PDPageLabelRange
operator|.
name|STYLE_DECIMAL
case|:
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|pageIndex
argument_list|)
return|;
case|case
name|PDPageLabelRange
operator|.
name|STYLE_LETTERS_LOWER
case|:
return|return
name|makeLetterLabel
argument_list|(
name|pageIndex
argument_list|)
return|;
case|case
name|PDPageLabelRange
operator|.
name|STYLE_LETTERS_UPPER
case|:
return|return
name|makeLetterLabel
argument_list|(
name|pageIndex
argument_list|)
operator|.
name|toUpperCase
argument_list|()
return|;
case|case
name|PDPageLabelRange
operator|.
name|STYLE_ROMAN_LOWER
case|:
return|return
name|makeRomanLabel
argument_list|(
name|pageIndex
argument_list|)
return|;
case|case
name|PDPageLabelRange
operator|.
name|STYLE_ROMAN_UPPER
case|:
return|return
name|makeRomanLabel
argument_list|(
name|pageIndex
argument_list|)
operator|.
name|toUpperCase
argument_list|()
return|;
default|default:
break|break;
block|}
block|}
comment|// Fall back to decimals.
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|pageIndex
argument_list|)
return|;
block|}
comment|/**          * Lookup table used by the {@link #makeRomanLabel(int)} method.          */
specifier|private
specifier|static
specifier|final
name|String
index|[]
index|[]
name|ROMANS
init|=
operator|new
name|String
index|[]
index|[]
block|{
block|{
literal|""
block|,
literal|"i"
block|,
literal|"ii"
block|,
literal|"iii"
block|,
literal|"iv"
block|,
literal|"v"
block|,
literal|"vi"
block|,
literal|"vii"
block|,
literal|"viii"
block|,
literal|"ix"
block|}
block|,
block|{
literal|""
block|,
literal|"x"
block|,
literal|"xx"
block|,
literal|"xxx"
block|,
literal|"xl"
block|,
literal|"l"
block|,
literal|"lx"
block|,
literal|"lxx"
block|,
literal|"lxxx"
block|,
literal|"xc"
block|}
block|,
block|{
literal|""
block|,
literal|"c"
block|,
literal|"cc"
block|,
literal|"ccc"
block|,
literal|"cd"
block|,
literal|"d"
block|,
literal|"dc"
block|,
literal|"dcc"
block|,
literal|"dccc"
block|,
literal|"cm"
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
name|String
name|makeRomanLabel
parameter_list|(
name|int
name|pageIndex
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|power
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|power
argument_list|<
literal|3
operator|&&
name|pageIndex
argument_list|>
literal|0
condition|)
block|{
name|buf
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|ROMANS
index|[
name|power
index|]
index|[
name|pageIndex
operator|%
literal|10
index|]
argument_list|)
expr_stmt|;
name|pageIndex
operator|/=
literal|10
expr_stmt|;
name|power
operator|++
expr_stmt|;
block|}
comment|// Prepend as many m as there are thousands (which is
comment|// incorrect by the roman numeral rules for numbers> 3999,
comment|// but is unbounded and Adobe Acrobat does it this way).
comment|// This code is somewhat inefficient for really big numbers,
comment|// but those don't occur too often (and the numbers in those cases
comment|// would be incomprehensible even if we and Adobe
comment|// used strict Roman rules).
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pageIndex
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**          * a..z, aa..zz, aaa..zzz ... labeling as described in PDF32000-1:2008,          * Table 159, Page 375.          */
specifier|private
specifier|static
name|String
name|makeLetterLabel
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|numLetters
init|=
name|num
operator|/
literal|26
operator|+
name|Integer
operator|.
name|signum
argument_list|(
name|num
operator|%
literal|26
argument_list|)
decl_stmt|;
name|int
name|letter
init|=
name|num
operator|%
literal|26
operator|+
literal|26
operator|*
operator|(
literal|1
operator|-
name|Integer
operator|.
name|signum
argument_list|(
name|num
operator|%
literal|26
argument_list|)
operator|)
operator|+
literal|'a'
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numLetters
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|appendCodePoint
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
comment|// This is a generator, no removing allowed.
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
block|}
end_class

end_unit

