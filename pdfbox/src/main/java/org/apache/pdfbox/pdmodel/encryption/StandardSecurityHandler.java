begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|GeneralSecurityException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|SecureRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|crypto
operator|.
name|Cipher
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|crypto
operator|.
name|spec
operator|.
name|IvParameterSpec
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|crypto
operator|.
name|spec
operator|.
name|SecretKeySpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|Charsets
import|;
end_import

begin_comment
comment|/**  * The standard security handler. This security handler protects document with password.  * @see StandardProtectionPolicy to see how to protect document with this security handler.  * @author Ben Litchfield  * @author Benoit Guillon  * @author Manuel Kasper  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|StandardSecurityHandler
extends|extends
name|SecurityHandler
block|{
comment|/**      * Log instance.      */
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|StandardSecurityHandler
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Type of security handler. */
specifier|public
specifier|static
specifier|final
name|String
name|FILTER
init|=
literal|"Standard"
decl_stmt|;
comment|/** Protection policy class for this handler. */
specifier|public
specifier|static
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|PROTECTION_POLICY_CLASS
init|=
name|StandardProtectionPolicy
operator|.
name|class
decl_stmt|;
comment|/** Standard padding for encryption. */
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|ENCRYPT_PADDING
init|=
block|{
operator|(
name|byte
operator|)
literal|0x28
block|,
operator|(
name|byte
operator|)
literal|0xBF
block|,
operator|(
name|byte
operator|)
literal|0x4E
block|,
operator|(
name|byte
operator|)
literal|0x5E
block|,
operator|(
name|byte
operator|)
literal|0x4E
block|,
operator|(
name|byte
operator|)
literal|0x75
block|,
operator|(
name|byte
operator|)
literal|0x8A
block|,
operator|(
name|byte
operator|)
literal|0x41
block|,
operator|(
name|byte
operator|)
literal|0x64
block|,
operator|(
name|byte
operator|)
literal|0x00
block|,
operator|(
name|byte
operator|)
literal|0x4E
block|,
operator|(
name|byte
operator|)
literal|0x56
block|,
operator|(
name|byte
operator|)
literal|0xFF
block|,
operator|(
name|byte
operator|)
literal|0xFA
block|,
operator|(
name|byte
operator|)
literal|0x01
block|,
operator|(
name|byte
operator|)
literal|0x08
block|,
operator|(
name|byte
operator|)
literal|0x2E
block|,
operator|(
name|byte
operator|)
literal|0x2E
block|,
operator|(
name|byte
operator|)
literal|0x00
block|,
operator|(
name|byte
operator|)
literal|0xB6
block|,
operator|(
name|byte
operator|)
literal|0xD0
block|,
operator|(
name|byte
operator|)
literal|0x68
block|,
operator|(
name|byte
operator|)
literal|0x3E
block|,
operator|(
name|byte
operator|)
literal|0x80
block|,
operator|(
name|byte
operator|)
literal|0x2F
block|,
operator|(
name|byte
operator|)
literal|0x0C
block|,
operator|(
name|byte
operator|)
literal|0xA9
block|,
operator|(
name|byte
operator|)
literal|0xFE
block|,
operator|(
name|byte
operator|)
literal|0x64
block|,
operator|(
name|byte
operator|)
literal|0x53
block|,
operator|(
name|byte
operator|)
literal|0x69
block|,
operator|(
name|byte
operator|)
literal|0x7A
block|}
decl_stmt|;
comment|// hashes used for Algorithm 2.B, depending on remainder from E modulo 3
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|HASHES_2B
init|=
operator|new
name|String
index|[]
block|{
literal|"SHA-256"
block|,
literal|"SHA-384"
block|,
literal|"SHA-512"
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_VERSION
init|=
literal|1
decl_stmt|;
specifier|private
name|StandardProtectionPolicy
name|policy
decl_stmt|;
comment|/**      * Constructor.      */
specifier|public
name|StandardSecurityHandler
parameter_list|()
block|{     }
comment|/**      * Constructor used for encryption.      *      * @param p The protection policy.      */
specifier|public
name|StandardSecurityHandler
parameter_list|(
name|StandardProtectionPolicy
name|p
parameter_list|)
block|{
name|policy
operator|=
name|p
expr_stmt|;
name|keyLength
operator|=
name|policy
operator|.
name|getEncryptionKeyLength
argument_list|()
expr_stmt|;
block|}
comment|/**      * Computes the version number of the StandardSecurityHandler      * regarding the encryption key length.      * See PDF Spec 1.6 p 93 and PDF 1.7 AEL3      *      * @return The computed version number.      */
specifier|private
name|int
name|computeVersionNumber
parameter_list|()
block|{
if|if
condition|(
name|keyLength
operator|==
literal|40
condition|)
block|{
return|return
name|DEFAULT_VERSION
return|;
block|}
elseif|else
if|if
condition|(
name|keyLength
operator|==
literal|128
operator|&&
name|policy
operator|.
name|isPreferAES
argument_list|()
condition|)
block|{
return|return
literal|4
return|;
block|}
elseif|else
if|if
condition|(
name|keyLength
operator|==
literal|256
condition|)
block|{
return|return
literal|5
return|;
block|}
return|return
literal|2
return|;
block|}
comment|/**      * Computes the revision version of the StandardSecurityHandler to      * use regarding the version number and the permissions bits set.      * See PDF Spec 1.6 p98      *       * @param version The version number.      *      * @return The computed revision number.      */
specifier|private
name|int
name|computeRevisionNumber
parameter_list|(
name|int
name|version
parameter_list|)
block|{
if|if
condition|(
name|version
operator|<
literal|2
operator|&&
operator|!
name|policy
operator|.
name|getPermissions
argument_list|()
operator|.
name|hasAnyRevision3PermissionSet
argument_list|()
condition|)
block|{
return|return
literal|2
return|;
block|}
if|if
condition|(
name|version
operator|==
literal|5
condition|)
block|{
comment|// note about revision 5: "Shall not be used. This value was used by a deprecated Adobe extension."
return|return
literal|6
return|;
block|}
if|if
condition|(
name|version
operator|==
literal|4
condition|)
block|{
return|return
literal|4
return|;
block|}
if|if
condition|(
name|version
operator|==
literal|2
operator|||
name|version
operator|==
literal|3
operator|||
name|policy
operator|.
name|getPermissions
argument_list|()
operator|.
name|hasAnyRevision3PermissionSet
argument_list|()
condition|)
block|{
return|return
literal|3
return|;
block|}
return|return
literal|4
return|;
block|}
comment|/**      * Prepares everything to decrypt the document.      *      * Only if decryption of single objects is needed this should be called.      *      * @param encryption  encryption dictionary      * @param documentIDArray  document id      * @param decryptionMaterial Information used to decrypt the document.      *      * @throws InvalidPasswordException If the password is incorrect.      * @throws IOException If there is an error accessing data.      */
annotation|@
name|Override
specifier|public
name|void
name|prepareForDecryption
parameter_list|(
name|PDEncryption
name|encryption
parameter_list|,
name|COSArray
name|documentIDArray
parameter_list|,
name|DecryptionMaterial
name|decryptionMaterial
parameter_list|)
throws|throws
name|InvalidPasswordException
throws|,
name|IOException
block|{
if|if
condition|(
operator|!
operator|(
name|decryptionMaterial
operator|instanceof
name|StandardDecryptionMaterial
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Decryption material is not compatible with the document"
argument_list|)
throw|;
block|}
name|setDecryptMetadata
argument_list|(
name|encryption
operator|.
name|isEncryptMetaData
argument_list|()
argument_list|)
expr_stmt|;
name|StandardDecryptionMaterial
name|material
init|=
operator|(
name|StandardDecryptionMaterial
operator|)
name|decryptionMaterial
decl_stmt|;
name|String
name|password
init|=
name|material
operator|.
name|getPassword
argument_list|()
decl_stmt|;
if|if
condition|(
name|password
operator|==
literal|null
condition|)
block|{
name|password
operator|=
literal|""
expr_stmt|;
block|}
name|int
name|dicPermissions
init|=
name|encryption
operator|.
name|getPermissions
argument_list|()
decl_stmt|;
name|int
name|dicRevision
init|=
name|encryption
operator|.
name|getRevision
argument_list|()
decl_stmt|;
name|int
name|dicLength
init|=
name|encryption
operator|.
name|getVersion
argument_list|()
operator|==
literal|1
condition|?
literal|5
else|:
name|encryption
operator|.
name|getLength
argument_list|()
operator|/
literal|8
decl_stmt|;
name|byte
index|[]
name|documentIDBytes
init|=
name|getDocumentIDBytes
argument_list|(
name|documentIDArray
argument_list|)
decl_stmt|;
comment|// we need to know whether the meta data was encrypted for password calculation
name|boolean
name|encryptMetadata
init|=
name|encryption
operator|.
name|isEncryptMetaData
argument_list|()
decl_stmt|;
name|byte
index|[]
name|userKey
init|=
name|encryption
operator|.
name|getUserKey
argument_list|()
decl_stmt|;
name|byte
index|[]
name|ownerKey
init|=
name|encryption
operator|.
name|getOwnerKey
argument_list|()
decl_stmt|;
name|byte
index|[]
name|ue
init|=
literal|null
decl_stmt|,
name|oe
init|=
literal|null
decl_stmt|;
name|Charset
name|passwordCharset
init|=
name|Charsets
operator|.
name|ISO_8859_1
decl_stmt|;
if|if
condition|(
name|dicRevision
operator|==
literal|6
operator|||
name|dicRevision
operator|==
literal|5
condition|)
block|{
name|passwordCharset
operator|=
name|Charsets
operator|.
name|UTF_8
expr_stmt|;
name|ue
operator|=
name|encryption
operator|.
name|getUserEncryptionKey
argument_list|()
expr_stmt|;
name|oe
operator|=
name|encryption
operator|.
name|getOwnerEncryptionKey
argument_list|()
expr_stmt|;
block|}
name|AccessPermission
name|currentAccessPermission
decl_stmt|;
if|if
condition|(
name|isOwnerPassword
argument_list|(
name|password
operator|.
name|getBytes
argument_list|(
name|passwordCharset
argument_list|)
argument_list|,
name|userKey
argument_list|,
name|ownerKey
argument_list|,
name|dicPermissions
argument_list|,
name|documentIDBytes
argument_list|,
name|dicRevision
argument_list|,
name|dicLength
argument_list|,
name|encryptMetadata
argument_list|)
condition|)
block|{
name|currentAccessPermission
operator|=
name|AccessPermission
operator|.
name|getOwnerAccessPermission
argument_list|()
expr_stmt|;
name|setCurrentAccessPermission
argument_list|(
name|currentAccessPermission
argument_list|)
expr_stmt|;
name|byte
index|[]
name|computedPassword
decl_stmt|;
if|if
condition|(
name|dicRevision
operator|==
literal|6
operator|||
name|dicRevision
operator|==
literal|5
condition|)
block|{
name|computedPassword
operator|=
name|password
operator|.
name|getBytes
argument_list|(
name|passwordCharset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|computedPassword
operator|=
name|getUserPassword
argument_list|(
name|password
operator|.
name|getBytes
argument_list|(
name|passwordCharset
argument_list|)
argument_list|,
name|ownerKey
argument_list|,
name|dicRevision
argument_list|,
name|dicLength
argument_list|)
expr_stmt|;
block|}
name|encryptionKey
operator|=
name|computeEncryptedKey
argument_list|(
name|computedPassword
argument_list|,
name|ownerKey
argument_list|,
name|userKey
argument_list|,
name|oe
argument_list|,
name|ue
argument_list|,
name|dicPermissions
argument_list|,
name|documentIDBytes
argument_list|,
name|dicRevision
argument_list|,
name|dicLength
argument_list|,
name|encryptMetadata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isUserPassword
argument_list|(
name|password
operator|.
name|getBytes
argument_list|(
name|passwordCharset
argument_list|)
argument_list|,
name|userKey
argument_list|,
name|ownerKey
argument_list|,
name|dicPermissions
argument_list|,
name|documentIDBytes
argument_list|,
name|dicRevision
argument_list|,
name|dicLength
argument_list|,
name|encryptMetadata
argument_list|)
condition|)
block|{
name|currentAccessPermission
operator|=
operator|new
name|AccessPermission
argument_list|(
name|dicPermissions
argument_list|)
expr_stmt|;
name|currentAccessPermission
operator|.
name|setReadOnly
argument_list|()
expr_stmt|;
name|setCurrentAccessPermission
argument_list|(
name|currentAccessPermission
argument_list|)
expr_stmt|;
name|encryptionKey
operator|=
name|computeEncryptedKey
argument_list|(
name|password
operator|.
name|getBytes
argument_list|(
name|passwordCharset
argument_list|)
argument_list|,
name|ownerKey
argument_list|,
name|userKey
argument_list|,
name|oe
argument_list|,
name|ue
argument_list|,
name|dicPermissions
argument_list|,
name|documentIDBytes
argument_list|,
name|dicRevision
argument_list|,
name|dicLength
argument_list|,
name|encryptMetadata
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|InvalidPasswordException
argument_list|(
literal|"Cannot decrypt PDF, the password is incorrect"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dicRevision
operator|==
literal|6
operator|||
name|dicRevision
operator|==
literal|5
condition|)
block|{
name|validatePerms
argument_list|(
name|encryption
argument_list|,
name|dicPermissions
argument_list|,
name|encryptMetadata
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|encryption
operator|.
name|getVersion
argument_list|()
operator|==
literal|4
operator|||
name|encryption
operator|.
name|getVersion
argument_list|()
operator|==
literal|5
condition|)
block|{
comment|// detect whether AES encryption is used. This assumes that the encryption algo is
comment|// stored in the PDCryptFilterDictionary
comment|// However, crypt filters are used only when V is 4 or 5.
name|PDCryptFilterDictionary
name|stdCryptFilterDictionary
init|=
name|encryption
operator|.
name|getStdCryptFilterDictionary
argument_list|()
decl_stmt|;
if|if
condition|(
name|stdCryptFilterDictionary
operator|!=
literal|null
condition|)
block|{
name|COSName
name|cryptFilterMethod
init|=
name|stdCryptFilterDictionary
operator|.
name|getCryptFilterMethod
argument_list|()
decl_stmt|;
name|setAES
argument_list|(
name|COSName
operator|.
name|AESV2
operator|.
name|equals
argument_list|(
name|cryptFilterMethod
argument_list|)
operator|||
name|COSName
operator|.
name|AESV3
operator|.
name|equals
argument_list|(
name|cryptFilterMethod
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|byte
index|[]
name|getDocumentIDBytes
parameter_list|(
name|COSArray
name|documentIDArray
parameter_list|)
block|{
comment|//some documents may not have document id, see
comment|//test\encryption\encrypted_doc_no_id.pdf
name|byte
index|[]
name|documentIDBytes
decl_stmt|;
if|if
condition|(
name|documentIDArray
operator|!=
literal|null
operator|&&
name|documentIDArray
operator|.
name|size
argument_list|()
operator|>=
literal|1
condition|)
block|{
name|COSString
name|id
init|=
operator|(
name|COSString
operator|)
name|documentIDArray
operator|.
name|getObject
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|documentIDBytes
operator|=
name|id
operator|.
name|getBytes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|documentIDBytes
operator|=
operator|new
name|byte
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|documentIDBytes
return|;
block|}
comment|// Algorithm 13: validate permissions ("Perms" field). Relaxed to accomodate buggy encoders
comment|// https://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/adobe_supplement_iso32000.pdf
specifier|private
name|void
name|validatePerms
parameter_list|(
name|PDEncryption
name|encryption
parameter_list|,
name|int
name|dicPermissions
parameter_list|,
name|boolean
name|encryptMetadata
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// "Decrypt the 16-byte Perms string using AES-256 in ECB mode with an
comment|// initialization vector of zero and the file encryption key as the key."
name|Cipher
name|cipher
init|=
name|Cipher
operator|.
name|getInstance
argument_list|(
literal|"AES/ECB/NoPadding"
argument_list|)
decl_stmt|;
name|cipher
operator|.
name|init
argument_list|(
name|Cipher
operator|.
name|DECRYPT_MODE
argument_list|,
operator|new
name|SecretKeySpec
argument_list|(
name|encryptionKey
argument_list|,
literal|"AES"
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|perms
init|=
name|cipher
operator|.
name|doFinal
argument_list|(
name|encryption
operator|.
name|getPerms
argument_list|()
argument_list|)
decl_stmt|;
comment|// "Verify that bytes 9-11 of the result are the characters ‘a’, ‘d’, ‘b’."
if|if
condition|(
name|perms
index|[
literal|9
index|]
operator|!=
literal|'a'
operator|||
name|perms
index|[
literal|10
index|]
operator|!=
literal|'d'
operator|||
name|perms
index|[
literal|11
index|]
operator|!=
literal|'b'
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Verification of permissions failed (constant)"
argument_list|)
expr_stmt|;
block|}
comment|// "Bytes 0-3 of the decrypted Perms entry, treated as a little-endian integer,
comment|// are the user permissions. They should match the value in the P key."
name|int
name|permsP
init|=
name|perms
index|[
literal|0
index|]
operator|&
literal|0xFF
operator||
operator|(
name|perms
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
operator||
operator|(
name|perms
index|[
literal|2
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|16
operator||
operator|(
name|perms
index|[
literal|3
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|24
decl_stmt|;
if|if
condition|(
name|permsP
operator|!=
name|dicPermissions
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Verification of permissions failed ("
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%08X"
argument_list|,
name|permsP
argument_list|)
operator|+
literal|" != "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%08X"
argument_list|,
name|dicPermissions
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|encryptMetadata
operator|&&
name|perms
index|[
literal|8
index|]
operator|!=
literal|'T'
operator|||
operator|!
name|encryptMetadata
operator|&&
name|perms
index|[
literal|8
index|]
operator|!=
literal|'F'
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Verification of permissions failed (EncryptMetadata)"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
name|e
parameter_list|)
block|{
name|logIfStrongEncryptionMissing
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Prepare document for encryption.      *      * @param document The documeent to encrypt.      *      * @throws IOException If there is an error accessing data.      */
annotation|@
name|Override
specifier|public
name|void
name|prepareDocumentForEncryption
parameter_list|(
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
name|PDEncryption
name|encryptionDictionary
init|=
name|document
operator|.
name|getEncryption
argument_list|()
decl_stmt|;
if|if
condition|(
name|encryptionDictionary
operator|==
literal|null
condition|)
block|{
name|encryptionDictionary
operator|=
operator|new
name|PDEncryption
argument_list|()
expr_stmt|;
block|}
name|int
name|version
init|=
name|computeVersionNumber
argument_list|()
decl_stmt|;
name|int
name|revision
init|=
name|computeRevisionNumber
argument_list|(
name|version
argument_list|)
decl_stmt|;
name|encryptionDictionary
operator|.
name|setFilter
argument_list|(
name|FILTER
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|4
operator|&&
name|version
operator|!=
literal|5
condition|)
block|{
comment|// remove CF, StmF, and StrF entries that may be left from a previous encryption
name|encryptionDictionary
operator|.
name|removeV45filters
argument_list|()
expr_stmt|;
block|}
name|encryptionDictionary
operator|.
name|setRevision
argument_list|(
name|revision
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setLength
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
name|String
name|ownerPassword
init|=
name|policy
operator|.
name|getOwnerPassword
argument_list|()
decl_stmt|;
name|String
name|userPassword
init|=
name|policy
operator|.
name|getUserPassword
argument_list|()
decl_stmt|;
if|if
condition|(
name|ownerPassword
operator|==
literal|null
condition|)
block|{
name|ownerPassword
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|userPassword
operator|==
literal|null
condition|)
block|{
name|userPassword
operator|=
literal|""
expr_stmt|;
block|}
comment|// If no owner password is set, use the user password instead.
if|if
condition|(
name|ownerPassword
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ownerPassword
operator|=
name|userPassword
expr_stmt|;
block|}
name|int
name|permissionInt
init|=
name|policy
operator|.
name|getPermissions
argument_list|()
operator|.
name|getPermissionBytes
argument_list|()
decl_stmt|;
name|encryptionDictionary
operator|.
name|setPermissions
argument_list|(
name|permissionInt
argument_list|)
expr_stmt|;
name|int
name|length
init|=
name|keyLength
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|revision
operator|==
literal|6
condition|)
block|{
name|prepareEncryptionDictRev6
argument_list|(
name|ownerPassword
argument_list|,
name|userPassword
argument_list|,
name|encryptionDictionary
argument_list|,
name|permissionInt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prepareEncryptionDictRev2345
argument_list|(
name|ownerPassword
argument_list|,
name|userPassword
argument_list|,
name|encryptionDictionary
argument_list|,
name|permissionInt
argument_list|,
name|document
argument_list|,
name|revision
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|document
operator|.
name|setEncryptionDictionary
argument_list|(
name|encryptionDictionary
argument_list|)
expr_stmt|;
name|document
operator|.
name|getDocument
argument_list|()
operator|.
name|setEncryptionDictionary
argument_list|(
name|encryptionDictionary
operator|.
name|getCOSDictionary
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|prepareEncryptionDictRev6
parameter_list|(
name|String
name|ownerPassword
parameter_list|,
name|String
name|userPassword
parameter_list|,
name|PDEncryption
name|encryptionDictionary
parameter_list|,
name|int
name|permissionInt
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|SecureRandom
name|rnd
init|=
operator|new
name|SecureRandom
argument_list|()
decl_stmt|;
name|Cipher
name|cipher
init|=
name|Cipher
operator|.
name|getInstance
argument_list|(
literal|"AES/CBC/NoPadding"
argument_list|)
decl_stmt|;
comment|// make a random 256-bit file encryption key
name|encryptionKey
operator|=
operator|new
name|byte
index|[
literal|32
index|]
expr_stmt|;
name|rnd
operator|.
name|nextBytes
argument_list|(
name|encryptionKey
argument_list|)
expr_stmt|;
comment|// Algorithm 8a: Compute U
name|byte
index|[]
name|userPasswordBytes
init|=
name|truncate127
argument_list|(
name|userPassword
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|userValidationSalt
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
name|byte
index|[]
name|userKeySalt
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
name|rnd
operator|.
name|nextBytes
argument_list|(
name|userValidationSalt
argument_list|)
expr_stmt|;
name|rnd
operator|.
name|nextBytes
argument_list|(
name|userKeySalt
argument_list|)
expr_stmt|;
name|byte
index|[]
name|hashU
init|=
name|computeHash2B
argument_list|(
name|concat
argument_list|(
name|userPasswordBytes
argument_list|,
name|userValidationSalt
argument_list|)
argument_list|,
name|userPasswordBytes
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|byte
index|[]
name|u
init|=
name|concat
argument_list|(
name|hashU
argument_list|,
name|userValidationSalt
argument_list|,
name|userKeySalt
argument_list|)
decl_stmt|;
comment|// Algorithm 8b: Compute UE
name|byte
index|[]
name|hashUE
init|=
name|computeHash2B
argument_list|(
name|concat
argument_list|(
name|userPasswordBytes
argument_list|,
name|userKeySalt
argument_list|)
argument_list|,
name|userPasswordBytes
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|cipher
operator|.
name|init
argument_list|(
name|Cipher
operator|.
name|ENCRYPT_MODE
argument_list|,
operator|new
name|SecretKeySpec
argument_list|(
name|hashUE
argument_list|,
literal|"AES"
argument_list|)
argument_list|,
operator|new
name|IvParameterSpec
argument_list|(
operator|new
name|byte
index|[
literal|16
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|ue
init|=
name|cipher
operator|.
name|doFinal
argument_list|(
name|encryptionKey
argument_list|)
decl_stmt|;
comment|// Algorithm 9a: Compute O
name|byte
index|[]
name|ownerPasswordBytes
init|=
name|truncate127
argument_list|(
name|ownerPassword
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|ownerValidationSalt
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
name|byte
index|[]
name|ownerKeySalt
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
name|rnd
operator|.
name|nextBytes
argument_list|(
name|ownerValidationSalt
argument_list|)
expr_stmt|;
name|rnd
operator|.
name|nextBytes
argument_list|(
name|ownerKeySalt
argument_list|)
expr_stmt|;
name|byte
index|[]
name|hashO
init|=
name|computeHash2B
argument_list|(
name|concat
argument_list|(
name|ownerPasswordBytes
argument_list|,
name|ownerValidationSalt
argument_list|,
name|u
argument_list|)
argument_list|,
name|ownerPasswordBytes
argument_list|,
name|u
argument_list|)
decl_stmt|;
name|byte
index|[]
name|o
init|=
name|concat
argument_list|(
name|hashO
argument_list|,
name|ownerValidationSalt
argument_list|,
name|ownerKeySalt
argument_list|)
decl_stmt|;
comment|// Algorithm 9b: Compute OE
name|byte
index|[]
name|hashOE
init|=
name|computeHash2B
argument_list|(
name|concat
argument_list|(
name|ownerPasswordBytes
argument_list|,
name|ownerKeySalt
argument_list|,
name|u
argument_list|)
argument_list|,
name|ownerPasswordBytes
argument_list|,
name|u
argument_list|)
decl_stmt|;
name|cipher
operator|.
name|init
argument_list|(
name|Cipher
operator|.
name|ENCRYPT_MODE
argument_list|,
operator|new
name|SecretKeySpec
argument_list|(
name|hashOE
argument_list|,
literal|"AES"
argument_list|)
argument_list|,
operator|new
name|IvParameterSpec
argument_list|(
operator|new
name|byte
index|[
literal|16
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|oe
init|=
name|cipher
operator|.
name|doFinal
argument_list|(
name|encryptionKey
argument_list|)
decl_stmt|;
comment|// Set keys and other required constants in encryption dictionary
name|encryptionDictionary
operator|.
name|setUserKey
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setUserEncryptionKey
argument_list|(
name|ue
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setOwnerKey
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setOwnerEncryptionKey
argument_list|(
name|oe
argument_list|)
expr_stmt|;
name|prepareEncryptionDictAES
argument_list|(
name|encryptionDictionary
argument_list|,
name|COSName
operator|.
name|AESV3
argument_list|)
expr_stmt|;
comment|// Algorithm 10: compute "Perms" value
name|byte
index|[]
name|perms
init|=
operator|new
name|byte
index|[
literal|16
index|]
decl_stmt|;
name|perms
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|permissionInt
expr_stmt|;
name|perms
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|permissionInt
operator|>>>
literal|8
argument_list|)
expr_stmt|;
name|perms
index|[
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|permissionInt
operator|>>>
literal|16
argument_list|)
expr_stmt|;
name|perms
index|[
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|permissionInt
operator|>>>
literal|24
argument_list|)
expr_stmt|;
name|perms
index|[
literal|4
index|]
operator|=
operator|(
name|byte
operator|)
literal|0xFF
expr_stmt|;
name|perms
index|[
literal|5
index|]
operator|=
operator|(
name|byte
operator|)
literal|0xFF
expr_stmt|;
name|perms
index|[
literal|6
index|]
operator|=
operator|(
name|byte
operator|)
literal|0xFF
expr_stmt|;
name|perms
index|[
literal|7
index|]
operator|=
operator|(
name|byte
operator|)
literal|0xFF
expr_stmt|;
name|perms
index|[
literal|8
index|]
operator|=
literal|'T'
expr_stmt|;
comment|// we always encrypt Metadata
name|perms
index|[
literal|9
index|]
operator|=
literal|'a'
expr_stmt|;
name|perms
index|[
literal|10
index|]
operator|=
literal|'d'
expr_stmt|;
name|perms
index|[
literal|11
index|]
operator|=
literal|'b'
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|12
init|;
name|i
operator|<=
literal|15
condition|;
name|i
operator|++
control|)
block|{
name|perms
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|rnd
operator|.
name|nextInt
argument_list|()
expr_stmt|;
block|}
name|cipher
operator|.
name|init
argument_list|(
name|Cipher
operator|.
name|ENCRYPT_MODE
argument_list|,
operator|new
name|SecretKeySpec
argument_list|(
name|encryptionKey
argument_list|,
literal|"AES"
argument_list|)
argument_list|,
operator|new
name|IvParameterSpec
argument_list|(
operator|new
name|byte
index|[
literal|16
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|permsEnc
init|=
name|cipher
operator|.
name|doFinal
argument_list|(
name|perms
argument_list|)
decl_stmt|;
name|encryptionDictionary
operator|.
name|setPerms
argument_list|(
name|permsEnc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
name|e
parameter_list|)
block|{
name|logIfStrongEncryptionMissing
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|prepareEncryptionDictRev2345
parameter_list|(
name|String
name|ownerPassword
parameter_list|,
name|String
name|userPassword
parameter_list|,
name|PDEncryption
name|encryptionDictionary
parameter_list|,
name|int
name|permissionInt
parameter_list|,
name|PDDocument
name|document
parameter_list|,
name|int
name|revision
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|COSArray
name|idArray
init|=
name|document
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocumentID
argument_list|()
decl_stmt|;
comment|//check if the document has an id yet.  If it does not then generate one
if|if
condition|(
name|idArray
operator|==
literal|null
operator|||
name|idArray
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
name|MessageDigest
name|md
init|=
name|MessageDigests
operator|.
name|getMD5
argument_list|()
decl_stmt|;
name|BigInteger
name|time
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
name|md
operator|.
name|update
argument_list|(
name|time
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|ownerPassword
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|userPassword
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|document
operator|.
name|getDocument
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|id
init|=
name|md
operator|.
name|digest
argument_list|(
name|this
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
decl_stmt|;
name|COSString
name|idString
init|=
operator|new
name|COSString
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|idArray
operator|=
operator|new
name|COSArray
argument_list|()
expr_stmt|;
name|idArray
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|idArray
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|document
operator|.
name|getDocument
argument_list|()
operator|.
name|setDocumentID
argument_list|(
name|idArray
argument_list|)
expr_stmt|;
block|}
name|COSString
name|id
init|=
operator|(
name|COSString
operator|)
name|idArray
operator|.
name|getObject
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|byte
index|[]
name|ownerBytes
init|=
name|computeOwnerPassword
argument_list|(
name|ownerPassword
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|,
name|userPassword
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|,
name|revision
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|byte
index|[]
name|userBytes
init|=
name|computeUserPassword
argument_list|(
name|userPassword
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|,
name|ownerBytes
argument_list|,
name|permissionInt
argument_list|,
name|id
operator|.
name|getBytes
argument_list|()
argument_list|,
name|revision
argument_list|,
name|length
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|encryptionKey
operator|=
name|computeEncryptedKey
argument_list|(
name|userPassword
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|,
name|ownerBytes
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|permissionInt
argument_list|,
name|id
operator|.
name|getBytes
argument_list|()
argument_list|,
name|revision
argument_list|,
name|length
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setOwnerKey
argument_list|(
name|ownerBytes
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setUserKey
argument_list|(
name|userBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|revision
operator|==
literal|4
condition|)
block|{
name|prepareEncryptionDictAES
argument_list|(
name|encryptionDictionary
argument_list|,
name|COSName
operator|.
name|AESV2
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|prepareEncryptionDictAES
parameter_list|(
name|PDEncryption
name|encryptionDictionary
parameter_list|,
name|COSName
name|aesVName
parameter_list|)
block|{
name|PDCryptFilterDictionary
name|cryptFilterDictionary
init|=
operator|new
name|PDCryptFilterDictionary
argument_list|()
decl_stmt|;
name|cryptFilterDictionary
operator|.
name|setCryptFilterMethod
argument_list|(
name|aesVName
argument_list|)
expr_stmt|;
name|cryptFilterDictionary
operator|.
name|setLength
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setStdCryptFilterDictionary
argument_list|(
name|cryptFilterDictionary
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setStreamFilterName
argument_list|(
name|COSName
operator|.
name|STD_CF
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setStringFilterName
argument_list|(
name|COSName
operator|.
name|STD_CF
argument_list|)
expr_stmt|;
name|setAES
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check for owner password.      *      * @param ownerPassword The owner password.      * @param user The u entry of the encryption dictionary.      * @param owner The o entry of the encryption dictionary.      * @param permissions The set of permissions on the document.      * @param id The document id.      * @param encRevision The encryption algorithm revision.      * @param length The encryption key length.      * @param encryptMetadata The encryption metadata      *      * @return True If the ownerPassword param is the owner password.      *      * @throws IOException If there is an error accessing data.      */
specifier|public
name|boolean
name|isOwnerPassword
parameter_list|(
name|byte
index|[]
name|ownerPassword
parameter_list|,
name|byte
index|[]
name|user
parameter_list|,
name|byte
index|[]
name|owner
parameter_list|,
name|int
name|permissions
parameter_list|,
name|byte
index|[]
name|id
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|encryptMetadata
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|encRevision
operator|==
literal|6
operator|||
name|encRevision
operator|==
literal|5
condition|)
block|{
name|byte
index|[]
name|truncatedOwnerPassword
init|=
name|truncate127
argument_list|(
name|ownerPassword
argument_list|)
decl_stmt|;
name|byte
index|[]
name|oHash
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
name|byte
index|[]
name|oValidationSalt
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|owner
argument_list|,
literal|0
argument_list|,
name|oHash
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|owner
argument_list|,
literal|32
argument_list|,
name|oValidationSalt
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|byte
index|[]
name|hash
decl_stmt|;
if|if
condition|(
name|encRevision
operator|==
literal|5
condition|)
block|{
name|hash
operator|=
name|computeSHA256
argument_list|(
name|truncatedOwnerPassword
argument_list|,
name|oValidationSalt
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hash
operator|=
name|computeHash2A
argument_list|(
name|truncatedOwnerPassword
argument_list|,
name|oValidationSalt
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
return|return
name|Arrays
operator|.
name|equals
argument_list|(
name|hash
argument_list|,
name|oHash
argument_list|)
return|;
block|}
else|else
block|{
name|byte
index|[]
name|userPassword
init|=
name|getUserPassword
argument_list|(
name|ownerPassword
argument_list|,
name|owner
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|)
decl_stmt|;
return|return
name|isUserPassword
argument_list|(
name|userPassword
argument_list|,
name|user
argument_list|,
name|owner
argument_list|,
name|permissions
argument_list|,
name|id
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|,
name|encryptMetadata
argument_list|)
return|;
block|}
block|}
comment|/**      * Get the user password based on the owner password.      *      * @param ownerPassword The plaintext owner password.      * @param owner The o entry of the encryption dictionary.      * @param encRevision The encryption revision number.      * @param length The key length.      *      * @return The u entry of the encryption dictionary.      *      * @throws IOException If there is an error accessing data while generating the user password.      */
specifier|public
name|byte
index|[]
name|getUserPassword
parameter_list|(
name|byte
index|[]
name|ownerPassword
parameter_list|,
name|byte
index|[]
name|owner
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|result
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|byte
index|[]
name|rc4Key
init|=
name|computeRC4key
argument_list|(
name|ownerPassword
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|encRevision
operator|==
literal|2
condition|)
block|{
name|encryptDataRC4
argument_list|(
name|rc4Key
argument_list|,
name|owner
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
name|byte
index|[]
name|iterationKey
init|=
operator|new
name|byte
index|[
name|rc4Key
operator|.
name|length
index|]
decl_stmt|;
name|byte
index|[]
name|otemp
init|=
operator|new
name|byte
index|[
name|owner
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|owner
argument_list|,
literal|0
argument_list|,
name|otemp
argument_list|,
literal|0
argument_list|,
name|owner
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|19
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|rc4Key
argument_list|,
literal|0
argument_list|,
name|iterationKey
argument_list|,
literal|0
argument_list|,
name|rc4Key
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iterationKey
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|iterationKey
index|[
name|j
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|iterationKey
index|[
name|j
index|]
operator|^
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|reset
argument_list|()
expr_stmt|;
name|encryptDataRC4
argument_list|(
name|iterationKey
argument_list|,
name|otemp
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|otemp
operator|=
name|result
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|result
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**      * Compute the encryption key.      *      * @param password The password to compute the encrypted key.      * @param o The O entry of the encryption dictionary.      * @param u The U entry of the encryption dictionary.      * @param oe The OE entry of the encryption dictionary.      * @param ue The UE entry of the encryption dictionary.      * @param permissions The permissions for the document.      * @param id The document id.      * @param encRevision The revision of the encryption algorithm.      * @param length The length of the encryption key.      * @param encryptMetadata The encryption metadata      * @param isOwnerPassword whether the password given is the owner password (for revision 6)      *      * @return The encrypted key bytes.      *      * @throws IOException If there is an error with encryption.      */
specifier|public
name|byte
index|[]
name|computeEncryptedKey
parameter_list|(
name|byte
index|[]
name|password
parameter_list|,
name|byte
index|[]
name|o
parameter_list|,
name|byte
index|[]
name|u
parameter_list|,
name|byte
index|[]
name|oe
parameter_list|,
name|byte
index|[]
name|ue
parameter_list|,
name|int
name|permissions
parameter_list|,
name|byte
index|[]
name|id
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|encryptMetadata
parameter_list|,
name|boolean
name|isOwnerPassword
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|encRevision
operator|==
literal|6
operator|||
name|encRevision
operator|==
literal|5
condition|)
block|{
return|return
name|computeEncryptedKeyRev56
argument_list|(
name|password
argument_list|,
name|isOwnerPassword
argument_list|,
name|o
argument_list|,
name|u
argument_list|,
name|oe
argument_list|,
name|ue
argument_list|,
name|encRevision
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|computeEncryptedKeyRev234
argument_list|(
name|password
argument_list|,
name|o
argument_list|,
name|permissions
argument_list|,
name|id
argument_list|,
name|encryptMetadata
argument_list|,
name|length
argument_list|,
name|encRevision
argument_list|)
return|;
block|}
block|}
specifier|private
name|byte
index|[]
name|computeEncryptedKeyRev234
parameter_list|(
name|byte
index|[]
name|password
parameter_list|,
name|byte
index|[]
name|o
parameter_list|,
name|int
name|permissions
parameter_list|,
name|byte
index|[]
name|id
parameter_list|,
name|boolean
name|encryptMetadata
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|encRevision
parameter_list|)
block|{
comment|//Algorithm 2, based on MD5
comment|//PDFReference 1.4 pg 78
name|byte
index|[]
name|padded
init|=
name|truncateOrPad
argument_list|(
name|password
argument_list|)
decl_stmt|;
name|MessageDigest
name|md
init|=
name|MessageDigests
operator|.
name|getMD5
argument_list|()
decl_stmt|;
name|md
operator|.
name|update
argument_list|(
name|padded
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
operator|(
name|byte
operator|)
name|permissions
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|permissions
operator|>>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|permissions
operator|>>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|permissions
operator|>>>
literal|24
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|//(Security handlers of revision 4 or greater) If document metadata is not being
comment|// encrypted, pass 4 bytes with the value 0xFFFFFFFF to the MD5 hash function.
comment|//see 7.6.3.3 Algorithm 2 Step f of PDF 32000-1:2008
if|if
condition|(
name|encRevision
operator|==
literal|4
operator|&&
operator|!
name|encryptMetadata
condition|)
block|{
name|md
operator|.
name|update
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
literal|0xff
block|,
operator|(
name|byte
operator|)
literal|0xff
block|,
operator|(
name|byte
operator|)
literal|0xff
block|,
operator|(
name|byte
operator|)
literal|0xff
block|}
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|digest
init|=
name|md
operator|.
name|digest
argument_list|()
decl_stmt|;
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|.
name|update
argument_list|(
name|digest
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|digest
operator|=
name|md
operator|.
name|digest
argument_list|()
expr_stmt|;
block|}
block|}
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|digest
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|byte
index|[]
name|computeEncryptedKeyRev56
parameter_list|(
name|byte
index|[]
name|password
parameter_list|,
name|boolean
name|isOwnerPassword
parameter_list|,
name|byte
index|[]
name|o
parameter_list|,
name|byte
index|[]
name|u
parameter_list|,
name|byte
index|[]
name|oe
parameter_list|,
name|byte
index|[]
name|ue
parameter_list|,
name|int
name|encRevision
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|hash
decl_stmt|,
name|fileKeyEnc
decl_stmt|;
if|if
condition|(
name|isOwnerPassword
condition|)
block|{
name|byte
index|[]
name|oKeySalt
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|o
argument_list|,
literal|40
argument_list|,
name|oKeySalt
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|encRevision
operator|==
literal|5
condition|)
block|{
name|hash
operator|=
name|computeSHA256
argument_list|(
name|password
argument_list|,
name|oKeySalt
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hash
operator|=
name|computeHash2A
argument_list|(
name|password
argument_list|,
name|oKeySalt
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|fileKeyEnc
operator|=
name|oe
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|uKeySalt
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|u
argument_list|,
literal|40
argument_list|,
name|uKeySalt
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|encRevision
operator|==
literal|5
condition|)
block|{
name|hash
operator|=
name|computeSHA256
argument_list|(
name|password
argument_list|,
name|uKeySalt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hash
operator|=
name|computeHash2A
argument_list|(
name|password
argument_list|,
name|uKeySalt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|fileKeyEnc
operator|=
name|ue
expr_stmt|;
block|}
try|try
block|{
name|Cipher
name|cipher
init|=
name|Cipher
operator|.
name|getInstance
argument_list|(
literal|"AES/CBC/NoPadding"
argument_list|)
decl_stmt|;
name|cipher
operator|.
name|init
argument_list|(
name|Cipher
operator|.
name|DECRYPT_MODE
argument_list|,
operator|new
name|SecretKeySpec
argument_list|(
name|hash
argument_list|,
literal|"AES"
argument_list|)
argument_list|,
operator|new
name|IvParameterSpec
argument_list|(
operator|new
name|byte
index|[
literal|16
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cipher
operator|.
name|doFinal
argument_list|(
name|fileKeyEnc
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
name|e
parameter_list|)
block|{
name|logIfStrongEncryptionMissing
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * This will compute the user password hash.      *      * @param password The plain text password.      * @param owner The owner password hash.      * @param permissions The document permissions.      * @param id The document id.      * @param encRevision The revision of the encryption.      * @param length The length of the encryption key.      * @param encryptMetadata The encryption metadata      *      * @return The user password.      *      * @throws IOException if the password could not be computed      */
specifier|public
name|byte
index|[]
name|computeUserPassword
parameter_list|(
name|byte
index|[]
name|password
parameter_list|,
name|byte
index|[]
name|owner
parameter_list|,
name|int
name|permissions
parameter_list|,
name|byte
index|[]
name|id
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|encryptMetadata
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|result
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|byte
index|[]
name|encKey
init|=
name|computeEncryptedKey
argument_list|(
name|password
argument_list|,
name|owner
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|permissions
argument_list|,
name|id
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|,
name|encryptMetadata
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|encRevision
operator|==
literal|2
condition|)
block|{
name|encryptDataRC4
argument_list|(
name|encKey
argument_list|,
name|ENCRYPT_PADDING
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
name|MessageDigest
name|md
init|=
name|MessageDigests
operator|.
name|getMD5
argument_list|()
decl_stmt|;
name|md
operator|.
name|update
argument_list|(
name|ENCRYPT_PADDING
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|result
operator|.
name|write
argument_list|(
name|md
operator|.
name|digest
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|iterationKey
init|=
operator|new
name|byte
index|[
name|encKey
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|encKey
argument_list|,
literal|0
argument_list|,
name|iterationKey
argument_list|,
literal|0
argument_list|,
name|iterationKey
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iterationKey
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|iterationKey
index|[
name|j
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|iterationKey
index|[
name|j
index|]
operator|^
name|i
argument_list|)
expr_stmt|;
block|}
name|ByteArrayInputStream
name|input
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|result
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|.
name|reset
argument_list|()
expr_stmt|;
name|encryptDataRC4
argument_list|(
name|iterationKey
argument_list|,
name|input
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|finalResult
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|result
operator|.
name|toByteArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|finalResult
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ENCRYPT_PADDING
argument_list|,
literal|0
argument_list|,
name|finalResult
argument_list|,
literal|16
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|result
operator|.
name|reset
argument_list|()
expr_stmt|;
name|result
operator|.
name|write
argument_list|(
name|finalResult
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**      * Compute the owner entry in the encryption dictionary.      *      * @param ownerPassword The plaintext owner password.      * @param userPassword The plaintext user password.      * @param encRevision The revision number of the encryption algorithm.      * @param length The length of the encryption key.      *      * @return The o entry of the encryption dictionary.      *      * @throws IOException if the owner password could not be computed      */
specifier|public
name|byte
index|[]
name|computeOwnerPassword
parameter_list|(
name|byte
index|[]
name|ownerPassword
parameter_list|,
name|byte
index|[]
name|userPassword
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|encRevision
operator|==
literal|2
operator|&&
name|length
operator|!=
literal|5
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected length=5 actual="
operator|+
name|length
argument_list|)
throw|;
block|}
name|byte
index|[]
name|rc4Key
init|=
name|computeRC4key
argument_list|(
name|ownerPassword
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|byte
index|[]
name|paddedUser
init|=
name|truncateOrPad
argument_list|(
name|userPassword
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|encrypted
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|encryptDataRC4
argument_list|(
name|rc4Key
argument_list|,
operator|new
name|ByteArrayInputStream
argument_list|(
name|paddedUser
argument_list|)
argument_list|,
name|encrypted
argument_list|)
expr_stmt|;
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
name|byte
index|[]
name|iterationKey
init|=
operator|new
name|byte
index|[
name|rc4Key
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|rc4Key
argument_list|,
literal|0
argument_list|,
name|iterationKey
argument_list|,
literal|0
argument_list|,
name|rc4Key
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iterationKey
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|iterationKey
index|[
name|j
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|iterationKey
index|[
name|j
index|]
operator|^
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
name|ByteArrayInputStream
name|input
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|encrypted
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|encrypted
operator|.
name|reset
argument_list|()
expr_stmt|;
name|encryptDataRC4
argument_list|(
name|iterationKey
argument_list|,
name|input
argument_list|,
name|encrypted
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|encrypted
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|// steps (a) to (d) of "Algorithm 3: Computing the encryption dictionary?s O (owner password) value".
specifier|private
name|byte
index|[]
name|computeRC4key
parameter_list|(
name|byte
index|[]
name|ownerPassword
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|MessageDigest
name|md
init|=
name|MessageDigests
operator|.
name|getMD5
argument_list|()
decl_stmt|;
name|byte
index|[]
name|digest
init|=
name|md
operator|.
name|digest
argument_list|(
name|truncateOrPad
argument_list|(
name|ownerPassword
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
comment|// this deviates from the spec - however, omitting the length
comment|// parameter prevents the file to be opened in Adobe Reader
comment|// with the owner password when the key length is 40 bit (= 5 bytes)
name|md
operator|.
name|update
argument_list|(
name|digest
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|digest
operator|=
name|md
operator|.
name|digest
argument_list|()
expr_stmt|;
block|}
block|}
name|byte
index|[]
name|rc4Key
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|digest
argument_list|,
literal|0
argument_list|,
name|rc4Key
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|rc4Key
return|;
block|}
comment|/**      * This will take the password and truncate or pad it as necessary.      *      * @param password The password to pad or truncate.      *      * @return The padded or truncated password.      */
specifier|private
name|byte
index|[]
name|truncateOrPad
parameter_list|(
name|byte
index|[]
name|password
parameter_list|)
block|{
name|byte
index|[]
name|padded
init|=
operator|new
name|byte
index|[
name|ENCRYPT_PADDING
operator|.
name|length
index|]
decl_stmt|;
name|int
name|bytesBeforePad
init|=
name|Math
operator|.
name|min
argument_list|(
name|password
operator|.
name|length
argument_list|,
name|padded
operator|.
name|length
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|password
argument_list|,
literal|0
argument_list|,
name|padded
argument_list|,
literal|0
argument_list|,
name|bytesBeforePad
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ENCRYPT_PADDING
argument_list|,
literal|0
argument_list|,
name|padded
argument_list|,
name|bytesBeforePad
argument_list|,
name|ENCRYPT_PADDING
operator|.
name|length
operator|-
name|bytesBeforePad
argument_list|)
expr_stmt|;
return|return
name|padded
return|;
block|}
comment|/**      * Check if a plaintext password is the user password.      *      * @param password The plaintext password.      * @param user The u entry of the encryption dictionary.      * @param owner The o entry of the encryption dictionary.      * @param permissions The permissions set in the PDF.      * @param id The document id used for encryption.      * @param encRevision The revision of the encryption algorithm.      * @param length The length of the encryption key.      * @param encryptMetadata The encryption metadata      *      * @return true If the plaintext password is the user password.      *      * @throws IOException If there is an error accessing data.      */
specifier|public
name|boolean
name|isUserPassword
parameter_list|(
name|byte
index|[]
name|password
parameter_list|,
name|byte
index|[]
name|user
parameter_list|,
name|byte
index|[]
name|owner
parameter_list|,
name|int
name|permissions
parameter_list|,
name|byte
index|[]
name|id
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|encryptMetadata
parameter_list|)
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|encRevision
condition|)
block|{
case|case
literal|2
case|:
block|{
name|byte
index|[]
name|passwordBytes
init|=
name|computeUserPassword
argument_list|(
name|password
argument_list|,
name|owner
argument_list|,
name|permissions
argument_list|,
name|id
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|,
name|encryptMetadata
argument_list|)
decl_stmt|;
return|return
name|Arrays
operator|.
name|equals
argument_list|(
name|user
argument_list|,
name|passwordBytes
argument_list|)
return|;
block|}
case|case
literal|3
case|:
case|case
literal|4
case|:
block|{
name|byte
index|[]
name|passwordBytes
init|=
name|computeUserPassword
argument_list|(
name|password
argument_list|,
name|owner
argument_list|,
name|permissions
argument_list|,
name|id
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|,
name|encryptMetadata
argument_list|)
decl_stmt|;
comment|// compare first 16 bytes only
return|return
name|Arrays
operator|.
name|equals
argument_list|(
name|Arrays
operator|.
name|copyOf
argument_list|(
name|user
argument_list|,
literal|16
argument_list|)
argument_list|,
name|Arrays
operator|.
name|copyOf
argument_list|(
name|passwordBytes
argument_list|,
literal|16
argument_list|)
argument_list|)
return|;
block|}
case|case
literal|5
case|:
case|case
literal|6
case|:
name|byte
index|[]
name|truncatedPassword
init|=
name|truncate127
argument_list|(
name|password
argument_list|)
decl_stmt|;
name|byte
index|[]
name|uHash
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
name|byte
index|[]
name|uValidationSalt
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|user
argument_list|,
literal|0
argument_list|,
name|uHash
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|user
argument_list|,
literal|32
argument_list|,
name|uValidationSalt
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|byte
index|[]
name|hash
decl_stmt|;
if|if
condition|(
name|encRevision
operator|==
literal|5
condition|)
block|{
name|hash
operator|=
name|computeSHA256
argument_list|(
name|truncatedPassword
argument_list|,
name|uValidationSalt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hash
operator|=
name|computeHash2A
argument_list|(
name|truncatedPassword
argument_list|,
name|uValidationSalt
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|Arrays
operator|.
name|equals
argument_list|(
name|hash
argument_list|,
name|uHash
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown Encryption Revision "
operator|+
name|encRevision
argument_list|)
throw|;
block|}
block|}
comment|/**      * Check if a plaintext password is the user password.      *      * @param password The plaintext password.      * @param user The u entry of the encryption dictionary.      * @param owner The o entry of the encryption dictionary.      * @param permissions The permissions set in the PDF.      * @param id The document id used for encryption.      * @param encRevision The revision of the encryption algorithm.      * @param length The length of the encryption key.      * @param encryptMetadata The encryption metadata      *      * @return true If the plaintext password is the user password.      *      * @throws IOException If there is an error accessing data.      */
specifier|public
name|boolean
name|isUserPassword
parameter_list|(
name|String
name|password
parameter_list|,
name|byte
index|[]
name|user
parameter_list|,
name|byte
index|[]
name|owner
parameter_list|,
name|int
name|permissions
parameter_list|,
name|byte
index|[]
name|id
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|encryptMetadata
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|encRevision
operator|==
literal|6
operator|||
name|encRevision
operator|==
literal|5
condition|)
block|{
return|return
name|isUserPassword
argument_list|(
name|password
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|,
name|user
argument_list|,
name|owner
argument_list|,
name|permissions
argument_list|,
name|id
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|,
name|encryptMetadata
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|isUserPassword
argument_list|(
name|password
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|,
name|user
argument_list|,
name|owner
argument_list|,
name|permissions
argument_list|,
name|id
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|,
name|encryptMetadata
argument_list|)
return|;
block|}
block|}
comment|/**      * Check for owner password.      *      * @param password The owner password.      * @param user The u entry of the encryption dictionary.      * @param owner The o entry of the encryption dictionary.      * @param permissions The set of permissions on the document.      * @param id The document id.      * @param encRevision The encryption algorithm revision.      * @param length The encryption key length.      * @param encryptMetadata The encryption metadata      *      * @return True If the ownerPassword param is the owner password.      *      * @throws IOException If there is an error accessing data.      */
specifier|public
name|boolean
name|isOwnerPassword
parameter_list|(
name|String
name|password
parameter_list|,
name|byte
index|[]
name|user
parameter_list|,
name|byte
index|[]
name|owner
parameter_list|,
name|int
name|permissions
parameter_list|,
name|byte
index|[]
name|id
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|encryptMetadata
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|isOwnerPassword
argument_list|(
name|password
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|,
name|user
argument_list|,
name|owner
argument_list|,
name|permissions
argument_list|,
name|id
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|,
name|encryptMetadata
argument_list|)
return|;
block|}
comment|// Algorithm 2.A from ISO 32000-1
specifier|private
name|byte
index|[]
name|computeHash2A
parameter_list|(
name|byte
index|[]
name|password
parameter_list|,
name|byte
index|[]
name|salt
parameter_list|,
name|byte
index|[]
name|u
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|userKey
decl_stmt|;
if|if
condition|(
name|u
operator|==
literal|null
condition|)
block|{
name|userKey
operator|=
operator|new
name|byte
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|.
name|length
operator|<
literal|48
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Bad U length"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|u
operator|.
name|length
operator|>
literal|48
condition|)
block|{
comment|// must truncate
name|userKey
operator|=
operator|new
name|byte
index|[
literal|48
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|u
argument_list|,
literal|0
argument_list|,
name|userKey
argument_list|,
literal|0
argument_list|,
literal|48
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|userKey
operator|=
name|u
expr_stmt|;
block|}
name|byte
index|[]
name|truncatedPassword
init|=
name|truncate127
argument_list|(
name|password
argument_list|)
decl_stmt|;
name|byte
index|[]
name|input
init|=
name|concat
argument_list|(
name|truncatedPassword
argument_list|,
name|salt
argument_list|,
name|userKey
argument_list|)
decl_stmt|;
return|return
name|computeHash2B
argument_list|(
name|input
argument_list|,
name|truncatedPassword
argument_list|,
name|userKey
argument_list|)
return|;
block|}
comment|// Algorithm 2.B from ISO 32000-2
specifier|private
specifier|static
name|byte
index|[]
name|computeHash2B
parameter_list|(
name|byte
index|[]
name|input
parameter_list|,
name|byte
index|[]
name|password
parameter_list|,
name|byte
index|[]
name|userKey
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|MessageDigest
name|md
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"SHA-256"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|k
init|=
name|md
operator|.
name|digest
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|byte
index|[]
name|e
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|round
init|=
literal|0
init|;
name|round
argument_list|<
literal|64
operator|||
operator|(
operator|(
name|int
operator|)
name|e
index|[
name|e
operator|.
name|length
operator|-
literal|1
index|]
operator|&
literal|0xFF
operator|)
argument_list|>
name|round
operator|-
literal|32
condition|;
name|round
operator|++
control|)
block|{
name|byte
index|[]
name|k1
decl_stmt|;
if|if
condition|(
name|userKey
operator|!=
literal|null
operator|&&
name|userKey
operator|.
name|length
operator|>=
literal|48
condition|)
block|{
name|k1
operator|=
operator|new
name|byte
index|[
literal|64
operator|*
operator|(
name|password
operator|.
name|length
operator|+
name|k
operator|.
name|length
operator|+
literal|48
operator|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|k1
operator|=
operator|new
name|byte
index|[
literal|64
operator|*
operator|(
name|password
operator|.
name|length
operator|+
name|k
operator|.
name|length
operator|)
index|]
expr_stmt|;
block|}
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|password
argument_list|,
literal|0
argument_list|,
name|k1
argument_list|,
name|pos
argument_list|,
name|password
operator|.
name|length
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|password
operator|.
name|length
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|k
argument_list|,
literal|0
argument_list|,
name|k1
argument_list|,
name|pos
argument_list|,
name|k
operator|.
name|length
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|k
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|userKey
operator|!=
literal|null
operator|&&
name|userKey
operator|.
name|length
operator|>=
literal|48
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|userKey
argument_list|,
literal|0
argument_list|,
name|k1
argument_list|,
name|pos
argument_list|,
literal|48
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|48
expr_stmt|;
block|}
block|}
name|byte
index|[]
name|kFirst
init|=
operator|new
name|byte
index|[
literal|16
index|]
decl_stmt|;
name|byte
index|[]
name|kSecond
init|=
operator|new
name|byte
index|[
literal|16
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|k
argument_list|,
literal|0
argument_list|,
name|kFirst
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|k
argument_list|,
literal|16
argument_list|,
name|kSecond
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|Cipher
name|cipher
init|=
name|Cipher
operator|.
name|getInstance
argument_list|(
literal|"AES/CBC/NoPadding"
argument_list|)
decl_stmt|;
name|SecretKeySpec
name|keySpec
init|=
operator|new
name|SecretKeySpec
argument_list|(
name|kFirst
argument_list|,
literal|"AES"
argument_list|)
decl_stmt|;
name|IvParameterSpec
name|ivSpec
init|=
operator|new
name|IvParameterSpec
argument_list|(
name|kSecond
argument_list|)
decl_stmt|;
name|cipher
operator|.
name|init
argument_list|(
name|Cipher
operator|.
name|ENCRYPT_MODE
argument_list|,
name|keySpec
argument_list|,
name|ivSpec
argument_list|)
expr_stmt|;
name|e
operator|=
name|cipher
operator|.
name|doFinal
argument_list|(
name|k1
argument_list|)
expr_stmt|;
name|byte
index|[]
name|eFirst
init|=
operator|new
name|byte
index|[
literal|16
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
name|eFirst
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|BigInteger
name|bi
init|=
operator|new
name|BigInteger
argument_list|(
literal|1
argument_list|,
name|eFirst
argument_list|)
decl_stmt|;
name|BigInteger
name|remainder
init|=
name|bi
operator|.
name|mod
argument_list|(
operator|new
name|BigInteger
argument_list|(
literal|"3"
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|nextHash
init|=
name|HASHES_2B
index|[
name|remainder
operator|.
name|intValue
argument_list|()
index|]
decl_stmt|;
name|md
operator|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
name|nextHash
argument_list|)
expr_stmt|;
name|k
operator|=
name|md
operator|.
name|digest
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|.
name|length
operator|>
literal|32
condition|)
block|{
name|byte
index|[]
name|kTrunc
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|k
argument_list|,
literal|0
argument_list|,
name|kTrunc
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
return|return
name|kTrunc
return|;
block|}
else|else
block|{
return|return
name|k
return|;
block|}
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
name|e
parameter_list|)
block|{
name|logIfStrongEncryptionMissing
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|byte
index|[]
name|computeSHA256
parameter_list|(
name|byte
index|[]
name|input
parameter_list|,
name|byte
index|[]
name|password
parameter_list|,
name|byte
index|[]
name|userKey
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|MessageDigest
name|md
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"SHA-256"
argument_list|)
decl_stmt|;
name|md
operator|.
name|update
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|password
argument_list|)
expr_stmt|;
return|return
name|userKey
operator|==
literal|null
condition|?
name|md
operator|.
name|digest
argument_list|()
else|:
name|md
operator|.
name|digest
argument_list|(
name|userKey
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|byte
index|[]
name|concat
parameter_list|(
name|byte
index|[]
name|a
parameter_list|,
name|byte
index|[]
name|b
parameter_list|)
block|{
name|byte
index|[]
name|o
init|=
operator|new
name|byte
index|[
name|a
operator|.
name|length
operator|+
name|b
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
name|o
argument_list|,
literal|0
argument_list|,
name|a
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|o
argument_list|,
name|a
operator|.
name|length
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
specifier|private
specifier|static
name|byte
index|[]
name|concat
parameter_list|(
name|byte
index|[]
name|a
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|byte
index|[]
name|c
parameter_list|)
block|{
name|byte
index|[]
name|o
init|=
operator|new
name|byte
index|[
name|a
operator|.
name|length
operator|+
name|b
operator|.
name|length
operator|+
name|c
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
name|o
argument_list|,
literal|0
argument_list|,
name|a
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|o
argument_list|,
name|a
operator|.
name|length
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
name|o
argument_list|,
name|a
operator|.
name|length
operator|+
name|b
operator|.
name|length
argument_list|,
name|c
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
specifier|private
specifier|static
name|byte
index|[]
name|truncate127
parameter_list|(
name|byte
index|[]
name|in
parameter_list|)
block|{
if|if
condition|(
name|in
operator|.
name|length
operator|<=
literal|127
condition|)
block|{
return|return
name|in
return|;
block|}
name|byte
index|[]
name|trunc
init|=
operator|new
name|byte
index|[
literal|127
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
name|trunc
argument_list|,
literal|0
argument_list|,
literal|127
argument_list|)
expr_stmt|;
return|return
name|trunc
return|;
block|}
specifier|private
specifier|static
name|void
name|logIfStrongEncryptionMissing
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|Cipher
operator|.
name|getMaxAllowedKeyLength
argument_list|(
literal|"AES"
argument_list|)
operator|!=
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"JCE unlimited strength jurisdiction policy files are not installed"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|ex
parameter_list|)
block|{         }
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
specifier|public
name|boolean
name|hasProtectionPolicy
parameter_list|()
block|{
return|return
name|policy
operator|!=
literal|null
return|;
block|}
block|}
end_class

end_unit

