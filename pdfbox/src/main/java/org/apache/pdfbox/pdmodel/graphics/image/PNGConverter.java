begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|image
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|color
operator|.
name|ColorSpace
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|color
operator|.
name|ICC_Profile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|stream
operator|.
name|ImageInputStream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|stream
operator|.
name|MemoryCacheImageInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|filter
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|filter
operator|.
name|FilterFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDColorSpace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceGray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceRGB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDICCBased
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDIndexed
import|;
end_import

begin_comment
comment|/**  * This factory tries to encode a PNG given as byte array into a PDImageXObject  * by directly coping the image data into the PDF streams without  * decoding/encoding and re-compressing the PNG data.  *<p>  * If this is for any reason not possible, the factory will return null. You  * must then encode the image by loading it and using the LosslessFactory.  *<p>  * The W3C PNG spec was used to implement this class:  * https://www.w3.org/TR/2003/REC-PNG-20031110  *  * @author Emmeran Seehuber  */
end_comment

begin_class
specifier|final
class|class
name|PNGConverter
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PNGConverter
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Chunk Type definitions. The bytes in the comments are the bytes in the spec.
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_IHDR
init|=
literal|0x49484452
decl_stmt|;
comment|// IHDR: 73 72 68 82
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_IDAT
init|=
literal|0x49444154
decl_stmt|;
comment|// IDAT: 73 68 65 84
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_PLTE
init|=
literal|0x504C5445
decl_stmt|;
comment|// PLTE: 80 76 84 69
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_IEND
init|=
literal|0x49454E44
decl_stmt|;
comment|// IEND: 73 69 78 68
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_TRNS
init|=
literal|0x74524E53
decl_stmt|;
comment|// tRNS: 116 82 78 83
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_CHRM
init|=
literal|0x6348524D
decl_stmt|;
comment|// cHRM: 99 72 82 77
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_GAMA
init|=
literal|0x67414D41
decl_stmt|;
comment|// gAMA: 103 65 77 65
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_ICCP
init|=
literal|0x69434350
decl_stmt|;
comment|// iCCP: 105 67 67 80
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_SBIT
init|=
literal|0x73424954
decl_stmt|;
comment|// sBIT: 115 66 73 84
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_SRGB
init|=
literal|0x73524742
decl_stmt|;
comment|// sRGB: 115 82 71 66
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_TEXT
init|=
literal|0x74455874
decl_stmt|;
comment|// tEXt: 116 69 88 116
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_ZTXT
init|=
literal|0x7A545874
decl_stmt|;
comment|// zTXt: 122 84 88 116
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_ITXT
init|=
literal|0x69545874
decl_stmt|;
comment|// iTXt: 105 84 88 116
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_KBKG
init|=
literal|0x6B424B47
decl_stmt|;
comment|// kBKG: 107 66 75 71
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_HIST
init|=
literal|0x68495354
decl_stmt|;
comment|// hIST: 104 73 83 84
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_PHYS
init|=
literal|0x70485973
decl_stmt|;
comment|// pHYs: 112 72 89 115
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_SPLT
init|=
literal|0x73504C54
decl_stmt|;
comment|// sPLT: 115 80 76 84
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_TIME
init|=
literal|0x74494D45
decl_stmt|;
comment|// tIME: 116 73 77 69
comment|// CRC Reference Implementation, see
comment|// https://www.w3.org/TR/2003/REC-PNG-20031110/#D-CRCAppendix
comment|// for details
comment|/* Table of CRCs of all 8-bit messages. */
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|CRC_TABLE
init|=
operator|new
name|int
index|[
literal|256
index|]
decl_stmt|;
static|static
block|{
name|makeCrcTable
argument_list|()
expr_stmt|;
block|}
specifier|private
name|PNGConverter
parameter_list|()
block|{     }
comment|/**      * Try to convert a PNG into a PDImageXObject. If for any reason the PNG can not      * be converted, null is returned.      *<p>      * This usually means the PNG structure is damaged (CRC error, etc.) or it uses      * some features which can not be mapped to PDF.      *      * @param doc       the document to put the image in      * @param imageData the byte data of the PNG      * @return null or the PDImageXObject built from the png      */
specifier|static
name|PDImageXObject
name|convertPNGImage
parameter_list|(
name|PDDocument
name|doc
parameter_list|,
name|byte
index|[]
name|imageData
parameter_list|)
throws|throws
name|IOException
block|{
name|PNGConverterState
name|state
init|=
name|parsePNGChunks
argument_list|(
name|imageData
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|checkConverterState
argument_list|(
name|state
argument_list|)
condition|)
block|{
comment|// There is something wrong, we can't convert this PNG
return|return
literal|null
return|;
block|}
return|return
name|convertPng
argument_list|(
name|doc
argument_list|,
name|state
argument_list|)
return|;
block|}
comment|/**      * Convert the image using the state.      *      * @param doc   the document to put the image in      * @param state the parser state containing the PNG chunks.      * @return null or the converted image      */
specifier|private
specifier|static
name|PDImageXObject
name|convertPng
parameter_list|(
name|PDDocument
name|doc
parameter_list|,
name|PNGConverterState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|Chunk
name|ihdr
init|=
name|state
operator|.
name|IHDR
decl_stmt|;
name|int
name|ihdrStart
init|=
name|ihdr
operator|.
name|start
decl_stmt|;
name|int
name|width
init|=
name|readInt
argument_list|(
name|ihdr
operator|.
name|bytes
argument_list|,
name|ihdrStart
argument_list|)
decl_stmt|;
name|int
name|height
init|=
name|readInt
argument_list|(
name|ihdr
operator|.
name|bytes
argument_list|,
name|ihdrStart
operator|+
literal|4
argument_list|)
decl_stmt|;
name|int
name|bitDepth
init|=
name|ihdr
operator|.
name|bytes
index|[
name|ihdrStart
operator|+
literal|8
index|]
operator|&
literal|0xFF
decl_stmt|;
name|int
name|colorType
init|=
name|ihdr
operator|.
name|bytes
index|[
name|ihdrStart
operator|+
literal|9
index|]
operator|&
literal|0xFF
decl_stmt|;
name|int
name|compressionMethod
init|=
name|ihdr
operator|.
name|bytes
index|[
name|ihdrStart
operator|+
literal|10
index|]
operator|&
literal|0xFF
decl_stmt|;
name|int
name|filterMethod
init|=
name|ihdr
operator|.
name|bytes
index|[
name|ihdrStart
operator|+
literal|11
index|]
operator|&
literal|0xFF
decl_stmt|;
name|int
name|interlaceMethod
init|=
name|ihdr
operator|.
name|bytes
index|[
name|ihdrStart
operator|+
literal|12
index|]
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
name|bitDepth
operator|!=
literal|1
operator|&&
name|bitDepth
operator|!=
literal|2
operator|&&
name|bitDepth
operator|!=
literal|4
operator|&&
name|bitDepth
operator|!=
literal|8
operator|&&
name|bitDepth
operator|!=
literal|16
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Invalid bit depth %d."
argument_list|,
name|bitDepth
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Invalid image size %d x %d"
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|compressionMethod
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unknown PNG compression method %d."
argument_list|,
name|compressionMethod
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|filterMethod
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unknown PNG filtering method %d."
argument_list|,
name|compressionMethod
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|interlaceMethod
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Can't handle interlace method %d."
argument_list|,
name|interlaceMethod
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|state
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|state
operator|.
name|height
operator|=
name|height
expr_stmt|;
name|state
operator|.
name|bitsPerComponent
operator|=
name|bitDepth
expr_stmt|;
switch|switch
condition|(
name|colorType
condition|)
block|{
case|case
literal|0
case|:
comment|// Grayscale
name|LOG
operator|.
name|debug
argument_list|(
literal|"Can't handle grayscale yet."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
case|case
literal|2
case|:
comment|// Truecolor
if|if
condition|(
name|state
operator|.
name|tRNS
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Can't handle images with transparent colors."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|buildImageObject
argument_list|(
name|doc
argument_list|,
name|state
argument_list|)
return|;
case|case
literal|3
case|:
comment|// Indexed image
return|return
name|buildIndexImage
argument_list|(
name|doc
argument_list|,
name|state
argument_list|)
return|;
case|case
literal|4
case|:
comment|// Grayscale with alpha.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Can't handle grayscale with alpha, would need to separate alpha from image data"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
case|case
literal|6
case|:
comment|// Truecolor with alpha.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Can't handle truecolor with alpha, would need to separate alpha from image data"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
default|default:
name|LOG
operator|.
name|error
argument_list|(
literal|"Unknown PNG color type "
operator|+
name|colorType
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Build a indexed image      */
specifier|private
specifier|static
name|PDImageXObject
name|buildIndexImage
parameter_list|(
name|PDDocument
name|doc
parameter_list|,
name|PNGConverterState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|Chunk
name|plte
init|=
name|state
operator|.
name|PLTE
decl_stmt|;
if|if
condition|(
name|plte
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Indexed image without PLTE chunk."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|plte
operator|.
name|length
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"PLTE table corrupted, last (r,g,b) tuple is not complete."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|state
operator|.
name|bitsPerComponent
operator|>
literal|8
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Can only convert indexed images with bit depth<= 8, not %d."
argument_list|,
name|state
operator|.
name|bitsPerComponent
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|PDImageXObject
name|image
init|=
name|buildImageObject
argument_list|(
name|doc
argument_list|,
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|image
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|highVal
init|=
operator|(
name|plte
operator|.
name|length
operator|/
literal|3
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|highVal
operator|>
literal|255
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"To much colors in PLTE, only 256 allowed, found %d colors."
argument_list|,
name|highVal
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|setupIndexedColorSpace
argument_list|(
name|doc
argument_list|,
name|plte
argument_list|,
name|image
argument_list|,
name|highVal
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|tRNS
operator|!=
literal|null
condition|)
block|{
name|image
operator|.
name|getCOSObject
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|SMASK
argument_list|,
name|buildTransparencyMaskFromIndexedData
argument_list|(
name|doc
argument_list|,
name|image
argument_list|,
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|image
return|;
block|}
specifier|private
specifier|static
name|PDImageXObject
name|buildTransparencyMaskFromIndexedData
parameter_list|(
name|PDDocument
name|doc
parameter_list|,
name|PDImageXObject
name|image
parameter_list|,
name|PNGConverterState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|Filter
name|flateDecode
init|=
name|FilterFactory
operator|.
name|INSTANCE
operator|.
name|getFilter
argument_list|(
name|COSName
operator|.
name|FLATE_DECODE
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|outputStream
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|COSDictionary
name|decodeParams
init|=
name|buildDecodeParams
argument_list|(
name|state
argument_list|,
name|PDDeviceGray
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|COSDictionary
name|imageDict
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|imageDict
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|FILTER
argument_list|,
name|COSName
operator|.
name|FLATE_DECODE
argument_list|)
expr_stmt|;
name|imageDict
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|DECODE_PARMS
argument_list|,
name|decodeParams
argument_list|)
expr_stmt|;
name|flateDecode
operator|.
name|decode
argument_list|(
name|getIDATInputStream
argument_list|(
name|state
argument_list|)
argument_list|,
name|outputStream
argument_list|,
name|imageDict
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|int
name|length
init|=
name|image
operator|.
name|getWidth
argument_list|()
operator|*
name|image
operator|.
name|getHeight
argument_list|()
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|byte
index|[]
name|transparencyTable
init|=
name|state
operator|.
name|tRNS
operator|.
name|getData
argument_list|()
decl_stmt|;
name|byte
index|[]
name|decodedIDAT
init|=
name|outputStream
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
try|try
init|(
name|ImageInputStream
name|iis
init|=
operator|new
name|MemoryCacheImageInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|decodedIDAT
argument_list|)
argument_list|)
init|)
block|{
name|int
name|bitsPerComponent
init|=
name|state
operator|.
name|bitsPerComponent
decl_stmt|;
name|int
name|w
init|=
literal|0
decl_stmt|;
name|int
name|neededBits
init|=
name|bitsPerComponent
operator|*
name|state
operator|.
name|width
decl_stmt|;
name|int
name|bitPadding
init|=
name|neededBits
operator|%
literal|8
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
operator|(
name|int
operator|)
name|iis
operator|.
name|readBits
argument_list|(
name|bitsPerComponent
argument_list|)
decl_stmt|;
name|byte
name|v
decl_stmt|;
if|if
condition|(
name|idx
operator|<
name|transparencyTable
operator|.
name|length
condition|)
block|{
comment|// Inside the table, use the transparency value
name|v
operator|=
name|transparencyTable
index|[
name|idx
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// Outside the table -> transparent value is 0xFF here.
name|v
operator|=
operator|(
name|byte
operator|)
literal|0xFF
expr_stmt|;
block|}
name|bytes
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
name|w
operator|++
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|state
operator|.
name|width
condition|)
block|{
name|w
operator|=
literal|0
expr_stmt|;
name|iis
operator|.
name|readBits
argument_list|(
name|bitPadding
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|LosslessFactory
operator|.
name|prepareImageXObject
argument_list|(
name|doc
argument_list|,
name|bytes
argument_list|,
name|image
operator|.
name|getWidth
argument_list|()
argument_list|,
name|image
operator|.
name|getHeight
argument_list|()
argument_list|,
literal|8
argument_list|,
name|PDDeviceGray
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|setupIndexedColorSpace
parameter_list|(
name|PDDocument
name|doc
parameter_list|,
name|Chunk
name|lookupTable
parameter_list|,
name|PDImageXObject
name|image
parameter_list|,
name|int
name|highVal
parameter_list|)
throws|throws
name|IOException
block|{
name|COSArray
name|indexedArray
init|=
operator|new
name|COSArray
argument_list|()
decl_stmt|;
name|indexedArray
operator|.
name|add
argument_list|(
name|COSName
operator|.
name|INDEXED
argument_list|)
expr_stmt|;
name|indexedArray
operator|.
name|add
argument_list|(
name|image
operator|.
name|getColorSpace
argument_list|()
argument_list|)
expr_stmt|;
operator|(
operator|(
name|COSDictionary
operator|)
name|image
operator|.
name|getCOSObject
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|DECODE_PARMS
argument_list|)
operator|)
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|COLORS
argument_list|,
name|COSInteger
operator|.
name|ONE
argument_list|)
expr_stmt|;
name|indexedArray
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|get
argument_list|(
name|highVal
argument_list|)
argument_list|)
expr_stmt|;
name|PDStream
name|colorTable
init|=
operator|new
name|PDStream
argument_list|(
name|doc
argument_list|)
decl_stmt|;
try|try
init|(
name|OutputStream
name|colorTableStream
init|=
name|colorTable
operator|.
name|createOutputStream
argument_list|(
name|COSName
operator|.
name|FLATE_DECODE
argument_list|)
init|)
block|{
name|colorTableStream
operator|.
name|write
argument_list|(
name|lookupTable
operator|.
name|bytes
argument_list|,
name|lookupTable
operator|.
name|start
argument_list|,
name|lookupTable
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|indexedArray
operator|.
name|add
argument_list|(
name|colorTable
argument_list|)
expr_stmt|;
name|PDIndexed
name|indexed
init|=
operator|new
name|PDIndexed
argument_list|(
name|indexedArray
argument_list|)
decl_stmt|;
name|image
operator|.
name|setColorSpace
argument_list|(
name|indexed
argument_list|)
expr_stmt|;
block|}
comment|/**      * Build the base image object from the IDATs and profile information      */
specifier|private
specifier|static
name|PDImageXObject
name|buildImageObject
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|PNGConverterState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|encodedByteStream
init|=
name|getIDATInputStream
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|PDColorSpace
name|colorSpace
init|=
name|PDDeviceRGB
operator|.
name|INSTANCE
decl_stmt|;
name|PDImageXObject
name|imageXObject
init|=
operator|new
name|PDImageXObject
argument_list|(
name|document
argument_list|,
name|encodedByteStream
argument_list|,
name|COSName
operator|.
name|FLATE_DECODE
argument_list|,
name|state
operator|.
name|width
argument_list|,
name|state
operator|.
name|height
argument_list|,
name|state
operator|.
name|bitsPerComponent
argument_list|,
name|colorSpace
argument_list|)
decl_stmt|;
name|COSDictionary
name|decodeParams
init|=
name|buildDecodeParams
argument_list|(
name|state
argument_list|,
name|colorSpace
argument_list|)
decl_stmt|;
name|imageXObject
operator|.
name|getCOSObject
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|DECODE_PARMS
argument_list|,
name|decodeParams
argument_list|)
expr_stmt|;
comment|// We ignore gAMA and cHRM chunks if we have a ICC profile, as the ICC profile
comment|// takes preference
name|boolean
name|hasICCColorProfile
init|=
name|state
operator|.
name|sRGB
operator|!=
literal|null
operator|||
name|state
operator|.
name|iCCP
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|gAMA
operator|!=
literal|null
operator|&&
operator|!
name|hasICCColorProfile
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|gAMA
operator|.
name|length
operator|!=
literal|4
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid gAMA chunk length "
operator|+
name|state
operator|.
name|gAMA
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|float
name|gamma
init|=
name|readPNGFloat
argument_list|(
name|state
operator|.
name|gAMA
operator|.
name|bytes
argument_list|,
name|state
operator|.
name|gAMA
operator|.
name|start
argument_list|)
decl_stmt|;
comment|// If the gamma is 2.2 for sRGB everything is fine. Otherwise bail out.
comment|// The gamma is stored as 1 / gamma.
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|gamma
operator|-
operator|(
literal|1
operator|/
literal|2.2f
operator|)
argument_list|)
operator|>
literal|0.00001
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"We can't handle gamma of %f yet."
argument_list|,
name|gamma
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
name|state
operator|.
name|sRGB
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|sRGB
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"sRGB chunk has an invalid length of %d"
argument_list|,
name|state
operator|.
name|sRGB
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Store the specified rendering intent
name|int
name|renderIntent
init|=
name|state
operator|.
name|sRGB
operator|.
name|bytes
index|[
name|state
operator|.
name|sRGB
operator|.
name|start
index|]
decl_stmt|;
name|COSName
name|value
init|=
name|mapPNGRenderIntent
argument_list|(
name|renderIntent
argument_list|)
decl_stmt|;
name|imageXObject
operator|.
name|getCOSObject
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|INTENT
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|.
name|cHRM
operator|!=
literal|null
operator|&&
operator|!
name|hasICCColorProfile
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|cHRM
operator|.
name|length
operator|!=
literal|32
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid cHRM chunk length "
operator|+
name|state
operator|.
name|cHRM
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"We can not handle cHRM chunks yet."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// If possible we prefer a ICCBased color profile, just because its way faster
comment|// to decode ...
if|if
condition|(
name|state
operator|.
name|iCCP
operator|!=
literal|null
operator|||
name|state
operator|.
name|sRGB
operator|!=
literal|null
condition|)
block|{
comment|// We have got a color profile, which we must attach
name|PDICCBased
name|profile
init|=
operator|new
name|PDICCBased
argument_list|(
name|document
argument_list|)
decl_stmt|;
name|COSStream
name|cosStream
init|=
name|profile
operator|.
name|getPDStream
argument_list|()
operator|.
name|getCOSObject
argument_list|()
decl_stmt|;
name|cosStream
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|N
argument_list|,
name|colorSpace
operator|.
name|getNumberOfComponents
argument_list|()
argument_list|)
expr_stmt|;
name|cosStream
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ALTERNATE
argument_list|,
name|colorSpace
operator|.
name|getNumberOfComponents
argument_list|()
operator|==
literal|1
condition|?
name|COSName
operator|.
name|DEVICEGRAY
else|:
name|COSName
operator|.
name|DEVICERGB
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|iCCP
operator|!=
literal|null
condition|)
block|{
comment|// We need to skip over the name
name|int
name|iccProfileDataStart
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iccProfileDataStart
operator|<
literal|80
operator|&&
name|iccProfileDataStart
operator|<
name|state
operator|.
name|iCCP
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|state
operator|.
name|iCCP
operator|.
name|bytes
index|[
name|state
operator|.
name|iCCP
operator|.
name|start
operator|+
name|iccProfileDataStart
index|]
operator|==
literal|0
condition|)
break|break;
name|iccProfileDataStart
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|iccProfileDataStart
operator|>=
name|state
operator|.
name|iCCP
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid iCCP chunk, to few bytes"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|byte
name|compressionMethod
init|=
name|state
operator|.
name|iCCP
operator|.
name|bytes
index|[
name|state
operator|.
name|iCCP
operator|.
name|start
operator|+
name|iccProfileDataStart
index|]
decl_stmt|;
if|if
condition|(
name|compressionMethod
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"iCCP chunk: invalid compression method %d"
argument_list|,
name|compressionMethod
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Skip over the compression method
name|iccProfileDataStart
operator|++
expr_stmt|;
try|try
init|(
name|OutputStream
name|rawOutputStream
init|=
name|cosStream
operator|.
name|createRawOutputStream
argument_list|()
init|)
block|{
name|rawOutputStream
operator|.
name|write
argument_list|(
name|state
operator|.
name|iCCP
operator|.
name|bytes
argument_list|,
name|state
operator|.
name|iCCP
operator|.
name|start
operator|+
name|iccProfileDataStart
argument_list|,
name|state
operator|.
name|iCCP
operator|.
name|length
operator|-
name|iccProfileDataStart
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We tag the image with the sRGB profile
name|ICC_Profile
name|rgbProfile
init|=
name|ICC_Profile
operator|.
name|getInstance
argument_list|(
name|ColorSpace
operator|.
name|CS_sRGB
argument_list|)
decl_stmt|;
try|try
init|(
name|OutputStream
name|outputStream
init|=
name|cosStream
operator|.
name|createRawOutputStream
argument_list|()
init|)
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|rgbProfile
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|imageXObject
operator|.
name|setColorSpace
argument_list|(
name|profile
argument_list|)
expr_stmt|;
block|}
return|return
name|imageXObject
return|;
block|}
specifier|private
specifier|static
name|COSDictionary
name|buildDecodeParams
parameter_list|(
name|PNGConverterState
name|state
parameter_list|,
name|PDColorSpace
name|colorSpace
parameter_list|)
block|{
name|COSDictionary
name|decodeParms
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|decodeParms
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|BITS_PER_COMPONENT
argument_list|,
name|COSInteger
operator|.
name|get
argument_list|(
name|state
operator|.
name|bitsPerComponent
argument_list|)
argument_list|)
expr_stmt|;
name|decodeParms
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|PREDICTOR
argument_list|,
name|COSInteger
operator|.
name|get
argument_list|(
literal|15
argument_list|)
argument_list|)
expr_stmt|;
name|decodeParms
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|COLUMNS
argument_list|,
name|COSInteger
operator|.
name|get
argument_list|(
name|state
operator|.
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|decodeParms
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|COLORS
argument_list|,
name|COSInteger
operator|.
name|get
argument_list|(
name|colorSpace
operator|.
name|getNumberOfComponents
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decodeParms
return|;
block|}
comment|/**      * Build an input stream for the IDAT data. May need to concat multiple IDAT      * chunks.      *      * @param state the converter state.      * @return a input stream with the IDAT data.      */
specifier|private
specifier|static
name|InputStream
name|getIDATInputStream
parameter_list|(
name|PNGConverterState
name|state
parameter_list|)
block|{
name|MultipleInputStream
name|inputStream
init|=
operator|new
name|MultipleInputStream
argument_list|()
decl_stmt|;
for|for
control|(
name|Chunk
name|idat
range|:
name|state
operator|.
name|IDATs
control|)
block|{
name|inputStream
operator|.
name|inputStreams
operator|.
name|add
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|idat
operator|.
name|bytes
argument_list|,
name|idat
operator|.
name|start
argument_list|,
name|idat
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|inputStream
return|;
block|}
specifier|private
specifier|static
class|class
name|MultipleInputStream
extends|extends
name|InputStream
block|{
name|List
argument_list|<
name|InputStream
argument_list|>
name|inputStreams
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|currentStreamIdx
decl_stmt|;
name|InputStream
name|currentStream
decl_stmt|;
specifier|private
name|boolean
name|ensureStream
parameter_list|()
block|{
if|if
condition|(
name|currentStream
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|currentStreamIdx
operator|>=
name|inputStreams
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|currentStream
operator|=
name|inputStreams
operator|.
name|get
argument_list|(
name|currentStreamIdx
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Only bulk reads are expected!"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|ensureStream
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|ensureStream
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|ret
init|=
name|currentStream
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|currentStream
operator|=
literal|null
expr_stmt|;
return|return
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
return|return
name|ret
return|;
block|}
block|}
comment|/**      * Map the renderIntent int to a PDF render intent. See also      * https://www.w3.org/TR/2003/REC-PNG-20031110/#11sRGB      *      * @param renderIntent the PNG render intent      * @return the matching PDF Render Intent or null      */
specifier|static
name|COSName
name|mapPNGRenderIntent
parameter_list|(
name|int
name|renderIntent
parameter_list|)
block|{
name|COSName
name|value
decl_stmt|;
switch|switch
condition|(
name|renderIntent
condition|)
block|{
case|case
literal|0
case|:
name|value
operator|=
name|COSName
operator|.
name|PERCEPTUAL
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|value
operator|=
name|COSName
operator|.
name|RELATIVE_COLORIMETRIC
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|value
operator|=
name|COSName
operator|.
name|SATURATION
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|value
operator|=
name|COSName
operator|.
name|ABSOLUTE_COLORIMETRIC
expr_stmt|;
break|break;
default|default:
name|value
operator|=
literal|null
expr_stmt|;
break|break;
block|}
return|return
name|value
return|;
block|}
comment|/**      * Check if the converter state is sane.      *      * @param state the parsed converter state      * @return true if the state seems plausible      */
specifier|static
name|boolean
name|checkConverterState
parameter_list|(
name|PNGConverterState
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|state
operator|.
name|IHDR
operator|==
literal|null
operator|||
operator|!
name|checkChunkSane
argument_list|(
name|state
operator|.
name|IHDR
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid IHDR chunk."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|checkChunkSane
argument_list|(
name|state
operator|.
name|PLTE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid PLTE chunk."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|checkChunkSane
argument_list|(
name|state
operator|.
name|iCCP
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid iCCP chunk."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|checkChunkSane
argument_list|(
name|state
operator|.
name|tRNS
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid tRNS chunk."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|checkChunkSane
argument_list|(
name|state
operator|.
name|sRGB
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid sRGB chunk."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|checkChunkSane
argument_list|(
name|state
operator|.
name|cHRM
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid cHRM chunk."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|checkChunkSane
argument_list|(
name|state
operator|.
name|gAMA
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid gAMA chunk."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Check the IDATs
if|if
condition|(
name|state
operator|.
name|IDATs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"No IDAT chunks."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|Chunk
name|idat
range|:
name|state
operator|.
name|IDATs
control|)
block|{
if|if
condition|(
operator|!
name|checkChunkSane
argument_list|(
name|idat
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid IDAT chunk."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Check if the chunk is sane, i.e. CRC matches and offsets and lengths in the      * byte array      */
specifier|static
name|boolean
name|checkChunkSane
parameter_list|(
name|Chunk
name|chunk
parameter_list|)
block|{
if|if
condition|(
name|chunk
operator|==
literal|null
condition|)
block|{
comment|// If the chunk does not exist, it can not be wrong...
return|return
literal|true
return|;
block|}
if|if
condition|(
name|chunk
operator|.
name|start
operator|+
name|chunk
operator|.
name|length
operator|>
name|chunk
operator|.
name|bytes
operator|.
name|length
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|chunk
operator|.
name|start
operator|<
literal|4
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We must include the chunk type in the CRC calculation
name|int
name|ourCRC
init|=
name|crc
argument_list|(
name|chunk
operator|.
name|bytes
argument_list|,
name|chunk
operator|.
name|start
operator|-
literal|4
argument_list|,
name|chunk
operator|.
name|length
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|ourCRC
operator|!=
name|chunk
operator|.
name|crc
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Invalid CRC %08X on chunk %08X, expected %08X."
argument_list|,
name|ourCRC
argument_list|,
name|chunk
operator|.
name|chunkType
argument_list|,
name|chunk
operator|.
name|crc
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Holds the information about a chunks      */
specifier|static
specifier|final
class|class
name|Chunk
block|{
comment|/**          * This field holds the whole byte array; In that it's redundant, as all chunks          * will have the same byte array. But have this byte array per chunk makes it          * easier to validate and pass around. And we won't have that many chunks, so          * those 8 bytes for the pointer (on 64-bit systems) don't matter.          */
name|byte
index|[]
name|bytes
decl_stmt|;
comment|/**          * The chunk type, see the CHUNK_??? constants.          */
name|int
name|chunkType
decl_stmt|;
comment|/**          * The crc of the chunk data, as stored in the PNG stream.          */
name|int
name|crc
decl_stmt|;
comment|/**          * The start index of the chunk data within bytes.          */
name|int
name|start
decl_stmt|;
comment|/**          * The length of the data within the byte array.          */
name|int
name|length
decl_stmt|;
comment|/**          * Get the data of this chunk as a byte array          *          * @return a byte-array with only the data of the chunk          */
name|byte
index|[]
name|getData
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|bytes
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|length
argument_list|)
return|;
block|}
block|}
comment|/**      * Holds all relevant chunks of the PNG      */
specifier|static
specifier|final
class|class
name|PNGConverterState
block|{
name|List
argument_list|<
name|Chunk
argument_list|>
name|IDATs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"SpellCheckingInspection"
argument_list|)
name|Chunk
name|IHDR
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"SpellCheckingInspection"
argument_list|)
name|Chunk
name|PLTE
decl_stmt|;
name|Chunk
name|iCCP
decl_stmt|;
name|Chunk
name|tRNS
decl_stmt|;
name|Chunk
name|sRGB
decl_stmt|;
name|Chunk
name|gAMA
decl_stmt|;
name|Chunk
name|cHRM
decl_stmt|;
comment|// Parsed header fields
name|int
name|width
decl_stmt|;
name|int
name|height
decl_stmt|;
name|int
name|bitsPerComponent
decl_stmt|;
block|}
specifier|private
specifier|static
name|int
name|readInt
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|b1
init|=
operator|(
name|data
index|[
name|offset
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|24
decl_stmt|;
name|int
name|b2
init|=
operator|(
name|data
index|[
name|offset
operator|+
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|16
decl_stmt|;
name|int
name|b3
init|=
operator|(
name|data
index|[
name|offset
operator|+
literal|2
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
decl_stmt|;
name|int
name|b4
init|=
operator|(
name|data
index|[
name|offset
operator|+
literal|3
index|]
operator|&
literal|0xFF
operator|)
decl_stmt|;
return|return
name|b1
operator||
name|b2
operator||
name|b3
operator||
name|b4
return|;
block|}
specifier|private
specifier|static
name|float
name|readPNGFloat
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|v
init|=
name|readInt
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|)
decl_stmt|;
return|return
name|v
operator|/
literal|100000f
return|;
block|}
comment|/**      * Parse the PNG structure into the PNGConverterState. If we can't handle      * something, this method will return null.      *      * @param imageData the byte array with the PNG data      * @return null or the converter state with all relevant chunks      */
specifier|private
specifier|static
name|PNGConverterState
name|parsePNGChunks
parameter_list|(
name|byte
index|[]
name|imageData
parameter_list|)
block|{
if|if
condition|(
name|imageData
operator|.
name|length
operator|<
literal|20
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"ByteArray way to small: "
operator|+
name|imageData
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|PNGConverterState
name|state
init|=
operator|new
name|PNGConverterState
argument_list|()
decl_stmt|;
name|int
name|ptr
init|=
literal|8
decl_stmt|;
name|int
name|firstChunkType
init|=
name|readInt
argument_list|(
name|imageData
argument_list|,
name|ptr
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChunkType
operator|!=
name|CHUNK_IHDR
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"First Chunktype was %08X, not IHDR"
argument_list|,
name|firstChunkType
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
while|while
condition|(
name|ptr
operator|+
literal|12
operator|<=
name|imageData
operator|.
name|length
condition|)
block|{
name|int
name|chunkLength
init|=
name|readInt
argument_list|(
name|imageData
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
name|int
name|chunkType
init|=
name|readInt
argument_list|(
name|imageData
argument_list|,
name|ptr
operator|+
literal|4
argument_list|)
decl_stmt|;
name|ptr
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|ptr
operator|+
name|chunkLength
operator|+
literal|4
operator|>
name|imageData
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Not enough bytes. At offset "
operator|+
name|ptr
operator|+
literal|" are "
operator|+
name|chunkLength
operator|+
literal|" bytes expected. Overall length is "
operator|+
name|imageData
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Chunk
name|chunk
init|=
operator|new
name|Chunk
argument_list|()
decl_stmt|;
name|chunk
operator|.
name|chunkType
operator|=
name|chunkType
expr_stmt|;
name|chunk
operator|.
name|bytes
operator|=
name|imageData
expr_stmt|;
name|chunk
operator|.
name|start
operator|=
name|ptr
expr_stmt|;
name|chunk
operator|.
name|length
operator|=
name|chunkLength
expr_stmt|;
switch|switch
condition|(
name|chunkType
condition|)
block|{
case|case
name|CHUNK_IHDR
case|:
if|if
condition|(
name|state
operator|.
name|IHDR
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Two IHDR chunks? There is something wrong."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|state
operator|.
name|IHDR
operator|=
name|chunk
expr_stmt|;
break|break;
case|case
name|CHUNK_IDAT
case|:
comment|// The image data itself
name|state
operator|.
name|IDATs
operator|.
name|add
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHUNK_PLTE
case|:
comment|// For indexed images the palette table
if|if
condition|(
name|state
operator|.
name|PLTE
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Two PLTE chunks? There is something wrong."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|state
operator|.
name|PLTE
operator|=
name|chunk
expr_stmt|;
break|break;
case|case
name|CHUNK_IEND
case|:
comment|// We are done, return the state
return|return
name|state
return|;
case|case
name|CHUNK_TRNS
case|:
comment|// For indexed images the alpha transparency table
if|if
condition|(
name|state
operator|.
name|tRNS
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Two tRNS chunks? There is something wrong."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|state
operator|.
name|tRNS
operator|=
name|chunk
expr_stmt|;
break|break;
case|case
name|CHUNK_GAMA
case|:
comment|// Gama
name|state
operator|.
name|gAMA
operator|=
name|chunk
expr_stmt|;
break|break;
case|case
name|CHUNK_CHRM
case|:
comment|// Chroma
name|state
operator|.
name|cHRM
operator|=
name|chunk
expr_stmt|;
break|break;
case|case
name|CHUNK_ICCP
case|:
comment|// ICC Profile
name|state
operator|.
name|iCCP
operator|=
name|chunk
expr_stmt|;
break|break;
case|case
name|CHUNK_SBIT
case|:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Can't convert PNGs with sBIT chunk."
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHUNK_SRGB
case|:
comment|// We use the rendering intent from the chunk
name|state
operator|.
name|sRGB
operator|=
name|chunk
expr_stmt|;
break|break;
case|case
name|CHUNK_TEXT
case|:
case|case
name|CHUNK_ZTXT
case|:
case|case
name|CHUNK_ITXT
case|:
comment|// We don't care about this text infos / metadata
break|break;
case|case
name|CHUNK_KBKG
case|:
comment|// As we can handle transparency we don't need the background color information.
break|break;
case|case
name|CHUNK_HIST
case|:
comment|// We don't need the color histogram
break|break;
case|case
name|CHUNK_PHYS
case|:
comment|// The PDImageXObject will be placed by the user however he wants,
comment|// so we can not enforce the physical dpi information stored here.
comment|// We just ignore it.
break|break;
case|case
name|CHUNK_SPLT
case|:
comment|// This palette stuff seems editor related, we don't need it.
break|break;
case|case
name|CHUNK_TIME
case|:
comment|// We don't need the last image change time either
break|break;
default|default:
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unknown chunk type %08X, skipping."
argument_list|,
name|chunkType
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptr
operator|+=
name|chunkLength
expr_stmt|;
comment|// Read the CRC
name|chunk
operator|.
name|crc
operator|=
name|readInt
argument_list|(
name|imageData
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"No IEND chunk found."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/* Make the table for a fast CRC. */
specifier|private
specifier|static
name|void
name|makeCrcTable
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
block|{
name|c
operator|=
name|n
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
literal|0xEDB88320
operator|^
operator|(
name|c
operator|>>>
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|c
operator|>>>
literal|1
expr_stmt|;
block|}
block|}
name|CRC_TABLE
index|[
name|n
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/*      * Update a running CRC with the bytes buf[0..len-1]--the CRC should be      * initialized to all 1's, and the transmitted value is the 1's complement of      * the final running CRC (see the crc() routine below).      */
specifier|private
specifier|static
name|int
name|updateCrc
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|c
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|end
init|=
name|offset
operator|+
name|len
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
name|offset
init|;
name|n
operator|<
name|end
condition|;
name|n
operator|++
control|)
block|{
name|c
operator|=
name|CRC_TABLE
index|[
operator|(
name|c
operator|^
name|buf
index|[
name|n
index|]
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|c
operator|>>>
literal|8
operator|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
comment|/* Return the CRC of the bytes buf[offset..(offset+len-1)]. */
specifier|static
name|int
name|crc
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|~
name|updateCrc
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
end_class

end_unit

