begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Color
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|AffineTransform
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|CmapLookup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|gsub
operator|.
name|CompoundCharacterTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|gsub
operator|.
name|GsubWorker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|gsub
operator|.
name|GsubWorkerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|model
operator|.
name|GsubData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|contentstream
operator|.
name|operator
operator|.
name|OperatorName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfwriter
operator|.
name|COSWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|documentinterchange
operator|.
name|markedcontent
operator|.
name|PDPropertyList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDFont
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDType0Font
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDColor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDColorSpace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceCMYK
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceGray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceN
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceRGB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDICCBased
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDPattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDSeparation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|form
operator|.
name|PDFormXObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|image
operator|.
name|PDImageXObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|image
operator|.
name|PDInlineImage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|shading
operator|.
name|PDShading
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|state
operator|.
name|PDExtendedGraphicsState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|state
operator|.
name|RenderingMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|Matrix
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|NumberFormatUtil
import|;
end_import

begin_comment
comment|/**  * Provides the ability to write to a content stream.  *  * @author Ben Litchfield  */
end_comment

begin_class
specifier|abstract
class|class
name|PDAbstractContentStream
implements|implements
name|Closeable
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PDAbstractContentStream
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|PDDocument
name|document
decl_stmt|;
comment|// may be null
specifier|protected
specifier|final
name|OutputStream
name|outputStream
decl_stmt|;
specifier|protected
specifier|final
name|PDResources
name|resources
decl_stmt|;
specifier|protected
name|boolean
name|inTextMode
init|=
literal|false
decl_stmt|;
specifier|protected
specifier|final
name|Deque
argument_list|<
name|PDFont
argument_list|>
name|fontStack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Deque
argument_list|<
name|PDColorSpace
argument_list|>
name|nonStrokingColorSpaceStack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Deque
argument_list|<
name|PDColorSpace
argument_list|>
name|strokingColorSpaceStack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
comment|// number format
specifier|private
specifier|final
name|NumberFormat
name|formatDecimal
init|=
name|NumberFormat
operator|.
name|getNumberInstance
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|formatBuffer
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|PDType0Font
argument_list|,
name|GsubWorker
argument_list|>
name|gsubWorkers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|GsubWorkerFactory
name|gsubWorkerFactory
init|=
operator|new
name|GsubWorkerFactory
argument_list|()
decl_stmt|;
comment|/**      * Create a new appearance stream.      *      * @param document may be null      * @param outputStream The appearances output stream to write to.      * @param resources The resources to use      */
name|PDAbstractContentStream
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|OutputStream
name|outputStream
parameter_list|,
name|PDResources
name|resources
parameter_list|)
block|{
name|this
operator|.
name|document
operator|=
name|document
expr_stmt|;
name|this
operator|.
name|outputStream
operator|=
name|outputStream
expr_stmt|;
name|this
operator|.
name|resources
operator|=
name|resources
expr_stmt|;
name|formatDecimal
operator|.
name|setMaximumFractionDigits
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|formatDecimal
operator|.
name|setGroupingUsed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the maximum number of digits allowed for fractional numbers.      *       * @see NumberFormat#setMaximumFractionDigits(int)      * @param fractionDigitsNumber      */
specifier|protected
name|void
name|setMaximumFractionDigits
parameter_list|(
name|int
name|fractionDigitsNumber
parameter_list|)
block|{
name|formatDecimal
operator|.
name|setMaximumFractionDigits
argument_list|(
name|fractionDigitsNumber
argument_list|)
expr_stmt|;
block|}
comment|/**      * Begin some text operations.      *      * @throws IOException If there is an error writing to the stream or if you attempt to      *         nest beginText calls.      * @throws IllegalStateException If the method was not allowed to be called at this time.      */
specifier|public
name|void
name|beginText
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: Nested beginText() calls are not allowed."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|BEGIN_TEXT
argument_list|)
expr_stmt|;
name|inTextMode
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * End some text operations.      *      * @throws IOException If there is an error writing to the stream or if you attempt to      *         nest endText calls.      * @throws IllegalStateException If the method was not allowed to be called at this time.      */
specifier|public
name|void
name|endText
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: You must call beginText() before calling endText."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|END_TEXT
argument_list|)
expr_stmt|;
name|inTextMode
operator|=
literal|false
expr_stmt|;
block|}
comment|/**      * Set the font and font size to draw text with.      *      * @param font The font to use.      * @param fontSize The font size to draw the text.      * @throws IOException If there is an error writing the font information.      */
specifier|public
name|void
name|setFont
parameter_list|(
name|PDFont
name|font
parameter_list|,
name|float
name|fontSize
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fontStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fontStack
operator|.
name|add
argument_list|(
name|font
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fontStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|fontStack
operator|.
name|push
argument_list|(
name|font
argument_list|)
expr_stmt|;
block|}
comment|// keep track of fonts which are configured for subsetting
if|if
condition|(
name|font
operator|.
name|willBeSubset
argument_list|()
condition|)
block|{
if|if
condition|(
name|document
operator|!=
literal|null
condition|)
block|{
name|document
operator|.
name|getFontsToSubset
argument_list|()
operator|.
name|add
argument_list|(
name|font
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"attempting to use subset font "
operator|+
name|font
operator|.
name|getName
argument_list|()
operator|+
literal|" without proper context"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// complex text layout
if|if
condition|(
name|font
operator|instanceof
name|PDType0Font
condition|)
block|{
name|PDType0Font
name|pdType0Font
init|=
operator|(
name|PDType0Font
operator|)
name|font
decl_stmt|;
name|GsubData
name|gsubData
init|=
name|pdType0Font
operator|.
name|getGsubData
argument_list|()
decl_stmt|;
if|if
condition|(
name|gsubData
operator|!=
name|GsubData
operator|.
name|NO_DATA_FOUND
condition|)
block|{
name|GsubWorker
name|gsubWorker
init|=
name|gsubWorkerFactory
operator|.
name|getGsubWorker
argument_list|(
name|pdType0Font
operator|.
name|getCmapLookup
argument_list|()
argument_list|,
name|gsubData
argument_list|)
decl_stmt|;
name|gsubWorkers
operator|.
name|put
argument_list|(
operator|(
name|PDType0Font
operator|)
name|font
argument_list|,
name|gsubWorker
argument_list|)
expr_stmt|;
block|}
block|}
name|writeOperand
argument_list|(
name|resources
operator|.
name|add
argument_list|(
name|font
argument_list|)
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|fontSize
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_FONT_AND_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Shows the given text at the location specified by the current text matrix with the given      * interspersed positioning. This allows the user to efficiently position each glyph or sequence      * of glyphs.      *      * @param textWithPositioningArray An array consisting of String and Float types. Each String is      * output to the page using the current text matrix. Using the default coordinate system, each      * interspersed number adjusts the current text matrix by translating to the left or down for      * horizontal and vertical text respectively. The number is expressed in thousands of a text      * space unit, and may be negative.      *      * @throws IOException if an io exception occurs.      */
specifier|public
name|void
name|showTextWithPositioning
parameter_list|(
name|Object
index|[]
name|textWithPositioningArray
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
name|obj
range|:
name|textWithPositioningArray
control|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|String
condition|)
block|{
name|showTextInternal
argument_list|(
operator|(
name|String
operator|)
name|obj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Float
condition|)
block|{
name|writeOperand
argument_list|(
operator|(
name|Float
operator|)
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Argument must consist of array of Float and String types"
argument_list|)
throw|;
block|}
block|}
name|write
argument_list|(
literal|"] "
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SHOW_TEXT_ADJUSTED
argument_list|)
expr_stmt|;
block|}
comment|/**      * Shows the given text at the location specified by the current text matrix.      *      * @param text The Unicode text to show.      * @throws IOException If an io exception occurs.      * @throws IllegalArgumentException if a character isn't supported by the current font      */
specifier|public
name|void
name|showText
parameter_list|(
name|String
name|text
parameter_list|)
throws|throws
name|IOException
block|{
name|showTextInternal
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SHOW_TEXT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Outputs a string using the correct encoding and subsetting as required.      *      * @param text The Unicode text to show.      *       * @throws IOException If an io exception occurs.      */
specifier|protected
name|void
name|showTextInternal
parameter_list|(
name|String
name|text
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Must call beginText() before showText()"
argument_list|)
throw|;
block|}
if|if
condition|(
name|fontStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Must call setFont() before showText()"
argument_list|)
throw|;
block|}
name|PDFont
name|font
init|=
name|fontStack
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// complex text layout
name|byte
index|[]
name|encodedText
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|font
operator|instanceof
name|PDType0Font
condition|)
block|{
name|GsubWorker
name|gsubWorker
init|=
name|gsubWorkers
operator|.
name|get
argument_list|(
name|font
argument_list|)
decl_stmt|;
if|if
condition|(
name|gsubWorker
operator|!=
literal|null
condition|)
block|{
name|PDType0Font
name|pdType0Font
init|=
operator|(
name|PDType0Font
operator|)
name|font
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|glyphIds
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|encodedText
operator|=
name|encodeForGsub
argument_list|(
name|gsubWorker
argument_list|,
name|glyphIds
argument_list|,
name|pdType0Font
argument_list|,
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdType0Font
operator|.
name|willBeSubset
argument_list|()
condition|)
block|{
name|pdType0Font
operator|.
name|addGlyphsToSubset
argument_list|(
name|glyphIds
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|encodedText
operator|==
literal|null
condition|)
block|{
name|encodedText
operator|=
name|font
operator|.
name|encode
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
comment|// Unicode code points to keep when subsetting
if|if
condition|(
name|font
operator|.
name|willBeSubset
argument_list|()
condition|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
name|int
name|codePoint
init|=
name|text
operator|.
name|codePointAt
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|font
operator|.
name|addToSubset
argument_list|(
name|codePoint
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|Character
operator|.
name|charCount
argument_list|(
name|codePoint
argument_list|)
expr_stmt|;
block|}
block|}
name|COSWriter
operator|.
name|writeString
argument_list|(
name|encodedText
argument_list|,
name|outputStream
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the text leading.      *      * @param leading The leading in unscaled text units.      * @throws IOException If there is an error writing to the stream.      */
specifier|public
name|void
name|setLeading
parameter_list|(
name|float
name|leading
parameter_list|)
throws|throws
name|IOException
block|{
name|writeOperand
argument_list|(
name|leading
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_TEXT_LEADING
argument_list|)
expr_stmt|;
block|}
comment|/**      * Move to the start of the next line of text. Requires the leading (see {@link #setLeading})      * to have been set.      *      * @throws IOException If there is an error writing to the stream.      */
specifier|public
name|void
name|newLine
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Must call beginText() before newLine()"
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|NEXT_LINE
argument_list|)
expr_stmt|;
block|}
comment|/**      * The Td operator.      * Move to the start of the next line, offset from the start of the current line by (tx, ty).      *      * @param tx The x translation.      * @param ty The y translation.      * @throws IOException If there is an error writing to the stream.      * @throws IllegalStateException If the method was not allowed to be called at this time.      */
specifier|public
name|void
name|newLineAtOffset
parameter_list|(
name|float
name|tx
parameter_list|,
name|float
name|ty
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: must call beginText() before newLineAtOffset()"
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|ty
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|MOVE_TEXT
argument_list|)
expr_stmt|;
block|}
comment|/**      * The Tm operator. Sets the text matrix to the given values.      * A current text matrix will be replaced with the new one.      *      * @param matrix the transformation matrix      * @throws IOException If there is an error writing to the stream.      * @throws IllegalStateException If the method was not allowed to be called at this time.      */
specifier|public
name|void
name|setTextMatrix
parameter_list|(
name|Matrix
name|matrix
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: must call beginText() before setTextMatrix"
argument_list|)
throw|;
block|}
name|writeAffineTransform
argument_list|(
name|matrix
operator|.
name|createAffineTransform
argument_list|()
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_MATRIX
argument_list|)
expr_stmt|;
block|}
comment|/**      * Draw an image at the x,y coordinates, with the default size of the image.      *      * @param image The image to draw.      * @param x The x-coordinate to draw the image.      * @param y The y-coordinate to draw the image.      *      * @throws IOException If there is an error writing to the stream.      */
specifier|public
name|void
name|drawImage
parameter_list|(
name|PDImageXObject
name|image
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
throws|throws
name|IOException
block|{
name|drawImage
argument_list|(
name|image
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|image
operator|.
name|getWidth
argument_list|()
argument_list|,
name|image
operator|.
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Draw an image at the x,y coordinates, with the given size.      *      * @param image The image to draw.      * @param x The x-coordinate to draw the image.      * @param y The y-coordinate to draw the image.      * @param width The width to draw the image.      * @param height The height to draw the image.      *      * @throws IOException If there is an error writing to the stream.      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|drawImage
parameter_list|(
name|PDImageXObject
name|image
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|width
parameter_list|,
name|float
name|height
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: drawImage is not allowed within a text block."
argument_list|)
throw|;
block|}
name|saveGraphicsState
argument_list|()
expr_stmt|;
name|AffineTransform
name|transform
init|=
operator|new
name|AffineTransform
argument_list|(
name|width
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|height
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|transform
argument_list|(
operator|new
name|Matrix
argument_list|(
name|transform
argument_list|)
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|resources
operator|.
name|add
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|DRAW_OBJECT
argument_list|)
expr_stmt|;
name|restoreGraphicsState
argument_list|()
expr_stmt|;
block|}
comment|/**      * Draw an image at the origin with the given transformation matrix.      *      * @param image The image to draw.      * @param matrix The transformation matrix to apply to the image.      *      * @throws IOException If there is an error writing to the stream.      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|drawImage
parameter_list|(
name|PDImageXObject
name|image
parameter_list|,
name|Matrix
name|matrix
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: drawImage is not allowed within a text block."
argument_list|)
throw|;
block|}
name|saveGraphicsState
argument_list|()
expr_stmt|;
name|AffineTransform
name|transform
init|=
name|matrix
operator|.
name|createAffineTransform
argument_list|()
decl_stmt|;
name|transform
argument_list|(
operator|new
name|Matrix
argument_list|(
name|transform
argument_list|)
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|resources
operator|.
name|add
argument_list|(
name|image
argument_list|)
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|DRAW_OBJECT
argument_list|)
expr_stmt|;
name|restoreGraphicsState
argument_list|()
expr_stmt|;
block|}
comment|/**      * Draw an inline image at the x,y coordinates, with the default size of the image.      *      * @param inlineImage The inline image to draw.      * @param x The x-coordinate to draw the inline image.      * @param y The y-coordinate to draw the inline image.      *      * @throws IOException If there is an error writing to the stream.      */
specifier|public
name|void
name|drawImage
parameter_list|(
name|PDInlineImage
name|inlineImage
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
throws|throws
name|IOException
block|{
name|drawImage
argument_list|(
name|inlineImage
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|inlineImage
operator|.
name|getWidth
argument_list|()
argument_list|,
name|inlineImage
operator|.
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Draw an inline image at the x,y coordinates and a certain width and height.      *      * @param inlineImage The inline image to draw.      * @param x The x-coordinate to draw the inline image.      * @param y The y-coordinate to draw the inline image.      * @param width The width of the inline image to draw.      * @param height The height of the inline image to draw.      *      * @throws IOException If there is an error writing to the stream.      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|drawImage
parameter_list|(
name|PDInlineImage
name|inlineImage
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|width
parameter_list|,
name|float
name|height
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: drawImage is not allowed within a text block."
argument_list|)
throw|;
block|}
name|saveGraphicsState
argument_list|()
expr_stmt|;
name|transform
argument_list|(
operator|new
name|Matrix
argument_list|(
name|width
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|height
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
comment|// create the image dictionary
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|OperatorName
operator|.
name|BEGIN_INLINE_IMAGE
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n /W "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|inlineImage
operator|.
name|getWidth
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n /H "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|inlineImage
operator|.
name|getHeight
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n /CS "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|inlineImage
operator|.
name|getColorSpace
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlineImage
operator|.
name|getDecode
argument_list|()
operator|!=
literal|null
operator|&&
name|inlineImage
operator|.
name|getDecode
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n /D "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|COSBase
name|base
range|:
name|inlineImage
operator|.
name|getDecode
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
operator|(
name|COSNumber
operator|)
name|base
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inlineImage
operator|.
name|isStencil
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n /IM true"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\n /BPC "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|inlineImage
operator|.
name|getBitsPerComponent
argument_list|()
argument_list|)
expr_stmt|;
comment|// image dictionary
name|write
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|writeLine
argument_list|()
expr_stmt|;
comment|// binary data
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|BEGIN_INLINE_IMAGE_DATA
argument_list|)
expr_stmt|;
name|writeBytes
argument_list|(
name|inlineImage
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
name|writeLine
argument_list|()
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|END_INLINE_IMAGE
argument_list|)
expr_stmt|;
name|restoreGraphicsState
argument_list|()
expr_stmt|;
block|}
comment|/**      * Draws the given Form XObject at the current location.      *      * @param form Form XObject      * @throws IOException if the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|drawForm
parameter_list|(
name|PDFormXObject
name|form
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: drawForm is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|resources
operator|.
name|add
argument_list|(
name|form
argument_list|)
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|DRAW_OBJECT
argument_list|)
expr_stmt|;
block|}
comment|/**      * The cm operator. Concatenates the given matrix with the CTM.      *      * @param matrix the transformation matrix      * @throws IOException If there is an error writing to the stream.      */
specifier|public
name|void
name|transform
parameter_list|(
name|Matrix
name|matrix
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: Modifying the current transformation matrix is not allowed within text objects."
argument_list|)
throw|;
block|}
name|writeAffineTransform
argument_list|(
name|matrix
operator|.
name|createAffineTransform
argument_list|()
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|CONCAT
argument_list|)
expr_stmt|;
block|}
comment|/**      * q operator. Saves the current graphics state.      * @throws IOException If an error occurs while writing to the stream.      */
specifier|public
name|void
name|saveGraphicsState
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: Saving the graphics state is not allowed within text objects."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fontStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fontStack
operator|.
name|push
argument_list|(
name|fontStack
operator|.
name|peek
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strokingColorSpaceStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|strokingColorSpaceStack
operator|.
name|push
argument_list|(
name|strokingColorSpaceStack
operator|.
name|peek
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nonStrokingColorSpaceStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|nonStrokingColorSpaceStack
operator|.
name|push
argument_list|(
name|nonStrokingColorSpaceStack
operator|.
name|peek
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SAVE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Q operator. Restores the current graphics state.      * @throws IOException If an error occurs while writing to the stream.      */
specifier|public
name|void
name|restoreGraphicsState
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: Restoring the graphics state is not allowed within text objects."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fontStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fontStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strokingColorSpaceStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|strokingColorSpaceStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nonStrokingColorSpaceStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|nonStrokingColorSpaceStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|RESTORE
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|COSName
name|getName
parameter_list|(
name|PDColorSpace
name|colorSpace
parameter_list|)
block|{
if|if
condition|(
name|colorSpace
operator|instanceof
name|PDDeviceGray
operator|||
name|colorSpace
operator|instanceof
name|PDDeviceRGB
operator|||
name|colorSpace
operator|instanceof
name|PDDeviceCMYK
condition|)
block|{
return|return
name|COSName
operator|.
name|getPDFName
argument_list|(
name|colorSpace
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|resources
operator|.
name|add
argument_list|(
name|colorSpace
argument_list|)
return|;
block|}
block|}
comment|/**      * Sets the stroking color and, if necessary, the stroking color space.      *      * @param color Color in a specific color space.      * @throws IOException If an IO error occurs while writing to the stream.      */
specifier|public
name|void
name|setStrokingColor
parameter_list|(
name|PDColor
name|color
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|strokingColorSpaceStack
operator|.
name|isEmpty
argument_list|()
operator|||
name|strokingColorSpaceStack
operator|.
name|peek
argument_list|()
operator|!=
name|color
operator|.
name|getColorSpace
argument_list|()
condition|)
block|{
name|writeOperand
argument_list|(
name|getName
argument_list|(
name|color
operator|.
name|getColorSpace
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|STROKING_COLORSPACE
argument_list|)
expr_stmt|;
name|setStrokingColorSpaceStack
argument_list|(
name|color
operator|.
name|getColorSpace
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|float
name|value
range|:
name|color
operator|.
name|getComponents
argument_list|()
control|)
block|{
name|writeOperand
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|color
operator|.
name|getColorSpace
argument_list|()
operator|instanceof
name|PDPattern
condition|)
block|{
name|writeOperand
argument_list|(
name|color
operator|.
name|getPatternName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|color
operator|.
name|getColorSpace
argument_list|()
operator|instanceof
name|PDPattern
operator|||
name|color
operator|.
name|getColorSpace
argument_list|()
operator|instanceof
name|PDSeparation
operator|||
name|color
operator|.
name|getColorSpace
argument_list|()
operator|instanceof
name|PDDeviceN
operator|||
name|color
operator|.
name|getColorSpace
argument_list|()
operator|instanceof
name|PDICCBased
condition|)
block|{
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|STROKING_COLOR_N
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|STROKING_COLOR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Set the stroking color using an AWT color. Conversion uses the default sRGB color space.      *      * @param color The color to set.      * @throws IOException If an IO error occurs while writing to the stream.      */
specifier|public
name|void
name|setStrokingColor
parameter_list|(
name|Color
name|color
parameter_list|)
throws|throws
name|IOException
block|{
name|float
index|[]
name|components
init|=
operator|new
name|float
index|[]
block|{
name|color
operator|.
name|getRed
argument_list|()
operator|/
literal|255f
block|,
name|color
operator|.
name|getGreen
argument_list|()
operator|/
literal|255f
block|,
name|color
operator|.
name|getBlue
argument_list|()
operator|/
literal|255f
block|}
decl_stmt|;
name|PDColor
name|pdColor
init|=
operator|new
name|PDColor
argument_list|(
name|components
argument_list|,
name|PDDeviceRGB
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|setStrokingColor
argument_list|(
name|pdColor
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the stroking color in the DeviceRGB color space. Range is 0..255.      *      * @param r The red value      * @param g The green value.      * @param b The blue value.      * @throws IOException If an IO error occurs while writing to the stream.      * @throws IllegalArgumentException If the parameters are invalid.      */
specifier|public
name|void
name|setStrokingColor
parameter_list|(
name|int
name|r
parameter_list|,
name|int
name|g
parameter_list|,
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isOutside255Interval
argument_list|(
name|r
argument_list|)
operator|||
name|isOutside255Interval
argument_list|(
name|g
argument_list|)
operator|||
name|isOutside255Interval
argument_list|(
name|b
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameters must be within 0..255, but are "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"(%d,%d,%d)"
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|r
operator|/
literal|255f
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|g
operator|/
literal|255f
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|b
operator|/
literal|255f
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|STROKING_COLOR_RGB
argument_list|)
expr_stmt|;
name|setStrokingColorSpaceStack
argument_list|(
name|PDDeviceRGB
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the stroking color in the DeviceCMYK color space. Range is 0..1      *      * @param c The cyan value.      * @param m The magenta value.      * @param y The yellow value.      * @param k The black value.      * @throws IOException If an IO error occurs while writing to the stream.      * @throws IllegalArgumentException If the parameters are invalid.      */
specifier|public
name|void
name|setStrokingColor
parameter_list|(
name|float
name|c
parameter_list|,
name|float
name|m
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|k
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isOutsideOneInterval
argument_list|(
name|c
argument_list|)
operator|||
name|isOutsideOneInterval
argument_list|(
name|m
argument_list|)
operator|||
name|isOutsideOneInterval
argument_list|(
name|y
argument_list|)
operator|||
name|isOutsideOneInterval
argument_list|(
name|k
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameters must be within 0..1, but are "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"(%.2f,%.2f,%.2f,%.2f)"
argument_list|,
name|c
argument_list|,
name|m
argument_list|,
name|y
argument_list|,
name|k
argument_list|)
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|STROKING_COLOR_CMYK
argument_list|)
expr_stmt|;
name|setStrokingColorSpaceStack
argument_list|(
name|PDDeviceCMYK
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the stroking color in the DeviceGray color space. Range is 0..1.      *      * @param g The gray value.      * @throws IOException If an IO error occurs while writing to the stream.      * @throws IllegalArgumentException If the parameter is invalid.      */
specifier|public
name|void
name|setStrokingColor
parameter_list|(
name|float
name|g
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isOutsideOneInterval
argument_list|(
name|g
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter must be within 0..1, but is "
operator|+
name|g
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|STROKING_COLOR_GRAY
argument_list|)
expr_stmt|;
name|setStrokingColorSpaceStack
argument_list|(
name|PDDeviceGray
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the non-stroking color and, if necessary, the non-stroking color space.      *      * @param color Color in a specific color space.      * @throws IOException If an IO error occurs while writing to the stream.      */
specifier|public
name|void
name|setNonStrokingColor
parameter_list|(
name|PDColor
name|color
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|nonStrokingColorSpaceStack
operator|.
name|isEmpty
argument_list|()
operator|||
name|nonStrokingColorSpaceStack
operator|.
name|peek
argument_list|()
operator|!=
name|color
operator|.
name|getColorSpace
argument_list|()
condition|)
block|{
name|writeOperand
argument_list|(
name|getName
argument_list|(
name|color
operator|.
name|getColorSpace
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|NON_STROKING_COLORSPACE
argument_list|)
expr_stmt|;
name|setNonStrokingColorSpaceStack
argument_list|(
name|color
operator|.
name|getColorSpace
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|float
name|value
range|:
name|color
operator|.
name|getComponents
argument_list|()
control|)
block|{
name|writeOperand
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|color
operator|.
name|getColorSpace
argument_list|()
operator|instanceof
name|PDPattern
condition|)
block|{
name|writeOperand
argument_list|(
name|color
operator|.
name|getPatternName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|color
operator|.
name|getColorSpace
argument_list|()
operator|instanceof
name|PDPattern
operator|||
name|color
operator|.
name|getColorSpace
argument_list|()
operator|instanceof
name|PDSeparation
operator|||
name|color
operator|.
name|getColorSpace
argument_list|()
operator|instanceof
name|PDDeviceN
operator|||
name|color
operator|.
name|getColorSpace
argument_list|()
operator|instanceof
name|PDICCBased
condition|)
block|{
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|NON_STROKING_COLOR_N
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|NON_STROKING_COLOR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Set the non-stroking color using an AWT color. Conversion uses the default sRGB color space.      *      * @param color The color to set.      * @throws IOException If an IO error occurs while writing to the stream.      */
specifier|public
name|void
name|setNonStrokingColor
parameter_list|(
name|Color
name|color
parameter_list|)
throws|throws
name|IOException
block|{
name|float
index|[]
name|components
init|=
operator|new
name|float
index|[]
block|{
name|color
operator|.
name|getRed
argument_list|()
operator|/
literal|255f
block|,
name|color
operator|.
name|getGreen
argument_list|()
operator|/
literal|255f
block|,
name|color
operator|.
name|getBlue
argument_list|()
operator|/
literal|255f
block|}
decl_stmt|;
name|PDColor
name|pdColor
init|=
operator|new
name|PDColor
argument_list|(
name|components
argument_list|,
name|PDDeviceRGB
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|setNonStrokingColor
argument_list|(
name|pdColor
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the non-stroking color in the DeviceRGB color space. Range is 0..255.      *      * @param r The red value.      * @param g The green value.      * @param b The blue value.      * @throws IOException If an IO error occurs while writing to the stream.      * @throws IllegalArgumentException If the parameters are invalid.      */
specifier|public
name|void
name|setNonStrokingColor
parameter_list|(
name|int
name|r
parameter_list|,
name|int
name|g
parameter_list|,
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isOutside255Interval
argument_list|(
name|r
argument_list|)
operator|||
name|isOutside255Interval
argument_list|(
name|g
argument_list|)
operator|||
name|isOutside255Interval
argument_list|(
name|b
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameters must be within 0..255, but are "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"(%d,%d,%d)"
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|r
operator|/
literal|255f
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|g
operator|/
literal|255f
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|b
operator|/
literal|255f
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|NON_STROKING_RGB
argument_list|)
expr_stmt|;
name|setNonStrokingColorSpaceStack
argument_list|(
name|PDDeviceRGB
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the non-stroking color in the DeviceCMYK color space. Range is 0..255.      *      * @param c The cyan value.      * @param m The magenta value.      * @param y The yellow value.      * @param k The black value.      * @throws IOException If an IO error occurs while writing to the stream.      * @throws IllegalArgumentException If the parameters are invalid.      */
specifier|public
name|void
name|setNonStrokingColor
parameter_list|(
name|int
name|c
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|k
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isOutside255Interval
argument_list|(
name|c
argument_list|)
operator|||
name|isOutside255Interval
argument_list|(
name|m
argument_list|)
operator|||
name|isOutside255Interval
argument_list|(
name|y
argument_list|)
operator|||
name|isOutside255Interval
argument_list|(
name|k
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameters must be within 0..255, but are "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"(%d,%d,%d,%d)"
argument_list|,
name|c
argument_list|,
name|m
argument_list|,
name|y
argument_list|,
name|k
argument_list|)
argument_list|)
throw|;
block|}
name|setNonStrokingColor
argument_list|(
name|c
operator|/
literal|255f
argument_list|,
name|m
operator|/
literal|255f
argument_list|,
name|y
operator|/
literal|255f
argument_list|,
name|k
operator|/
literal|255f
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the non-stroking color in the DeviceCMYK color space. Range is 0..1.      *      * @param c The cyan value.      * @param m The magenta value.      * @param y The yellow value.      * @param k The black value.      * @throws IOException If an IO error occurs while writing to the stream.      */
specifier|public
name|void
name|setNonStrokingColor
parameter_list|(
name|float
name|c
parameter_list|,
name|float
name|m
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|k
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isOutsideOneInterval
argument_list|(
name|c
argument_list|)
operator|||
name|isOutsideOneInterval
argument_list|(
name|m
argument_list|)
operator|||
name|isOutsideOneInterval
argument_list|(
name|y
argument_list|)
operator|||
name|isOutsideOneInterval
argument_list|(
name|k
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameters must be within 0..1, but are "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"(%.2f,%.2f,%.2f,%.2f)"
argument_list|,
name|c
argument_list|,
name|m
argument_list|,
name|y
argument_list|,
name|k
argument_list|)
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|NON_STROKING_CMYK
argument_list|)
expr_stmt|;
name|setNonStrokingColorSpaceStack
argument_list|(
name|PDDeviceCMYK
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the non-stroking color in the DeviceGray color space. Range is 0..255.      *      * @param g The gray value.      * @throws IOException If an IO error occurs while writing to the stream.      * @throws IllegalArgumentException If the parameter is invalid.      */
specifier|public
name|void
name|setNonStrokingColor
parameter_list|(
name|int
name|g
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isOutside255Interval
argument_list|(
name|g
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter must be within 0..255, but is "
operator|+
name|g
argument_list|)
throw|;
block|}
name|setNonStrokingColor
argument_list|(
name|g
operator|/
literal|255f
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the non-stroking color in the DeviceGray color space. Range is 0..1.      *      * @param g The gray value.      * @throws IOException If an IO error occurs while writing to the stream.      * @throws IllegalArgumentException If the parameter is invalid.      */
specifier|public
name|void
name|setNonStrokingColor
parameter_list|(
name|float
name|g
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isOutsideOneInterval
argument_list|(
name|g
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter must be within 0..1, but is "
operator|+
name|g
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|NON_STROKING_GRAY
argument_list|)
expr_stmt|;
name|setNonStrokingColorSpaceStack
argument_list|(
name|PDDeviceGray
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a rectangle to the current path.      *      * @param x The lower left x coordinate.      * @param y The lower left y coordinate.      * @param width The width of the rectangle.      * @param height The height of the rectangle.      * @throws IOException If the content stream could not be written.      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|addRect
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|width
parameter_list|,
name|float
name|height
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: addRect is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|height
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|APPEND_RECT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Append a cubic Bézier curve to the current path. The curve extends from the current point to      * the point (x3, y3), using (x1, y1) and (x2, y2) as the Bézier control points.      *      * @param x1 x coordinate of the point 1      * @param y1 y coordinate of the point 1      * @param x2 x coordinate of the point 2      * @param y2 y coordinate of the point 2      * @param x3 x coordinate of the point 3      * @param y3 y coordinate of the point 3      * @throws IOException If the content stream could not be written.      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|curveTo
parameter_list|(
name|float
name|x1
parameter_list|,
name|float
name|y1
parameter_list|,
name|float
name|x2
parameter_list|,
name|float
name|y2
parameter_list|,
name|float
name|x3
parameter_list|,
name|float
name|y3
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: curveTo is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|x2
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y2
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|x3
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y3
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|CURVE_TO
argument_list|)
expr_stmt|;
block|}
comment|/**      * Append a cubic Bézier curve to the current path. The curve extends from the current point to      * the point (x3, y3), using the current point and (x2, y2) as the Bézier control points.      *      * @param x2 x coordinate of the point 2      * @param y2 y coordinate of the point 2      * @param x3 x coordinate of the point 3      * @param y3 y coordinate of the point 3      * @throws IllegalStateException If the method was called within a text block.      * @throws IOException If the content stream could not be written.      */
specifier|public
name|void
name|curveTo2
parameter_list|(
name|float
name|x2
parameter_list|,
name|float
name|y2
parameter_list|,
name|float
name|x3
parameter_list|,
name|float
name|y3
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: curveTo2 is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|x2
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y2
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|x3
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y3
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|CURVE_TO_REPLICATE_INITIAL_POINT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Append a cubic Bézier curve to the current path. The curve extends from the current point to      * the point (x3, y3), using (x1, y1) and (x3, y3) as the Bézier control points.      *      * @param x1 x coordinate of the point 1      * @param y1 y coordinate of the point 1      * @param x3 x coordinate of the point 3      * @param y3 y coordinate of the point 3      * @throws IOException If the content stream could not be written.      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|curveTo1
parameter_list|(
name|float
name|x1
parameter_list|,
name|float
name|y1
parameter_list|,
name|float
name|x3
parameter_list|,
name|float
name|y3
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: curveTo1 is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|x3
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y3
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|CURVE_TO_REPLICATE_FINAL_POINT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Move the current position to the given coordinates.      *      * @param x The x coordinate.      * @param y The y coordinate.      * @throws IOException If the content stream could not be written.      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|moveTo
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: moveTo is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|MOVE_TO
argument_list|)
expr_stmt|;
block|}
comment|/**      * Draw a line from the current position to the given coordinates.      *      * @param x The x coordinate.      * @param y The y coordinate.      * @throws IOException If the content stream could not be written.      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|lineTo
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: lineTo is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|LINE_TO
argument_list|)
expr_stmt|;
block|}
comment|/**      * Stroke the path.      *       * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|stroke
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: stroke is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|STROKE_PATH
argument_list|)
expr_stmt|;
block|}
comment|/**      * Close and stroke the path.      *       * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|closeAndStroke
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: closeAndStroke is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|CLOSE_AND_STROKE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Fills the path using the nonzero winding number rule.      *      * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|fill
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: fill is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|FILL_NON_ZERO
argument_list|)
expr_stmt|;
block|}
comment|/**      * Fills the path using the even-odd winding rule.      *      * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|fillEvenOdd
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: fillEvenOdd is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|FILL_EVEN_ODD
argument_list|)
expr_stmt|;
block|}
comment|/**      * Fill and then stroke the path, using the nonzero winding number rule to determine the region      * to fill. This shall produce the same result as constructing two identical path objects,      * painting the first with {@link #fill() } and the second with {@link #stroke() }.      *      * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|fillAndStroke
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: fillAndStroke is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|FILL_NON_ZERO_AND_STROKE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Fill and then stroke the path, using the even-odd rule to determine the region to      * fill. This shall produce the same result as constructing two identical path objects, painting      * the first with {@link #fillEvenOdd() } and the second with {@link #stroke() }.      *      * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|fillAndStrokeEvenOdd
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: fillAndStrokeEvenOdd is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|FILL_EVEN_ODD_AND_STROKE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Close, fill, and then stroke the path, using the nonzero winding number rule to determine the      * region to fill. This shall have the same effect as the sequence {@link #closePath() }      * and then {@link #fillAndStroke() }.      *      * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|closeAndFillAndStroke
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: closeAndFillAndStroke is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|CLOSE_FILL_NON_ZERO_AND_STROKE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Close, fill, and then stroke the path, using the even-odd rule to determine the region to      * fill. This shall have the same effect as the sequence {@link #closePath() }      * and then {@link #fillAndStrokeEvenOdd() }.      *      * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|closeAndFillAndStrokeEvenOdd
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: closeAndFillAndStrokeEvenOdd is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|CLOSE_FILL_EVEN_ODD_AND_STROKE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Fills the clipping area with the given shading.      *      * @param shading Shading resource      * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|shadingFill
parameter_list|(
name|PDShading
name|shading
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: shadingFill is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|resources
operator|.
name|add
argument_list|(
name|shading
argument_list|)
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SHADING_FILL
argument_list|)
expr_stmt|;
block|}
comment|/**      * Closes the current subpath.      *      * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|closePath
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: closePath is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|CLOSE_PATH
argument_list|)
expr_stmt|;
block|}
comment|/**      * Intersects the current clipping path with the current path, using the nonzero rule.      *      * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|clip
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: clip is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|CLIP_NON_ZERO
argument_list|)
expr_stmt|;
comment|// end path without filling or stroking
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|ENDPATH
argument_list|)
expr_stmt|;
block|}
comment|/**      * Intersects the current clipping path with the current path, using the even-odd rule.      *      * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|clipEvenOdd
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: clipEvenOdd is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|CLIP_EVEN_ODD
argument_list|)
expr_stmt|;
comment|// end path without filling or stroking
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|ENDPATH
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set line width to the given value.      *      * @param lineWidth The width which is used for drawing.      * @throws IOException If the content stream could not be written      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|setLineWidth
parameter_list|(
name|float
name|lineWidth
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: setLineWidth is not allowed within a text block."
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|lineWidth
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_LINE_WIDTH
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the line join style.      *      * @param lineJoinStyle 0 for miter join, 1 for round join, and 2 for bevel join.      * @throws IOException If the content stream could not be written.      * @throws IllegalStateException If the method was called within a text block.      * @throws IllegalArgumentException If the parameter is not a valid line join style.      */
specifier|public
name|void
name|setLineJoinStyle
parameter_list|(
name|int
name|lineJoinStyle
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: setLineJoinStyle is not allowed within a text block."
argument_list|)
throw|;
block|}
if|if
condition|(
name|lineJoinStyle
operator|>=
literal|0
operator|&&
name|lineJoinStyle
operator|<=
literal|2
condition|)
block|{
name|writeOperand
argument_list|(
name|lineJoinStyle
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_LINE_JOINSTYLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Error: unknown value for line join style"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Set the line cap style.      *      * @param lineCapStyle 0 for butt cap, 1 for round cap, and 2 for projecting square cap.      * @throws IOException If the content stream could not be written.      * @throws IllegalStateException If the method was called within a text block.      * @throws IllegalArgumentException If the parameter is not a valid line cap style.      */
specifier|public
name|void
name|setLineCapStyle
parameter_list|(
name|int
name|lineCapStyle
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: setLineCapStyle is not allowed within a text block."
argument_list|)
throw|;
block|}
if|if
condition|(
name|lineCapStyle
operator|>=
literal|0
operator|&&
name|lineCapStyle
operator|<=
literal|2
condition|)
block|{
name|writeOperand
argument_list|(
name|lineCapStyle
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_LINE_CAPSTYLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Error: unknown value for line cap style"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Set the line dash pattern.      *      * @param pattern The pattern array      * @param phase The phase of the pattern      * @throws IOException If the content stream could not be written.      * @throws IllegalStateException If the method was called within a text block.      */
specifier|public
name|void
name|setLineDashPattern
parameter_list|(
name|float
index|[]
name|pattern
parameter_list|,
name|float
name|phase
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: setLineDashPattern is not allowed within a text block."
argument_list|)
throw|;
block|}
name|write
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|float
name|value
range|:
name|pattern
control|)
block|{
name|writeOperand
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
literal|"] "
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|phase
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_LINE_DASHPATTERN
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the miter limit.      *      * @param miterLimit the new miter limit.      * @throws IOException If the content stream could not be written.      */
specifier|public
name|void
name|setMiterLimit
parameter_list|(
name|float
name|miterLimit
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error: setMiterLimit is not allowed within a text block."
argument_list|)
throw|;
block|}
if|if
condition|(
name|miterLimit
operator|<=
literal|0.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"A miter limit<= 0 is invalid and will not render in Acrobat Reader"
argument_list|)
throw|;
block|}
name|writeOperand
argument_list|(
name|miterLimit
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_LINE_MITERLIMIT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Begin a marked content sequence.      *      * @param tag the tag      * @throws IOException If the content stream could not be written      */
specifier|public
name|void
name|beginMarkedContent
parameter_list|(
name|COSName
name|tag
parameter_list|)
throws|throws
name|IOException
block|{
name|writeOperand
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|BEGIN_MARKED_CONTENT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Begin a marked content sequence with a reference to an entry in the page resources'      * Properties dictionary.      *      * @param tag the tag      * @param propertyList property list      * @throws IOException If the content stream could not be written      */
specifier|public
name|void
name|beginMarkedContent
parameter_list|(
name|COSName
name|tag
parameter_list|,
name|PDPropertyList
name|propertyList
parameter_list|)
throws|throws
name|IOException
block|{
name|writeOperand
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|writeOperand
argument_list|(
name|resources
operator|.
name|add
argument_list|(
name|propertyList
argument_list|)
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|BEGIN_MARKED_CONTENT_SEQ
argument_list|)
expr_stmt|;
block|}
comment|/**      * End a marked content sequence.      *      * @throws IOException If the content stream could not be written      */
specifier|public
name|void
name|endMarkedContent
parameter_list|()
throws|throws
name|IOException
block|{
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|END_MARKED_CONTENT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set an extended graphics state.      *       * @param state The extended graphics state.      * @throws IOException If the content stream could not be written.      */
specifier|public
name|void
name|setGraphicsStateParameters
parameter_list|(
name|PDExtendedGraphicsState
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|writeOperand
argument_list|(
name|resources
operator|.
name|add
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_GRAPHICS_STATE_PARAMS
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write a comment line.      *      * @param comment      * @throws IOException If the content stream could not be written.      * @throws IllegalArgumentException If the comment contains a newline. This is not allowed,      * because the next line could be ordinary PDF content.      */
specifier|public
name|void
name|addComment
parameter_list|(
name|String
name|comment
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|comment
operator|.
name|indexOf
argument_list|(
literal|'\n'
argument_list|)
operator|>=
literal|0
operator|||
name|comment
operator|.
name|indexOf
argument_list|(
literal|'\r'
argument_list|)
operator|>=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"comment should not include a newline"
argument_list|)
throw|;
block|}
name|outputStream
operator|.
name|write
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|write
argument_list|(
name|comment
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|write
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes a real number to the content stream.      * @param real      * @throws java.io.IOException      */
specifier|protected
name|void
name|writeOperand
parameter_list|(
name|float
name|real
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|byteCount
init|=
name|NumberFormatUtil
operator|.
name|formatFloatFast
argument_list|(
name|real
argument_list|,
name|formatDecimal
operator|.
name|getMaximumFractionDigits
argument_list|()
argument_list|,
name|formatBuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|byteCount
operator|==
operator|-
literal|1
condition|)
block|{
comment|//Fast formatting failed
name|write
argument_list|(
name|formatDecimal
operator|.
name|format
argument_list|(
name|real
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|formatBuffer
argument_list|,
literal|0
argument_list|,
name|byteCount
argument_list|)
expr_stmt|;
block|}
name|outputStream
operator|.
name|write
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes an integer number to the content stream.      * @param integer      * @throws java.io.IOException      */
specifier|protected
name|void
name|writeOperand
parameter_list|(
name|int
name|integer
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|formatDecimal
operator|.
name|format
argument_list|(
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|write
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes a COSName to the content stream.      * @param name      * @throws java.io.IOException      */
specifier|protected
name|void
name|writeOperand
parameter_list|(
name|COSName
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|name
operator|.
name|writePDF
argument_list|(
name|outputStream
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|write
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes a string to the content stream as ASCII.      * @param text      * @throws java.io.IOException      */
specifier|protected
name|void
name|writeOperator
parameter_list|(
name|String
name|text
parameter_list|)
throws|throws
name|IOException
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|text
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|write
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes a string to the content stream as ASCII.      * @param text      * @throws java.io.IOException      */
specifier|protected
name|void
name|write
parameter_list|(
name|String
name|text
parameter_list|)
throws|throws
name|IOException
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|text
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes a byte[] to the content stream.      * @param data      * @throws java.io.IOException      */
specifier|protected
name|void
name|write
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes a newline to the content stream as ASCII.      * @throws java.io.IOException      */
specifier|protected
name|void
name|writeLine
parameter_list|()
throws|throws
name|IOException
block|{
name|outputStream
operator|.
name|write
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes binary data to the content stream.      * @param data      * @throws java.io.IOException      */
specifier|protected
name|void
name|writeBytes
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes an AffineTransform to the content stream as an array.      */
specifier|private
name|void
name|writeAffineTransform
parameter_list|(
name|AffineTransform
name|transform
parameter_list|)
throws|throws
name|IOException
block|{
name|double
index|[]
name|values
init|=
operator|new
name|double
index|[
literal|6
index|]
decl_stmt|;
name|transform
operator|.
name|getMatrix
argument_list|(
name|values
argument_list|)
expr_stmt|;
for|for
control|(
name|double
name|v
range|:
name|values
control|)
block|{
name|writeOperand
argument_list|(
operator|(
name|float
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Close the content stream.  This must be called when you are done with this object.      *      * @throws IOException If the underlying stream has a problem being written to.      */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inTextMode
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"You did not call endText(), some viewers won't display your text"
argument_list|)
expr_stmt|;
block|}
name|outputStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|boolean
name|isOutside255Interval
parameter_list|(
name|int
name|val
parameter_list|)
block|{
return|return
name|val
argument_list|<
literal|0
operator|||
name|val
argument_list|>
literal|255
return|;
block|}
specifier|private
name|boolean
name|isOutsideOneInterval
parameter_list|(
name|double
name|val
parameter_list|)
block|{
return|return
name|val
argument_list|<
literal|0
operator|||
name|val
argument_list|>
literal|1
return|;
block|}
specifier|protected
name|void
name|setStrokingColorSpaceStack
parameter_list|(
name|PDColorSpace
name|colorSpace
parameter_list|)
block|{
if|if
condition|(
name|strokingColorSpaceStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|strokingColorSpaceStack
operator|.
name|add
argument_list|(
name|colorSpace
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strokingColorSpaceStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|strokingColorSpaceStack
operator|.
name|push
argument_list|(
name|colorSpace
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|setNonStrokingColorSpaceStack
parameter_list|(
name|PDColorSpace
name|colorSpace
parameter_list|)
block|{
if|if
condition|(
name|nonStrokingColorSpaceStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|nonStrokingColorSpaceStack
operator|.
name|add
argument_list|(
name|colorSpace
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonStrokingColorSpaceStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|nonStrokingColorSpaceStack
operator|.
name|push
argument_list|(
name|colorSpace
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Set the character spacing. The value shall be added to the horizontal or vertical component      * of the glyph's displacement, depending on the writing mode.      *      * @param spacing character spacing      * @throws IOException If the content stream could not be written.      */
specifier|public
name|void
name|setCharacterSpacing
parameter_list|(
name|float
name|spacing
parameter_list|)
throws|throws
name|IOException
block|{
name|writeOperand
argument_list|(
name|spacing
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_CHAR_SPACING
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the word spacing. The value shall be added to the horizontal or vertical component of the      * ASCII SPACE character, depending on the writing mode.      *<p>      * This will have an effect only with Type1 and TrueType fonts, not with Type0 fonts. The PDF      * specification tells why: "Word spacing shall be applied to every occurrence of the      * single-byte character code 32 in a string when using a simple font or a composite font that      * defines code 32 as a single-byte code. It shall not apply to occurrences of the byte value 32      * in multiple-byte codes."      *      * @param spacing word spacing      * @throws IOException If the content stream could not be written.      */
specifier|public
name|void
name|setWordSpacing
parameter_list|(
name|float
name|spacing
parameter_list|)
throws|throws
name|IOException
block|{
name|writeOperand
argument_list|(
name|spacing
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_WORD_SPACING
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the horizontal scaling to scale / 100.      *      * @param scale number specifying the percentage of the normal width. Default value: 100 (normal      * width).      * @throws IOException If the content stream could not be written.      */
specifier|public
name|void
name|setHorizontalScaling
parameter_list|(
name|float
name|scale
parameter_list|)
throws|throws
name|IOException
block|{
name|writeOperand
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_TEXT_HORIZONTAL_SCALING
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the text rendering mode. This determines whether showing text shall cause glyph outlines      * to be stroked, filled, used as a clipping boundary, or some combination of the three.      *      * @param rm The text rendering mode.      * @throws IOException If the content stream could not be written.      */
specifier|public
name|void
name|setRenderingMode
parameter_list|(
name|RenderingMode
name|rm
parameter_list|)
throws|throws
name|IOException
block|{
name|writeOperand
argument_list|(
name|rm
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_TEXT_RENDERINGMODE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the text rise value, i.e. move the baseline up or down. This is useful for drawing      * superscripts or subscripts.      *      * @param rise Specifies the distance, in unscaled text space units, to move the baseline up or      * down from its default location. 0 restores the default location.      * @throws IOException      */
specifier|public
name|void
name|setTextRise
parameter_list|(
name|float
name|rise
parameter_list|)
throws|throws
name|IOException
block|{
name|writeOperand
argument_list|(
name|rise
argument_list|)
expr_stmt|;
name|writeOperator
argument_list|(
name|OperatorName
operator|.
name|SET_TEXT_RISE
argument_list|)
expr_stmt|;
block|}
specifier|private
name|byte
index|[]
name|encodeForGsub
parameter_list|(
name|GsubWorker
name|gsubWorker
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|glyphIds
parameter_list|,
name|PDType0Font
name|font
parameter_list|,
name|String
name|text
parameter_list|)
throws|throws
name|IOException
block|{
name|Pattern
name|spaceRegex
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|;
comment|// break the entire chunk of text into words by splitting it with space
name|List
argument_list|<
name|String
argument_list|>
name|words
init|=
operator|new
name|CompoundCharacterTokenizer
argument_list|(
literal|"\\s"
argument_list|)
operator|.
name|tokenize
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|out
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|word
range|:
name|words
control|)
block|{
if|if
condition|(
name|spaceRegex
operator|.
name|matcher
argument_list|(
name|word
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|font
operator|.
name|encode
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|glyphIds
operator|.
name|addAll
argument_list|(
name|applyGSUBRules
argument_list|(
name|gsubWorker
argument_list|,
name|out
argument_list|,
name|font
argument_list|,
name|word
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|out
operator|.
name|toByteArray
argument_list|()
return|;
block|}
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|applyGSUBRules
parameter_list|(
name|GsubWorker
name|gsubWorker
parameter_list|,
name|ByteArrayOutputStream
name|out
parameter_list|,
name|PDType0Font
name|font
parameter_list|,
name|String
name|word
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|originalGlyphIds
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|CmapLookup
name|cmapLookup
init|=
name|font
operator|.
name|getCmapLookup
argument_list|()
decl_stmt|;
comment|// convert characters into glyphIds
for|for
control|(
name|char
name|unicodeChar
range|:
name|word
operator|.
name|toCharArray
argument_list|()
control|)
block|{
name|int
name|glyphId
init|=
name|cmapLookup
operator|.
name|getGlyphId
argument_list|(
name|unicodeChar
argument_list|)
decl_stmt|;
if|if
condition|(
name|glyphId
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"could not find the glyphId for the character: "
operator|+
name|unicodeChar
argument_list|)
throw|;
block|}
name|originalGlyphIds
operator|.
name|add
argument_list|(
name|glyphId
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|glyphIdsAfterGsub
init|=
name|gsubWorker
operator|.
name|applyTransforms
argument_list|(
name|originalGlyphIds
argument_list|)
decl_stmt|;
for|for
control|(
name|Integer
name|glyphId
range|:
name|glyphIdsAfterGsub
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|font
operator|.
name|encodeGlyphId
argument_list|(
name|glyphId
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|glyphIdsAfterGsub
return|;
block|}
block|}
end_class

end_unit

