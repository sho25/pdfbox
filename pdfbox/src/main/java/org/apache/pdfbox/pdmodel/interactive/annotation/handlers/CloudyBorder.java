begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|annotation
operator|.
name|handlers
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|AffineTransform
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|Ellipse2D
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|PathIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|Point2D
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRectangle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|annotation
operator|.
name|PDAppearanceContentStream
import|;
end_import

begin_comment
comment|/**  * Generates annotation appearances with a cloudy border.  *<p>  * Dashed stroke styles are not recommended with cloudy borders. The result would  * not look good because some parts of the arcs are traced twice by the stroked  * path. Actually Acrobat Reader's line style dialog does not allow to choose a  * dashed and a cloudy style at the same time.  */
end_comment

begin_class
class|class
name|CloudyBorder
block|{
specifier|private
specifier|static
specifier|final
name|double
name|ANGLE_180_DEG
init|=
name|Math
operator|.
name|PI
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|ANGLE_90_DEG
init|=
name|Math
operator|.
name|PI
operator|/
literal|2
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|ANGLE_34_DEG
init|=
name|Math
operator|.
name|toRadians
argument_list|(
literal|34
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|ANGLE_30_DEG
init|=
name|Math
operator|.
name|toRadians
argument_list|(
literal|30
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|double
name|ANGLE_12_DEG
init|=
name|Math
operator|.
name|toRadians
argument_list|(
literal|12
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|PDAppearanceContentStream
name|output
decl_stmt|;
specifier|private
specifier|final
name|PDRectangle
name|annotRect
decl_stmt|;
specifier|private
specifier|final
name|double
name|intensity
decl_stmt|;
specifier|private
specifier|final
name|double
name|lineWidth
decl_stmt|;
specifier|private
name|PDRectangle
name|rectWithDiff
decl_stmt|;
specifier|private
name|boolean
name|outputStarted
init|=
literal|false
decl_stmt|;
specifier|private
name|double
name|bboxMinX
decl_stmt|;
specifier|private
name|double
name|bboxMinY
decl_stmt|;
specifier|private
name|double
name|bboxMaxX
decl_stmt|;
specifier|private
name|double
name|bboxMaxY
decl_stmt|;
comment|/**      * Creates a new<code>CloudyBorder</code> that writes to the specified      * content stream.      *      * @param stream content stream      * @param intensity intensity of cloudy effect (entry<code>I</code>); typically 1.0 or 2.0      * @param lineWidth line width for annotation border (entry<code>W</code>)      * @param rect annotation rectangle (entry<code>Rect</code>)      */
name|CloudyBorder
parameter_list|(
name|PDAppearanceContentStream
name|stream
parameter_list|,
name|double
name|intensity
parameter_list|,
name|double
name|lineWidth
parameter_list|,
name|PDRectangle
name|rect
parameter_list|)
block|{
name|this
operator|.
name|output
operator|=
name|stream
expr_stmt|;
name|this
operator|.
name|intensity
operator|=
name|intensity
expr_stmt|;
name|this
operator|.
name|lineWidth
operator|=
name|lineWidth
expr_stmt|;
name|this
operator|.
name|annotRect
operator|=
name|rect
expr_stmt|;
block|}
comment|/**      * Creates a cloudy border for a rectangular annotation.      * The rectangle is specified by the<code>RD</code> entry and the      *<code>Rect</code> entry that was passed in to the constructor.      *<p>      * This can be used for Square and FreeText annotations. However, this does      * not produce the text and the callout line for FreeTexts.      *      * @param rd entry<code>RD</code>, or null if the entry does not exist      * @throws IOException If there is an error writing to the stream.      */
name|void
name|createCloudyRectangle
parameter_list|(
name|PDRectangle
name|rd
parameter_list|)
throws|throws
name|IOException
block|{
name|rectWithDiff
operator|=
name|applyRectDiff
argument_list|(
name|rd
argument_list|,
name|lineWidth
operator|/
literal|2
argument_list|)
expr_stmt|;
name|double
name|left
init|=
name|rectWithDiff
operator|.
name|getLowerLeftX
argument_list|()
decl_stmt|;
name|double
name|bottom
init|=
name|rectWithDiff
operator|.
name|getLowerLeftY
argument_list|()
decl_stmt|;
name|double
name|right
init|=
name|rectWithDiff
operator|.
name|getUpperRightX
argument_list|()
decl_stmt|;
name|double
name|top
init|=
name|rectWithDiff
operator|.
name|getUpperRightY
argument_list|()
decl_stmt|;
name|cloudyRectangleImpl
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|,
name|right
argument_list|,
name|top
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|finish
argument_list|()
expr_stmt|;
block|}
comment|/**      * Creates a cloudy border for a Polygon annotation.      *      * @param path polygon path      * @throws IOException If there is an error writing to the stream.      */
name|void
name|createCloudyPolygon
parameter_list|(
name|float
index|[]
index|[]
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|n
init|=
name|path
operator|.
name|length
decl_stmt|;
name|Point2D
operator|.
name|Double
index|[]
name|polygon
init|=
operator|new
name|Point2D
operator|.
name|Double
index|[
name|n
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|float
index|[]
name|array
init|=
name|path
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|array
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|polygon
index|[
name|i
index|]
operator|=
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|array
index|[
literal|0
index|]
argument_list|,
name|array
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|array
operator|.
name|length
operator|==
literal|6
condition|)
block|{
comment|// TODO Curve segments are not yet supported in cloudy border.
name|polygon
index|[
name|i
index|]
operator|=
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|array
index|[
literal|4
index|]
argument_list|,
name|array
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|cloudyPolygonImpl
argument_list|(
name|polygon
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|finish
argument_list|()
expr_stmt|;
block|}
comment|/**      * Creates a cloudy border for a Circle annotation.      * The ellipse is specified by the<code>RD</code> entry and the      *<code>Rect</code> entry that was passed in to the constructor.      *      * @param rd entry<code>RD</code>, or null if the entry does not exist      * @throws IOException If there is an error writing to the stream.      */
name|void
name|createCloudyEllipse
parameter_list|(
name|PDRectangle
name|rd
parameter_list|)
throws|throws
name|IOException
block|{
name|rectWithDiff
operator|=
name|applyRectDiff
argument_list|(
name|rd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|double
name|left
init|=
name|rectWithDiff
operator|.
name|getLowerLeftX
argument_list|()
decl_stmt|;
name|double
name|bottom
init|=
name|rectWithDiff
operator|.
name|getLowerLeftY
argument_list|()
decl_stmt|;
name|double
name|right
init|=
name|rectWithDiff
operator|.
name|getUpperRightX
argument_list|()
decl_stmt|;
name|double
name|top
init|=
name|rectWithDiff
operator|.
name|getUpperRightY
argument_list|()
decl_stmt|;
name|cloudyEllipseImpl
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|,
name|right
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|finish
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns the<code>BBox</code> entry (bounding box) for the      * appearance stream form XObject.      *      * @return Bounding box for appearance stream form XObject.      */
name|PDRectangle
name|getBBox
parameter_list|()
block|{
return|return
name|getRectangle
argument_list|()
return|;
block|}
comment|/**      * Returns the updated<code>Rect</code> entry for the annotation.      * The rectangle completely contains the cloudy border.      *      * @return Annotation<code>Rect</code>.      */
name|PDRectangle
name|getRectangle
parameter_list|()
block|{
return|return
operator|new
name|PDRectangle
argument_list|(
operator|(
name|float
operator|)
name|bboxMinX
argument_list|,
operator|(
name|float
operator|)
name|bboxMinY
argument_list|,
call|(
name|float
call|)
argument_list|(
name|bboxMaxX
operator|-
name|bboxMinX
argument_list|)
argument_list|,
call|(
name|float
call|)
argument_list|(
name|bboxMaxY
operator|-
name|bboxMinY
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns the<code>Matrix</code> entry for the appearance stream form XObject.      *      * @return Matrix for appearance stream form XObject.      */
name|AffineTransform
name|getMatrix
parameter_list|()
block|{
return|return
name|AffineTransform
operator|.
name|getTranslateInstance
argument_list|(
operator|-
name|bboxMinX
argument_list|,
operator|-
name|bboxMinY
argument_list|)
return|;
block|}
comment|/**      * Returns the updated<code>RD</code> entry for Square and Circle annotations.      *      * @return Annotation<code>RD</code> value.      */
name|PDRectangle
name|getRectDifference
parameter_list|()
block|{
if|if
condition|(
name|annotRect
operator|==
literal|null
condition|)
block|{
name|float
name|d
init|=
operator|(
name|float
operator|)
name|lineWidth
operator|/
literal|2
decl_stmt|;
return|return
operator|new
name|PDRectangle
argument_list|(
name|d
argument_list|,
name|d
argument_list|,
operator|(
name|float
operator|)
name|lineWidth
argument_list|,
operator|(
name|float
operator|)
name|lineWidth
argument_list|)
return|;
block|}
name|PDRectangle
name|re
init|=
operator|(
name|rectWithDiff
operator|!=
literal|null
operator|)
condition|?
name|rectWithDiff
else|:
name|annotRect
decl_stmt|;
name|float
name|left
init|=
name|re
operator|.
name|getLowerLeftX
argument_list|()
operator|-
operator|(
name|float
operator|)
name|bboxMinX
decl_stmt|;
name|float
name|bottom
init|=
name|re
operator|.
name|getLowerLeftY
argument_list|()
operator|-
operator|(
name|float
operator|)
name|bboxMinY
decl_stmt|;
name|float
name|right
init|=
operator|(
name|float
operator|)
name|bboxMaxX
operator|-
name|re
operator|.
name|getUpperRightX
argument_list|()
decl_stmt|;
name|float
name|top
init|=
operator|(
name|float
operator|)
name|bboxMaxY
operator|-
name|re
operator|.
name|getUpperRightY
argument_list|()
decl_stmt|;
return|return
operator|new
name|PDRectangle
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|,
name|right
operator|-
name|left
argument_list|,
name|top
operator|-
name|bottom
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|double
name|cosine
parameter_list|(
name|double
name|dx
parameter_list|,
name|double
name|hypot
parameter_list|)
block|{
if|if
condition|(
name|Double
operator|.
name|compare
argument_list|(
name|hypot
argument_list|,
literal|0.0
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|dx
operator|/
name|hypot
return|;
block|}
specifier|private
specifier|static
name|double
name|sine
parameter_list|(
name|double
name|dy
parameter_list|,
name|double
name|hypot
parameter_list|)
block|{
if|if
condition|(
name|Double
operator|.
name|compare
argument_list|(
name|hypot
argument_list|,
literal|0.0
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|dy
operator|/
name|hypot
return|;
block|}
comment|/**      * Cloudy rectangle implementation is based on converting the rectangle      * to a polygon.      */
specifier|private
name|void
name|cloudyRectangleImpl
parameter_list|(
name|double
name|left
parameter_list|,
name|double
name|bottom
parameter_list|,
name|double
name|right
parameter_list|,
name|double
name|top
parameter_list|,
name|boolean
name|isEllipse
parameter_list|)
throws|throws
name|IOException
block|{
name|double
name|w
init|=
name|right
operator|-
name|left
decl_stmt|;
name|double
name|h
init|=
name|top
operator|-
name|bottom
decl_stmt|;
if|if
condition|(
name|intensity
operator|<=
literal|0.0
condition|)
block|{
name|output
operator|.
name|addRect
argument_list|(
operator|(
name|float
operator|)
name|left
argument_list|,
operator|(
name|float
operator|)
name|bottom
argument_list|,
operator|(
name|float
operator|)
name|w
argument_list|,
operator|(
name|float
operator|)
name|h
argument_list|)
expr_stmt|;
name|bboxMinX
operator|=
name|left
expr_stmt|;
name|bboxMinY
operator|=
name|bottom
expr_stmt|;
name|bboxMaxX
operator|=
name|right
expr_stmt|;
name|bboxMaxY
operator|=
name|top
expr_stmt|;
return|return;
block|}
comment|// Make a polygon with direction equal to the positive angle direction.
name|Point2D
operator|.
name|Double
index|[]
name|polygon
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|1.0
condition|)
block|{
name|polygon
operator|=
operator|new
name|Point2D
operator|.
name|Double
index|[]
block|{
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|)
block|,
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|left
argument_list|,
name|top
argument_list|)
block|,
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|)
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|<
literal|1.0
condition|)
block|{
name|polygon
operator|=
operator|new
name|Point2D
operator|.
name|Double
index|[]
block|{
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|)
block|,
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|right
argument_list|,
name|bottom
argument_list|)
block|,
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|)
block|}
expr_stmt|;
block|}
else|else
block|{
name|polygon
operator|=
operator|new
name|Point2D
operator|.
name|Double
index|[]
block|{
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|)
block|,
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|right
argument_list|,
name|bottom
argument_list|)
block|,
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|right
argument_list|,
name|top
argument_list|)
block|,
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|left
argument_list|,
name|top
argument_list|)
block|,
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|)
block|}
expr_stmt|;
block|}
name|cloudyPolygonImpl
argument_list|(
name|polygon
argument_list|,
name|isEllipse
argument_list|)
expr_stmt|;
block|}
comment|/**      * Cloudy polygon implementation.      *      * @param vertices polygon vertices; first and last point must be equal      * @param isEllipse specifies if the polygon represents an ellipse      */
specifier|private
name|void
name|cloudyPolygonImpl
parameter_list|(
name|Point2D
operator|.
name|Double
index|[]
name|vertices
parameter_list|,
name|boolean
name|isEllipse
parameter_list|)
throws|throws
name|IOException
block|{
name|Point2D
operator|.
name|Double
index|[]
name|polygon
init|=
name|removeZeroLengthSegments
argument_list|(
name|vertices
argument_list|)
decl_stmt|;
name|getPositivePolygon
argument_list|(
name|polygon
argument_list|)
expr_stmt|;
name|int
name|numPoints
init|=
name|polygon
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|numPoints
operator|<
literal|2
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|intensity
operator|<=
literal|0.0
condition|)
block|{
name|moveTo
argument_list|(
name|polygon
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numPoints
condition|;
name|i
operator|++
control|)
block|{
name|lineTo
argument_list|(
name|polygon
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|double
name|cloudRadius
init|=
name|isEllipse
condition|?
name|getEllipseCloudRadius
argument_list|()
else|:
name|getPolygonCloudRadius
argument_list|()
decl_stmt|;
if|if
condition|(
name|cloudRadius
operator|<
literal|0.5
condition|)
block|{
name|cloudRadius
operator|=
literal|0.5
expr_stmt|;
block|}
specifier|final
name|double
name|k
init|=
name|Math
operator|.
name|cos
argument_list|(
name|ANGLE_34_DEG
argument_list|)
decl_stmt|;
specifier|final
name|double
name|advIntermDefault
init|=
literal|2
operator|*
name|k
operator|*
name|cloudRadius
decl_stmt|;
specifier|final
name|double
name|advCornerDefault
init|=
name|k
operator|*
name|cloudRadius
decl_stmt|;
name|double
index|[]
name|array
init|=
operator|new
name|double
index|[
literal|2
index|]
decl_stmt|;
name|double
name|anglePrev
init|=
literal|0
decl_stmt|;
comment|// The number of curls per polygon segment is hardly ever an integer,
comment|// so the length of some curls must be adjustable. We adjust the angle
comment|// of the trailing arc of corner curls and the leading arc of the first
comment|// intermediate curl.
comment|// In each polygon segment, we have n intermediate curls plus one half of a
comment|// corner curl at each end. One of the n intermediate curls is adjustable.
comment|// Thus the number of fixed (or unadjusted) intermediate curls is n - 1.
comment|// Find the adjusted angle `alpha` for the first corner curl.
name|int
name|n0
init|=
name|computeParamsPolygon
argument_list|(
name|advIntermDefault
argument_list|,
name|advCornerDefault
argument_list|,
name|k
argument_list|,
name|cloudRadius
argument_list|,
name|polygon
index|[
name|numPoints
operator|-
literal|2
index|]
operator|.
name|distance
argument_list|(
name|polygon
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|array
argument_list|)
decl_stmt|;
name|double
name|alphaPrev
init|=
operator|(
name|n0
operator|==
literal|0
operator|)
condition|?
name|array
index|[
literal|0
index|]
else|:
name|ANGLE_34_DEG
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|+
literal|1
operator|<
name|numPoints
condition|;
name|j
operator|++
control|)
block|{
name|Point2D
operator|.
name|Double
name|pt
init|=
name|polygon
index|[
name|j
index|]
decl_stmt|;
name|Point2D
operator|.
name|Double
name|ptNext
init|=
name|polygon
index|[
name|j
operator|+
literal|1
index|]
decl_stmt|;
name|double
name|length
init|=
name|pt
operator|.
name|distance
argument_list|(
name|ptNext
argument_list|)
decl_stmt|;
if|if
condition|(
name|Double
operator|.
name|compare
argument_list|(
name|length
argument_list|,
literal|0.0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|alphaPrev
operator|=
name|ANGLE_34_DEG
expr_stmt|;
continue|continue;
block|}
comment|// n is the number of intermediate curls in the current polygon segment.
name|int
name|n
init|=
name|computeParamsPolygon
argument_list|(
name|advIntermDefault
argument_list|,
name|advCornerDefault
argument_list|,
name|k
argument_list|,
name|cloudRadius
argument_list|,
name|length
argument_list|,
name|array
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|outputStarted
condition|)
block|{
name|moveTo
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|double
name|alpha
init|=
name|array
index|[
literal|0
index|]
decl_stmt|;
name|double
name|dx
init|=
name|array
index|[
literal|1
index|]
decl_stmt|;
name|double
name|angleCur
init|=
name|Math
operator|.
name|atan2
argument_list|(
name|ptNext
operator|.
name|y
operator|-
name|pt
operator|.
name|y
argument_list|,
name|ptNext
operator|.
name|x
operator|-
name|pt
operator|.
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
name|Point2D
operator|.
name|Double
name|ptPrev
init|=
name|polygon
index|[
name|numPoints
operator|-
literal|2
index|]
decl_stmt|;
name|anglePrev
operator|=
name|Math
operator|.
name|atan2
argument_list|(
name|pt
operator|.
name|y
operator|-
name|ptPrev
operator|.
name|y
argument_list|,
name|pt
operator|.
name|x
operator|-
name|ptPrev
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
name|double
name|cos
init|=
name|cosine
argument_list|(
name|ptNext
operator|.
name|x
operator|-
name|pt
operator|.
name|x
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|double
name|sin
init|=
name|sine
argument_list|(
name|ptNext
operator|.
name|y
operator|-
name|pt
operator|.
name|y
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|double
name|x
init|=
name|pt
operator|.
name|x
decl_stmt|;
name|double
name|y
init|=
name|pt
operator|.
name|y
decl_stmt|;
name|addCornerCurl
argument_list|(
name|anglePrev
argument_list|,
name|angleCur
argument_list|,
name|cloudRadius
argument_list|,
name|pt
operator|.
name|x
argument_list|,
name|pt
operator|.
name|y
argument_list|,
name|alpha
argument_list|,
name|alphaPrev
argument_list|,
operator|!
name|outputStarted
argument_list|)
expr_stmt|;
comment|// Proceed to the center point of the first intermediate curl.
name|double
name|adv
init|=
literal|2
operator|*
name|k
operator|*
name|cloudRadius
operator|+
literal|2
operator|*
name|dx
decl_stmt|;
name|x
operator|+=
name|adv
operator|*
name|cos
expr_stmt|;
name|y
operator|+=
name|adv
operator|*
name|sin
expr_stmt|;
comment|// Create the first intermediate curl.
name|int
name|numInterm
init|=
name|n
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|1
condition|)
block|{
name|addFirstIntermediateCurl
argument_list|(
name|angleCur
argument_list|,
name|cloudRadius
argument_list|,
name|alpha
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|x
operator|+=
name|advIntermDefault
operator|*
name|cos
expr_stmt|;
name|y
operator|+=
name|advIntermDefault
operator|*
name|sin
expr_stmt|;
name|numInterm
operator|=
name|n
operator|-
literal|1
expr_stmt|;
block|}
comment|// Create one intermediate curl and replicate it along the polygon segment.
name|Point2D
operator|.
name|Double
index|[]
name|template
init|=
name|getIntermediateCurlTemplate
argument_list|(
name|angleCur
argument_list|,
name|cloudRadius
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numInterm
condition|;
name|i
operator|++
control|)
block|{
name|outputCurlTemplate
argument_list|(
name|template
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|x
operator|+=
name|advIntermDefault
operator|*
name|cos
expr_stmt|;
name|y
operator|+=
name|advIntermDefault
operator|*
name|sin
expr_stmt|;
block|}
name|anglePrev
operator|=
name|angleCur
expr_stmt|;
name|alphaPrev
operator|=
operator|(
name|n
operator|==
literal|0
operator|)
condition|?
name|alpha
else|:
name|ANGLE_34_DEG
expr_stmt|;
block|}
block|}
comment|/**      * Computes parameters for a cloudy polygon: n, alpha, and dx.      */
specifier|private
name|int
name|computeParamsPolygon
parameter_list|(
name|double
name|advInterm
parameter_list|,
name|double
name|advCorner
parameter_list|,
name|double
name|k
parameter_list|,
name|double
name|r
parameter_list|,
name|double
name|length
parameter_list|,
name|double
index|[]
name|array
parameter_list|)
block|{
if|if
condition|(
name|Double
operator|.
name|compare
argument_list|(
name|length
argument_list|,
literal|0.0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|array
index|[
literal|0
index|]
operator|=
name|ANGLE_34_DEG
expr_stmt|;
name|array
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|// n is the number of intermediate curls in the current polygon segment
name|int
name|n
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|length
operator|-
literal|2
operator|*
name|advCorner
operator|)
operator|/
name|advInterm
argument_list|)
decl_stmt|;
comment|// Fitting error along polygon segment
name|double
name|e
init|=
name|length
operator|-
operator|(
literal|2
operator|*
name|advCorner
operator|+
name|n
operator|*
name|advInterm
operator|)
decl_stmt|;
comment|// Fitting error per each adjustable half curl
name|double
name|dx
init|=
name|e
operator|/
literal|2
decl_stmt|;
comment|// Convert fitting error to an angle that can be used to control arcs.
name|double
name|arg
init|=
operator|(
name|k
operator|*
name|r
operator|+
name|dx
operator|)
operator|/
name|r
decl_stmt|;
name|double
name|alpha
init|=
operator|(
name|arg
argument_list|<
operator|-
literal|1.0
operator|||
name|arg
argument_list|>
literal|1.0
operator|)
condition|?
literal|0.0
else|:
name|Math
operator|.
name|acos
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|array
index|[
literal|0
index|]
operator|=
name|alpha
expr_stmt|;
name|array
index|[
literal|1
index|]
operator|=
name|dx
expr_stmt|;
return|return
name|n
return|;
block|}
comment|/**      * Creates a corner curl for polygons and ellipses.      */
specifier|private
name|void
name|addCornerCurl
parameter_list|(
name|double
name|anglePrev
parameter_list|,
name|double
name|angleCur
parameter_list|,
name|double
name|radius
parameter_list|,
name|double
name|cx
parameter_list|,
name|double
name|cy
parameter_list|,
name|double
name|alpha
parameter_list|,
name|double
name|alphaPrev
parameter_list|,
name|boolean
name|addMoveTo
parameter_list|)
throws|throws
name|IOException
block|{
name|double
name|a
init|=
name|anglePrev
operator|+
name|ANGLE_180_DEG
operator|+
name|alphaPrev
decl_stmt|;
name|double
name|b
init|=
name|anglePrev
operator|+
name|ANGLE_180_DEG
operator|+
name|alphaPrev
operator|-
name|Math
operator|.
name|toRadians
argument_list|(
literal|22
argument_list|)
decl_stmt|;
name|getArcSegment
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|radius
argument_list|,
name|radius
argument_list|,
literal|null
argument_list|,
name|addMoveTo
argument_list|)
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|angleCur
operator|-
name|alpha
expr_stmt|;
name|getArc
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|radius
argument_list|,
name|radius
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Generates the first intermediate curl for a cloudy polygon.      */
specifier|private
name|void
name|addFirstIntermediateCurl
parameter_list|(
name|double
name|angleCur
parameter_list|,
name|double
name|r
parameter_list|,
name|double
name|alpha
parameter_list|,
name|double
name|cx
parameter_list|,
name|double
name|cy
parameter_list|)
throws|throws
name|IOException
block|{
name|double
name|a
init|=
name|angleCur
operator|+
name|ANGLE_180_DEG
decl_stmt|;
name|getArcSegment
argument_list|(
name|a
operator|+
name|alpha
argument_list|,
name|a
operator|+
name|alpha
operator|-
name|ANGLE_30_DEG
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|getArcSegment
argument_list|(
name|a
operator|+
name|alpha
operator|-
name|ANGLE_30_DEG
argument_list|,
name|a
operator|+
name|ANGLE_90_DEG
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|getArcSegment
argument_list|(
name|a
operator|+
name|ANGLE_90_DEG
argument_list|,
name|a
operator|+
name|ANGLE_180_DEG
operator|-
name|ANGLE_34_DEG
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a template for intermediate curls in a cloudy polygon.      */
specifier|private
name|Point2D
operator|.
name|Double
index|[]
name|getIntermediateCurlTemplate
parameter_list|(
name|double
name|angleCur
parameter_list|,
name|double
name|r
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|Point2D
operator|.
name|Double
argument_list|>
name|points
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|double
name|a
init|=
name|angleCur
operator|+
name|ANGLE_180_DEG
decl_stmt|;
name|getArcSegment
argument_list|(
name|a
operator|+
name|ANGLE_34_DEG
argument_list|,
name|a
operator|+
name|ANGLE_12_DEG
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|points
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|getArcSegment
argument_list|(
name|a
operator|+
name|ANGLE_12_DEG
argument_list|,
name|a
operator|+
name|ANGLE_90_DEG
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|points
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|getArcSegment
argument_list|(
name|a
operator|+
name|ANGLE_90_DEG
argument_list|,
name|a
operator|+
name|ANGLE_180_DEG
operator|-
name|ANGLE_34_DEG
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|points
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|points
operator|.
name|toArray
argument_list|(
operator|new
name|Point2D
operator|.
name|Double
index|[
name|points
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Writes the curl template points to the output and applies translation (x, y).      */
specifier|private
name|void
name|outputCurlTemplate
parameter_list|(
name|Point2D
operator|.
name|Double
index|[]
name|template
parameter_list|,
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|n
init|=
name|template
operator|.
name|length
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|%
literal|3
operator|)
operator|==
literal|1
condition|)
block|{
name|Point2D
operator|.
name|Double
name|a
init|=
name|template
index|[
literal|0
index|]
decl_stmt|;
name|moveTo
argument_list|(
name|a
operator|.
name|x
operator|+
name|x
argument_list|,
name|a
operator|.
name|y
operator|+
name|y
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|+
literal|2
operator|<
name|n
condition|;
name|i
operator|+=
literal|3
control|)
block|{
name|Point2D
operator|.
name|Double
name|a
init|=
name|template
index|[
name|i
index|]
decl_stmt|;
name|Point2D
operator|.
name|Double
name|b
init|=
name|template
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|Point2D
operator|.
name|Double
name|c
init|=
name|template
index|[
name|i
operator|+
literal|2
index|]
decl_stmt|;
name|curveTo
argument_list|(
name|a
operator|.
name|x
operator|+
name|x
argument_list|,
name|a
operator|.
name|y
operator|+
name|y
argument_list|,
name|b
operator|.
name|x
operator|+
name|x
argument_list|,
name|b
operator|.
name|y
operator|+
name|y
argument_list|,
name|c
operator|.
name|x
operator|+
name|x
argument_list|,
name|c
operator|.
name|y
operator|+
name|y
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|PDRectangle
name|applyRectDiff
parameter_list|(
name|PDRectangle
name|rd
parameter_list|,
name|double
name|min
parameter_list|)
block|{
name|float
name|rectLeft
init|=
name|annotRect
operator|.
name|getLowerLeftX
argument_list|()
decl_stmt|;
name|float
name|rectBottom
init|=
name|annotRect
operator|.
name|getLowerLeftY
argument_list|()
decl_stmt|;
name|float
name|rectRight
init|=
name|annotRect
operator|.
name|getUpperRightX
argument_list|()
decl_stmt|;
name|float
name|rectTop
init|=
name|annotRect
operator|.
name|getUpperRightY
argument_list|()
decl_stmt|;
comment|// Normalize
name|rectLeft
operator|=
name|Math
operator|.
name|min
argument_list|(
name|rectLeft
argument_list|,
name|rectRight
argument_list|)
expr_stmt|;
name|rectBottom
operator|=
name|Math
operator|.
name|min
argument_list|(
name|rectBottom
argument_list|,
name|rectTop
argument_list|)
expr_stmt|;
name|rectRight
operator|=
name|Math
operator|.
name|max
argument_list|(
name|rectLeft
argument_list|,
name|rectRight
argument_list|)
expr_stmt|;
name|rectTop
operator|=
name|Math
operator|.
name|max
argument_list|(
name|rectBottom
argument_list|,
name|rectTop
argument_list|)
expr_stmt|;
name|double
name|rdLeft
decl_stmt|;
name|double
name|rdBottom
decl_stmt|;
name|double
name|rdRight
decl_stmt|;
name|double
name|rdTop
decl_stmt|;
if|if
condition|(
name|rd
operator|!=
literal|null
condition|)
block|{
name|rdLeft
operator|=
name|Math
operator|.
name|max
argument_list|(
name|rd
operator|.
name|getLowerLeftX
argument_list|()
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|rdBottom
operator|=
name|Math
operator|.
name|max
argument_list|(
name|rd
operator|.
name|getLowerLeftY
argument_list|()
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|rdRight
operator|=
name|Math
operator|.
name|max
argument_list|(
name|rd
operator|.
name|getUpperRightX
argument_list|()
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|rdTop
operator|=
name|Math
operator|.
name|max
argument_list|(
name|rd
operator|.
name|getUpperRightY
argument_list|()
argument_list|,
name|min
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rdLeft
operator|=
name|min
expr_stmt|;
name|rdBottom
operator|=
name|min
expr_stmt|;
name|rdRight
operator|=
name|min
expr_stmt|;
name|rdTop
operator|=
name|min
expr_stmt|;
block|}
name|rectLeft
operator|+=
name|rdLeft
expr_stmt|;
name|rectBottom
operator|+=
name|rdBottom
expr_stmt|;
name|rectRight
operator|-=
name|rdRight
expr_stmt|;
name|rectTop
operator|-=
name|rdTop
expr_stmt|;
return|return
operator|new
name|PDRectangle
argument_list|(
name|rectLeft
argument_list|,
name|rectBottom
argument_list|,
name|rectRight
operator|-
name|rectLeft
argument_list|,
name|rectTop
operator|-
name|rectBottom
argument_list|)
return|;
block|}
specifier|private
name|void
name|reversePolygon
parameter_list|(
name|Point2D
operator|.
name|Double
index|[]
name|points
parameter_list|)
block|{
name|int
name|len
init|=
name|points
operator|.
name|length
decl_stmt|;
name|int
name|n
init|=
name|len
operator|/
literal|2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|len
operator|-
name|i
operator|-
literal|1
decl_stmt|;
name|Point2D
operator|.
name|Double
name|pi
init|=
name|points
index|[
name|i
index|]
decl_stmt|;
name|Point2D
operator|.
name|Double
name|pj
init|=
name|points
index|[
name|j
index|]
decl_stmt|;
name|points
index|[
name|i
index|]
operator|=
name|pj
expr_stmt|;
name|points
index|[
name|j
index|]
operator|=
name|pi
expr_stmt|;
block|}
block|}
comment|/**      * Makes a polygon whose direction is the same as the positive angle      * direction in the coordinate system.      * The polygon must not intersect itself.      */
specifier|private
name|void
name|getPositivePolygon
parameter_list|(
name|Point2D
operator|.
name|Double
index|[]
name|points
parameter_list|)
block|{
if|if
condition|(
name|getPolygonDirection
argument_list|(
name|points
argument_list|)
operator|<
literal|0
condition|)
block|{
name|reversePolygon
argument_list|(
name|points
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the direction of the specified polygon.      * A positive value indicates that the polygon's direction is the same as the      * direction of positive angles in the coordinate system.      * A negative value indicates the opposite direction.      *      * The polygon must not intersect itself. A 2-point polygon is not acceptable.      * This is based on the "shoelace formula".      */
specifier|private
name|double
name|getPolygonDirection
parameter_list|(
name|Point2D
operator|.
name|Double
index|[]
name|points
parameter_list|)
block|{
name|double
name|a
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|points
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|len
decl_stmt|;
name|a
operator|+=
name|points
index|[
name|i
index|]
operator|.
name|x
operator|*
name|points
index|[
name|j
index|]
operator|.
name|y
operator|-
name|points
index|[
name|i
index|]
operator|.
name|y
operator|*
name|points
index|[
name|j
index|]
operator|.
name|x
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
comment|/**      * Creates one or more Bézier curves that represent an elliptical arc.      * Angles are in radians.      * The arc will always proceed in the positive angle direction.      * If the argument `out` is null, this writes the results to the instance      * variable `output`.      */
specifier|private
name|void
name|getArc
parameter_list|(
name|double
name|startAng
parameter_list|,
name|double
name|endAng
parameter_list|,
name|double
name|rx
parameter_list|,
name|double
name|ry
parameter_list|,
name|double
name|cx
parameter_list|,
name|double
name|cy
parameter_list|,
name|ArrayList
argument_list|<
name|Point2D
operator|.
name|Double
argument_list|>
name|out
parameter_list|,
name|boolean
name|addMoveTo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|double
name|angleIncr
init|=
name|Math
operator|.
name|PI
operator|/
literal|2
decl_stmt|;
name|double
name|startx
init|=
name|rx
operator|*
name|Math
operator|.
name|cos
argument_list|(
name|startAng
argument_list|)
operator|+
name|cx
decl_stmt|;
name|double
name|starty
init|=
name|ry
operator|*
name|Math
operator|.
name|sin
argument_list|(
name|startAng
argument_list|)
operator|+
name|cy
decl_stmt|;
name|double
name|angleTodo
init|=
name|endAng
operator|-
name|startAng
decl_stmt|;
while|while
condition|(
name|angleTodo
operator|<
literal|0
condition|)
block|{
name|angleTodo
operator|+=
literal|2
operator|*
name|Math
operator|.
name|PI
expr_stmt|;
block|}
name|double
name|sweep
init|=
name|angleTodo
decl_stmt|;
name|double
name|angleDone
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|addMoveTo
condition|)
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|add
argument_list|(
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|startx
argument_list|,
name|starty
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|moveTo
argument_list|(
name|startx
argument_list|,
name|starty
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|angleTodo
operator|>
name|angleIncr
condition|)
block|{
name|getArcSegment
argument_list|(
name|startAng
operator|+
name|angleDone
argument_list|,
name|startAng
operator|+
name|angleDone
operator|+
name|angleIncr
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|,
name|out
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|angleDone
operator|+=
name|angleIncr
expr_stmt|;
name|angleTodo
operator|-=
name|angleIncr
expr_stmt|;
block|}
if|if
condition|(
name|angleTodo
operator|>
literal|0
condition|)
block|{
name|getArcSegment
argument_list|(
name|startAng
operator|+
name|angleDone
argument_list|,
name|startAng
operator|+
name|sweep
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|,
name|out
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Creates a single Bézier curve that represents a section of an elliptical      * arc. The sweep angle of the section must not be larger than 90 degrees.      * If argument `out` is null, this writes the results to the instance      * variable `output`.      */
specifier|private
name|void
name|getArcSegment
parameter_list|(
name|double
name|startAng
parameter_list|,
name|double
name|endAng
parameter_list|,
name|double
name|cx
parameter_list|,
name|double
name|cy
parameter_list|,
name|double
name|rx
parameter_list|,
name|double
name|ry
parameter_list|,
name|ArrayList
argument_list|<
name|Point2D
operator|.
name|Double
argument_list|>
name|out
parameter_list|,
name|boolean
name|addMoveTo
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Algorithm is from the FAQ of the news group comp.text.pdf
name|double
name|cosA
init|=
name|Math
operator|.
name|cos
argument_list|(
name|startAng
argument_list|)
decl_stmt|;
name|double
name|sinA
init|=
name|Math
operator|.
name|sin
argument_list|(
name|startAng
argument_list|)
decl_stmt|;
name|double
name|cosB
init|=
name|Math
operator|.
name|cos
argument_list|(
name|endAng
argument_list|)
decl_stmt|;
name|double
name|sinB
init|=
name|Math
operator|.
name|sin
argument_list|(
name|endAng
argument_list|)
decl_stmt|;
name|double
name|denom
init|=
name|Math
operator|.
name|sin
argument_list|(
operator|(
name|endAng
operator|-
name|startAng
operator|)
operator|/
literal|2.0
argument_list|)
decl_stmt|;
if|if
condition|(
name|Double
operator|.
name|compare
argument_list|(
name|denom
argument_list|,
literal|0.0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// This can happen only if endAng == startAng.
comment|// The arc sweep angle is zero, so we create no arc at all.
if|if
condition|(
name|addMoveTo
condition|)
block|{
name|double
name|xs
init|=
name|cx
operator|+
name|rx
operator|*
name|cosA
decl_stmt|;
name|double
name|ys
init|=
name|cy
operator|+
name|ry
operator|*
name|sinA
decl_stmt|;
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|add
argument_list|(
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|moveTo
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
name|double
name|bcp
init|=
literal|1.333333333
operator|*
operator|(
literal|1
operator|-
name|Math
operator|.
name|cos
argument_list|(
operator|(
name|endAng
operator|-
name|startAng
operator|)
operator|/
literal|2.0
argument_list|)
operator|)
operator|/
name|denom
decl_stmt|;
name|double
name|p1x
init|=
name|cx
operator|+
name|rx
operator|*
operator|(
name|cosA
operator|-
name|bcp
operator|*
name|sinA
operator|)
decl_stmt|;
name|double
name|p1y
init|=
name|cy
operator|+
name|ry
operator|*
operator|(
name|sinA
operator|+
name|bcp
operator|*
name|cosA
operator|)
decl_stmt|;
name|double
name|p2x
init|=
name|cx
operator|+
name|rx
operator|*
operator|(
name|cosB
operator|+
name|bcp
operator|*
name|sinB
operator|)
decl_stmt|;
name|double
name|p2y
init|=
name|cy
operator|+
name|ry
operator|*
operator|(
name|sinB
operator|-
name|bcp
operator|*
name|cosB
operator|)
decl_stmt|;
name|double
name|p3x
init|=
name|cx
operator|+
name|rx
operator|*
name|cosB
decl_stmt|;
name|double
name|p3y
init|=
name|cy
operator|+
name|ry
operator|*
name|sinB
decl_stmt|;
if|if
condition|(
name|addMoveTo
condition|)
block|{
name|double
name|xs
init|=
name|cx
operator|+
name|rx
operator|*
name|cosA
decl_stmt|;
name|double
name|ys
init|=
name|cy
operator|+
name|ry
operator|*
name|sinA
decl_stmt|;
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|add
argument_list|(
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|moveTo
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|add
argument_list|(
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|p1x
argument_list|,
name|p1y
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|add
argument_list|(
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|p2x
argument_list|,
name|p2y
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|add
argument_list|(
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|p3x
argument_list|,
name|p3y
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curveTo
argument_list|(
name|p1x
argument_list|,
name|p1y
argument_list|,
name|p2x
argument_list|,
name|p2y
argument_list|,
name|p3x
argument_list|,
name|p3y
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Flattens an ellipse into a polygon.      */
specifier|private
specifier|static
name|Point2D
operator|.
name|Double
index|[]
name|flattenEllipse
parameter_list|(
name|double
name|left
parameter_list|,
name|double
name|bottom
parameter_list|,
name|double
name|right
parameter_list|,
name|double
name|top
parameter_list|)
block|{
name|Ellipse2D
operator|.
name|Double
name|ellipse
init|=
operator|new
name|Ellipse2D
operator|.
name|Double
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|,
name|right
operator|-
name|left
argument_list|,
name|top
operator|-
name|bottom
argument_list|)
decl_stmt|;
specifier|final
name|double
name|flatness
init|=
literal|0.50
decl_stmt|;
name|PathIterator
name|iterator
init|=
name|ellipse
operator|.
name|getPathIterator
argument_list|(
literal|null
argument_list|,
name|flatness
argument_list|)
decl_stmt|;
name|double
index|[]
name|coords
init|=
operator|new
name|double
index|[
literal|6
index|]
decl_stmt|;
name|ArrayList
argument_list|<
name|Point2D
operator|.
name|Double
argument_list|>
name|points
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|iterator
operator|.
name|isDone
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|iterator
operator|.
name|currentSegment
argument_list|(
name|coords
argument_list|)
condition|)
block|{
case|case
name|PathIterator
operator|.
name|SEG_MOVETO
case|:
case|case
name|PathIterator
operator|.
name|SEG_LINETO
case|:
name|points
operator|.
name|add
argument_list|(
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|coords
index|[
literal|0
index|]
argument_list|,
name|coords
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Curve segments are not expected because the path iterator is
comment|// flattened. SEG_CLOSE can be ignored.
default|default:
break|break;
block|}
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|int
name|size
init|=
name|points
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|double
name|closeTestLimit
init|=
literal|0.05
decl_stmt|;
if|if
condition|(
name|size
operator|>=
literal|2
operator|&&
name|points
operator|.
name|get
argument_list|(
name|size
operator|-
literal|1
argument_list|)
operator|.
name|distance
argument_list|(
name|points
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|>
name|closeTestLimit
condition|)
block|{
name|points
operator|.
name|add
argument_list|(
name|points
operator|.
name|get
argument_list|(
name|points
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|points
operator|.
name|toArray
argument_list|(
operator|new
name|Point2D
operator|.
name|Double
index|[
name|points
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Cloudy ellipse implementation.      */
specifier|private
name|void
name|cloudyEllipseImpl
parameter_list|(
specifier|final
name|double
name|leftOrig
parameter_list|,
specifier|final
name|double
name|bottomOrig
parameter_list|,
specifier|final
name|double
name|rightOrig
parameter_list|,
specifier|final
name|double
name|topOrig
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|intensity
operator|<=
literal|0.0
condition|)
block|{
name|drawBasicEllipse
argument_list|(
name|leftOrig
argument_list|,
name|bottomOrig
argument_list|,
name|rightOrig
argument_list|,
name|topOrig
argument_list|)
expr_stmt|;
return|return;
block|}
name|double
name|left
init|=
name|leftOrig
decl_stmt|;
name|double
name|bottom
init|=
name|bottomOrig
decl_stmt|;
name|double
name|right
init|=
name|rightOrig
decl_stmt|;
name|double
name|top
init|=
name|topOrig
decl_stmt|;
name|double
name|width
init|=
name|right
operator|-
name|left
decl_stmt|;
name|double
name|height
init|=
name|top
operator|-
name|bottom
decl_stmt|;
name|double
name|cloudRadius
init|=
name|getEllipseCloudRadius
argument_list|()
decl_stmt|;
comment|// Omit cloudy border if the ellipse is very small.
specifier|final
name|double
name|threshold1
init|=
literal|0.50
operator|*
name|cloudRadius
decl_stmt|;
if|if
condition|(
name|width
operator|<
name|threshold1
operator|&&
name|height
operator|<
name|threshold1
condition|)
block|{
name|drawBasicEllipse
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|,
name|right
argument_list|,
name|top
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Draw a cloudy rectangle instead of an ellipse when the
comment|// width or height is very small.
specifier|final
name|double
name|threshold2
init|=
literal|5
decl_stmt|;
if|if
condition|(
operator|(
name|width
argument_list|<
name|threshold2
operator|&&
name|height
argument_list|>
literal|20
operator|)
operator|||
operator|(
name|width
operator|>
literal|20
operator|&&
name|height
operator|<
name|threshold2
operator|)
condition|)
block|{
name|cloudyRectangleImpl
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|,
name|right
argument_list|,
name|top
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Decrease radii (while center point does not move). This makes the
comment|// "tails" of the curls almost touch the ellipse outline.
name|double
name|radiusAdj
init|=
name|Math
operator|.
name|sin
argument_list|(
name|ANGLE_12_DEG
argument_list|)
operator|*
name|cloudRadius
operator|-
literal|1.50
decl_stmt|;
if|if
condition|(
name|width
operator|>
literal|2
operator|*
name|radiusAdj
condition|)
block|{
name|left
operator|+=
name|radiusAdj
expr_stmt|;
name|right
operator|-=
name|radiusAdj
expr_stmt|;
block|}
else|else
block|{
name|double
name|mid
init|=
operator|(
name|left
operator|+
name|right
operator|)
operator|/
literal|2
decl_stmt|;
name|left
operator|=
name|mid
operator|-
literal|0.10
expr_stmt|;
name|right
operator|=
name|mid
operator|+
literal|0.10
expr_stmt|;
block|}
if|if
condition|(
name|height
operator|>
literal|2
operator|*
name|radiusAdj
condition|)
block|{
name|top
operator|-=
name|radiusAdj
expr_stmt|;
name|bottom
operator|+=
name|radiusAdj
expr_stmt|;
block|}
else|else
block|{
name|double
name|mid
init|=
operator|(
name|top
operator|+
name|bottom
operator|)
operator|/
literal|2
decl_stmt|;
name|top
operator|=
name|mid
operator|+
literal|0.10
expr_stmt|;
name|bottom
operator|=
name|mid
operator|-
literal|0.10
expr_stmt|;
block|}
comment|// Flatten the ellipse into a polygon. The segment lengths of the flattened
comment|// result don't need to be extremely short because the loop below is able to
comment|// interpolate between polygon points when it computes the center points
comment|// at which each curl is placed.
name|Point2D
operator|.
name|Double
index|[]
name|flatPolygon
init|=
name|flattenEllipse
argument_list|(
name|left
argument_list|,
name|bottom
argument_list|,
name|right
argument_list|,
name|top
argument_list|)
decl_stmt|;
name|int
name|numPoints
init|=
name|flatPolygon
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|numPoints
operator|<
literal|2
condition|)
block|{
return|return;
block|}
name|double
name|totLen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numPoints
condition|;
name|i
operator|++
control|)
block|{
name|totLen
operator|+=
name|flatPolygon
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|distance
argument_list|(
name|flatPolygon
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
specifier|final
name|double
name|k
init|=
name|Math
operator|.
name|cos
argument_list|(
name|ANGLE_34_DEG
argument_list|)
decl_stmt|;
name|double
name|curlAdvance
init|=
literal|2
operator|*
name|k
operator|*
name|cloudRadius
decl_stmt|;
name|int
name|n
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|totLen
operator|/
name|curlAdvance
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|2
condition|)
block|{
name|drawBasicEllipse
argument_list|(
name|leftOrig
argument_list|,
name|bottomOrig
argument_list|,
name|rightOrig
argument_list|,
name|topOrig
argument_list|)
expr_stmt|;
return|return;
block|}
name|curlAdvance
operator|=
name|totLen
operator|/
name|n
expr_stmt|;
name|cloudRadius
operator|=
name|curlAdvance
operator|/
operator|(
literal|2
operator|*
name|k
operator|)
expr_stmt|;
if|if
condition|(
name|cloudRadius
operator|<
literal|0.5
condition|)
block|{
name|cloudRadius
operator|=
literal|0.5
expr_stmt|;
name|curlAdvance
operator|=
literal|2
operator|*
name|k
operator|*
name|cloudRadius
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cloudRadius
operator|<
literal|3.0
condition|)
block|{
comment|// Draw a small circle when the scaled radius becomes very small.
comment|// This happens also if intensity is much smaller than 1.
name|drawBasicEllipse
argument_list|(
name|leftOrig
argument_list|,
name|bottomOrig
argument_list|,
name|rightOrig
argument_list|,
name|topOrig
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Construct centerPoints array, in which each point is the center point of a curl.
comment|// The length of each centerPoints segment ideally equals curlAdv but that
comment|// is not true in regions where the ellipse curvature is high.
name|int
name|centerPointsLength
init|=
name|n
decl_stmt|;
name|Point2D
operator|.
name|Double
index|[]
name|centerPoints
init|=
operator|new
name|Point2D
operator|.
name|Double
index|[
name|centerPointsLength
index|]
decl_stmt|;
name|int
name|centerPointsIndex
init|=
literal|0
decl_stmt|;
name|double
name|lengthRemain
init|=
literal|0
decl_stmt|;
specifier|final
name|double
name|comparisonToler
init|=
name|lineWidth
operator|*
literal|0.10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|+
literal|1
operator|<
name|numPoints
condition|;
name|i
operator|++
control|)
block|{
name|Point2D
operator|.
name|Double
name|p1
init|=
name|flatPolygon
index|[
name|i
index|]
decl_stmt|;
name|Point2D
operator|.
name|Double
name|p2
init|=
name|flatPolygon
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|double
name|dx
init|=
name|p2
operator|.
name|x
operator|-
name|p1
operator|.
name|x
decl_stmt|;
name|double
name|dy
init|=
name|p2
operator|.
name|y
operator|-
name|p1
operator|.
name|y
decl_stmt|;
name|double
name|length
init|=
name|p1
operator|.
name|distance
argument_list|(
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|Double
operator|.
name|compare
argument_list|(
name|length
argument_list|,
literal|0.0
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|double
name|lengthTodo
init|=
name|length
operator|+
name|lengthRemain
decl_stmt|;
if|if
condition|(
name|lengthTodo
operator|>=
name|curlAdvance
operator|-
name|comparisonToler
operator|||
name|i
operator|==
name|numPoints
operator|-
literal|2
condition|)
block|{
name|double
name|cos
init|=
name|cosine
argument_list|(
name|dx
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|double
name|sin
init|=
name|sine
argument_list|(
name|dy
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|double
name|d
init|=
name|curlAdvance
operator|-
name|lengthRemain
decl_stmt|;
do|do
block|{
name|double
name|x
init|=
name|p1
operator|.
name|x
operator|+
name|d
operator|*
name|cos
decl_stmt|;
name|double
name|y
init|=
name|p1
operator|.
name|y
operator|+
name|d
operator|*
name|sin
decl_stmt|;
if|if
condition|(
name|centerPointsIndex
operator|<
name|centerPointsLength
condition|)
block|{
name|centerPoints
index|[
name|centerPointsIndex
operator|++
index|]
operator|=
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|lengthTodo
operator|-=
name|curlAdvance
expr_stmt|;
name|d
operator|+=
name|curlAdvance
expr_stmt|;
block|}
do|while
condition|(
name|lengthTodo
operator|>=
name|curlAdvance
operator|-
name|comparisonToler
condition|)
do|;
name|lengthRemain
operator|=
name|lengthTodo
expr_stmt|;
if|if
condition|(
name|lengthRemain
operator|<
literal|0
condition|)
block|{
name|lengthRemain
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|lengthRemain
operator|+=
name|length
expr_stmt|;
block|}
block|}
comment|// Note: centerPoints does not repeat the first point as the last point
comment|// to create a "closing" segment.
comment|// Place a curl at each point of the centerPoints array.
comment|// In regions where the ellipse curvature is high, the centerPoints segments
comment|// are shorter than the actual distance along the ellipse. Thus we must
comment|// again compute arc adjustments like in cloudy polygons.
name|numPoints
operator|=
name|centerPointsIndex
expr_stmt|;
name|double
name|anglePrev
init|=
literal|0
decl_stmt|;
name|double
name|alphaPrev
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numPoints
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idxNext
init|=
name|i
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|numPoints
condition|)
block|{
name|idxNext
operator|=
literal|0
expr_stmt|;
block|}
name|Point2D
operator|.
name|Double
name|pt
init|=
name|centerPoints
index|[
name|i
index|]
decl_stmt|;
name|Point2D
operator|.
name|Double
name|ptNext
init|=
name|centerPoints
index|[
name|idxNext
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|Point2D
operator|.
name|Double
name|ptPrev
init|=
name|centerPoints
index|[
name|numPoints
operator|-
literal|1
index|]
decl_stmt|;
name|anglePrev
operator|=
name|Math
operator|.
name|atan2
argument_list|(
name|pt
operator|.
name|y
operator|-
name|ptPrev
operator|.
name|y
argument_list|,
name|pt
operator|.
name|x
operator|-
name|ptPrev
operator|.
name|x
argument_list|)
expr_stmt|;
name|alphaPrev
operator|=
name|computeParamsEllipse
argument_list|(
name|ptPrev
argument_list|,
name|pt
argument_list|,
name|cloudRadius
argument_list|,
name|curlAdvance
argument_list|)
expr_stmt|;
block|}
name|double
name|angleCur
init|=
name|Math
operator|.
name|atan2
argument_list|(
name|ptNext
operator|.
name|y
operator|-
name|pt
operator|.
name|y
argument_list|,
name|ptNext
operator|.
name|x
operator|-
name|pt
operator|.
name|x
argument_list|)
decl_stmt|;
name|double
name|alpha
init|=
name|computeParamsEllipse
argument_list|(
name|pt
argument_list|,
name|ptNext
argument_list|,
name|cloudRadius
argument_list|,
name|curlAdvance
argument_list|)
decl_stmt|;
name|addCornerCurl
argument_list|(
name|anglePrev
argument_list|,
name|angleCur
argument_list|,
name|cloudRadius
argument_list|,
name|pt
operator|.
name|x
argument_list|,
name|pt
operator|.
name|y
argument_list|,
name|alpha
argument_list|,
name|alphaPrev
argument_list|,
operator|!
name|outputStarted
argument_list|)
expr_stmt|;
name|anglePrev
operator|=
name|angleCur
expr_stmt|;
name|alphaPrev
operator|=
name|alpha
expr_stmt|;
block|}
block|}
comment|/**      * Computes the alpha parameter for an ellipse curl.      */
specifier|private
name|double
name|computeParamsEllipse
parameter_list|(
name|Point2D
operator|.
name|Double
name|pt
parameter_list|,
name|Point2D
operator|.
name|Double
name|ptNext
parameter_list|,
name|double
name|r
parameter_list|,
name|double
name|curlAdv
parameter_list|)
block|{
name|double
name|length
init|=
name|pt
operator|.
name|distance
argument_list|(
name|ptNext
argument_list|)
decl_stmt|;
if|if
condition|(
name|Double
operator|.
name|compare
argument_list|(
name|length
argument_list|,
literal|0.0
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|ANGLE_34_DEG
return|;
block|}
name|double
name|e
init|=
name|length
operator|-
name|curlAdv
decl_stmt|;
name|double
name|arg
init|=
operator|(
name|curlAdv
operator|/
literal|2
operator|+
name|e
operator|/
literal|2
operator|)
operator|/
name|r
decl_stmt|;
return|return
operator|(
name|arg
argument_list|<
operator|-
literal|1.0
operator|||
name|arg
argument_list|>
literal|1.0
operator|)
condition|?
literal|0.0
else|:
name|Math
operator|.
name|acos
argument_list|(
name|arg
argument_list|)
return|;
block|}
specifier|private
name|Point2D
operator|.
name|Double
index|[]
name|removeZeroLengthSegments
parameter_list|(
name|Point2D
operator|.
name|Double
index|[]
name|polygon
parameter_list|)
block|{
name|int
name|np
init|=
name|polygon
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|np
operator|<=
literal|2
condition|)
block|{
return|return
name|polygon
return|;
block|}
specifier|final
name|double
name|toler
init|=
literal|0.50
decl_stmt|;
name|int
name|npNew
init|=
name|np
decl_stmt|;
name|Point2D
operator|.
name|Double
name|ptPrev
init|=
name|polygon
index|[
literal|0
index|]
decl_stmt|;
comment|// Don't remove the last point if it equals the first point.
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|np
condition|;
name|i
operator|++
control|)
block|{
name|Point2D
operator|.
name|Double
name|pt
init|=
name|polygon
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|pt
operator|.
name|x
operator|-
name|ptPrev
operator|.
name|x
argument_list|)
operator|<
name|toler
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|pt
operator|.
name|y
operator|-
name|ptPrev
operator|.
name|y
argument_list|)
operator|<
name|toler
condition|)
block|{
name|polygon
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
name|npNew
operator|--
expr_stmt|;
block|}
name|ptPrev
operator|=
name|pt
expr_stmt|;
block|}
if|if
condition|(
name|npNew
operator|==
name|np
condition|)
block|{
return|return
name|polygon
return|;
block|}
name|Point2D
operator|.
name|Double
index|[]
name|polygonNew
init|=
operator|new
name|Point2D
operator|.
name|Double
index|[
name|npNew
index|]
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|np
condition|;
name|i
operator|++
control|)
block|{
name|Point2D
operator|.
name|Double
name|pt
init|=
name|polygon
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pt
operator|!=
literal|null
condition|)
block|{
name|polygonNew
index|[
name|j
operator|++
index|]
operator|=
name|pt
expr_stmt|;
block|}
block|}
return|return
name|polygonNew
return|;
block|}
comment|/**      * Draws an ellipse without a cloudy border effect.      */
specifier|private
name|void
name|drawBasicEllipse
parameter_list|(
name|double
name|left
parameter_list|,
name|double
name|bottom
parameter_list|,
name|double
name|right
parameter_list|,
name|double
name|top
parameter_list|)
throws|throws
name|IOException
block|{
name|double
name|rx
init|=
name|Math
operator|.
name|abs
argument_list|(
name|right
operator|-
name|left
argument_list|)
operator|/
literal|2
decl_stmt|;
name|double
name|ry
init|=
name|Math
operator|.
name|abs
argument_list|(
name|top
operator|-
name|bottom
argument_list|)
operator|/
literal|2
decl_stmt|;
name|double
name|cx
init|=
operator|(
name|left
operator|+
name|right
operator|)
operator|/
literal|2
decl_stmt|;
name|double
name|cy
init|=
operator|(
name|bottom
operator|+
name|top
operator|)
operator|/
literal|2
decl_stmt|;
name|getArc
argument_list|(
literal|0
argument_list|,
literal|2
operator|*
name|Math
operator|.
name|PI
argument_list|,
name|rx
argument_list|,
name|ry
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|beginOutput
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
throws|throws
name|IOException
block|{
name|bboxMinX
operator|=
name|x
expr_stmt|;
name|bboxMinY
operator|=
name|y
expr_stmt|;
name|bboxMaxX
operator|=
name|x
expr_stmt|;
name|bboxMaxY
operator|=
name|y
expr_stmt|;
name|outputStarted
operator|=
literal|true
expr_stmt|;
comment|// Set line join to bevel to avoid spikes
name|output
operator|.
name|setLineJoinStyle
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|updateBBox
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
block|{
name|bboxMinX
operator|=
name|Math
operator|.
name|min
argument_list|(
name|bboxMinX
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|bboxMinY
operator|=
name|Math
operator|.
name|min
argument_list|(
name|bboxMinY
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bboxMaxX
operator|=
name|Math
operator|.
name|max
argument_list|(
name|bboxMaxX
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|bboxMaxY
operator|=
name|Math
operator|.
name|max
argument_list|(
name|bboxMaxY
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|moveTo
parameter_list|(
name|Point2D
operator|.
name|Double
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|moveTo
argument_list|(
name|p
operator|.
name|x
argument_list|,
name|p
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|moveTo
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|outputStarted
condition|)
block|{
name|updateBBox
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|beginOutput
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|moveTo
argument_list|(
operator|(
name|float
operator|)
name|x
argument_list|,
operator|(
name|float
operator|)
name|y
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|lineTo
parameter_list|(
name|Point2D
operator|.
name|Double
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|lineTo
argument_list|(
name|p
operator|.
name|x
argument_list|,
name|p
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|lineTo
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|outputStarted
condition|)
block|{
name|updateBBox
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|beginOutput
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|lineTo
argument_list|(
operator|(
name|float
operator|)
name|x
argument_list|,
operator|(
name|float
operator|)
name|y
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|curveTo
parameter_list|(
name|double
name|ax
parameter_list|,
name|double
name|ay
parameter_list|,
name|double
name|bx
parameter_list|,
name|double
name|by
parameter_list|,
name|double
name|cx
parameter_list|,
name|double
name|cy
parameter_list|)
throws|throws
name|IOException
block|{
name|updateBBox
argument_list|(
name|ax
argument_list|,
name|ay
argument_list|)
expr_stmt|;
name|updateBBox
argument_list|(
name|bx
argument_list|,
name|by
argument_list|)
expr_stmt|;
name|updateBBox
argument_list|(
name|cx
argument_list|,
name|cy
argument_list|)
expr_stmt|;
name|output
operator|.
name|curveTo
argument_list|(
operator|(
name|float
operator|)
name|ax
argument_list|,
operator|(
name|float
operator|)
name|ay
argument_list|,
operator|(
name|float
operator|)
name|bx
argument_list|,
operator|(
name|float
operator|)
name|by
argument_list|,
operator|(
name|float
operator|)
name|cx
argument_list|,
operator|(
name|float
operator|)
name|cy
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|finish
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|outputStarted
condition|)
block|{
name|output
operator|.
name|closePath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lineWidth
operator|>
literal|0
condition|)
block|{
name|double
name|d
init|=
name|lineWidth
operator|/
literal|2
decl_stmt|;
name|bboxMinX
operator|-=
name|d
expr_stmt|;
name|bboxMinY
operator|-=
name|d
expr_stmt|;
name|bboxMaxX
operator|+=
name|d
expr_stmt|;
name|bboxMaxY
operator|+=
name|d
expr_stmt|;
block|}
block|}
specifier|private
name|double
name|getEllipseCloudRadius
parameter_list|()
block|{
comment|// Equation deduced from Acrobat Reader's appearance streams. Circle
comment|// annotations have a slightly larger radius than Polygons and Squares.
return|return
literal|4.75
operator|*
name|intensity
operator|+
literal|0.5
operator|*
name|lineWidth
return|;
block|}
specifier|private
name|double
name|getPolygonCloudRadius
parameter_list|()
block|{
comment|// Equation deduced from Acrobat Reader's appearance streams.
return|return
literal|4
operator|*
name|intensity
operator|+
literal|0.5
operator|*
name|lineWidth
return|;
block|}
block|}
end_class

end_unit

