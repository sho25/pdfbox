begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|afm
operator|.
name|AFMParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|afm
operator|.
name|FontMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|cmap
operator|.
name|CMapParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|cmap
operator|.
name|CMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|AFMEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|DictionaryEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|Encoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|EncodingManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|Type1Encoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|conversion
operator|.
name|CMapSubstitution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|COSArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|COSObjectable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDMatrix
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRectangle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|ResourceLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Graphics
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|AffineTransform
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_comment
comment|/**  * This is the base class for all PDF fonts.  *  * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  * @version $Revision: 1.46 $  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|PDFont
implements|implements
name|COSObjectable
block|{
comment|/**      * Log instance.      */
specifier|private
specifier|static
specifier|final
name|Log
name|log
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PDFont
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The cos dictionary for this font.      */
specifier|protected
name|COSDictionary
name|font
decl_stmt|;
comment|/**      * This is only used if this is a font object and it has an encoding.      */
specifier|private
name|Encoding
name|fontEncoding
init|=
literal|null
decl_stmt|;
comment|/**      * This is only used if this is a font object and it has an encoding and it is      * a type0 font with a cmap.      */
specifier|protected
name|CMap
name|cmap
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|CMap
argument_list|>
name|cmapObjects
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|CMap
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * The static map of the default Adobe font metrics.      */
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|FontMetric
argument_list|>
name|afmObjects
init|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|getAdobeFontMetrics
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|FontMetric
argument_list|>
name|getAdobeFontMetrics
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|FontMetric
argument_list|>
name|metrics
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|FontMetric
argument_list|>
argument_list|()
decl_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Courier-Bold"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Courier-BoldOblique"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Courier"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Courier-Oblique"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Helvetica"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Helvetica-Bold"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Helvetica-BoldOblique"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Helvetica-Oblique"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Symbol"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Times-Bold"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Times-BoldItalic"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Times-Italic"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"Times-Roman"
argument_list|)
expr_stmt|;
name|addAdobeFontMetric
argument_list|(
name|metrics
argument_list|,
literal|"ZapfDingbats"
argument_list|)
expr_stmt|;
return|return
name|metrics
return|;
block|}
specifier|private
specifier|static
name|String
name|resourceRootCMAP
init|=
literal|"org/apache/pdfbox/resources/cmap/"
decl_stmt|;
specifier|private
specifier|static
name|String
name|resourceRootAFM
init|=
literal|"org/apache/pdfbox/resources/afm/"
decl_stmt|;
specifier|private
specifier|static
name|void
name|addAdobeFontMetric
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|FontMetric
argument_list|>
name|metrics
parameter_list|,
name|String
name|name
parameter_list|)
block|{
try|try
block|{
name|String
name|resource
init|=
name|resourceRootAFM
operator|+
name|name
operator|+
literal|".afm"
decl_stmt|;
name|InputStream
name|afmStream
init|=
name|ResourceLoader
operator|.
name|loadResource
argument_list|(
name|resource
argument_list|)
decl_stmt|;
if|if
condition|(
name|afmStream
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|AFMParser
name|parser
init|=
operator|new
name|AFMParser
argument_list|(
name|afmStream
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|parser
operator|.
name|getResult
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|afmStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
comment|/**      * This will clear AFM resources that are stored statically.      * This is usually not a problem unless you want to reclaim      * resources for a long running process.      *      * SPECIAL NOTE: The font calculations are currently in COSObject, which      * is where they will reside until PDFont is mature enough to take them over.      * PDFont is the appropriate place for them and not in COSObject but we need font      * calculations for text extraction.  THIS METHOD WILL BE MOVED OR REMOVED      * TO ANOTHER LOCATION IN A FUTURE VERSION OF PDFBOX.      */
specifier|public
specifier|static
name|void
name|clearResources
parameter_list|()
block|{
name|cmapObjects
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Constructor.      */
specifier|public
name|PDFont
parameter_list|()
block|{
name|font
operator|=
operator|new
name|COSDictionary
argument_list|()
expr_stmt|;
name|font
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|,
name|COSName
operator|.
name|FONT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *      * @param fontDictionary The font dictionary according to the PDF specification.      */
specifier|public
name|PDFont
parameter_list|(
name|COSDictionary
name|fontDictionary
parameter_list|)
block|{
name|font
operator|=
name|fontDictionary
expr_stmt|;
name|determineEncoding
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|determineEncoding
parameter_list|()
block|{
name|String
name|cmapName
init|=
literal|null
decl_stmt|;
name|COSName
name|encodingName
init|=
literal|null
decl_stmt|;
name|COSBase
name|toUnicode
init|=
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|TO_UNICODE
argument_list|)
decl_stmt|;
name|COSBase
name|encoding
init|=
name|getEncodingObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|toUnicode
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|toUnicode
operator|instanceof
name|COSStream
condition|)
block|{
try|try
block|{
name|parseCmap
argument_list|(
literal|null
argument_list|,
operator|(
operator|(
name|COSStream
operator|)
name|toUnicode
operator|)
operator|.
name|getUnfilteredStream
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error: Could not load embedded CMAP"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|toUnicode
operator|instanceof
name|COSName
condition|)
block|{
name|encodingName
operator|=
operator|(
name|COSName
operator|)
name|toUnicode
expr_stmt|;
name|cmap
operator|=
name|cmapObjects
operator|.
name|get
argument_list|(
name|encodingName
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap
operator|==
literal|null
condition|)
block|{
name|cmapName
operator|=
name|encodingName
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|encoding
operator|instanceof
name|COSName
condition|)
block|{
if|if
condition|(
name|cmap
operator|==
literal|null
condition|)
block|{
name|encodingName
operator|=
operator|(
name|COSName
operator|)
name|encoding
expr_stmt|;
name|cmap
operator|=
name|cmapObjects
operator|.
name|get
argument_list|(
name|encodingName
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap
operator|==
literal|null
condition|)
block|{
name|cmapName
operator|=
name|encodingName
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmap
operator|==
literal|null
operator|&&
name|cmapName
operator|!=
literal|null
condition|)
block|{
name|EncodingManager
name|manager
init|=
name|getEncodingManager
argument_list|()
decl_stmt|;
try|try
block|{
name|fontEncoding
operator|=
name|manager
operator|.
name|getEncoding
argument_list|(
name|encodingName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Debug: Could not find encoding for "
operator|+
name|encodingName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|encoding
operator|instanceof
name|COSDictionary
condition|)
block|{
try|try
block|{
name|fontEncoding
operator|=
operator|new
name|DictionaryEncoding
argument_list|(
operator|(
name|COSDictionary
operator|)
name|encoding
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error: Could not create the DictionaryEncoding"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|encoding
operator|instanceof
name|COSStream
condition|)
block|{
if|if
condition|(
name|cmap
operator|==
literal|null
condition|)
block|{
name|COSStream
name|encodingStream
init|=
operator|(
name|COSStream
operator|)
name|encoding
decl_stmt|;
try|try
block|{
name|parseCmap
argument_list|(
literal|null
argument_list|,
name|encodingStream
operator|.
name|getUnfilteredStream
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error: Could not parse the embedded CMAP"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|COSDictionary
name|cidsysteminfo
init|=
operator|(
name|COSDictionary
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|CIDSYSTEMINFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|cidsysteminfo
operator|!=
literal|null
condition|)
block|{
name|String
name|ordering
init|=
name|cidsysteminfo
operator|.
name|getString
argument_list|(
name|COSName
operator|.
name|ORDERING
argument_list|)
decl_stmt|;
name|String
name|registry
init|=
name|cidsysteminfo
operator|.
name|getString
argument_list|(
name|COSName
operator|.
name|REGISTRY
argument_list|)
decl_stmt|;
name|int
name|supplement
init|=
name|cidsysteminfo
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|SUPPLEMENT
argument_list|)
decl_stmt|;
name|cmapName
operator|=
name|registry
operator|+
literal|"-"
operator|+
name|ordering
operator|+
literal|"-"
operator|+
name|supplement
expr_stmt|;
name|cmapName
operator|=
name|CMapSubstitution
operator|.
name|substituteCMap
argument_list|(
name|cmapName
argument_list|)
expr_stmt|;
name|cmap
operator|=
name|cmapObjects
operator|.
name|get
argument_list|(
name|cmapName
argument_list|)
expr_stmt|;
block|}
name|FontMetric
name|metric
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|null
condition|)
block|{
name|fontEncoding
operator|=
operator|new
name|AFMEncoding
argument_list|(
name|metric
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmap
operator|==
literal|null
operator|&&
name|cmapName
operator|!=
literal|null
condition|)
block|{
name|String
name|resourceName
init|=
name|resourceRootCMAP
operator|+
name|cmapName
decl_stmt|;
try|try
block|{
name|parseCmap
argument_list|(
name|resourceRootCMAP
argument_list|,
name|ResourceLoader
operator|.
name|loadResource
argument_list|(
name|resourceName
argument_list|)
argument_list|,
name|encodingName
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap
operator|==
literal|null
operator|&&
name|encodingName
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error: Could not parse predefined CMAP file for '"
operator|+
name|cmapName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error: Could not find predefined CMAP file for '"
operator|+
name|cmapName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|//        if (fontEncoding == null)
comment|//        {
name|getEncodingFromFont
argument_list|()
expr_stmt|;
comment|//        }
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|COSBase
name|getCOSObject
parameter_list|()
block|{
return|return
name|font
return|;
block|}
comment|/**      * This will get the font width for a character.      *      * @param c The character code to get the width for.      * @param offset The offset into the array.      * @param length The length of the data.      *      * @return The width is in 1000 unit of text space, ie 333 or 777      *      * @throws IOException If an error occurs while parsing.      */
specifier|public
specifier|abstract
name|float
name|getFontWidth
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * This will get the font width for a character.      *      * @param c The character code to get the width for.      * @param offset The offset into the array.      * @param length The length of the data.      *      * @return The width is in 1000 unit of text space, ie 333 or 777      *      * @throws IOException If an error occurs while parsing.      */
specifier|public
specifier|abstract
name|float
name|getFontHeight
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * This will get the width of this string for this font.      *      * @param string The string to get the width of.      *      * @return The width of the string in 1000 units of text space, ie 333 567...      *      * @throws IOException If there is an error getting the width information.      */
specifier|public
name|float
name|getStringWidth
parameter_list|(
name|String
name|string
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|data
init|=
name|string
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|float
name|totalWidth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|totalWidth
operator|+=
name|getFontWidth
argument_list|(
name|data
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|totalWidth
return|;
block|}
comment|/**      * This will get the average font width for all characters.      *      * @return The width is in 1000 unit of text space, ie 333 or 777      *      * @throws IOException If an error occurs while parsing.      */
specifier|public
specifier|abstract
name|float
name|getAverageFontWidth
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**      * This will draw a string on a canvas using the font.      *      * @param string The string to draw.      * @param g The graphics to draw onto.      * @param fontSize The size of the font to draw.      * @param at The transformation matrix with all infos for scaling and shearing of the font.      * @param x The x coordinate to draw at.      * @param y The y coordinate to draw at.      *      * @throws IOException If there is an error drawing the specific string.      */
specifier|public
specifier|abstract
name|void
name|drawString
parameter_list|(
name|String
name|string
parameter_list|,
name|Graphics
name|g
parameter_list|,
name|float
name|fontSize
parameter_list|,
name|AffineTransform
name|at
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Used for multibyte encodings.      *      * @param data The array of data.      * @param offset The offset into the array.      * @param length The number of bytes to use.      *      * @return The int value of data from the array.      */
specifier|protected
name|int
name|getCodeFromArray
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|code
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|code
operator|<<=
literal|8
expr_stmt|;
name|code
operator||=
operator|(
name|data
index|[
name|offset
operator|+
name|i
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
comment|/**      * This will attempt to get the font width from an AFM file.      *      * @param code The character code we are trying to get.      *      * @return The font width from the AFM file.      *      * @throws IOException if we cannot find the width.      */
specifier|protected
name|float
name|getFontWidthFromAFMFile
parameter_list|(
name|int
name|code
parameter_list|)
throws|throws
name|IOException
block|{
name|float
name|retval
init|=
literal|0
decl_stmt|;
name|FontMetric
name|metric
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|null
condition|)
block|{
name|Encoding
name|encoding
init|=
name|getEncoding
argument_list|()
decl_stmt|;
name|String
name|characterName
init|=
name|encoding
operator|.
name|getName
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|retval
operator|=
name|metric
operator|.
name|getCharacterWidth
argument_list|(
name|characterName
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will attempt to get the average font width from an AFM file.      *      * @return The average font width from the AFM file.      *      * @throws IOException if we cannot find the width.      */
specifier|protected
name|float
name|getAverageFontWidthFromAFMFile
parameter_list|()
throws|throws
name|IOException
block|{
name|float
name|retval
init|=
literal|0
decl_stmt|;
name|FontMetric
name|metric
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|metric
operator|.
name|getAverageCharacterWidth
argument_list|()
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will get an AFM object if one exists.      *      * @return The afm object from the name.      *      */
specifier|protected
name|FontMetric
name|getAFM
parameter_list|()
block|{
if|if
condition|(
name|afm
operator|==
literal|null
condition|)
block|{
name|COSBase
name|baseFont
init|=
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|BASE_FONT
argument_list|)
decl_stmt|;
name|String
name|name
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|baseFont
operator|instanceof
name|COSName
condition|)
block|{
name|name
operator|=
operator|(
operator|(
name|COSName
operator|)
name|baseFont
operator|)
operator|.
name|getName
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|indexOf
argument_list|(
literal|"+"
argument_list|)
operator|>
operator|-
literal|1
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
name|name
operator|.
name|indexOf
argument_list|(
literal|"+"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|baseFont
operator|instanceof
name|COSString
condition|)
block|{
name|COSString
name|string
init|=
operator|(
name|COSString
operator|)
name|baseFont
decl_stmt|;
name|name
operator|=
name|string
operator|.
name|getString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|afm
operator|=
name|afmObjects
operator|.
name|get
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|afm
return|;
block|}
specifier|private
name|FontMetric
name|afm
init|=
literal|null
decl_stmt|;
specifier|private
name|COSBase
name|encodingObject
init|=
literal|null
decl_stmt|;
comment|/**      * cache the {@link COSName#ENCODING} object from      * the font's dictionary since it is called so often.      *<p>      * Use this method instead of      *<pre>      *   font.getDictionaryObject(COSName.ENCODING);      *</pre>      * @return      */
specifier|private
name|COSBase
name|getEncodingObject
parameter_list|()
block|{
if|if
condition|(
name|encodingObject
operator|==
literal|null
condition|)
block|{
name|encodingObject
operator|=
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ENCODING
argument_list|)
expr_stmt|;
block|}
return|return
name|encodingObject
return|;
block|}
comment|/**      * This will perform the encoding of a character if needed.      *      * @param c The character to encode.      * @param offset The offset into the array to get the data      * @param length The number of bytes to read.      *      * @return The value of the encoded character.      *      * @throws IOException If there is an error during the encoding.      */
specifier|public
name|String
name|encode
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|retval
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cmap
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|1
operator|&&
name|cmap
operator|.
name|hasOneByteMappings
argument_list|()
condition|)
block|{
name|retval
operator|=
name|cmap
operator|.
name|lookup
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|2
operator|&&
name|cmap
operator|.
name|hasTwoByteMappings
argument_list|()
condition|)
block|{
name|retval
operator|=
name|cmap
operator|.
name|lookup
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|// there is no cmap but probably an encoding with a suitable mapping
if|if
condition|(
name|retval
operator|==
literal|null
operator|&&
name|length
operator|==
literal|1
condition|)
block|{
name|Encoding
name|encoding
init|=
name|getEncoding
argument_list|()
decl_stmt|;
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|encoding
operator|.
name|getCharacter
argument_list|(
name|getCodeFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
literal|null
operator|&&
name|cmap
operator|==
literal|null
condition|)
block|{
name|retval
operator|=
name|getStringFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|SINGLE_CHAR_STRING
init|=
operator|new
name|String
index|[
literal|256
index|]
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
index|[]
index|[]
name|DOUBLE_CHAR_STRING
init|=
operator|new
name|String
index|[
literal|256
index|]
index|[
literal|256
index|]
decl_stmt|;
static|static
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|SINGLE_CHAR_STRING
index|[
name|i
index|]
operator|=
operator|new
name|String
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
name|i
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|DOUBLE_CHAR_STRING
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|new
name|String
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
name|i
block|,
operator|(
name|byte
operator|)
name|j
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|String
name|getStringFromArray
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|retval
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|1
condition|)
block|{
name|retval
operator|=
name|SINGLE_CHAR_STRING
index|[
operator|(
name|c
index|[
name|offset
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|2
condition|)
block|{
name|retval
operator|=
name|DOUBLE_CHAR_STRING
index|[
operator|(
name|c
index|[
name|offset
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
index|[
operator|(
name|c
index|[
name|offset
operator|+
literal|1
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error:Unknown character length:"
operator|+
name|length
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
specifier|private
name|void
name|parseCmap
parameter_list|(
name|String
name|cmapRoot
parameter_list|,
name|InputStream
name|cmapStream
parameter_list|,
name|COSName
name|encodingName
parameter_list|)
block|{
if|if
condition|(
name|cmapStream
operator|!=
literal|null
condition|)
block|{
name|CMapParser
name|parser
init|=
operator|new
name|CMapParser
argument_list|()
decl_stmt|;
try|try
block|{
name|cmap
operator|=
name|parser
operator|.
name|parse
argument_list|(
name|cmapRoot
argument_list|,
name|cmapStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|encodingName
operator|!=
literal|null
condition|)
block|{
name|cmapObjects
operator|.
name|put
argument_list|(
name|encodingName
operator|.
name|getName
argument_list|()
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{}
block|}
block|}
comment|/**      * The will set the encoding for this font.      *      * @param enc The font encoding.      */
specifier|public
name|void
name|setEncoding
parameter_list|(
name|Encoding
name|enc
parameter_list|)
block|{
name|font
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ENCODING
argument_list|,
name|enc
argument_list|)
expr_stmt|;
name|fontEncoding
operator|=
name|enc
expr_stmt|;
block|}
comment|/**      * This will get or create the encoder.      *      * modified by Christophe Huault : DGBS Strasbourg huault@free.fr october 2004      *      * @return The encoding to use.      *      * @throws IOException If there is an error getting the encoding.      */
specifier|public
name|Encoding
name|getEncoding
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|fontEncoding
return|;
block|}
comment|/**      * This will always return "Font" for fonts.      *      * @return The type of object that this is.      */
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|font
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
return|;
block|}
comment|// Memorized values to avoid repeated dictionary lookups
specifier|private
name|String
name|subtype
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|type1Font
decl_stmt|;
specifier|private
name|boolean
name|trueTypeFont
decl_stmt|;
specifier|private
name|boolean
name|typeFont
decl_stmt|;
comment|/**      * This will get the subtype of font, Type1, Type3, ...      *      * @return The type of font that this is.      */
specifier|public
name|String
name|getSubType
parameter_list|()
block|{
if|if
condition|(
name|subtype
operator|==
literal|null
condition|)
block|{
name|subtype
operator|=
name|font
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|SUBTYPE
argument_list|)
expr_stmt|;
name|type1Font
operator|=
literal|"Type1"
operator|.
name|equals
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
name|trueTypeFont
operator|=
literal|"TrueType"
operator|.
name|equals
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
name|typeFont
operator|=
name|type1Font
operator|||
literal|"Type0"
operator|.
name|equals
argument_list|(
name|subtype
argument_list|)
operator|||
name|trueTypeFont
expr_stmt|;
block|}
return|return
name|subtype
return|;
block|}
specifier|private
name|boolean
name|isType1Font
parameter_list|()
block|{
name|getSubType
argument_list|()
expr_stmt|;
return|return
name|type1Font
return|;
block|}
specifier|private
name|boolean
name|isTrueTypeFont
parameter_list|()
block|{
name|getSubType
argument_list|()
expr_stmt|;
return|return
name|trueTypeFont
return|;
block|}
specifier|private
name|boolean
name|isTypeFont
parameter_list|()
block|{
name|getSubType
argument_list|()
expr_stmt|;
return|return
name|typeFont
return|;
block|}
comment|/**      * The PostScript name of the font.      *      * @return The postscript name of the font.      */
specifier|public
name|String
name|getBaseFont
parameter_list|()
block|{
return|return
name|font
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|BASE_FONT
argument_list|)
return|;
block|}
comment|/**      * Set the PostScript name of the font.      *      * @param baseFont The postscript name for the font.      */
specifier|public
name|void
name|setBaseFont
parameter_list|(
name|String
name|baseFont
parameter_list|)
block|{
name|font
operator|.
name|setName
argument_list|(
name|COSName
operator|.
name|BASE_FONT
argument_list|,
name|baseFont
argument_list|)
expr_stmt|;
block|}
comment|/**      * The code for the first char or -1 if there is none.      *      * @return The code for the first character.      */
specifier|public
name|int
name|getFirstChar
parameter_list|()
block|{
return|return
name|font
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|FIRST_CHAR
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * Set the first character this font supports.      *      * @param firstChar The first character.      */
specifier|public
name|void
name|setFirstChar
parameter_list|(
name|int
name|firstChar
parameter_list|)
block|{
name|font
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|FIRST_CHAR
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
block|}
comment|/**      * The code for the last char or -1 if there is none.      *      * @return The code for the last character.      */
specifier|public
name|int
name|getLastChar
parameter_list|()
block|{
return|return
name|font
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|LAST_CHAR
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * Set the last character this font supports.      *      * @param lastChar The last character.      */
specifier|public
name|void
name|setLastChar
parameter_list|(
name|int
name|lastChar
parameter_list|)
block|{
name|font
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|LAST_CHAR
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
block|}
comment|/**      * The widths of the characters.  This will be null for the standard 14 fonts.      *      * @return The widths of the characters.      */
specifier|public
name|List
name|getWidths
parameter_list|()
block|{
name|COSArray
name|array
init|=
operator|(
name|COSArray
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|WIDTHS
argument_list|)
decl_stmt|;
return|return
name|COSArrayList
operator|.
name|convertFloatCOSArrayToList
argument_list|(
name|array
argument_list|)
return|;
block|}
comment|/**      * Set the widths of the characters code.      *      * @param widths The widths of the character codes.      */
specifier|public
name|void
name|setWidths
parameter_list|(
name|List
name|widths
parameter_list|)
block|{
name|font
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|WIDTHS
argument_list|,
name|COSArrayList
operator|.
name|converterToCOSArray
argument_list|(
name|widths
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will get the matrix that is used to transform glyph space to      * text space.  By default there are 1000 glyph units to 1 text space      * unit, but type3 fonts can use any value.      *      * Note:If this is a type3 font then it can be modified via the PDType3Font.setFontMatrix, otherwise this      * is a read-only property.      *      * @return The matrix to transform from glyph space to text space.      */
specifier|public
name|PDMatrix
name|getFontMatrix
parameter_list|()
block|{
name|PDMatrix
name|matrix
init|=
literal|null
decl_stmt|;
name|COSArray
name|array
init|=
operator|(
name|COSArray
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_MATRIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|==
literal|null
condition|)
block|{
name|array
operator|=
operator|new
name|COSArray
argument_list|()
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
operator|new
name|COSFloat
argument_list|(
literal|0.001f
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
operator|new
name|COSFloat
argument_list|(
literal|0.001f
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
name|matrix
operator|=
operator|new
name|PDMatrix
argument_list|(
name|array
argument_list|)
expr_stmt|;
return|return
name|matrix
return|;
block|}
comment|/**      * Tries to get the encoding for the type1 font.      *      */
specifier|private
name|void
name|getEncodingFromFont
parameter_list|()
block|{
comment|// This whole section of code needs to be replaced with an actual type1 font parser!!
comment|// Get the font program from the embedded type font.
if|if
condition|(
name|isType1Font
argument_list|()
condition|)
block|{
name|COSDictionary
name|fontDescriptor
init|=
operator|(
name|COSDictionary
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_DESC
argument_list|)
decl_stmt|;
if|if
condition|(
name|fontDescriptor
operator|!=
literal|null
condition|)
block|{
name|COSStream
name|fontFile
init|=
operator|(
name|COSStream
operator|)
name|fontDescriptor
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
name|fontFile
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|fontFile
operator|.
name|getUnfilteredStream
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// this section parses the font program stream searching for a /Encoding entry
comment|// if it contains an array of values a Type1Encoding will be returned
comment|// if it encoding contains an encoding name the corresponding Encoding will be returned
name|String
name|line
init|=
literal|""
decl_stmt|;
name|Type1Encoding
name|encoding
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"currentdict end"
argument_list|)
condition|)
block|{
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
name|fontEncoding
operator|=
name|encoding
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"/Encoding"
argument_list|)
condition|)
block|{
if|if
condition|(
name|line
operator|.
name|endsWith
argument_list|(
literal|"array"
argument_list|)
condition|)
block|{
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|line
argument_list|)
decl_stmt|;
comment|// ignore the first token
name|st
operator|.
name|nextElement
argument_list|()
expr_stmt|;
name|int
name|arraySize
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
argument_list|)
decl_stmt|;
name|encoding
operator|=
operator|new
name|Type1Encoding
argument_list|(
name|arraySize
argument_list|)
expr_stmt|;
block|}
comment|// if there is already an encoding, we don't need to
comment|// assign another one
elseif|else
if|if
condition|(
name|fontEncoding
operator|==
literal|null
condition|)
block|{
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|line
argument_list|)
decl_stmt|;
comment|// ignore the first token
name|st
operator|.
name|nextElement
argument_list|()
expr_stmt|;
name|String
name|type1Encoding
init|=
name|st
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|fontEncoding
operator|=
name|getEncodingManager
argument_list|()
operator|.
name|getEncoding
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
name|type1Encoding
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"dup"
argument_list|)
condition|)
block|{
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|line
argument_list|)
decl_stmt|;
comment|// ignore the first token
name|st
operator|.
name|nextElement
argument_list|()
expr_stmt|;
name|int
name|index
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|st
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|encoding
operator|.
name|addCharacterEncoding
argument_list|(
name|index
argument_list|,
name|name
operator|.
name|replace
argument_list|(
literal|"/"
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error: Could not extract the encoding from the embedded type1 font."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * This will get the fonts bounding box.      *      * @return The fonts bounding box.      *      * @throws IOException If there is an error getting the bounding box.      */
specifier|public
specifier|abstract
name|PDRectangle
name|getFontBoundingBox
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**      * {@inheritDoc}      */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|other
operator|instanceof
name|PDFont
operator|&&
operator|(
operator|(
name|PDFont
operator|)
name|other
operator|)
operator|.
name|getCOSObject
argument_list|()
operator|==
name|this
operator|.
name|getCOSObject
argument_list|()
return|;
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCOSObject
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|EncodingManager
name|encodingManager
init|=
literal|null
decl_stmt|;
specifier|protected
specifier|static
name|EncodingManager
name|getEncodingManager
parameter_list|()
block|{
if|if
condition|(
name|encodingManager
operator|==
literal|null
condition|)
block|{
name|encodingManager
operator|=
operator|new
name|EncodingManager
argument_list|()
expr_stmt|;
block|}
return|return
name|encodingManager
return|;
block|}
block|}
end_class

end_unit

