begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|afm
operator|.
name|FontMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|cmap
operator|.
name|CMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|cmap
operator|.
name|CMapParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|DictionaryEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|Encoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|COSArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|COSObjectable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDMatrix
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRectangle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|ResourceLoader
import|;
end_import

begin_comment
comment|/**  * This is the base class for all PDF fonts.  *   * @author Ben Litchfield  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|PDFont
implements|implements
name|COSObjectable
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PDFont
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|SPACE_BYTES
init|=
block|{
operator|(
name|byte
operator|)
literal|32
block|}
decl_stmt|;
comment|// formerly in PDSimpleFont
specifier|protected
specifier|static
specifier|final
name|String
name|resourceRootCMAP
init|=
literal|"org/apache/pdfbox/resources/cmap/"
decl_stmt|;
specifier|protected
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|CMap
argument_list|>
name|cmapObjects
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|CMap
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// todo: why synchronized?
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|SINGLE_CHAR_STRING
init|=
operator|new
name|String
index|[
literal|256
index|]
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
index|[]
index|[]
name|DOUBLE_CHAR_STRING
init|=
operator|new
name|String
index|[
literal|256
index|]
index|[
literal|256
index|]
decl_stmt|;
static|static
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|SINGLE_CHAR_STRING
index|[
name|i
index|]
operator|=
operator|new
name|String
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
name|i
block|}
argument_list|,
literal|"ISO-8859-1"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
comment|// Nothing should happen here
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
try|try
block|{
name|DOUBLE_CHAR_STRING
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|new
name|String
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
name|i
block|,
operator|(
name|byte
operator|)
name|j
block|}
argument_list|,
literal|"UTF-16BE"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
comment|// Nothing should happen here
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|String
name|getStringFromArray
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|retval
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|1
condition|)
block|{
name|retval
operator|=
name|SINGLE_CHAR_STRING
index|[
operator|(
name|c
index|[
name|offset
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|2
condition|)
block|{
name|retval
operator|=
name|DOUBLE_CHAR_STRING
index|[
operator|(
name|c
index|[
name|offset
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
index|[
operator|(
name|c
index|[
name|offset
operator|+
literal|1
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error:Unknown character length:"
operator|+
name|length
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * The Font dictionary.      */
specifier|protected
name|COSDictionary
name|dict
decl_stmt|;
comment|/**      * The font matrix.      */
specifier|protected
name|PDMatrix
name|fontMatrix
init|=
literal|null
decl_stmt|;
comment|// CMap / Encoding
specifier|protected
name|CMap
name|cmap
init|=
literal|null
decl_stmt|;
comment|// only used when this is a Type0 font with a CMap
specifier|protected
name|Encoding
name|fontEncoding
init|=
literal|null
decl_stmt|;
comment|// only used when this font has an encoding
comment|// the CMap holding the ToUnicode mapping
specifier|private
name|CMap
name|toUnicodeCmap
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|hasToUnicode
init|=
literal|false
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|widths
init|=
literal|null
decl_stmt|;
specifier|private
name|PDFontDescriptor
name|fontDescriptor
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|widthsAreMissing
init|=
literal|false
decl_stmt|;
comment|// formerly in PDSimpleFont
specifier|private
specifier|final
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Float
argument_list|>
name|fontSizes
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Float
argument_list|>
argument_list|(
literal|128
argument_list|)
decl_stmt|;
specifier|private
name|float
name|avgFontWidth
init|=
literal|0.0f
decl_stmt|;
specifier|private
name|float
name|avgFontHeight
init|=
literal|0.0f
decl_stmt|;
specifier|private
name|float
name|fontWidthOfSpace
init|=
operator|-
literal|1f
decl_stmt|;
comment|/**      * This will clear AFM resources that are stored statically. This is usually not a problem      * unless you want to reclaim resources for a long running process.      *       * SPECIAL NOTE: The font calculations are currently in COSObject, which is where they will      * reside until PDFont is mature enough to take them over. PDFont is the appropriate place for      * them and not in COSObject but we need font calculations for text extraction. THIS METHOD WILL      * BE MOVED OR REMOVED TO ANOTHER LOCATION IN A FUTURE VERSION OF PDFBOX.      *      * @deprecated This method will be removed in a future version of PDFBox.      */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|void
name|clearResources
parameter_list|()
block|{
name|cmapObjects
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Constructor.      */
specifier|protected
name|PDFont
parameter_list|()
block|{
name|dict
operator|=
operator|new
name|COSDictionary
argument_list|()
expr_stmt|;
name|dict
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|,
name|COSName
operator|.
name|FONT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param fontDictionary The font dictionary according to the PDF specification.      */
specifier|protected
name|PDFont
parameter_list|(
name|COSDictionary
name|fontDictionary
parameter_list|)
block|{
name|dict
operator|=
name|fontDictionary
expr_stmt|;
name|determineEncoding
argument_list|()
expr_stmt|;
block|}
comment|/**      * This will get the font descriptor for this font.      *       * @return The font descriptor for this font.      */
specifier|public
name|PDFontDescriptor
name|getFontDescriptor
parameter_list|()
block|{
if|if
condition|(
name|fontDescriptor
operator|==
literal|null
condition|)
block|{
name|COSDictionary
name|fd
init|=
operator|(
name|COSDictionary
operator|)
name|dict
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_DESC
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
literal|null
condition|)
block|{
name|fontDescriptor
operator|=
operator|new
name|PDFontDescriptorDictionary
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FontMetric
name|afm
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|afm
operator|!=
literal|null
condition|)
block|{
name|fontDescriptor
operator|=
operator|new
name|PDFontDescriptorAFM
argument_list|(
name|afm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|fontDescriptor
return|;
block|}
comment|/**      * Determines the encoding for the font. This method as to be overwritten, as there are      * different possibilities to define a mapping.      */
specifier|protected
name|void
name|determineEncoding
parameter_list|()
block|{
name|COSBase
name|encoding
init|=
name|dict
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
name|Encoding
name|fontEncoding
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|encoding
operator|instanceof
name|COSName
condition|)
block|{
name|COSName
name|encodingName
init|=
operator|(
name|COSName
operator|)
name|encoding
decl_stmt|;
try|try
block|{
name|fontEncoding
operator|=
name|Encoding
operator|.
name|getInstance
argument_list|(
name|encodingName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Debug: Could not find encoding for "
operator|+
name|encodingName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|encoding
operator|instanceof
name|COSDictionary
condition|)
block|{
try|try
block|{
name|fontEncoding
operator|=
operator|new
name|DictionaryEncoding
argument_list|(
operator|(
name|COSDictionary
operator|)
name|encoding
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error: Could not create the DictionaryEncoding"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|this
operator|.
name|fontEncoding
operator|=
name|fontEncoding
expr_stmt|;
name|extractToUnicodeEncoding
argument_list|()
expr_stmt|;
block|}
specifier|protected
specifier|final
name|void
name|extractToUnicodeEncoding
parameter_list|()
block|{
name|COSName
name|encodingName
decl_stmt|;
name|String
name|cmapName
decl_stmt|;
name|COSBase
name|toUnicode
init|=
name|dict
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|TO_UNICODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|toUnicode
operator|!=
literal|null
condition|)
block|{
name|hasToUnicode
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|toUnicode
operator|instanceof
name|COSStream
condition|)
block|{
try|try
block|{
name|InputStream
name|is
init|=
operator|(
operator|(
name|COSStream
operator|)
name|toUnicode
operator|)
operator|.
name|getUnfilteredStream
argument_list|()
decl_stmt|;
name|toUnicodeCmap
operator|=
name|parseCmap
argument_list|(
name|resourceRootCMAP
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error: Could not load embedded ToUnicode CMap"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|toUnicode
operator|instanceof
name|COSName
condition|)
block|{
name|encodingName
operator|=
operator|(
name|COSName
operator|)
name|toUnicode
expr_stmt|;
name|toUnicodeCmap
operator|=
name|cmapObjects
operator|.
name|get
argument_list|(
name|encodingName
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|toUnicodeCmap
operator|==
literal|null
condition|)
block|{
name|cmapName
operator|=
name|encodingName
operator|.
name|getName
argument_list|()
expr_stmt|;
name|String
name|resourceName
init|=
name|resourceRootCMAP
operator|+
name|cmapName
decl_stmt|;
try|try
block|{
name|toUnicodeCmap
operator|=
name|parseCmap
argument_list|(
name|resourceRootCMAP
argument_list|,
name|ResourceLoader
operator|.
name|loadResource
argument_list|(
name|resourceName
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error: Could not find predefined ToUnicode CMap file for '"
operator|+
name|cmapName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toUnicodeCmap
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error: Could not parse predefined ToUnicode CMap file for '"
operator|+
name|cmapName
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|COSBase
name|getCOSObject
parameter_list|()
block|{
return|return
name|dict
return|;
block|}
comment|/**      * This will get the font width for a character.      *       * @param c The character code to get the width for.      * @param offset The offset into the array.      * @param length The length of the data.      * @return The width is in 1000 unit of text space, ie 333 or 777      * @throws IOException If an error occurs while parsing.      */
specifier|public
name|float
name|getFontWidth
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|code
init|=
name|getCodeFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|Float
name|fontWidth
init|=
name|fontSizes
operator|.
name|get
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|fontWidth
operator|==
literal|null
condition|)
block|{
name|fontWidth
operator|=
name|getFontWidth
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontWidth
operator|<=
literal|0
condition|)
block|{
comment|// TODO should this be in PDType1Font??
name|fontWidth
operator|=
name|getFontWidthFromAFMFile
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
name|fontSizes
operator|.
name|put
argument_list|(
name|code
argument_list|,
name|fontWidth
argument_list|)
expr_stmt|;
block|}
return|return
name|fontWidth
return|;
block|}
comment|/**      * This will get the font height for a character.      *       * @param c The character code to get the height for.      * @param offset The offset into the array.      * @param length The length of the data.      * @return The height is in 1000 unit of text space, ie 333 or 777      * @throws IOException If an error occurs while parsing.      */
specifier|public
name|float
name|getFontHeight
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
comment|// maybe there is already a precalculated value
if|if
condition|(
name|avgFontHeight
operator|>
literal|0
condition|)
block|{
return|return
name|avgFontHeight
return|;
block|}
name|float
name|retval
init|=
literal|0
decl_stmt|;
name|FontMetric
name|metric
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|null
condition|)
block|{
name|int
name|code
init|=
name|getCodeFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|Encoding
name|encoding
init|=
name|getFontEncoding
argument_list|()
decl_stmt|;
name|String
name|characterName
init|=
name|encoding
operator|.
name|getName
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|retval
operator|=
name|metric
operator|.
name|getCharacterHeight
argument_list|(
name|characterName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PDFontDescriptor
name|desc
init|=
name|getFontDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
comment|// the following values are all more or less accurate at least all are average
comment|// values. Maybe we'll find another way to get those value for every single glyph
comment|// in the future if needed
name|PDRectangle
name|fontBBox
init|=
name|desc
operator|.
name|getFontBoundingBox
argument_list|()
decl_stmt|;
if|if
condition|(
name|fontBBox
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|fontBBox
operator|.
name|getHeight
argument_list|()
operator|/
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|desc
operator|.
name|getCapHeight
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|desc
operator|.
name|getAscent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|desc
operator|.
name|getXHeight
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|>
literal|0
condition|)
block|{
name|retval
operator|-=
name|desc
operator|.
name|getDescent
argument_list|()
expr_stmt|;
block|}
block|}
name|avgFontHeight
operator|=
name|retval
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will get the width of this string for this font.      *       * @param string The string to get the width of.      * @return The width of the string in 1000 units of text space, ie 333 567...      * @throws IOException If there is an error getting the width information.      */
specifier|public
name|float
name|getStringWidth
parameter_list|(
name|String
name|string
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|data
init|=
name|string
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
decl_stmt|;
name|float
name|totalWidth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|totalWidth
operator|+=
name|getFontWidth
argument_list|(
name|data
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|totalWidth
return|;
block|}
comment|/**      * This will get the average font width for all characters.      *       * @return The width is in 1000 unit of text space, ie 333 or 777      * @throws IOException If an error occurs while parsing.      */
specifier|public
name|float
name|getAverageFontWidth
parameter_list|()
throws|throws
name|IOException
block|{
name|float
name|average
decl_stmt|;
if|if
condition|(
name|avgFontWidth
operator|!=
literal|0.0f
condition|)
block|{
name|average
operator|=
name|avgFontWidth
expr_stmt|;
block|}
else|else
block|{
name|float
name|totalWidth
init|=
literal|0.0f
decl_stmt|;
name|float
name|characterCount
init|=
literal|0.0f
decl_stmt|;
name|COSArray
name|widths
init|=
operator|(
name|COSArray
operator|)
name|dict
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|WIDTHS
argument_list|)
decl_stmt|;
if|if
condition|(
name|widths
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|widths
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|COSNumber
name|fontWidth
init|=
operator|(
name|COSNumber
operator|)
name|widths
operator|.
name|getObject
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|fontWidth
operator|.
name|floatValue
argument_list|()
operator|>
literal|0
condition|)
block|{
name|totalWidth
operator|+=
name|fontWidth
operator|.
name|floatValue
argument_list|()
expr_stmt|;
name|characterCount
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|totalWidth
operator|>
literal|0
condition|)
block|{
name|average
operator|=
name|totalWidth
operator|/
name|characterCount
expr_stmt|;
block|}
else|else
block|{
name|average
operator|=
name|getAverageFontWidthFromAFMFile
argument_list|()
expr_stmt|;
block|}
name|avgFontWidth
operator|=
name|average
expr_stmt|;
block|}
return|return
name|average
return|;
block|}
comment|/**      * Used for multibyte encodings.      *       * @param data The array of data.      * @param offset The offset into the array.      * @param length The number of bytes to use.      * @return The int value of data from the array.      */
specifier|public
name|int
name|getCodeFromArray
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|code
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|code
operator|<<=
literal|8
expr_stmt|;
name|code
operator||=
operator|(
name|data
index|[
name|offset
operator|+
name|i
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
comment|/**      * This will attempt to get the font width from an AFM file.      *       * @param code The character code we are trying to get.      * @return The font width from the AFM file.      * @throws IOException if we cannot find the width.      */
specifier|private
name|float
name|getFontWidthFromAFMFile
parameter_list|(
name|int
name|code
parameter_list|)
throws|throws
name|IOException
block|{
name|float
name|retval
init|=
literal|0
decl_stmt|;
name|FontMetric
name|metric
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|null
condition|)
block|{
name|String
name|characterName
init|=
name|fontEncoding
operator|.
name|getName
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|retval
operator|=
name|metric
operator|.
name|getCharacterWidth
argument_list|(
name|characterName
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will attempt to get the average font width from an AFM file.      *       * @return The average font width from the AFM file.      * @throws IOException if we cannot find the width.      */
specifier|private
name|float
name|getAverageFontWidthFromAFMFile
parameter_list|()
throws|throws
name|IOException
block|{
name|float
name|retval
init|=
literal|0
decl_stmt|;
name|FontMetric
name|metric
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|metric
operator|.
name|getAverageCharacterWidth
argument_list|()
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will get an AFM object if one exists.      *       * @return The afm object from the name.      */
specifier|protected
name|FontMetric
name|getAFM
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**      * Encode the given value using the CMap of the font.      *       * @param code the code to encode.      * @param length the byte length of the given code.      * @param isCIDFont indicates that the used font is a CID font.      *       * @return The value of the encoded character.      * @throws IOException if something went wrong      */
specifier|protected
specifier|final
name|String
name|cmapEncoding
parameter_list|(
name|int
name|code
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|isCIDFont
parameter_list|,
name|CMap
name|sourceCmap
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|retval
init|=
literal|null
decl_stmt|;
comment|// there is not sourceCmap if this is a descendant font
if|if
condition|(
name|sourceCmap
operator|==
literal|null
condition|)
block|{
name|sourceCmap
operator|=
name|cmap
expr_stmt|;
block|}
if|if
condition|(
name|sourceCmap
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|sourceCmap
operator|.
name|lookup
argument_list|(
name|code
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|null
operator|&&
name|isCIDFont
condition|)
block|{
name|retval
operator|=
name|sourceCmap
operator|.
name|lookupCID
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will perform the encoding of a character if needed.      *       * @param c The character to encode.      * @param offset The offset into the array to get the data      * @param length The number of bytes to read.      * @return The value of the encoded character.      * @throws IOException If there is an error during the encoding.      */
specifier|public
name|String
name|encode
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|retval
init|=
literal|null
decl_stmt|;
name|int
name|code
init|=
name|getCodeFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|toUnicodeCmap
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|cmapEncoding
argument_list|(
name|code
argument_list|,
name|length
argument_list|,
literal|false
argument_list|,
name|toUnicodeCmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
literal|null
operator|&&
name|cmap
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|cmapEncoding
argument_list|(
name|code
argument_list|,
name|length
argument_list|,
literal|false
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
block|}
comment|// there is no cmap but probably an encoding with a suitable mapping
if|if
condition|(
name|retval
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|fontEncoding
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|fontEncoding
operator|.
name|getCharacter
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
literal|null
operator|&&
operator|(
name|cmap
operator|==
literal|null
operator|||
name|length
operator|==
literal|2
operator|)
condition|)
block|{
name|retval
operator|=
name|getStringFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
specifier|public
name|int
name|encodeToCID
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|code
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|encode
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|code
operator|=
name|getCodeFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
comment|/**      * Parse the given CMap.      *       * @param cmapRoot the root path pointing to the provided CMaps      * @param cmapStream the CMap to be read      * @return the parsed CMap      */
specifier|protected
specifier|final
name|CMap
name|parseCmap
parameter_list|(
name|String
name|cmapRoot
parameter_list|,
name|InputStream
name|cmapStream
parameter_list|)
block|{
name|CMap
name|targetCmap
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cmapStream
operator|!=
literal|null
condition|)
block|{
name|CMapParser
name|parser
init|=
operator|new
name|CMapParser
argument_list|()
decl_stmt|;
try|try
block|{
name|targetCmap
operator|=
name|parser
operator|.
name|parse
argument_list|(
name|cmapRoot
argument_list|,
name|cmapStream
argument_list|)
expr_stmt|;
comment|// limit the cache to external CMaps
if|if
condition|(
name|cmapRoot
operator|!=
literal|null
condition|)
block|{
name|cmapObjects
operator|.
name|put
argument_list|(
name|targetCmap
operator|.
name|getName
argument_list|()
argument_list|,
name|targetCmap
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"An error occurs while reading a CMap"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|targetCmap
return|;
block|}
comment|/**      * This will get or create the encoder.      *       * @return The encoding to use.      */
specifier|public
name|Encoding
name|getFontEncoding
parameter_list|()
block|{
return|return
name|fontEncoding
return|;
block|}
comment|/**      * This will always return "Font" for fonts.      *       * @return The type of object that this is.      */
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|dict
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
return|;
block|}
comment|/**      * This will get the subtype of font.      *       * @return The type of font that this is.      */
specifier|public
name|String
name|getSubType
parameter_list|()
block|{
return|return
name|dict
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|SUBTYPE
argument_list|)
return|;
block|}
comment|/**      * Determines if the font is a type 1 font.      *       * @return returns true if the font is a type 1 font      */
specifier|public
name|boolean
name|isType1Font
parameter_list|()
block|{
return|return
literal|"Type1"
operator|.
name|equals
argument_list|(
name|getSubType
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Determines if the font is a type 3 font.      *       * @return returns true if the font is a type 3 font      */
specifier|public
name|boolean
name|isType3Font
parameter_list|()
block|{
return|return
literal|"Type3"
operator|.
name|equals
argument_list|(
name|getSubType
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Determines if the font is a type 0 font.      *       * @return returns true if the font is a type 0 font      */
specifier|public
name|boolean
name|isType0Font
parameter_list|()
block|{
return|return
literal|"Type0"
operator|.
name|equals
argument_list|(
name|getSubType
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Determines if the font is a true type font.      *       * @return returns true if the font is a true type font      */
specifier|public
name|boolean
name|isTrueTypeFont
parameter_list|()
block|{
return|return
literal|"TrueType"
operator|.
name|equals
argument_list|(
name|getSubType
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Determines if the font is a symbolic font.      *       * @return returns true if the font is a symbolic font      */
specifier|public
name|boolean
name|isSymbolicFont
parameter_list|()
block|{
comment|// not all fonts have a font descriptor
if|if
condition|(
name|getFontDescriptor
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|getFontDescriptor
argument_list|()
operator|.
name|isSymbolic
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * The PostScript name of the font.      *       * @return The postscript name of the font.      */
specifier|public
name|String
name|getBaseFont
parameter_list|()
block|{
return|return
name|dict
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|BASE_FONT
argument_list|)
return|;
block|}
comment|/**      * The code for the first char or -1 if there is none.      *       * @return The code for the first character.      */
specifier|public
name|int
name|getFirstChar
parameter_list|()
block|{
return|return
name|dict
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|FIRST_CHAR
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * The code for the last char or -1 if there is none.      *       * @return The code for the last character.      */
specifier|public
name|int
name|getLastChar
parameter_list|()
block|{
return|return
name|dict
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|LAST_CHAR
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * The widths of the characters. This will be null for the standard 14 fonts.      *       * @return The widths of the characters.      */
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|getWidths
parameter_list|()
block|{
if|if
condition|(
name|widths
operator|==
literal|null
operator|&&
operator|!
name|widthsAreMissing
condition|)
block|{
name|COSArray
name|array
init|=
operator|(
name|COSArray
operator|)
name|dict
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|WIDTHS
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
name|widths
operator|=
name|COSArrayList
operator|.
name|convertIntegerCOSArrayToList
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|widthsAreMissing
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|widths
return|;
block|}
comment|/**      * This will get the matrix that is used to transform glyph space to text space. By default      * there are 1000 glyph units to 1 text space unit, but type3 fonts can use any value.      *       * Note: If this is a type3 font then it can be modified via the PDType3Font.setFontMatrix,      * otherwise this is a read-only property.      *       * @return The matrix to transform from glyph space to text space.      */
specifier|public
name|PDMatrix
name|getFontMatrix
parameter_list|()
block|{
if|if
condition|(
name|fontMatrix
operator|==
literal|null
condition|)
block|{
name|COSArray
name|array
init|=
operator|(
name|COSArray
operator|)
name|dict
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_MATRIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|==
literal|null
condition|)
block|{
name|array
operator|=
operator|new
name|COSArray
argument_list|()
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
operator|new
name|COSFloat
argument_list|(
literal|0.001f
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
operator|new
name|COSFloat
argument_list|(
literal|0.001f
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
name|fontMatrix
operator|=
operator|new
name|PDMatrix
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
return|return
name|fontMatrix
return|;
block|}
comment|/**      * This will get the fonts bounding box.      *       * @return The fonts bounding box.      * @throws IOException If there is an error getting the bounding box.      */
specifier|public
name|PDRectangle
name|getFontBoundingBox
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getFontDescriptor
argument_list|()
operator|.
name|getFontBoundingBox
argument_list|()
return|;
block|}
comment|/**      * Determines the width of the given character.      *       * @param charCode the code of the given character      * @return the width of the character      */
specifier|public
name|float
name|getFontWidth
parameter_list|(
name|int
name|charCode
parameter_list|)
block|{
name|float
name|width
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|firstChar
init|=
name|getFirstChar
argument_list|()
decl_stmt|;
name|int
name|lastChar
init|=
name|getLastChar
argument_list|()
decl_stmt|;
if|if
condition|(
name|charCode
operator|>=
name|firstChar
operator|&&
name|charCode
operator|<=
name|lastChar
condition|)
block|{
comment|// maybe the font doesn't provide any widths
if|if
condition|(
operator|!
name|widthsAreMissing
condition|)
block|{
name|getWidths
argument_list|()
expr_stmt|;
if|if
condition|(
name|widths
operator|!=
literal|null
condition|)
block|{
name|width
operator|=
name|widths
operator|.
name|get
argument_list|(
name|charCode
operator|-
name|firstChar
argument_list|)
operator|.
name|floatValue
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|PDFontDescriptor
name|fd
init|=
name|getFontDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|fd
operator|instanceof
name|PDFontDescriptorDictionary
condition|)
block|{
name|width
operator|=
name|fd
operator|.
name|getMissingWidth
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|width
return|;
block|}
comment|/**      * Determines if a font as a ToUnicode entry.      *       * @return true if the font has a ToUnicode entry      */
specifier|public
name|boolean
name|hasToUnicode
parameter_list|()
block|{
return|return
name|hasToUnicode
return|;
block|}
comment|/**      * Determines the width of the space character.      *       * @return the width of the space character      */
specifier|public
name|float
name|getSpaceWidth
parameter_list|()
block|{
if|if
condition|(
name|fontWidthOfSpace
operator|==
operator|-
literal|1f
condition|)
block|{
name|COSBase
name|toUnicode
init|=
name|dict
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|TO_UNICODE
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|toUnicode
operator|!=
literal|null
condition|)
block|{
name|int
name|spaceMapping
init|=
name|toUnicodeCmap
operator|.
name|getSpaceMapping
argument_list|()
decl_stmt|;
if|if
condition|(
name|spaceMapping
operator|>
operator|-
literal|1
condition|)
block|{
name|fontWidthOfSpace
operator|=
name|getFontWidth
argument_list|(
name|spaceMapping
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fontWidthOfSpace
operator|=
name|getFontWidth
argument_list|(
name|SPACE_BYTES
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// use the average font width as fall back
if|if
condition|(
name|fontWidthOfSpace
operator|<=
literal|0
condition|)
block|{
name|fontWidthOfSpace
operator|=
name|getAverageFontWidth
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't determine the width of the space character, assuming 250"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|fontWidthOfSpace
operator|=
literal|250f
expr_stmt|;
block|}
block|}
return|return
name|fontWidthOfSpace
return|;
block|}
comment|/**      * Returns the toUnicode mapping if present.      *       * @return the CMap representing the toUnicode mapping      */
specifier|public
name|CMap
name|getToUnicodeCMap
parameter_list|()
block|{
return|return
name|toUnicodeCmap
return|;
block|}
comment|/**      * Returns the CMap if present.      *       * @return the CMap representing the character encoding      */
specifier|public
name|CMap
name|getCMap
parameter_list|()
block|{
return|return
name|cmap
return|;
block|}
comment|/**      * Calling this will release all cached information.      */
specifier|public
name|void
name|clear
parameter_list|()
block|{     }
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|other
operator|instanceof
name|PDFont
operator|&&
operator|(
operator|(
name|PDFont
operator|)
name|other
operator|)
operator|.
name|getCOSObject
argument_list|()
operator|==
name|this
operator|.
name|getCOSObject
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCOSObject
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
end_class

end_unit

