begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|afm
operator|.
name|FontMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|cmap
operator|.
name|CMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|cmap
operator|.
name|CMapParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|Encoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|COSArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|COSObjectable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDMatrix
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRectangle
import|;
end_import

begin_comment
comment|/**  * This is the base class for all PDF fonts.  *   * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  *   */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|PDFont
implements|implements
name|COSObjectable
block|{
comment|/**      * Log instance.      */
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PDFont
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The cos dictionary for this font.      */
specifier|protected
name|COSDictionary
name|font
decl_stmt|;
comment|/**      * This is only used if this is a font object and it has an encoding.      */
specifier|private
name|Encoding
name|fontEncoding
init|=
literal|null
decl_stmt|;
comment|/**      * The descriptor of the font.      */
specifier|private
name|PDFontDescriptor
name|fontDescriptor
init|=
literal|null
decl_stmt|;
comment|/**      * The font matrix.      */
specifier|protected
name|PDMatrix
name|fontMatrix
init|=
literal|null
decl_stmt|;
comment|/**      * This is only used if this is a font object and it has an encoding and it is a type0 font with a cmap.      */
specifier|protected
name|CMap
name|cmap
init|=
literal|null
decl_stmt|;
comment|/**      * The CMap holding the ToUnicode mapping.      */
specifier|protected
name|CMap
name|toUnicodeCmap
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|hasToUnicode
init|=
literal|false
decl_stmt|;
specifier|protected
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|CMap
argument_list|>
name|cmapObjects
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|CMap
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * A list a floats representing the widths.      */
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|widths
init|=
literal|null
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|resourceRootCMAP
init|=
literal|"org/apache/pdfbox/resources/cmap/"
decl_stmt|;
comment|/**      * This will clear AFM resources that are stored statically. This is usually not a problem unless you want to      * reclaim resources for a long running process.      *       * SPECIAL NOTE: The font calculations are currently in COSObject, which is where they will reside until PDFont is      * mature enough to take them over. PDFont is the appropriate place for them and not in COSObject but we need font      * calculations for text extraction. THIS METHOD WILL BE MOVED OR REMOVED TO ANOTHER LOCATION IN A FUTURE VERSION OF      * PDFBOX.      */
specifier|public
specifier|static
name|void
name|clearResources
parameter_list|()
block|{
name|cmapObjects
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Constructor.      */
specifier|public
name|PDFont
parameter_list|()
block|{
name|font
operator|=
operator|new
name|COSDictionary
argument_list|()
expr_stmt|;
name|font
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|,
name|COSName
operator|.
name|FONT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param fontDictionary The font dictionary according to the PDF specification.      */
specifier|public
name|PDFont
parameter_list|(
name|COSDictionary
name|fontDictionary
parameter_list|)
block|{
name|font
operator|=
name|fontDictionary
expr_stmt|;
name|determineEncoding
argument_list|()
expr_stmt|;
block|}
comment|/**      * This will get the font descriptor for this font.      *       * @return The font descriptor for this font.      *       */
specifier|public
name|PDFontDescriptor
name|getFontDescriptor
parameter_list|()
block|{
if|if
condition|(
name|fontDescriptor
operator|==
literal|null
condition|)
block|{
name|COSDictionary
name|fd
init|=
operator|(
name|COSDictionary
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_DESC
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
literal|null
condition|)
block|{
name|fontDescriptor
operator|=
operator|new
name|PDFontDescriptorDictionary
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FontMetric
name|afm
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|afm
operator|!=
literal|null
condition|)
block|{
name|fontDescriptor
operator|=
operator|new
name|PDFontDescriptorAFM
argument_list|(
name|afm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|fontDescriptor
return|;
block|}
comment|/**      * This will set the font descriptor.      *       * @param fdDictionary The font descriptor.      */
specifier|public
name|void
name|setFontDescriptor
parameter_list|(
name|PDFontDescriptorDictionary
name|fdDictionary
parameter_list|)
block|{
name|COSDictionary
name|dic
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fdDictionary
operator|!=
literal|null
condition|)
block|{
name|dic
operator|=
name|fdDictionary
operator|.
name|getCOSDictionary
argument_list|()
expr_stmt|;
block|}
name|font
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|FONT_DESC
argument_list|,
name|dic
argument_list|)
expr_stmt|;
name|fontDescriptor
operator|=
name|fdDictionary
expr_stmt|;
block|}
comment|/**      * Determines the encoding for the font. This method as to be overwritten, as there are different possibilities to      * define a mapping.      */
specifier|protected
specifier|abstract
name|void
name|determineEncoding
parameter_list|()
function_decl|;
comment|/**      * {@inheritDoc}      */
specifier|public
name|COSBase
name|getCOSObject
parameter_list|()
block|{
return|return
name|font
return|;
block|}
comment|/**      * This will get the font width for a character.      *       * @param c The character code to get the width for.      * @param offset The offset into the array.      * @param length The length of the data.      *       * @return The width is in 1000 unit of text space, ie 333 or 777      *       * @throws IOException If an error occurs while parsing.      */
specifier|public
specifier|abstract
name|float
name|getFontWidth
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * This will get the font height for a character.      *       * @param c The character code to get the height for.      * @param offset The offset into the array.      * @param length The length of the data.      *       * @return The height is in 1000 unit of text space, ie 333 or 777      *       * @throws IOException If an error occurs while parsing.      */
specifier|public
specifier|abstract
name|float
name|getFontHeight
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * This will get the width of this string for this font.      *       * @param string The string to get the width of.      *       * @return The width of the string in 1000 units of text space, ie 333 567...      *       * @throws IOException If there is an error getting the width information.      */
specifier|public
name|float
name|getStringWidth
parameter_list|(
name|String
name|string
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|data
init|=
name|string
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
decl_stmt|;
name|float
name|totalWidth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|totalWidth
operator|+=
name|getFontWidth
argument_list|(
name|data
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|totalWidth
return|;
block|}
comment|/**      * This will get the average font width for all characters.      *       * @return The width is in 1000 unit of text space, ie 333 or 777      *       * @throws IOException If an error occurs while parsing.      */
specifier|public
specifier|abstract
name|float
name|getAverageFontWidth
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**      * Used for multibyte encodings.      *       * @param data The array of data.      * @param offset The offset into the array.      * @param length The number of bytes to use.      *       * @return The int value of data from the array.      */
specifier|public
name|int
name|getCodeFromArray
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|code
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|code
operator|<<=
literal|8
expr_stmt|;
name|code
operator||=
operator|(
name|data
index|[
name|offset
operator|+
name|i
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
comment|/**      * This will attempt to get the font width from an AFM file.      *       * @param code The character code we are trying to get.      *       * @return The font width from the AFM file.      *       * @throws IOException if we cannot find the width.      */
specifier|protected
name|float
name|getFontWidthFromAFMFile
parameter_list|(
name|int
name|code
parameter_list|)
throws|throws
name|IOException
block|{
name|float
name|retval
init|=
literal|0
decl_stmt|;
name|FontMetric
name|metric
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|null
condition|)
block|{
name|String
name|characterName
init|=
name|fontEncoding
operator|.
name|getName
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|retval
operator|=
name|metric
operator|.
name|getCharacterWidth
argument_list|(
name|characterName
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will attempt to get the average font width from an AFM file.      *       * @return The average font width from the AFM file.      *       * @throws IOException if we cannot find the width.      */
specifier|protected
name|float
name|getAverageFontWidthFromAFMFile
parameter_list|()
throws|throws
name|IOException
block|{
name|float
name|retval
init|=
literal|0
decl_stmt|;
name|FontMetric
name|metric
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|metric
operator|.
name|getAverageCharacterWidth
argument_list|()
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will get an AFM object if one exists.      *       * @return The afm object from the name.      *       */
specifier|protected
name|FontMetric
name|getAFM
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|private
name|COSBase
name|encoding
init|=
literal|null
decl_stmt|;
comment|/**      * cache the {@link COSName#ENCODING} object from the font's dictionary since it is called so often.      *<p>      * Use this method instead of      *       *<pre>      * font.getDictionaryObject(COSName.ENCODING);      *</pre>      *       * @return the encoding      */
specifier|protected
name|COSBase
name|getEncoding
parameter_list|()
block|{
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
block|{
name|encoding
operator|=
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ENCODING
argument_list|)
expr_stmt|;
block|}
return|return
name|encoding
return|;
block|}
comment|/**      * Set the encoding object from the fonts dictionary.      *       * @param encodingValue the given encoding.      */
specifier|protected
name|void
name|setEncoding
parameter_list|(
name|COSBase
name|encodingValue
parameter_list|)
block|{
name|font
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ENCODING
argument_list|,
name|encodingValue
argument_list|)
expr_stmt|;
name|encoding
operator|=
name|encodingValue
expr_stmt|;
block|}
comment|/**      * Encode the given value using the CMap of the font.      *       * @param code the code to encode.      * @param length the byte length of the given code.      * @param isCIDFont indicates that the used font is a CID font.      *       * @return The value of the encoded character.      * @throws IOException if something went wrong      */
specifier|protected
name|String
name|cmapEncoding
parameter_list|(
name|int
name|code
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|isCIDFont
parameter_list|,
name|CMap
name|sourceCmap
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|retval
init|=
literal|null
decl_stmt|;
comment|// there is not sourceCmap if this is a descendant font
if|if
condition|(
name|sourceCmap
operator|==
literal|null
condition|)
block|{
name|sourceCmap
operator|=
name|cmap
expr_stmt|;
block|}
if|if
condition|(
name|sourceCmap
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|sourceCmap
operator|.
name|lookup
argument_list|(
name|code
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|null
operator|&&
name|isCIDFont
condition|)
block|{
name|retval
operator|=
name|sourceCmap
operator|.
name|lookupCID
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will perform the encoding of a character if needed.      *       * @param c The character to encode.      * @param offset The offset into the array to get the data      * @param length The number of bytes to read.      *       * @return The value of the encoded character.      *       * @throws IOException If there is an error during the encoding.      */
specifier|public
name|String
name|encode
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|retval
init|=
literal|null
decl_stmt|;
name|int
name|code
init|=
name|getCodeFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|toUnicodeCmap
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|cmapEncoding
argument_list|(
name|code
argument_list|,
name|length
argument_list|,
literal|false
argument_list|,
name|toUnicodeCmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
literal|null
operator|&&
name|cmap
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|cmapEncoding
argument_list|(
name|code
argument_list|,
name|length
argument_list|,
literal|false
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
block|}
comment|// there is no cmap but probably an encoding with a suitable mapping
if|if
condition|(
name|retval
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|fontEncoding
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|fontEncoding
operator|.
name|getCharacter
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
literal|null
operator|&&
operator|(
name|cmap
operator|==
literal|null
operator|||
name|length
operator|==
literal|2
operator|)
condition|)
block|{
name|retval
operator|=
name|getStringFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
specifier|public
name|int
name|encodeToCID
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|code
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|encode
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|code
operator|=
name|getCodeFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|SINGLE_CHAR_STRING
init|=
operator|new
name|String
index|[
literal|256
index|]
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
index|[]
index|[]
name|DOUBLE_CHAR_STRING
init|=
operator|new
name|String
index|[
literal|256
index|]
index|[
literal|256
index|]
decl_stmt|;
static|static
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|SINGLE_CHAR_STRING
index|[
name|i
index|]
operator|=
operator|new
name|String
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
name|i
block|}
argument_list|,
literal|"ISO-8859-1"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
comment|// Nothing should happen here
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
try|try
block|{
name|DOUBLE_CHAR_STRING
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|new
name|String
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
name|i
block|,
operator|(
name|byte
operator|)
name|j
block|}
argument_list|,
literal|"UTF-16BE"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
comment|// Nothing should happen here
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|String
name|getStringFromArray
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|retval
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|1
condition|)
block|{
name|retval
operator|=
name|SINGLE_CHAR_STRING
index|[
operator|(
name|c
index|[
name|offset
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|2
condition|)
block|{
name|retval
operator|=
name|DOUBLE_CHAR_STRING
index|[
operator|(
name|c
index|[
name|offset
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
index|[
operator|(
name|c
index|[
name|offset
operator|+
literal|1
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error:Unknown character length:"
operator|+
name|length
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Parse the given CMap.      *       * @param cmapRoot the root path pointing to the provided CMaps      * @param cmapStream the CMap to be read      * @return the parsed CMap      */
specifier|protected
name|CMap
name|parseCmap
parameter_list|(
name|String
name|cmapRoot
parameter_list|,
name|InputStream
name|cmapStream
parameter_list|)
block|{
name|CMap
name|targetCmap
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cmapStream
operator|!=
literal|null
condition|)
block|{
name|CMapParser
name|parser
init|=
operator|new
name|CMapParser
argument_list|()
decl_stmt|;
try|try
block|{
name|targetCmap
operator|=
name|parser
operator|.
name|parse
argument_list|(
name|cmapRoot
argument_list|,
name|cmapStream
argument_list|)
expr_stmt|;
comment|// limit the cache to external CMaps
if|if
condition|(
name|cmapRoot
operator|!=
literal|null
condition|)
block|{
name|cmapObjects
operator|.
name|put
argument_list|(
name|targetCmap
operator|.
name|getName
argument_list|()
argument_list|,
name|targetCmap
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"An error occurs while reading a CMap"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|targetCmap
return|;
block|}
comment|/**      * The will set the encoding for this font.      *       * @param enc The font encoding.      */
specifier|public
name|void
name|setFontEncoding
parameter_list|(
name|Encoding
name|enc
parameter_list|)
block|{
name|fontEncoding
operator|=
name|enc
expr_stmt|;
block|}
comment|/**      * This will get or create the encoder.      *       * @return The encoding to use.      */
specifier|public
name|Encoding
name|getFontEncoding
parameter_list|()
block|{
return|return
name|fontEncoding
return|;
block|}
comment|/**      * This will always return "Font" for fonts.      *       * @return The type of object that this is.      */
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|font
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
return|;
block|}
comment|// Memorized values to avoid repeated dictionary lookups
specifier|private
name|String
name|subtype
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|type1Font
decl_stmt|;
specifier|private
name|boolean
name|type3Font
decl_stmt|;
specifier|private
name|boolean
name|trueTypeFont
decl_stmt|;
specifier|private
name|boolean
name|type0Font
decl_stmt|;
comment|/**      * This will get the subtype of font, Type1, Type3, ...      *       * @return The type of font that this is.      */
specifier|public
name|String
name|getSubType
parameter_list|()
block|{
if|if
condition|(
name|subtype
operator|==
literal|null
condition|)
block|{
name|subtype
operator|=
name|font
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|SUBTYPE
argument_list|)
expr_stmt|;
name|type1Font
operator|=
literal|"Type1"
operator|.
name|equals
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
name|trueTypeFont
operator|=
literal|"TrueType"
operator|.
name|equals
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
name|type0Font
operator|=
literal|"Type0"
operator|.
name|equals
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
name|type3Font
operator|=
literal|"Type3"
operator|.
name|equals
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
block|}
return|return
name|subtype
return|;
block|}
comment|/**      * Determines if the font is a type 1 font.      *       * @return returns true if the font is a type 1 font      */
specifier|public
name|boolean
name|isType1Font
parameter_list|()
block|{
name|getSubType
argument_list|()
expr_stmt|;
return|return
name|type1Font
return|;
block|}
comment|/**      * Determines if the font is a type 3 font.      *       * @return returns true if the font is a type 3 font      */
specifier|public
name|boolean
name|isType3Font
parameter_list|()
block|{
name|getSubType
argument_list|()
expr_stmt|;
return|return
name|type3Font
return|;
block|}
comment|/**      * Determines if the font is a type 0 font.      *       * @return returns true if the font is a type 0 font      */
specifier|public
name|boolean
name|isType0Font
parameter_list|()
block|{
name|getSubType
argument_list|()
expr_stmt|;
return|return
name|type0Font
return|;
block|}
comment|/**      * Determines if the font is a true type font.      *       * @return returns true if the font is a true type font      */
specifier|public
name|boolean
name|isTrueTypeFont
parameter_list|()
block|{
name|getSubType
argument_list|()
expr_stmt|;
return|return
name|trueTypeFont
return|;
block|}
comment|/**      * Determines if the font is a symbolic font.      *       * @return returns true if the font is a symbolic font      */
specifier|public
name|boolean
name|isSymbolicFont
parameter_list|()
block|{
if|if
condition|(
name|getFontDescriptor
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|getFontDescriptor
argument_list|()
operator|.
name|isSymbolic
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * The PostScript name of the font.      *       * @return The postscript name of the font.      */
specifier|public
name|String
name|getBaseFont
parameter_list|()
block|{
return|return
name|font
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|BASE_FONT
argument_list|)
return|;
block|}
comment|/**      * Set the PostScript name of the font.      *       * @param baseFont The postscript name for the font.      */
specifier|public
name|void
name|setBaseFont
parameter_list|(
name|String
name|baseFont
parameter_list|)
block|{
name|font
operator|.
name|setName
argument_list|(
name|COSName
operator|.
name|BASE_FONT
argument_list|,
name|baseFont
argument_list|)
expr_stmt|;
block|}
comment|/**      * The code for the first char or -1 if there is none.      *       * @return The code for the first character.      */
specifier|public
name|int
name|getFirstChar
parameter_list|()
block|{
return|return
name|font
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|FIRST_CHAR
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * Set the first character this font supports.      *       * @param firstChar The first character.      */
specifier|public
name|void
name|setFirstChar
parameter_list|(
name|int
name|firstChar
parameter_list|)
block|{
name|font
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|FIRST_CHAR
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
block|}
comment|/**      * The code for the last char or -1 if there is none.      *       * @return The code for the last character.      */
specifier|public
name|int
name|getLastChar
parameter_list|()
block|{
return|return
name|font
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|LAST_CHAR
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * Set the last character this font supports.      *       * @param lastChar The last character.      */
specifier|public
name|void
name|setLastChar
parameter_list|(
name|int
name|lastChar
parameter_list|)
block|{
name|font
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|LAST_CHAR
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
block|}
comment|/**      * The widths of the characters. This will be null for the standard 14 fonts.      *       * @return The widths of the characters.      */
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|getWidths
parameter_list|()
block|{
if|if
condition|(
name|widths
operator|==
literal|null
condition|)
block|{
name|COSArray
name|array
init|=
operator|(
name|COSArray
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|WIDTHS
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
name|widths
operator|=
name|COSArrayList
operator|.
name|convertIntegerCOSArrayToList
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|widths
return|;
block|}
comment|/**      * Set the widths of the characters code.      *       * @param widthsList The widths of the character codes.      */
specifier|public
name|void
name|setWidths
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|widthsList
parameter_list|)
block|{
name|widths
operator|=
name|widthsList
expr_stmt|;
name|font
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|WIDTHS
argument_list|,
name|COSArrayList
operator|.
name|converterToCOSArray
argument_list|(
name|widths
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will get the matrix that is used to transform glyph space to text space. By default there are 1000 glyph      * units to 1 text space unit, but type3 fonts can use any value.      *       * Note:If this is a type3 font then it can be modified via the PDType3Font.setFontMatrix, otherwise this is a      * read-only property.      *       * @return The matrix to transform from glyph space to text space.      */
specifier|public
name|PDMatrix
name|getFontMatrix
parameter_list|()
block|{
if|if
condition|(
name|fontMatrix
operator|==
literal|null
condition|)
block|{
name|COSArray
name|array
init|=
operator|(
name|COSArray
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_MATRIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|==
literal|null
condition|)
block|{
name|array
operator|=
operator|new
name|COSArray
argument_list|()
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
operator|new
name|COSFloat
argument_list|(
literal|0.001f
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
operator|new
name|COSFloat
argument_list|(
literal|0.001f
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
name|fontMatrix
operator|=
operator|new
name|PDMatrix
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
return|return
name|fontMatrix
return|;
block|}
comment|/**      * This will get the fonts bounding box.      *       * @return The fonts bounding box.      *       * @throws IOException If there is an error getting the bounding box.      */
specifier|public
specifier|abstract
name|PDRectangle
name|getFontBoundingBox
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**      * {@inheritDoc}      */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|other
operator|instanceof
name|PDFont
operator|&&
operator|(
operator|(
name|PDFont
operator|)
name|other
operator|)
operator|.
name|getCOSObject
argument_list|()
operator|==
name|this
operator|.
name|getCOSObject
argument_list|()
return|;
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCOSObject
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**      * Determines the width of the given character.      *       * @param charCode the code of the given character      * @return the width of the character      */
specifier|public
name|float
name|getFontWidth
parameter_list|(
name|int
name|charCode
parameter_list|)
block|{
name|float
name|width
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|firstChar
init|=
name|getFirstChar
argument_list|()
decl_stmt|;
name|int
name|lastChar
init|=
name|getLastChar
argument_list|()
decl_stmt|;
if|if
condition|(
name|charCode
operator|>=
name|firstChar
operator|&&
name|charCode
operator|<=
name|lastChar
condition|)
block|{
comment|// maybe the font doesn't provide any widths
name|getWidths
argument_list|()
expr_stmt|;
if|if
condition|(
name|widths
operator|!=
literal|null
condition|)
block|{
name|width
operator|=
name|widths
operator|.
name|get
argument_list|(
name|charCode
operator|-
name|firstChar
argument_list|)
operator|.
name|floatValue
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|PDFontDescriptor
name|fd
init|=
name|getFontDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|fd
operator|instanceof
name|PDFontDescriptorDictionary
condition|)
block|{
name|width
operator|=
name|fd
operator|.
name|getMissingWidth
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|width
return|;
block|}
comment|/**      * Determines if a font as a ToUnicode entry.      *       * @return true if the font has a ToUnicode entry      */
specifier|public
name|boolean
name|hasToUnicode
parameter_list|()
block|{
return|return
name|hasToUnicode
return|;
block|}
comment|/**      * Sets hasToUnicode to the given value.      *       * @param hasToUnicodeValue the given value for hasToUnicode      */
specifier|protected
name|void
name|setHasToUnicode
parameter_list|(
name|boolean
name|hasToUnicodeValue
parameter_list|)
block|{
name|hasToUnicode
operator|=
name|hasToUnicodeValue
expr_stmt|;
block|}
comment|/**      * Determines the width of the space character.      *       * @return the width of the space character      */
specifier|public
specifier|abstract
name|float
name|getSpaceWidth
parameter_list|()
function_decl|;
comment|/**      * Returns the toUnicode mapping if present.      *       * @return the CMap representing the toUnicode mapping      */
specifier|public
name|CMap
name|getToUnicodeCMap
parameter_list|()
block|{
return|return
name|toUnicodeCmap
return|;
block|}
comment|/**      * Returns the CMap if present.      *       * @return the CMap representing the character encoding      */
specifier|public
name|CMap
name|getCMap
parameter_list|()
block|{
return|return
name|cmap
return|;
block|}
comment|/**      * Calling this will release all cached information.      */
specifier|public
name|void
name|clear
parameter_list|()
block|{     }
block|}
end_class

end_unit

