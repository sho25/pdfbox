begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|image
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Extends InputStream to wrap the data from the CCITT Fax with a suitable TIFF Header.  * For details see www.tiff.org, which contains useful information including pointers  * to the TIFF 6.0 Specification.  *  * @author Ben Litchfield  * @author BenKing  */
end_comment

begin_comment
comment|// TODO should this extend OutputStream instead?
end_comment

begin_class
specifier|public
specifier|final
class|class
name|TIFFInputStream
extends|extends
name|InputStream
block|{
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|FAX_FILTERS
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|FAX_FILTERS
operator|.
name|add
argument_list|(
name|COSName
operator|.
name|CCITTFAX_DECODE
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|FAX_FILTERS
operator|.
name|add
argument_list|(
name|COSName
operator|.
name|CCITTFAX_DECODE_ABBREVIATION
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|currentOffset
decl_stmt|;
comment|// When reading, where in the tiffheader are we.
specifier|private
name|byte
index|[]
name|tiffheader
decl_stmt|;
comment|// Byte array to store tiff header data
specifier|private
name|InputStream
name|datastream
decl_stmt|;
comment|// Original InputStream
comment|/**      * Writes the TIFF image to an OutputStream.      *       * @param image the image which data should be written      * @param out the OutputStream to write to      */
comment|// TODO this should be refactored
specifier|public
specifier|static
name|void
name|writeToOutputStream
parameter_list|(
name|PDImage
name|image
parameter_list|,
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We should use another format than TIFF to get rid of the TIFFInputStream
name|InputStream
name|faxInput
init|=
name|image
operator|.
name|getStream
argument_list|()
operator|.
name|getPartiallyFilteredStream
argument_list|(
name|FAX_FILTERS
argument_list|)
decl_stmt|;
name|COSStream
name|cosStream
init|=
operator|(
name|COSStream
operator|)
name|image
operator|.
name|getStream
argument_list|()
operator|.
name|getCOSObject
argument_list|()
decl_stmt|;
name|InputStream
name|data
init|=
operator|new
name|TIFFInputStream
argument_list|(
name|faxInput
argument_list|,
name|cosStream
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|data
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
specifier|private
name|TIFFInputStream
parameter_list|(
name|InputStream
name|rawstream
parameter_list|,
name|COSDictionary
name|options
parameter_list|)
block|{
name|buildHeader
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|currentOffset
operator|=
literal|0
expr_stmt|;
name|datastream
operator|=
name|rawstream
expr_stmt|;
block|}
comment|// Implement basic methods from InputStream
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"reset not supported"
argument_list|)
throw|;
block|}
comment|/**      * For simple read, take a byte from the tiff header array or pass through.      * {@inheritDoc}      */
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentOffset
operator|<
name|tiffheader
operator|.
name|length
condition|)
block|{
return|return
name|tiffheader
index|[
name|currentOffset
operator|++
index|]
return|;
block|}
return|return
name|datastream
operator|.
name|read
argument_list|()
return|;
block|}
comment|/**      * For read methods only return as many bytes as we have left in the header if we've      * exhausted the header, pass through to the InputStream of the raw CCITT data.      * {@inheritDoc}      */
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentOffset
operator|<
name|tiffheader
operator|.
name|length
condition|)
block|{
name|int
name|length
init|=
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|min
argument_list|(
name|tiffheader
operator|.
name|length
operator|-
name|currentOffset
argument_list|,
name|data
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|tiffheader
argument_list|,
name|currentOffset
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|currentOffset
operator|+=
name|length
expr_stmt|;
return|return
name|length
return|;
block|}
else|else
block|{
return|return
name|datastream
operator|.
name|read
argument_list|(
name|data
argument_list|)
return|;
block|}
block|}
comment|/**      * For read methods only return as many bytes as we have left in the header if we've      * exhausted the header, pass  through to the InputStream of the raw CCITT data.      * {@inheritDoc}      */
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentOffset
operator|<
name|tiffheader
operator|.
name|length
condition|)
block|{
name|int
name|length
init|=
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|min
argument_list|(
name|tiffheader
operator|.
name|length
operator|-
name|currentOffset
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|tiffheader
argument_list|,
name|currentOffset
argument_list|,
name|data
argument_list|,
name|off
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|currentOffset
operator|+=
name|length
expr_stmt|;
return|return
name|length
return|;
block|}
else|else
block|{
return|return
name|datastream
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
comment|/**      * When skipping if any header data not yet read, only allow to      * skip what we've in the buffer Otherwise just pass through.      * {@inheritDoc}      */
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentOffset
operator|<
name|tiffheader
operator|.
name|length
condition|)
block|{
name|long
name|length
init|=
name|Math
operator|.
name|min
argument_list|(
name|tiffheader
operator|.
name|length
operator|-
name|currentOffset
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|currentOffset
operator|+=
name|length
expr_stmt|;
return|return
name|length
return|;
block|}
else|else
block|{
return|return
name|datastream
operator|.
name|skip
argument_list|(
name|n
argument_list|)
return|;
block|}
block|}
comment|// Static data for the beginning of the TIFF header
specifier|private
specifier|final
name|byte
index|[]
name|basicHeader
init|=
block|{
literal|'I'
block|,
literal|'I'
block|,
literal|42
block|,
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// File introducer and pointer to first IFD
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|// Number of tags start with two
specifier|private
name|int
name|additionalOffset
decl_stmt|;
comment|// Offset in header to additional data
comment|// Builds up the tiffheader based on the options passed through.
specifier|private
name|void
name|buildHeader
parameter_list|(
name|COSDictionary
name|options
parameter_list|)
block|{
specifier|final
name|int
name|numOfTags
init|=
literal|10
decl_stmt|;
comment|// The maximum tags we'll fill
specifier|final
name|int
name|maxAdditionalData
init|=
literal|24
decl_stmt|;
comment|// The maximum amount of additional data
comment|// outside the IFDs. (bytes)
comment|// The length of the header will be the length of the basic header (10)
comment|// plus 12 bytes for each IFD, 4 bytes as a pointer to the next IFD (will be 0)
comment|// plus the length of the additional data
name|int
name|ifdSize
init|=
literal|10
operator|+
operator|(
literal|12
operator|*
name|numOfTags
operator|)
operator|+
literal|4
decl_stmt|;
name|tiffheader
operator|=
operator|new
name|byte
index|[
name|ifdSize
operator|+
name|maxAdditionalData
index|]
expr_stmt|;
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|fill
argument_list|(
name|tiffheader
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|basicHeader
argument_list|,
literal|0
argument_list|,
name|tiffheader
argument_list|,
literal|0
argument_list|,
name|basicHeader
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Additional data outside the IFD starts after the IFD's and pointer to the next IFD(0)
name|additionalOffset
operator|=
name|ifdSize
expr_stmt|;
comment|// Now work out the variable values from TIFF defaults,
comment|// PDF Defaults and the Dictionary for this XObject
name|short
name|cols
init|=
literal|1728
decl_stmt|;
name|short
name|rows
init|=
literal|0
decl_stmt|;
name|short
name|blackis1
init|=
literal|0
decl_stmt|;
name|short
name|comptype
init|=
literal|3
decl_stmt|;
comment|// T4 compression
name|long
name|t4options
init|=
literal|0
decl_stmt|;
comment|// Will set if 1d or 2d T4
name|COSArray
name|decode
init|=
operator|(
name|COSArray
operator|)
name|options
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|DECODE
argument_list|)
decl_stmt|;
comment|// we have to invert the b/w-values,
comment|// if the Decode array exists and consists of (1,0)
if|if
condition|(
name|decode
operator|!=
literal|null
operator|&&
name|decode
operator|.
name|getInt
argument_list|(
literal|0
argument_list|)
operator|==
literal|1
condition|)
block|{
name|blackis1
operator|=
literal|1
expr_stmt|;
block|}
name|COSBase
name|dicOrArrayParms
init|=
name|options
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|DECODE_PARMS
argument_list|)
decl_stmt|;
name|COSDictionary
name|decodeParms
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|dicOrArrayParms
operator|instanceof
name|COSDictionary
condition|)
block|{
name|decodeParms
operator|=
operator|(
name|COSDictionary
operator|)
name|dicOrArrayParms
expr_stmt|;
block|}
else|else
block|{
name|COSArray
name|parmsArray
init|=
operator|(
name|COSArray
operator|)
name|dicOrArrayParms
decl_stmt|;
if|if
condition|(
name|parmsArray
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|decodeParms
operator|=
operator|(
name|COSDictionary
operator|)
name|parmsArray
operator|.
name|getObject
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// else find the first dictionary with Row/Column info and use that.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parmsArray
operator|.
name|size
argument_list|()
operator|&&
name|decodeParms
operator|==
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|COSDictionary
name|dic
init|=
operator|(
name|COSDictionary
operator|)
name|parmsArray
operator|.
name|getObject
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|dic
operator|!=
literal|null
operator|&&
operator|(
name|dic
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|COLUMNS
argument_list|)
operator|!=
literal|null
operator|||
name|dic
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ROWS
argument_list|)
operator|!=
literal|null
operator|)
condition|)
block|{
name|decodeParms
operator|=
name|dic
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|decodeParms
operator|!=
literal|null
condition|)
block|{
name|cols
operator|=
operator|(
name|short
operator|)
name|decodeParms
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|COLUMNS
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|rows
operator|=
operator|(
name|short
operator|)
name|decodeParms
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|ROWS
argument_list|,
name|rows
argument_list|)
expr_stmt|;
if|if
condition|(
name|decodeParms
operator|.
name|getBoolean
argument_list|(
name|COSName
operator|.
name|BLACK_IS_1
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|blackis1
operator|=
literal|1
expr_stmt|;
block|}
name|int
name|k
init|=
name|decodeParms
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|K
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Mandatory parm
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
comment|// T6
name|comptype
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
comment|// T4 2D
name|comptype
operator|=
literal|3
expr_stmt|;
name|t4options
operator|=
literal|1
expr_stmt|;
block|}
comment|// else k = 0, leave as default T4 1D compression
block|}
comment|// If we couldn't get the number of rows, use the main item from XObject
if|if
condition|(
name|rows
operator|==
literal|0
condition|)
block|{
name|rows
operator|=
operator|(
name|short
operator|)
name|options
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|HEIGHT
argument_list|,
name|rows
argument_list|)
expr_stmt|;
block|}
comment|// Now put the tags into the tiffheader
comment|// These musn't exceed the maximum set above, and by TIFF spec should be sorted into
comment|// Numeric sequence.
name|addTag
argument_list|(
literal|256
argument_list|,
name|cols
argument_list|)
expr_stmt|;
comment|// Columns
name|addTag
argument_list|(
literal|257
argument_list|,
name|rows
argument_list|)
expr_stmt|;
comment|// Rows
name|addTag
argument_list|(
literal|259
argument_list|,
name|comptype
argument_list|)
expr_stmt|;
comment|// T6
name|addTag
argument_list|(
literal|262
argument_list|,
name|blackis1
argument_list|)
expr_stmt|;
comment|// Photometric Interpretation
name|addTag
argument_list|(
literal|273
argument_list|,
name|tiffheader
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Offset to start of image data - updated below
name|addTag
argument_list|(
literal|279
argument_list|,
name|options
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|)
argument_list|)
expr_stmt|;
comment|// Length of image data
name|addTag
argument_list|(
literal|282
argument_list|,
literal|300
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// X Resolution 300 (default unit Inches) This is arbitary
name|addTag
argument_list|(
literal|283
argument_list|,
literal|300
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Y Resolution 300 (default unit Inches) This is arbitary
if|if
condition|(
name|comptype
operator|==
literal|3
condition|)
block|{
name|addTag
argument_list|(
literal|292
argument_list|,
name|t4options
argument_list|)
expr_stmt|;
block|}
name|addTag
argument_list|(
literal|305
argument_list|,
literal|"PDFBOX"
argument_list|)
expr_stmt|;
comment|// Software generating image
block|}
comment|/* Tiff types 1 = byte, 2=ascii, 3=short, 4=ulong 5=rational */
specifier|private
name|void
name|addTag
parameter_list|(
name|int
name|tag
parameter_list|,
name|long
name|value
parameter_list|)
block|{
comment|// Adds a tag of type 4 (ulong)
name|int
name|count
init|=
operator|++
name|tiffheader
index|[
literal|8
index|]
decl_stmt|;
name|int
name|offset
init|=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|12
operator|+
literal|10
decl_stmt|;
name|tiffheader
index|[
name|offset
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|tag
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|4
expr_stmt|;
comment|// Type Long
name|tiffheader
index|[
name|offset
operator|+
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|// One Value
name|tiffheader
index|[
name|offset
operator|+
literal|8
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|9
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|10
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|11
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addTag
parameter_list|(
name|int
name|tag
parameter_list|,
name|short
name|value
parameter_list|)
block|{
comment|// Adds a tag of type 3 (short)
name|int
name|count
init|=
operator|++
name|tiffheader
index|[
literal|8
index|]
decl_stmt|;
name|int
name|offset
init|=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|12
operator|+
literal|10
decl_stmt|;
name|tiffheader
index|[
name|offset
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|tag
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|3
expr_stmt|;
comment|// Type Short
name|tiffheader
index|[
name|offset
operator|+
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|// One Value
name|tiffheader
index|[
name|offset
operator|+
literal|8
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|9
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addTag
parameter_list|(
name|int
name|tag
parameter_list|,
name|String
name|value
parameter_list|)
block|{
comment|// Adds a tag of type 2 (ascii)
name|int
name|count
init|=
operator|++
name|tiffheader
index|[
literal|8
index|]
decl_stmt|;
name|int
name|offset
init|=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|12
operator|+
literal|10
decl_stmt|;
name|tiffheader
index|[
name|offset
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|tag
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|2
expr_stmt|;
comment|// Type Ascii
name|int
name|len
init|=
name|value
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|4
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|8
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|additionalOffset
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|9
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|10
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|11
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
try|try
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|value
operator|.
name|getBytes
argument_list|(
literal|"US-ASCII"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|tiffheader
argument_list|,
name|additionalOffset
argument_list|,
name|value
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Incompatible VM without US-ASCII encoding"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|additionalOffset
operator|+=
name|len
expr_stmt|;
block|}
specifier|private
name|void
name|addTag
parameter_list|(
name|int
name|tag
parameter_list|,
name|long
name|numerator
parameter_list|,
name|long
name|denominator
parameter_list|)
block|{
comment|// Adds a tag of type 5 (rational)
name|int
name|count
init|=
operator|++
name|tiffheader
index|[
literal|8
index|]
decl_stmt|;
name|int
name|offset
init|=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|12
operator|+
literal|10
decl_stmt|;
name|tiffheader
index|[
name|offset
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|tag
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|5
expr_stmt|;
comment|// Type Rational
name|tiffheader
index|[
name|offset
operator|+
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|// One Value
name|tiffheader
index|[
name|offset
operator|+
literal|8
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|additionalOffset
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|9
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|10
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|11
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|numerator
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|numerator
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|numerator
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|numerator
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|denominator
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|denominator
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|denominator
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|denominator
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

