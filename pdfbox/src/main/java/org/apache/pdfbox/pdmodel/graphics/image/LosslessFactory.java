begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2014 The Apache Software Foundation.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|image
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Transparency
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|image
operator|.
name|BufferedImage
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|stream
operator|.
name|MemoryCacheImageOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|filter
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|filter
operator|.
name|FilterFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDColorSpace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceColorSpace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceGray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceRGB
import|;
end_import

begin_comment
comment|/**  * Factory for creating a PDImageXObject containing a lossless compressed image.  *  * @author Tilman Hausherr  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|LosslessFactory
block|{
specifier|private
name|LosslessFactory
parameter_list|()
block|{     }
comment|/**      * Creates a new lossless encoded Image XObject from a Buffered Image.      *      * @param document the document where the image will be created      * @param image the buffered image to embed      * @return a new Image XObject      * @throws IOException if something goes wrong      */
specifier|public
specifier|static
name|PDImageXObject
name|createFromImage
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|BufferedImage
name|image
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|image
operator|.
name|getType
argument_list|()
operator|==
name|BufferedImage
operator|.
name|TYPE_BYTE_GRAY
operator|&&
name|image
operator|.
name|getColorModel
argument_list|()
operator|.
name|getPixelSize
argument_list|()
operator|<=
literal|8
operator|)
operator|||
operator|(
name|image
operator|.
name|getType
argument_list|()
operator|==
name|BufferedImage
operator|.
name|TYPE_BYTE_BINARY
operator|&&
name|image
operator|.
name|getColorModel
argument_list|()
operator|.
name|getPixelSize
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
return|return
name|createFromGrayImage
argument_list|(
name|image
argument_list|,
name|document
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|createFromRGBImage
argument_list|(
name|image
argument_list|,
name|document
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|PDImageXObject
name|createFromGrayImage
parameter_list|(
name|BufferedImage
name|image
parameter_list|,
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|height
init|=
name|image
operator|.
name|getHeight
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|image
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|int
index|[]
name|rgbLineBuffer
init|=
operator|new
name|int
index|[
name|width
index|]
decl_stmt|;
name|int
name|bpc
decl_stmt|;
comment|// grayscale images need one color per sample
name|bpc
operator|=
name|image
operator|.
name|getColorModel
argument_list|()
operator|.
name|getPixelSize
argument_list|()
expr_stmt|;
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
operator|(
operator|(
name|width
operator|*
name|bpc
operator|/
literal|8
operator|)
operator|+
operator|(
name|width
operator|*
name|bpc
operator|%
literal|8
operator|!=
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator|*
name|height
argument_list|)
decl_stmt|;
try|try
init|(
name|MemoryCacheImageOutputStream
name|mcios
init|=
operator|new
name|MemoryCacheImageOutputStream
argument_list|(
name|baos
argument_list|)
init|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|pixel
range|:
name|image
operator|.
name|getRGB
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
literal|1
argument_list|,
name|rgbLineBuffer
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
control|)
block|{
name|mcios
operator|.
name|writeBits
argument_list|(
name|pixel
operator|&
literal|0xFF
argument_list|,
name|bpc
argument_list|)
expr_stmt|;
block|}
name|int
name|bitOffset
init|=
name|mcios
operator|.
name|getBitOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|bitOffset
operator|!=
literal|0
condition|)
block|{
name|mcios
operator|.
name|writeBits
argument_list|(
literal|0
argument_list|,
literal|8
operator|-
name|bitOffset
argument_list|)
expr_stmt|;
block|}
block|}
name|mcios
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
return|return
name|prepareImageXObject
argument_list|(
name|document
argument_list|,
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|image
operator|.
name|getWidth
argument_list|()
argument_list|,
name|image
operator|.
name|getHeight
argument_list|()
argument_list|,
name|bpc
argument_list|,
name|PDDeviceGray
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|PDImageXObject
name|createFromRGBImage
parameter_list|(
name|BufferedImage
name|image
parameter_list|,
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|height
init|=
name|image
operator|.
name|getHeight
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|image
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|int
index|[]
name|rgbLineBuffer
init|=
operator|new
name|int
index|[
name|width
index|]
decl_stmt|;
name|int
name|bpc
init|=
literal|8
decl_stmt|;
name|PDDeviceColorSpace
name|deviceColorSpace
init|=
name|PDDeviceRGB
operator|.
name|INSTANCE
decl_stmt|;
name|byte
index|[]
name|imageData
init|=
operator|new
name|byte
index|[
name|width
operator|*
name|height
operator|*
literal|3
index|]
decl_stmt|;
name|int
name|byteIdx
init|=
literal|0
decl_stmt|;
name|int
name|alphaByteIdx
init|=
literal|0
decl_stmt|;
name|int
name|alphaBitPos
init|=
literal|7
decl_stmt|;
name|int
name|transparency
init|=
name|image
operator|.
name|getTransparency
argument_list|()
decl_stmt|;
name|int
name|apbc
init|=
name|transparency
operator|==
name|Transparency
operator|.
name|BITMASK
condition|?
literal|1
else|:
literal|8
decl_stmt|;
name|byte
index|[]
name|alphaImageData
decl_stmt|;
if|if
condition|(
name|transparency
operator|!=
name|Transparency
operator|.
name|OPAQUE
condition|)
block|{
name|alphaImageData
operator|=
operator|new
name|byte
index|[
operator|(
operator|(
name|width
operator|*
name|apbc
operator|/
literal|8
operator|)
operator|+
operator|(
name|width
operator|*
name|apbc
operator|%
literal|8
operator|!=
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator|*
name|height
index|]
expr_stmt|;
block|}
else|else
block|{
name|alphaImageData
operator|=
operator|new
name|byte
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|pixel
range|:
name|image
operator|.
name|getRGB
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
literal|1
argument_list|,
name|rgbLineBuffer
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
control|)
block|{
name|imageData
index|[
name|byteIdx
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|pixel
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|imageData
index|[
name|byteIdx
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|pixel
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|imageData
index|[
name|byteIdx
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|pixel
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|transparency
operator|!=
name|Transparency
operator|.
name|OPAQUE
condition|)
block|{
comment|// we have the alpha right here, so no need to do it separately
comment|// as done prior April 2018
if|if
condition|(
name|transparency
operator|==
name|Transparency
operator|.
name|BITMASK
condition|)
block|{
comment|// write a bit
name|alphaImageData
index|[
name|alphaByteIdx
index|]
operator||=
operator|(
operator|(
name|pixel
operator|>>
literal|24
operator|)
operator|&
literal|1
operator|)
operator|<<
name|alphaBitPos
expr_stmt|;
if|if
condition|(
operator|--
name|alphaBitPos
operator|<
literal|0
condition|)
block|{
name|alphaBitPos
operator|=
literal|7
expr_stmt|;
operator|++
name|alphaByteIdx
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// write a byte
name|alphaImageData
index|[
name|alphaByteIdx
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|pixel
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|transparency
operator|==
name|Transparency
operator|.
name|BITMASK
condition|)
block|{
comment|// skip boundary if needed
if|if
condition|(
name|alphaBitPos
operator|!=
literal|7
condition|)
block|{
name|alphaBitPos
operator|=
literal|7
expr_stmt|;
operator|++
name|alphaByteIdx
expr_stmt|;
block|}
block|}
block|}
name|PDImageXObject
name|pdImage
init|=
name|prepareImageXObject
argument_list|(
name|document
argument_list|,
name|imageData
argument_list|,
name|image
operator|.
name|getWidth
argument_list|()
argument_list|,
name|image
operator|.
name|getHeight
argument_list|()
argument_list|,
name|bpc
argument_list|,
name|deviceColorSpace
argument_list|)
decl_stmt|;
if|if
condition|(
name|transparency
operator|!=
name|Transparency
operator|.
name|OPAQUE
condition|)
block|{
name|PDImageXObject
name|pdMask
init|=
name|prepareImageXObject
argument_list|(
name|document
argument_list|,
name|alphaImageData
argument_list|,
name|image
operator|.
name|getWidth
argument_list|()
argument_list|,
name|image
operator|.
name|getHeight
argument_list|()
argument_list|,
name|apbc
argument_list|,
name|PDDeviceGray
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|pdImage
operator|.
name|getCOSObject
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|SMASK
argument_list|,
name|pdMask
argument_list|)
expr_stmt|;
block|}
return|return
name|pdImage
return|;
block|}
comment|/**      * Create a PDImageXObject while making a decision whether not to       * compress, use Flate filter only, or Flate and LZW filters.      *       * @param document The document.      * @param byteArray array with data.      * @param width the image width      * @param height the image height      * @param bitsPerComponent the bits per component      * @param initColorSpace the color space      * @return the newly created PDImageXObject with the data compressed.      * @throws IOException       */
specifier|private
specifier|static
name|PDImageXObject
name|prepareImageXObject
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|byte
index|[]
name|byteArray
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bitsPerComponent
parameter_list|,
name|PDColorSpace
name|initColorSpace
parameter_list|)
throws|throws
name|IOException
block|{
comment|//pre-size the output stream to half of the input
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|byteArray
operator|.
name|length
operator|/
literal|2
argument_list|)
decl_stmt|;
name|Filter
name|filter
init|=
name|FilterFactory
operator|.
name|INSTANCE
operator|.
name|getFilter
argument_list|(
name|COSName
operator|.
name|FLATE_DECODE
argument_list|)
decl_stmt|;
name|filter
operator|.
name|encode
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|byteArray
argument_list|)
argument_list|,
name|baos
argument_list|,
operator|new
name|COSDictionary
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|encodedByteStream
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|PDImageXObject
argument_list|(
name|document
argument_list|,
name|encodedByteStream
argument_list|,
name|COSName
operator|.
name|FLATE_DECODE
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bitsPerComponent
argument_list|,
name|initColorSpace
argument_list|)
return|;
block|}
block|}
end_class

end_unit

