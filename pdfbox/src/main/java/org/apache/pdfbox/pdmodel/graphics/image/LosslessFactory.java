begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2014 The Apache Software Foundation.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|image
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Transparency
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|color
operator|.
name|ColorSpace
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|color
operator|.
name|ICC_ColorSpace
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|color
operator|.
name|ICC_Profile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|image
operator|.
name|BufferedImage
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|image
operator|.
name|DataBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|image
operator|.
name|Raster
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Deflater
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|DeflaterOutputStream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|stream
operator|.
name|MemoryCacheImageOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|filter
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|filter
operator|.
name|FilterFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDColorSpace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceCMYK
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceColorSpace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceGray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceRGB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDICCBased
import|;
end_import

begin_comment
comment|/**  * Factory for creating a PDImageXObject containing a lossless compressed image.  *  * @author Tilman Hausherr  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|LosslessFactory
block|{
comment|/**       * Internal, only for benchmark purpose      */
specifier|static
name|boolean
name|usePredictorEncoder
init|=
literal|true
decl_stmt|;
specifier|private
name|LosslessFactory
parameter_list|()
block|{     }
comment|/**      * Creates a new lossless encoded Image XObject from a Buffered Image.      *      * @param document the document where the image will be created      * @param image the buffered image to embed      * @return a new Image XObject      * @throws IOException if something goes wrong      */
specifier|public
specifier|static
name|PDImageXObject
name|createFromImage
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|BufferedImage
name|image
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|image
operator|.
name|getType
argument_list|()
operator|==
name|BufferedImage
operator|.
name|TYPE_BYTE_GRAY
operator|&&
name|image
operator|.
name|getColorModel
argument_list|()
operator|.
name|getPixelSize
argument_list|()
operator|<=
literal|8
operator|)
operator|||
operator|(
name|image
operator|.
name|getType
argument_list|()
operator|==
name|BufferedImage
operator|.
name|TYPE_BYTE_BINARY
operator|&&
name|image
operator|.
name|getColorModel
argument_list|()
operator|.
name|getPixelSize
argument_list|()
operator|==
literal|1
operator|)
condition|)
block|{
return|return
name|createFromGrayImage
argument_list|(
name|image
argument_list|,
name|document
argument_list|)
return|;
block|}
else|else
block|{
comment|// We try to encode the image with predictor
if|if
condition|(
name|usePredictorEncoder
condition|)
block|{
name|PDImageXObject
name|pdImageXObject
init|=
operator|new
name|PredictorEncoder
argument_list|(
name|document
argument_list|,
name|image
argument_list|)
operator|.
name|encode
argument_list|()
decl_stmt|;
if|if
condition|(
name|pdImageXObject
operator|!=
literal|null
condition|)
block|{
return|return
name|pdImageXObject
return|;
block|}
block|}
comment|// Fallback: We export the image as 8-bit sRGB and might loose color information
return|return
name|createFromRGBImage
argument_list|(
name|image
argument_list|,
name|document
argument_list|)
return|;
block|}
block|}
comment|// grayscale images need one color per sample
specifier|private
specifier|static
name|PDImageXObject
name|createFromGrayImage
parameter_list|(
name|BufferedImage
name|image
parameter_list|,
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|height
init|=
name|image
operator|.
name|getHeight
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|image
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|int
index|[]
name|rgbLineBuffer
init|=
operator|new
name|int
index|[
name|width
index|]
decl_stmt|;
name|int
name|bpc
init|=
name|image
operator|.
name|getColorModel
argument_list|()
operator|.
name|getPixelSize
argument_list|()
decl_stmt|;
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
operator|(
operator|(
name|width
operator|*
name|bpc
operator|/
literal|8
operator|)
operator|+
operator|(
name|width
operator|*
name|bpc
operator|%
literal|8
operator|!=
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator|*
name|height
argument_list|)
decl_stmt|;
try|try
init|(
name|MemoryCacheImageOutputStream
name|mcios
init|=
operator|new
name|MemoryCacheImageOutputStream
argument_list|(
name|baos
argument_list|)
init|)
block|{
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|pixel
range|:
name|image
operator|.
name|getRGB
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
literal|1
argument_list|,
name|rgbLineBuffer
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
control|)
block|{
name|mcios
operator|.
name|writeBits
argument_list|(
name|pixel
operator|&
literal|0xFF
argument_list|,
name|bpc
argument_list|)
expr_stmt|;
block|}
name|int
name|bitOffset
init|=
name|mcios
operator|.
name|getBitOffset
argument_list|()
decl_stmt|;
if|if
condition|(
name|bitOffset
operator|!=
literal|0
condition|)
block|{
name|mcios
operator|.
name|writeBits
argument_list|(
literal|0
argument_list|,
literal|8
operator|-
name|bitOffset
argument_list|)
expr_stmt|;
block|}
block|}
name|mcios
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
return|return
name|prepareImageXObject
argument_list|(
name|document
argument_list|,
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|image
operator|.
name|getWidth
argument_list|()
argument_list|,
name|image
operator|.
name|getHeight
argument_list|()
argument_list|,
name|bpc
argument_list|,
name|PDDeviceGray
operator|.
name|INSTANCE
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|PDImageXObject
name|createFromRGBImage
parameter_list|(
name|BufferedImage
name|image
parameter_list|,
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|height
init|=
name|image
operator|.
name|getHeight
argument_list|()
decl_stmt|;
name|int
name|width
init|=
name|image
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|int
index|[]
name|rgbLineBuffer
init|=
operator|new
name|int
index|[
name|width
index|]
decl_stmt|;
name|int
name|bpc
init|=
literal|8
decl_stmt|;
name|PDDeviceColorSpace
name|deviceColorSpace
init|=
name|PDDeviceRGB
operator|.
name|INSTANCE
decl_stmt|;
name|byte
index|[]
name|imageData
init|=
operator|new
name|byte
index|[
name|width
operator|*
name|height
operator|*
literal|3
index|]
decl_stmt|;
name|int
name|byteIdx
init|=
literal|0
decl_stmt|;
name|int
name|alphaByteIdx
init|=
literal|0
decl_stmt|;
name|int
name|alphaBitPos
init|=
literal|7
decl_stmt|;
name|int
name|transparency
init|=
name|image
operator|.
name|getTransparency
argument_list|()
decl_stmt|;
name|int
name|apbc
init|=
name|transparency
operator|==
name|Transparency
operator|.
name|BITMASK
condition|?
literal|1
else|:
literal|8
decl_stmt|;
name|byte
index|[]
name|alphaImageData
decl_stmt|;
if|if
condition|(
name|transparency
operator|!=
name|Transparency
operator|.
name|OPAQUE
condition|)
block|{
name|alphaImageData
operator|=
operator|new
name|byte
index|[
operator|(
operator|(
name|width
operator|*
name|apbc
operator|/
literal|8
operator|)
operator|+
operator|(
name|width
operator|*
name|apbc
operator|%
literal|8
operator|!=
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator|*
name|height
index|]
expr_stmt|;
block|}
else|else
block|{
name|alphaImageData
operator|=
operator|new
name|byte
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|y
init|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
operator|++
name|y
control|)
block|{
for|for
control|(
name|int
name|pixel
range|:
name|image
operator|.
name|getRGB
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
literal|1
argument_list|,
name|rgbLineBuffer
argument_list|,
literal|0
argument_list|,
name|width
argument_list|)
control|)
block|{
name|imageData
index|[
name|byteIdx
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|pixel
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|imageData
index|[
name|byteIdx
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|pixel
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|imageData
index|[
name|byteIdx
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|pixel
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|transparency
operator|!=
name|Transparency
operator|.
name|OPAQUE
condition|)
block|{
comment|// we have the alpha right here, so no need to do it separately
comment|// as done prior April 2018
if|if
condition|(
name|transparency
operator|==
name|Transparency
operator|.
name|BITMASK
condition|)
block|{
comment|// write a bit
name|alphaImageData
index|[
name|alphaByteIdx
index|]
operator||=
operator|(
operator|(
name|pixel
operator|>>
literal|24
operator|)
operator|&
literal|1
operator|)
operator|<<
name|alphaBitPos
expr_stmt|;
if|if
condition|(
operator|--
name|alphaBitPos
operator|<
literal|0
condition|)
block|{
name|alphaBitPos
operator|=
literal|7
expr_stmt|;
operator|++
name|alphaByteIdx
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// write a byte
name|alphaImageData
index|[
name|alphaByteIdx
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|pixel
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// skip boundary if needed
if|if
condition|(
name|transparency
operator|==
name|Transparency
operator|.
name|BITMASK
operator|&&
name|alphaBitPos
operator|!=
literal|7
condition|)
block|{
name|alphaBitPos
operator|=
literal|7
expr_stmt|;
operator|++
name|alphaByteIdx
expr_stmt|;
block|}
block|}
name|PDImageXObject
name|pdImage
init|=
name|prepareImageXObject
argument_list|(
name|document
argument_list|,
name|imageData
argument_list|,
name|image
operator|.
name|getWidth
argument_list|()
argument_list|,
name|image
operator|.
name|getHeight
argument_list|()
argument_list|,
name|bpc
argument_list|,
name|deviceColorSpace
argument_list|)
decl_stmt|;
if|if
condition|(
name|transparency
operator|!=
name|Transparency
operator|.
name|OPAQUE
condition|)
block|{
name|PDImageXObject
name|pdMask
init|=
name|prepareImageXObject
argument_list|(
name|document
argument_list|,
name|alphaImageData
argument_list|,
name|image
operator|.
name|getWidth
argument_list|()
argument_list|,
name|image
operator|.
name|getHeight
argument_list|()
argument_list|,
name|apbc
argument_list|,
name|PDDeviceGray
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|pdImage
operator|.
name|getCOSObject
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|SMASK
argument_list|,
name|pdMask
argument_list|)
expr_stmt|;
block|}
return|return
name|pdImage
return|;
block|}
comment|/**      * Create a PDImageXObject while making a decision whether not to       * compress, use Flate filter only, or Flate and LZW filters.      *       * @param document The document.      * @param byteArray array with data.      * @param width the image width      * @param height the image height      * @param bitsPerComponent the bits per component      * @param initColorSpace the color space      * @return the newly created PDImageXObject with the data compressed.      * @throws IOException       */
specifier|private
specifier|static
name|PDImageXObject
name|prepareImageXObject
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|byte
index|[]
name|byteArray
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bitsPerComponent
parameter_list|,
name|PDColorSpace
name|initColorSpace
parameter_list|)
throws|throws
name|IOException
block|{
comment|//pre-size the output stream to half of the input
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|byteArray
operator|.
name|length
operator|/
literal|2
argument_list|)
decl_stmt|;
name|Filter
name|filter
init|=
name|FilterFactory
operator|.
name|INSTANCE
operator|.
name|getFilter
argument_list|(
name|COSName
operator|.
name|FLATE_DECODE
argument_list|)
decl_stmt|;
name|filter
operator|.
name|encode
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|byteArray
argument_list|)
argument_list|,
name|baos
argument_list|,
operator|new
name|COSDictionary
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|encodedByteStream
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|PDImageXObject
argument_list|(
name|document
argument_list|,
name|encodedByteStream
argument_list|,
name|COSName
operator|.
name|FLATE_DECODE
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bitsPerComponent
argument_list|,
name|initColorSpace
argument_list|)
return|;
block|}
specifier|private
specifier|static
class|class
name|PredictorEncoder
block|{
specifier|private
specifier|final
name|PDDocument
name|document
decl_stmt|;
specifier|private
specifier|final
name|BufferedImage
name|image
decl_stmt|;
specifier|private
specifier|final
name|int
name|componentsPerPixel
decl_stmt|;
specifier|private
specifier|final
name|int
name|transferType
decl_stmt|;
specifier|private
specifier|final
name|int
name|bytesPerComponent
decl_stmt|;
specifier|private
specifier|final
name|int
name|bytesPerPixel
decl_stmt|;
specifier|private
specifier|final
name|int
name|height
decl_stmt|;
specifier|private
specifier|final
name|int
name|width
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|dataRawRowNone
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|dataRawRowSub
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|dataRawRowUp
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|dataRawRowAverage
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|dataRawRowPaeth
decl_stmt|;
specifier|final
name|int
name|imageType
decl_stmt|;
specifier|final
name|boolean
name|hasAlpha
decl_stmt|;
specifier|final
name|byte
index|[]
name|alphaImageData
decl_stmt|;
specifier|final
name|byte
index|[]
name|aValues
decl_stmt|;
specifier|final
name|byte
index|[]
name|cValues
decl_stmt|;
specifier|final
name|byte
index|[]
name|bValues
decl_stmt|;
specifier|final
name|byte
index|[]
name|xValues
decl_stmt|;
specifier|final
name|byte
index|[]
name|tmpResultValues
decl_stmt|;
comment|/**          * Initialize the encoder and set all final fields          */
name|PredictorEncoder
parameter_list|(
name|PDDocument
name|document
parameter_list|,
name|BufferedImage
name|image
parameter_list|)
block|{
name|this
operator|.
name|document
operator|=
name|document
expr_stmt|;
name|this
operator|.
name|image
operator|=
name|image
expr_stmt|;
comment|// The raw count of components per pixel including optional alpha
name|this
operator|.
name|componentsPerPixel
operator|=
name|image
operator|.
name|getColorModel
argument_list|()
operator|.
name|getNumComponents
argument_list|()
expr_stmt|;
name|this
operator|.
name|transferType
operator|=
name|image
operator|.
name|getRaster
argument_list|()
operator|.
name|getTransferType
argument_list|()
expr_stmt|;
name|this
operator|.
name|bytesPerComponent
operator|=
operator|(
name|transferType
operator|==
name|DataBuffer
operator|.
name|TYPE_SHORT
operator|||
name|transferType
operator|==
name|DataBuffer
operator|.
name|TYPE_USHORT
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|// Only the bytes we need in the output (excluding alpha)
name|this
operator|.
name|bytesPerPixel
operator|=
name|image
operator|.
name|getColorModel
argument_list|()
operator|.
name|getNumColorComponents
argument_list|()
operator|*
name|bytesPerComponent
expr_stmt|;
name|this
operator|.
name|height
operator|=
name|image
operator|.
name|getHeight
argument_list|()
expr_stmt|;
name|this
operator|.
name|width
operator|=
name|image
operator|.
name|getWidth
argument_list|()
expr_stmt|;
name|this
operator|.
name|imageType
operator|=
name|image
operator|.
name|getType
argument_list|()
expr_stmt|;
name|this
operator|.
name|hasAlpha
operator|=
name|image
operator|.
name|getColorModel
argument_list|()
operator|.
name|getNumComponents
argument_list|()
operator|!=
name|image
operator|.
name|getColorModel
argument_list|()
operator|.
name|getNumColorComponents
argument_list|()
expr_stmt|;
name|this
operator|.
name|alphaImageData
operator|=
name|hasAlpha
condition|?
operator|new
name|byte
index|[
name|width
operator|*
name|height
operator|*
name|bytesPerComponent
index|]
else|:
literal|null
expr_stmt|;
comment|// The rows have 1-byte encoding marker and width * BYTES_PER_PIXEL pixel-bytes
name|int
name|dataRowByteCount
init|=
name|width
operator|*
name|bytesPerPixel
operator|+
literal|1
decl_stmt|;
name|this
operator|.
name|dataRawRowNone
operator|=
operator|new
name|byte
index|[
name|dataRowByteCount
index|]
expr_stmt|;
name|this
operator|.
name|dataRawRowSub
operator|=
operator|new
name|byte
index|[
name|dataRowByteCount
index|]
expr_stmt|;
name|this
operator|.
name|dataRawRowUp
operator|=
operator|new
name|byte
index|[
name|dataRowByteCount
index|]
expr_stmt|;
name|this
operator|.
name|dataRawRowAverage
operator|=
operator|new
name|byte
index|[
name|dataRowByteCount
index|]
expr_stmt|;
name|this
operator|.
name|dataRawRowPaeth
operator|=
operator|new
name|byte
index|[
name|dataRowByteCount
index|]
expr_stmt|;
comment|// Write the encoding markers
name|dataRawRowNone
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dataRawRowSub
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|dataRawRowUp
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|dataRawRowAverage
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
name|dataRawRowPaeth
index|[
literal|0
index|]
operator|=
literal|4
expr_stmt|;
comment|// c | b
comment|// -----
comment|// a | x
comment|//
comment|// x => current pixel
name|this
operator|.
name|aValues
operator|=
operator|new
name|byte
index|[
name|bytesPerPixel
index|]
expr_stmt|;
name|this
operator|.
name|cValues
operator|=
operator|new
name|byte
index|[
name|bytesPerPixel
index|]
expr_stmt|;
name|this
operator|.
name|bValues
operator|=
operator|new
name|byte
index|[
name|bytesPerPixel
index|]
expr_stmt|;
name|this
operator|.
name|xValues
operator|=
operator|new
name|byte
index|[
name|bytesPerPixel
index|]
expr_stmt|;
name|this
operator|.
name|tmpResultValues
operator|=
operator|new
name|byte
index|[
name|bytesPerPixel
index|]
expr_stmt|;
block|}
comment|/**          * Tries to compress the image using a predictor.          *          * @return the image or null if it is not possible to encoded the image (e.g. not supported          * raster format etc.)          */
name|PDImageXObject
name|encode
parameter_list|()
throws|throws
name|IOException
block|{
name|Raster
name|imageRaster
init|=
name|image
operator|.
name|getRaster
argument_list|()
decl_stmt|;
specifier|final
name|int
name|elementsInRowPerPixel
decl_stmt|;
comment|// This variable store a row of the image each, the exact type depends
comment|// on the image encoding. Can be a int[], short[] or byte[]
name|Object
name|prevRow
decl_stmt|,
name|transferRow
decl_stmt|;
switch|switch
condition|(
name|imageType
condition|)
block|{
case|case
name|BufferedImage
operator|.
name|TYPE_CUSTOM
case|:
block|{
switch|switch
condition|(
name|imageRaster
operator|.
name|getTransferType
argument_list|()
condition|)
block|{
case|case
name|DataBuffer
operator|.
name|TYPE_USHORT
case|:
name|elementsInRowPerPixel
operator|=
name|componentsPerPixel
expr_stmt|;
name|prevRow
operator|=
operator|new
name|short
index|[
name|width
operator|*
name|elementsInRowPerPixel
index|]
expr_stmt|;
name|transferRow
operator|=
operator|new
name|short
index|[
name|width
operator|*
name|elementsInRowPerPixel
index|]
expr_stmt|;
break|break;
case|case
name|DataBuffer
operator|.
name|TYPE_BYTE
case|:
name|elementsInRowPerPixel
operator|=
name|componentsPerPixel
expr_stmt|;
name|prevRow
operator|=
operator|new
name|byte
index|[
name|width
operator|*
name|elementsInRowPerPixel
index|]
expr_stmt|;
name|transferRow
operator|=
operator|new
name|byte
index|[
name|width
operator|*
name|elementsInRowPerPixel
index|]
expr_stmt|;
break|break;
default|default:
return|return
literal|null
return|;
block|}
break|break;
block|}
case|case
name|BufferedImage
operator|.
name|TYPE_3BYTE_BGR
case|:
case|case
name|BufferedImage
operator|.
name|TYPE_4BYTE_ABGR
case|:
block|{
name|elementsInRowPerPixel
operator|=
name|componentsPerPixel
expr_stmt|;
name|prevRow
operator|=
operator|new
name|byte
index|[
name|width
operator|*
name|elementsInRowPerPixel
index|]
expr_stmt|;
name|transferRow
operator|=
operator|new
name|byte
index|[
name|width
operator|*
name|elementsInRowPerPixel
index|]
expr_stmt|;
break|break;
block|}
case|case
name|BufferedImage
operator|.
name|TYPE_INT_BGR
case|:
case|case
name|BufferedImage
operator|.
name|TYPE_INT_ARGB
case|:
case|case
name|BufferedImage
operator|.
name|TYPE_INT_RGB
case|:
block|{
name|elementsInRowPerPixel
operator|=
literal|1
expr_stmt|;
name|prevRow
operator|=
operator|new
name|int
index|[
name|width
operator|*
name|elementsInRowPerPixel
index|]
expr_stmt|;
name|transferRow
operator|=
operator|new
name|int
index|[
name|width
operator|*
name|elementsInRowPerPixel
index|]
expr_stmt|;
break|break;
block|}
default|default:
comment|// We can not handle this unknown format
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|elementsInTransferRow
init|=
name|width
operator|*
name|elementsInRowPerPixel
decl_stmt|;
comment|// pre-size the output stream to half of the maximum size
name|ByteArrayOutputStream
name|stream
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|height
operator|*
name|width
operator|*
name|bytesPerPixel
operator|/
literal|2
argument_list|)
decl_stmt|;
name|Deflater
name|deflater
init|=
operator|new
name|Deflater
argument_list|(
name|Filter
operator|.
name|getCompressionLevel
argument_list|()
argument_list|)
decl_stmt|;
name|DeflaterOutputStream
name|zip
init|=
operator|new
name|DeflaterOutputStream
argument_list|(
name|stream
argument_list|,
name|deflater
argument_list|)
decl_stmt|;
name|int
name|alphaPtr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|rowNum
init|=
literal|0
init|;
name|rowNum
operator|<
name|height
condition|;
name|rowNum
operator|++
control|)
block|{
name|imageRaster
operator|.
name|getDataElements
argument_list|(
literal|0
argument_list|,
name|rowNum
argument_list|,
name|width
argument_list|,
literal|1
argument_list|,
name|transferRow
argument_list|)
expr_stmt|;
comment|// We start to write at index one, as the predictor marker is in index zero
name|int
name|writerPtr
init|=
literal|1
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|aValues
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|cValues
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
specifier|final
name|byte
index|[]
name|transferRowByte
decl_stmt|;
specifier|final
name|byte
index|[]
name|prevRowByte
decl_stmt|;
specifier|final
name|int
index|[]
name|transferRowInt
decl_stmt|;
specifier|final
name|int
index|[]
name|prevRowInt
decl_stmt|;
specifier|final
name|short
index|[]
name|transferRowShort
decl_stmt|;
specifier|final
name|short
index|[]
name|prevRowShort
decl_stmt|;
if|if
condition|(
name|transferRow
operator|instanceof
name|byte
index|[]
condition|)
block|{
name|transferRowByte
operator|=
operator|(
name|byte
index|[]
operator|)
name|transferRow
expr_stmt|;
name|prevRowByte
operator|=
operator|(
name|byte
index|[]
operator|)
name|prevRow
expr_stmt|;
name|transferRowInt
operator|=
name|prevRowInt
operator|=
literal|null
expr_stmt|;
name|transferRowShort
operator|=
name|prevRowShort
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|transferRow
operator|instanceof
name|int
index|[]
condition|)
block|{
name|transferRowInt
operator|=
operator|(
name|int
index|[]
operator|)
name|transferRow
expr_stmt|;
name|prevRowInt
operator|=
operator|(
name|int
index|[]
operator|)
name|prevRow
expr_stmt|;
name|transferRowShort
operator|=
name|prevRowShort
operator|=
literal|null
expr_stmt|;
name|transferRowByte
operator|=
name|prevRowByte
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// This must be short[]
name|transferRowShort
operator|=
operator|(
name|short
index|[]
operator|)
name|transferRow
expr_stmt|;
name|prevRowShort
operator|=
operator|(
name|short
index|[]
operator|)
name|prevRow
expr_stmt|;
name|transferRowInt
operator|=
name|prevRowInt
operator|=
literal|null
expr_stmt|;
name|transferRowByte
operator|=
name|prevRowByte
operator|=
literal|null
expr_stmt|;
block|}
for|for
control|(
name|int
name|indexInTransferRow
init|=
literal|0
init|;
name|indexInTransferRow
operator|<
name|elementsInTransferRow
condition|;
name|indexInTransferRow
operator|+=
name|elementsInRowPerPixel
operator|,
name|alphaPtr
operator|+=
name|bytesPerComponent
control|)
block|{
comment|// Copy the pixel values into the byte array
if|if
condition|(
name|transferRowByte
operator|!=
literal|null
condition|)
block|{
name|copyImageBytes
argument_list|(
name|transferRowByte
argument_list|,
name|indexInTransferRow
argument_list|,
name|xValues
argument_list|,
name|alphaImageData
argument_list|,
name|alphaPtr
argument_list|)
expr_stmt|;
name|copyImageBytes
argument_list|(
name|prevRowByte
argument_list|,
name|indexInTransferRow
argument_list|,
name|bValues
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|transferRowInt
operator|!=
literal|null
condition|)
block|{
name|copyIntToBytes
argument_list|(
name|transferRowInt
argument_list|,
name|indexInTransferRow
argument_list|,
name|xValues
argument_list|,
name|alphaImageData
argument_list|,
name|alphaPtr
argument_list|)
expr_stmt|;
name|copyIntToBytes
argument_list|(
name|prevRowInt
argument_list|,
name|indexInTransferRow
argument_list|,
name|bValues
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This must be short[]
name|copyShortsToBytes
argument_list|(
name|transferRowShort
argument_list|,
name|indexInTransferRow
argument_list|,
name|xValues
argument_list|,
name|alphaImageData
argument_list|,
name|alphaPtr
argument_list|)
expr_stmt|;
name|copyShortsToBytes
argument_list|(
name|prevRowShort
argument_list|,
name|indexInTransferRow
argument_list|,
name|bValues
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Encode the pixel values in the different encodings
name|int
name|length
init|=
name|xValues
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|bytePtr
init|=
literal|0
init|;
name|bytePtr
operator|<
name|length
condition|;
name|bytePtr
operator|++
control|)
block|{
name|int
name|x
init|=
name|xValues
index|[
name|bytePtr
index|]
operator|&
literal|0xFF
decl_stmt|;
name|int
name|a
init|=
name|aValues
index|[
name|bytePtr
index|]
operator|&
literal|0xFF
decl_stmt|;
name|int
name|b
init|=
name|bValues
index|[
name|bytePtr
index|]
operator|&
literal|0xFF
decl_stmt|;
name|int
name|c
init|=
name|cValues
index|[
name|bytePtr
index|]
operator|&
literal|0xFF
decl_stmt|;
name|dataRawRowNone
index|[
name|writerPtr
index|]
operator|=
operator|(
name|byte
operator|)
name|x
expr_stmt|;
name|dataRawRowSub
index|[
name|writerPtr
index|]
operator|=
name|pngFilterSub
argument_list|(
name|x
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|dataRawRowUp
index|[
name|writerPtr
index|]
operator|=
name|pngFilterUp
argument_list|(
name|x
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|dataRawRowAverage
index|[
name|writerPtr
index|]
operator|=
name|pngFilterAverage
argument_list|(
name|x
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|dataRawRowPaeth
index|[
name|writerPtr
index|]
operator|=
name|pngFilterPaeth
argument_list|(
name|x
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|writerPtr
operator|++
expr_stmt|;
block|}
comment|//  We shift the values into the prev / upper left values for the next pixel
name|System
operator|.
name|arraycopy
argument_list|(
name|xValues
argument_list|,
literal|0
argument_list|,
name|aValues
argument_list|,
literal|0
argument_list|,
name|bytesPerPixel
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bValues
argument_list|,
literal|0
argument_list|,
name|cValues
argument_list|,
literal|0
argument_list|,
name|bytesPerPixel
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|rowToWrite
init|=
name|chooseDataRowToWrite
argument_list|()
decl_stmt|;
comment|// Write and compress the row as long it is hot (CPU cache wise)
name|zip
operator|.
name|write
argument_list|(
name|rowToWrite
argument_list|,
literal|0
argument_list|,
name|rowToWrite
operator|.
name|length
argument_list|)
expr_stmt|;
block|{
comment|// We swap prev and transfer row, so that we have the prev row for the next row.
name|Object
name|temp
init|=
name|prevRow
decl_stmt|;
name|prevRow
operator|=
name|transferRow
expr_stmt|;
name|transferRow
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|zip
operator|.
name|close
argument_list|()
expr_stmt|;
name|deflater
operator|.
name|end
argument_list|()
expr_stmt|;
return|return
name|preparePredictorPDImage
argument_list|(
name|stream
argument_list|,
name|bytesPerComponent
operator|*
literal|8
argument_list|)
return|;
block|}
specifier|private
name|void
name|copyIntToBytes
parameter_list|(
name|int
index|[]
name|transferRow
parameter_list|,
name|int
name|indexInTranferRow
parameter_list|,
name|byte
index|[]
name|targetValues
parameter_list|,
name|byte
index|[]
name|alphaImageData
parameter_list|,
name|int
name|alphaPtr
parameter_list|)
block|{
name|int
name|val
init|=
name|transferRow
index|[
name|indexInTranferRow
index|]
decl_stmt|;
name|byte
name|b0
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0xFF
operator|)
argument_list|)
decl_stmt|;
name|byte
name|b1
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
decl_stmt|;
name|byte
name|b2
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|imageType
condition|)
block|{
case|case
name|BufferedImage
operator|.
name|TYPE_INT_BGR
case|:
block|{
name|targetValues
index|[
literal|0
index|]
operator|=
name|b0
expr_stmt|;
name|targetValues
index|[
literal|1
index|]
operator|=
name|b1
expr_stmt|;
name|targetValues
index|[
literal|2
index|]
operator|=
name|b2
expr_stmt|;
break|break;
block|}
case|case
name|BufferedImage
operator|.
name|TYPE_INT_ARGB
case|:
block|{
name|targetValues
index|[
literal|0
index|]
operator|=
name|b2
expr_stmt|;
name|targetValues
index|[
literal|1
index|]
operator|=
name|b1
expr_stmt|;
name|targetValues
index|[
literal|2
index|]
operator|=
name|b0
expr_stmt|;
if|if
condition|(
name|alphaImageData
operator|!=
literal|null
condition|)
block|{
name|byte
name|b3
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
decl_stmt|;
name|alphaImageData
index|[
name|alphaPtr
index|]
operator|=
name|b3
expr_stmt|;
block|}
break|break;
block|}
case|case
name|BufferedImage
operator|.
name|TYPE_INT_RGB
case|:
name|targetValues
index|[
literal|0
index|]
operator|=
name|b2
expr_stmt|;
name|targetValues
index|[
literal|1
index|]
operator|=
name|b1
expr_stmt|;
name|targetValues
index|[
literal|2
index|]
operator|=
name|b0
expr_stmt|;
break|break;
block|}
block|}
specifier|private
name|void
name|copyImageBytes
parameter_list|(
name|byte
index|[]
name|transferRow
parameter_list|,
name|int
name|indexInTranferRow
parameter_list|,
name|byte
index|[]
name|targetValues
parameter_list|,
name|byte
index|[]
name|alphaImageData
parameter_list|,
name|int
name|alphaPtr
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|transferRow
argument_list|,
name|indexInTranferRow
argument_list|,
name|targetValues
argument_list|,
literal|0
argument_list|,
name|targetValues
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|alphaImageData
operator|!=
literal|null
condition|)
block|{
name|alphaImageData
index|[
name|alphaPtr
index|]
operator|=
name|transferRow
index|[
name|indexInTranferRow
operator|+
name|targetValues
operator|.
name|length
index|]
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|copyShortsToBytes
parameter_list|(
name|short
index|[]
name|transferRow
parameter_list|,
name|int
name|indexInTranferRow
parameter_list|,
name|byte
index|[]
name|targetValues
parameter_list|,
name|byte
index|[]
name|alphaImageData
parameter_list|,
name|int
name|alphaPtr
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetValues
operator|.
name|length
condition|;
control|)
block|{
name|short
name|val
init|=
name|transferRow
index|[
name|indexInTranferRow
operator|++
index|]
decl_stmt|;
name|targetValues
index|[
name|i
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|targetValues
index|[
name|i
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|val
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alphaImageData
operator|!=
literal|null
condition|)
block|{
name|short
name|alpha
init|=
name|transferRow
index|[
name|indexInTranferRow
index|]
decl_stmt|;
name|alphaImageData
index|[
name|alphaPtr
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|alpha
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|alphaImageData
index|[
name|alphaPtr
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|alpha
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|PDImageXObject
name|preparePredictorPDImage
parameter_list|(
name|ByteArrayOutputStream
name|stream
parameter_list|,
name|int
name|bitsPerComponent
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|h
init|=
name|image
operator|.
name|getHeight
argument_list|()
decl_stmt|;
name|int
name|w
init|=
name|image
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|ColorSpace
name|srcCspace
init|=
name|image
operator|.
name|getColorModel
argument_list|()
operator|.
name|getColorSpace
argument_list|()
decl_stmt|;
name|PDColorSpace
name|pdColorSpace
init|=
name|srcCspace
operator|.
name|getType
argument_list|()
operator|!=
name|ColorSpace
operator|.
name|TYPE_CMYK
condition|?
name|PDDeviceRGB
operator|.
name|INSTANCE
else|:
name|PDDeviceCMYK
operator|.
name|INSTANCE
decl_stmt|;
comment|// Encode the image profile if the image has one
if|if
condition|(
name|srcCspace
operator|instanceof
name|ICC_ColorSpace
condition|)
block|{
name|ICC_ColorSpace
name|icc_colorSpace
init|=
operator|(
name|ICC_ColorSpace
operator|)
name|srcCspace
decl_stmt|;
name|ICC_Profile
name|profile
init|=
name|icc_colorSpace
operator|.
name|getProfile
argument_list|()
decl_stmt|;
comment|// We only encode a color profile if it is not sRGB
if|if
condition|(
name|profile
operator|!=
name|ICC_Profile
operator|.
name|getInstance
argument_list|(
name|ColorSpace
operator|.
name|CS_sRGB
argument_list|)
condition|)
block|{
name|PDICCBased
name|pdProfile
init|=
operator|new
name|PDICCBased
argument_list|(
name|document
argument_list|)
decl_stmt|;
name|OutputStream
name|outputStream
init|=
name|pdProfile
operator|.
name|getPDStream
argument_list|()
operator|.
name|createOutputStream
argument_list|(
name|COSName
operator|.
name|FLATE_DECODE
argument_list|)
decl_stmt|;
name|outputStream
operator|.
name|write
argument_list|(
name|profile
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
name|outputStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|pdProfile
operator|.
name|getPDStream
argument_list|()
operator|.
name|getCOSObject
argument_list|()
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|N
argument_list|,
name|srcCspace
operator|.
name|getNumComponents
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|PDImageXObject
name|imageXObject
init|=
operator|new
name|PDImageXObject
argument_list|(
name|document
argument_list|,
operator|new
name|ByteArrayInputStream
argument_list|(
name|stream
operator|.
name|toByteArray
argument_list|()
argument_list|)
argument_list|,
name|COSName
operator|.
name|FLATE_DECODE
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|bitsPerComponent
argument_list|,
name|pdColorSpace
argument_list|)
decl_stmt|;
name|COSDictionary
name|decodeParms
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|decodeParms
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|BITS_PER_COMPONENT
argument_list|,
name|COSInteger
operator|.
name|get
argument_list|(
name|bitsPerComponent
argument_list|)
argument_list|)
expr_stmt|;
name|decodeParms
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|PREDICTOR
argument_list|,
name|COSInteger
operator|.
name|get
argument_list|(
literal|15
argument_list|)
argument_list|)
expr_stmt|;
name|decodeParms
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|COLUMNS
argument_list|,
name|COSInteger
operator|.
name|get
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|decodeParms
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|COLORS
argument_list|,
name|COSInteger
operator|.
name|get
argument_list|(
name|srcCspace
operator|.
name|getNumComponents
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|imageXObject
operator|.
name|getCOSObject
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|DECODE_PARMS
argument_list|,
name|decodeParms
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|.
name|getTransparency
argument_list|()
operator|!=
name|Transparency
operator|.
name|OPAQUE
condition|)
block|{
name|PDImageXObject
name|pdMask
init|=
name|prepareImageXObject
argument_list|(
name|document
argument_list|,
name|alphaImageData
argument_list|,
name|image
operator|.
name|getWidth
argument_list|()
argument_list|,
name|image
operator|.
name|getHeight
argument_list|()
argument_list|,
literal|8
operator|*
name|bytesPerComponent
argument_list|,
name|PDDeviceGray
operator|.
name|INSTANCE
argument_list|)
decl_stmt|;
name|imageXObject
operator|.
name|getCOSObject
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|SMASK
argument_list|,
name|pdMask
argument_list|)
expr_stmt|;
block|}
return|return
name|imageXObject
return|;
block|}
comment|/**          * We look which row encoding is the "best" one, ie. has the lowest sum. We don't implement          * anything fancier to choose the right row encoding. This is just the recommend algorithm          * in the spec. The get the perfect encoding you would need to do a brute force check how          * all the different encoded rows compress in the zip stream together. You have would have          * to check 5*image-height permutations...          *          * @return the "best" row encoding of the row encodings          */
specifier|private
name|byte
index|[]
name|chooseDataRowToWrite
parameter_list|()
block|{
name|byte
index|[]
name|rowToWrite
init|=
name|dataRawRowNone
decl_stmt|;
name|long
name|estCompressSum
init|=
name|estCompressSum
argument_list|(
name|dataRawRowNone
argument_list|)
decl_stmt|;
name|long
name|estCompressSumSub
init|=
name|estCompressSum
argument_list|(
name|dataRawRowSub
argument_list|)
decl_stmt|;
name|long
name|estCompressSumUp
init|=
name|estCompressSum
argument_list|(
name|dataRawRowUp
argument_list|)
decl_stmt|;
name|long
name|estCompressSumAvg
init|=
name|estCompressSum
argument_list|(
name|dataRawRowAverage
argument_list|)
decl_stmt|;
name|long
name|estCompressSumPaeth
init|=
name|estCompressSum
argument_list|(
name|dataRawRowPaeth
argument_list|)
decl_stmt|;
if|if
condition|(
name|estCompressSum
operator|>
name|estCompressSumSub
condition|)
block|{
name|rowToWrite
operator|=
name|dataRawRowSub
expr_stmt|;
name|estCompressSum
operator|=
name|estCompressSumSub
expr_stmt|;
block|}
if|if
condition|(
name|estCompressSum
operator|>
name|estCompressSumUp
condition|)
block|{
name|rowToWrite
operator|=
name|dataRawRowUp
expr_stmt|;
name|estCompressSum
operator|=
name|estCompressSumUp
expr_stmt|;
block|}
if|if
condition|(
name|estCompressSum
operator|>
name|estCompressSumAvg
condition|)
block|{
name|rowToWrite
operator|=
name|dataRawRowAverage
expr_stmt|;
name|estCompressSum
operator|=
name|estCompressSumAvg
expr_stmt|;
block|}
if|if
condition|(
name|estCompressSum
operator|>
name|estCompressSumPaeth
condition|)
block|{
name|rowToWrite
operator|=
name|dataRawRowPaeth
expr_stmt|;
block|}
return|return
name|rowToWrite
return|;
block|}
comment|/*          * PNG Filters, see https://www.w3.org/TR/PNG-Filters.html          */
specifier|private
specifier|static
name|byte
name|pngFilterSub
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|a
parameter_list|)
block|{
return|return
call|(
name|byte
call|)
argument_list|(
operator|(
name|x
operator|&
literal|0xFF
operator|)
operator|-
operator|(
name|a
operator|&
literal|0xFF
operator|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|byte
name|pngFilterUp
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|b
parameter_list|)
block|{
comment|// Same as pngFilterSub, just called with the prior row
return|return
name|pngFilterSub
argument_list|(
name|x
argument_list|,
name|b
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|byte
name|pngFilterAverage
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
call|(
name|byte
call|)
argument_list|(
name|x
operator|-
operator|(
operator|(
name|b
operator|+
name|a
operator|)
operator|/
literal|2
operator|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|byte
name|pngFilterPaeth
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|p
init|=
name|a
operator|+
name|b
operator|-
name|c
decl_stmt|;
name|int
name|pa
init|=
name|Math
operator|.
name|abs
argument_list|(
name|p
operator|-
name|a
argument_list|)
decl_stmt|;
name|int
name|pb
init|=
name|Math
operator|.
name|abs
argument_list|(
name|p
operator|-
name|b
argument_list|)
decl_stmt|;
name|int
name|pc
init|=
name|Math
operator|.
name|abs
argument_list|(
name|p
operator|-
name|c
argument_list|)
decl_stmt|;
specifier|final
name|int
name|Pr
decl_stmt|;
if|if
condition|(
name|pa
operator|<=
name|pb
operator|&&
name|pa
operator|<=
name|pc
condition|)
block|{
name|Pr
operator|=
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pb
operator|<=
name|pc
condition|)
block|{
name|Pr
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
name|Pr
operator|=
name|c
expr_stmt|;
block|}
name|int
name|r
init|=
name|x
operator|-
name|Pr
decl_stmt|;
return|return
call|(
name|byte
call|)
argument_list|(
name|r
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|long
name|estCompressSum
parameter_list|(
name|byte
index|[]
name|dataRawRowSub
parameter_list|)
block|{
name|long
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|byte
name|aDataRawRowSub
range|:
name|dataRawRowSub
control|)
block|{
name|sum
operator|+=
name|aDataRawRowSub
operator|&
literal|0xFF
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
block|}
block|}
end_class

end_unit

