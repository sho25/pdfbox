begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|print
operator|.
name|PageFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|print
operator|.
name|Pageable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|print
operator|.
name|Printable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|print
operator|.
name|PrinterException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|print
operator|.
name|PrinterJob
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|COSVisitorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|CryptographyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|InvalidPasswordException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
operator|.
name|PDFParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfwriter
operator|.
name|COSWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|COSArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|AccessPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|BadSecurityHandlerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|DecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|PDEncryptionDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|ProtectionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|SecurityHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|SecurityHandlersManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|StandardDecryptionMaterial
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|StandardProtectionPolicy
import|;
end_import

begin_comment
comment|/**  * This is the in-memory representation of the PDF document.  You need to call  * close() on this object when you are done using it!!  *<p>  * This class implements the {@link Pageable} interface, but since PDFBox  * version 1.3.0 you should be using the {@link PDPageable} adapter instead  * (see<a href="https://issues.apache.org/jira/browse/PDFBOX-788">PDFBOX-788</a>).  *  * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  * @version $Revision: 1.47 $  */
end_comment

begin_class
specifier|public
class|class
name|PDDocument
implements|implements
name|Pageable
block|{
specifier|private
name|COSDocument
name|document
decl_stmt|;
comment|// NOTE BGUILLON: this property must be removed because it is
comment|// not the responsability of this class to know
comment|//private boolean encryptOnSave = false;
comment|// NOTE BGUILLON: these properties are not used anymore. See getCurrentAccessPermission() instead
comment|//private String encryptUserPassword = null;
comment|//private String encryptOwnerPassword = null;
comment|//cached values
specifier|private
name|PDDocumentInformation
name|documentInformation
decl_stmt|;
specifier|private
name|PDDocumentCatalog
name|documentCatalog
decl_stmt|;
comment|//The encParameters will be cached here.  When the document is decrypted then
comment|//the COSDocument will not have an "Encrypt" dictionary anymore and this object
comment|//must be used.
specifier|private
name|PDEncryptionDictionary
name|encParameters
init|=
literal|null
decl_stmt|;
comment|/**      * This will tell if the document was decrypted with the master password.      * NOTE BGUILLON: this property is not used anymore. See getCurrentAccessPermission() instead      */
comment|//private boolean decryptedWithOwnerPassword = false;
comment|/**      * The security handler used to decrypt / encrypt the document.      */
specifier|private
name|SecurityHandler
name|securityHandler
init|=
literal|null
decl_stmt|;
comment|/**      * This assocates object ids with a page number.  It's used to determine      * the page number for bookmarks (or page numbers for anything else for      * which you have an object id for that matter).       */
specifier|private
name|Map
name|pageMap
init|=
literal|null
decl_stmt|;
comment|/**      * This will hold a flag which tells us if we should remove all security      * from this documents      */
specifier|private
name|boolean
name|allSecurityToBeRemoved
init|=
literal|false
decl_stmt|;
comment|/**      * Constructor, creates a new PDF Document with no pages.  You need to add      * at least one page for the document to be valid.      *      * @throws IOException If there is an error creating this document.      */
specifier|public
name|PDDocument
parameter_list|()
throws|throws
name|IOException
block|{
name|document
operator|=
operator|new
name|COSDocument
argument_list|()
expr_stmt|;
comment|//First we need a trailer
name|COSDictionary
name|trailer
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|document
operator|.
name|setTrailer
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
comment|//Next we need the root dictionary.
name|COSDictionary
name|rootDictionary
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|,
name|rootDictionary
argument_list|)
expr_stmt|;
name|rootDictionary
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|,
name|COSName
operator|.
name|CATALOG
argument_list|)
expr_stmt|;
name|rootDictionary
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|VERSION
argument_list|,
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"1.4"
argument_list|)
argument_list|)
expr_stmt|;
comment|//next we need the pages tree structure
name|COSDictionary
name|pages
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|rootDictionary
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|PAGES
argument_list|,
name|pages
argument_list|)
expr_stmt|;
name|pages
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|,
name|COSName
operator|.
name|PAGES
argument_list|)
expr_stmt|;
name|COSArray
name|kidsArray
init|=
operator|new
name|COSArray
argument_list|()
decl_stmt|;
name|pages
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|KIDS
argument_list|,
name|kidsArray
argument_list|)
expr_stmt|;
name|pages
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|COUNT
argument_list|,
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|generatePageMap
parameter_list|()
block|{
name|pageMap
operator|=
operator|new
name|HashMap
argument_list|()
expr_stmt|;
comment|// these page nodes could be references to pages,
comment|// or references to arrays which have references to pages
comment|// or references to arrays which have references to arrays which have references to pages
comment|// or ... (I think you get the idea...)
name|processListOfPageReferences
argument_list|(
name|getDocumentCatalog
argument_list|()
operator|.
name|getPages
argument_list|()
operator|.
name|getKids
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|processListOfPageReferences
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|pageNodes
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pageNodes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Object
name|pageOrArray
init|=
name|pageNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageOrArray
operator|instanceof
name|PDPage
condition|)
block|{
name|COSArray
name|pageArray
init|=
operator|(
call|(
name|COSArrayList
call|)
argument_list|(
operator|(
operator|(
name|PDPage
operator|)
name|pageOrArray
operator|)
operator|.
name|getParent
argument_list|()
argument_list|)
operator|.
name|getKids
argument_list|()
operator|)
operator|.
name|toList
argument_list|()
decl_stmt|;
name|parseCatalogObject
argument_list|(
operator|(
name|COSObject
operator|)
name|pageArray
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pageOrArray
operator|instanceof
name|PDPageNode
condition|)
block|{
name|processListOfPageReferences
argument_list|(
operator|(
operator|(
name|PDPageNode
operator|)
name|pageOrArray
operator|)
operator|.
name|getKids
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This will either add the page passed in, or, if it's a pointer to an array      * of pages, it'll recursivly call itself and process everything in the list.      */
specifier|private
name|void
name|parseCatalogObject
parameter_list|(
name|COSObject
name|thePageOrArrayObject
parameter_list|)
block|{
name|COSBase
name|arrayCountBase
init|=
name|thePageOrArrayObject
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|COUNT
argument_list|)
decl_stmt|;
name|int
name|arrayCount
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|arrayCountBase
operator|instanceof
name|COSInteger
condition|)
block|{
name|arrayCount
operator|=
operator|(
operator|(
name|COSInteger
operator|)
name|arrayCountBase
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
name|COSBase
name|kidsBase
init|=
name|thePageOrArrayObject
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|KIDS
argument_list|)
decl_stmt|;
name|int
name|kidsCount
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|kidsBase
operator|instanceof
name|COSArray
condition|)
block|{
name|kidsCount
operator|=
operator|(
operator|(
name|COSArray
operator|)
name|kidsBase
operator|)
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|arrayCount
operator|==
operator|-
literal|1
operator|||
name|kidsCount
operator|==
operator|-
literal|1
condition|)
block|{
comment|// these cases occur when we have a page, not an array of pages
name|String
name|objStr
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|thePageOrArrayObject
operator|.
name|getObjectNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|genStr
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|thePageOrArrayObject
operator|.
name|getGenerationNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|getPageMap
argument_list|()
operator|.
name|put
argument_list|(
name|objStr
operator|+
literal|","
operator|+
name|genStr
argument_list|,
operator|new
name|Integer
argument_list|(
name|getPageMap
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we either have an array of page pointers, or an array of arrays
if|if
condition|(
name|arrayCount
operator|==
name|kidsCount
condition|)
block|{
comment|// process the kids... they're all references to pages
name|COSArray
name|kidsArray
init|=
operator|(
operator|(
name|COSArray
operator|)
name|kidsBase
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kidsArray
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|COSObject
name|thisObject
init|=
operator|(
name|COSObject
operator|)
name|kidsArray
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|objStr
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|thisObject
operator|.
name|getObjectNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|genStr
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|thisObject
operator|.
name|getGenerationNumber
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|getPageMap
argument_list|()
operator|.
name|put
argument_list|(
name|objStr
operator|+
literal|","
operator|+
name|genStr
argument_list|,
operator|new
name|Integer
argument_list|(
name|getPageMap
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// this object is an array of references to other arrays
name|COSArray
name|list
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|kidsBase
operator|instanceof
name|COSArray
condition|)
block|{
name|list
operator|=
operator|(
operator|(
name|COSArray
operator|)
name|kidsBase
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|arrayCounter
init|=
literal|0
init|;
name|arrayCounter
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
operator|++
name|arrayCounter
control|)
block|{
name|parseCatalogObject
argument_list|(
operator|(
name|COSObject
operator|)
name|list
operator|.
name|get
argument_list|(
name|arrayCounter
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * This will return the Map containing the mapping from object-ids to pagenumbers.      *       * @return the pageMap      */
specifier|public
specifier|final
name|Map
name|getPageMap
parameter_list|()
block|{
if|if
condition|(
name|pageMap
operator|==
literal|null
condition|)
block|{
name|generatePageMap
argument_list|()
expr_stmt|;
block|}
return|return
name|pageMap
return|;
block|}
comment|/**      * This will add a page to the document.  This is a convenience method, that      * will add the page to the root of the hierarchy and set the parent of the      * page to the root.      *      * @param page The page to add to the document.      */
specifier|public
name|void
name|addPage
parameter_list|(
name|PDPage
name|page
parameter_list|)
block|{
name|PDPageNode
name|rootPages
init|=
name|getDocumentCatalog
argument_list|()
operator|.
name|getPages
argument_list|()
decl_stmt|;
name|rootPages
operator|.
name|getKids
argument_list|()
operator|.
name|add
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|.
name|setParent
argument_list|(
name|rootPages
argument_list|)
expr_stmt|;
name|rootPages
operator|.
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**      * Remove the page from the document.      *      * @param page The page to remove from the document.      *      * @return true if the page was found false otherwise.      */
specifier|public
name|boolean
name|removePage
parameter_list|(
name|PDPage
name|page
parameter_list|)
block|{
name|PDPageNode
name|parent
init|=
name|page
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|boolean
name|retval
init|=
name|parent
operator|.
name|getKids
argument_list|()
operator|.
name|remove
argument_list|(
name|page
argument_list|)
decl_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
comment|//do a recursive updateCount starting at the root
comment|//of the document
name|getDocumentCatalog
argument_list|()
operator|.
name|getPages
argument_list|()
operator|.
name|updateCount
argument_list|()
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Remove the page from the document.      *      * @param pageNumber 0 based index to page number.      * @return true if the page was found false otherwise.      */
specifier|public
name|boolean
name|removePage
parameter_list|(
name|int
name|pageNumber
parameter_list|)
block|{
name|boolean
name|removed
init|=
literal|false
decl_stmt|;
name|List
name|allPages
init|=
name|getDocumentCatalog
argument_list|()
operator|.
name|getAllPages
argument_list|()
decl_stmt|;
if|if
condition|(
name|allPages
operator|.
name|size
argument_list|()
operator|>
name|pageNumber
condition|)
block|{
name|PDPage
name|page
init|=
operator|(
name|PDPage
operator|)
name|allPages
operator|.
name|get
argument_list|(
name|pageNumber
argument_list|)
decl_stmt|;
name|removed
operator|=
name|removePage
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
comment|/**      * This will import and copy the contents from another location.  Currently      * the content stream is stored in a scratch file.  The scratch file is      * associated with the document.  If you are adding a page to this document      * from another document and want to copy the contents to this document's      * scratch file then use this method otherwise just use the addPage method.      *      * @param page The page to import.      * @return The page that was imported.      *      * @throws IOException If there is an error copying the page.      */
specifier|public
name|PDPage
name|importPage
parameter_list|(
name|PDPage
name|page
parameter_list|)
throws|throws
name|IOException
block|{
name|PDPage
name|importedPage
init|=
operator|new
name|PDPage
argument_list|(
operator|new
name|COSDictionary
argument_list|(
name|page
operator|.
name|getCOSDictionary
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
name|OutputStream
name|os
init|=
literal|null
decl_stmt|;
try|try
block|{
name|PDStream
name|src
init|=
name|page
operator|.
name|getContents
argument_list|()
decl_stmt|;
name|PDStream
name|dest
init|=
operator|new
name|PDStream
argument_list|(
operator|new
name|COSStream
argument_list|(
name|src
operator|.
name|getStream
argument_list|()
argument_list|,
name|document
operator|.
name|getScratchFile
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|importedPage
operator|.
name|setContents
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|os
operator|=
name|dest
operator|.
name|createOutputStream
argument_list|()
expr_stmt|;
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|10240
index|]
decl_stmt|;
name|int
name|amountRead
init|=
literal|0
decl_stmt|;
name|is
operator|=
name|src
operator|.
name|createInputStream
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|amountRead
operator|=
name|is
operator|.
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|10240
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
name|os
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|amountRead
argument_list|)
expr_stmt|;
block|}
name|addPage
argument_list|(
name|importedPage
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|os
operator|!=
literal|null
condition|)
block|{
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|importedPage
return|;
block|}
comment|/**      * Constructor that uses an existing document.  The COSDocument that      * is passed in must be valid.      *      * @param doc The COSDocument that this document wraps.      */
specifier|public
name|PDDocument
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
block|{
name|document
operator|=
name|doc
expr_stmt|;
block|}
comment|/**      * This will get the low level document.      *      * @return The document that this layer sits on top of.      */
specifier|public
name|COSDocument
name|getDocument
parameter_list|()
block|{
return|return
name|document
return|;
block|}
comment|/**      * This will get the document info dictionary.  This is guaranteed to not return null.      *      * @return The documents /Info dictionary      */
specifier|public
name|PDDocumentInformation
name|getDocumentInformation
parameter_list|()
block|{
if|if
condition|(
name|documentInformation
operator|==
literal|null
condition|)
block|{
name|COSDictionary
name|trailer
init|=
name|document
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|COSDictionary
name|infoDic
init|=
operator|(
name|COSDictionary
operator|)
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoDic
operator|==
literal|null
condition|)
block|{
name|infoDic
operator|=
operator|new
name|COSDictionary
argument_list|()
expr_stmt|;
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|,
name|infoDic
argument_list|)
expr_stmt|;
block|}
name|documentInformation
operator|=
operator|new
name|PDDocumentInformation
argument_list|(
name|infoDic
argument_list|)
expr_stmt|;
block|}
return|return
name|documentInformation
return|;
block|}
comment|/**      * This will set the document information for this document.      *      * @param info The updated document information.      */
specifier|public
name|void
name|setDocumentInformation
parameter_list|(
name|PDDocumentInformation
name|info
parameter_list|)
block|{
name|documentInformation
operator|=
name|info
expr_stmt|;
name|document
operator|.
name|getTrailer
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|,
name|info
operator|.
name|getDictionary
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will get the document CATALOG.  This is guaranteed to not return null.      *      * @return The documents /Root dictionary      */
specifier|public
name|PDDocumentCatalog
name|getDocumentCatalog
parameter_list|()
block|{
if|if
condition|(
name|documentCatalog
operator|==
literal|null
condition|)
block|{
name|COSDictionary
name|trailer
init|=
name|document
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|COSDictionary
name|infoDic
init|=
operator|(
name|COSDictionary
operator|)
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|infoDic
operator|==
literal|null
condition|)
block|{
name|documentCatalog
operator|=
operator|new
name|PDDocumentCatalog
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|documentCatalog
operator|=
operator|new
name|PDDocumentCatalog
argument_list|(
name|this
argument_list|,
name|infoDic
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|documentCatalog
return|;
block|}
comment|/**      * This will tell if this document is encrypted or not.      *      * @return true If this document is encrypted.      */
specifier|public
name|boolean
name|isEncrypted
parameter_list|()
block|{
return|return
name|document
operator|.
name|isEncrypted
argument_list|()
return|;
block|}
comment|/**      * This will get the encryption dictionary for this document.  This will still      * return the parameters if the document was decrypted.  If the document was      * never encrypted then this will return null.  As the encryption architecture      * in PDF documents is plugable this returns an abstract class, but the only      * supported subclass at this time is a PDStandardEncryption object.      *      * @return The encryption dictionary(most likely a PDStandardEncryption object)      *      * @throws IOException If there is an error determining which security handler to use.      */
specifier|public
name|PDEncryptionDictionary
name|getEncryptionDictionary
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|encParameters
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isEncrypted
argument_list|()
condition|)
block|{
name|encParameters
operator|=
operator|new
name|PDEncryptionDictionary
argument_list|(
name|document
operator|.
name|getEncryptionDictionary
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|encParameters
return|;
block|}
comment|/**      * This will set the encryption dictionary for this document.      *      * @param encDictionary The encryption dictionary(most likely a PDStandardEncryption object)      *      * @throws IOException If there is an error determining which security handler to use.      */
specifier|public
name|void
name|setEncryptionDictionary
parameter_list|(
name|PDEncryptionDictionary
name|encDictionary
parameter_list|)
throws|throws
name|IOException
block|{
name|encParameters
operator|=
name|encDictionary
expr_stmt|;
block|}
comment|/**      * This will determine if this is the user password.  This only applies when      * the document is encrypted and uses standard encryption.      *      * @param password The plain text user password.      *      * @return true If the password passed in matches the user password used to encrypt the document.      *      * @throws IOException If there is an error determining if it is the user password.      * @throws CryptographyException If there is an error in the encryption algorithms.      *      * @deprecated      */
specifier|public
name|boolean
name|isUserPassword
parameter_list|(
name|String
name|password
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
block|{
return|return
literal|false
return|;
comment|/*boolean retval = false;         if( password == null )         {             password = "";         }         PDFEncryption encryptor = new PDFEncryption();         PDEncryptionDictionary encryptionDictionary = getEncryptionDictionary();         if( encryptionDictionary == null )         {             throw new IOException( "Error: Document is not encrypted" );         }         else         {             if( encryptionDictionary instanceof PDStandardEncryption )             {                 COSString documentID = (COSString)document.getDocumentID().get(0);                 PDStandardEncryption standard = (PDStandardEncryption)encryptionDictionary;                 retval = encryptor.isUserPassword(                     password.getBytes(),                     standard.getUserKey(),                     standard.getOwnerKey(),                     standard.getPermissions(),                     documentID.getBytes(),                     standard.getRevision(),                     standard.getLength()/8 );             }             else             {                 throw new IOException( "Error: Encyption dictionary is not 'Standard'" +                     encryptionDictionary.getClass().getName() );             }         }         return retval;*/
block|}
comment|/**      * This will determine if this is the owner password.  This only applies when      * the document is encrypted and uses standard encryption.      *      * @param password The plain text owner password.      *      * @return true If the password passed in matches the owner password used to encrypt the document.      *      * @throws IOException If there is an error determining if it is the user password.      * @throws CryptographyException If there is an error in the encryption algorithms.      *      * @deprecated      */
specifier|public
name|boolean
name|isOwnerPassword
parameter_list|(
name|String
name|password
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
block|{
return|return
literal|false
return|;
comment|/*boolean retval = false;         if( password == null )         {             password = "";         }         PDFEncryption encryptor = new PDFEncryption();         PDEncryptionDictionary encryptionDictionary = getEncryptionDictionary();         if( encryptionDictionary == null )         {             throw new IOException( "Error: Document is not encrypted" );         }         else         {             if( encryptionDictionary instanceof PDStandardEncryption )             {                 COSString documentID = (COSString)document.getDocumentID().get( 0 );                 PDStandardEncryption standard = (PDStandardEncryption)encryptionDictionary;                 retval = encryptor.isOwnerPassword(                     password.getBytes(),                     standard.getUserKey(),                     standard.getOwnerKey(),                     standard.getPermissions(),                     documentID.getBytes(),                     standard.getRevision(),                     standard.getLength()/8 );             }             else             {                 throw new IOException( "Error: Encyption dictionary is not 'Standard'" +                     encryptionDictionary.getClass().getName() );             }         }         return retval;*/
block|}
comment|/**      * This will decrypt a document. This method is provided for compatibility reasons only. User should use      * the new security layer instead and the openProtection method especially.      *      * @param password Either the user or owner password.      *      * @throws CryptographyException If there is an error decrypting the document.      * @throws IOException If there is an error getting the stream data.      * @throws InvalidPasswordException If the password is not a user or owner password.      *      */
specifier|public
name|void
name|decrypt
parameter_list|(
name|String
name|password
parameter_list|)
throws|throws
name|CryptographyException
throws|,
name|IOException
throws|,
name|InvalidPasswordException
block|{
try|try
block|{
name|StandardDecryptionMaterial
name|m
init|=
operator|new
name|StandardDecryptionMaterial
argument_list|(
name|password
argument_list|)
decl_stmt|;
name|this
operator|.
name|openProtection
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|document
operator|.
name|dereferenceObjectStreams
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BadSecurityHandlerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * This will tell if the document was decrypted with the master password.  This      * entry is invalid if the PDF was not decrypted.      *      * @return true if the pdf was decrypted with the master password.      *      * @deprecated use<code>getCurrentAccessPermission</code> instead      */
specifier|public
name|boolean
name|wasDecryptedWithOwnerPassword
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**      * This will<b>mark</b> a document to be encrypted.  The actual encryption      * will occur when the document is saved.      * This method is provided for compatibility reasons only. User should use      * the new security layer instead and the openProtection method especially.      *      * @param ownerPassword The owner password to encrypt the document.      * @param userPassword The user password to encrypt the document.      *      * @throws CryptographyException If an error occurs during encryption.      * @throws IOException If there is an error accessing the data.      *      */
specifier|public
name|void
name|encrypt
parameter_list|(
name|String
name|ownerPassword
parameter_list|,
name|String
name|userPassword
parameter_list|)
throws|throws
name|CryptographyException
throws|,
name|IOException
block|{
try|try
block|{
name|StandardProtectionPolicy
name|policy
init|=
operator|new
name|StandardProtectionPolicy
argument_list|(
name|ownerPassword
argument_list|,
name|userPassword
argument_list|,
operator|new
name|AccessPermission
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|protect
argument_list|(
name|policy
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BadSecurityHandlerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * The owner password that was passed into the encrypt method. You should      * never use this method.  This will not longer be valid once encryption      * has occured.      *      * @return The owner password passed to the encrypt method.      *      * @deprecated Do not rely on this method anymore.      */
specifier|public
name|String
name|getOwnerPasswordForEncryption
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**      * The user password that was passed into the encrypt method.  You should      * never use this method.  This will not longer be valid once encryption      * has occured.      *      * @return The user password passed to the encrypt method.      *      * @deprecated Do not rely on this method anymore.      */
specifier|public
name|String
name|getUserPasswordForEncryption
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**      * Internal method do determine if the document will be encrypted when it is saved.      *      * @return True if encrypt has been called and the document      *              has not been saved yet.      *      * @deprecated Do not rely on this method anymore. It is the responsibility of      * COSWriter to hold this state      */
specifier|public
name|boolean
name|willEncryptWhenSaving
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**      * This shoule only be called by the COSWriter after encryption has completed.      *      * @deprecated Do not rely on this method anymore. It is the responsability of      * COSWriter to hold this state.      */
specifier|public
name|void
name|clearWillEncryptWhenSaving
parameter_list|()
block|{
comment|//method is deprecated.
block|}
comment|/**      * This will load a document from a url.      *      * @param url The url to load the PDF from.      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|URL
name|url
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|load
argument_list|(
name|url
operator|.
name|openStream
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will load a document from a url. Used for skipping corrupt      * pdf objects      *      * @param url The url to load the PDF from.      * @param force When true, the parser will skip corrupt pdf objects and       * will continue parsing at the next object in the file      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|URL
name|url
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|load
argument_list|(
name|url
operator|.
name|openStream
argument_list|()
argument_list|,
name|force
argument_list|)
return|;
block|}
comment|/**      * This will load a document from a url.      *      * @param url The url to load the PDF from.      * @param scratchFile A location to store temp PDFBox data for this document.      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|URL
name|url
parameter_list|,
name|RandomAccess
name|scratchFile
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|load
argument_list|(
name|url
operator|.
name|openStream
argument_list|()
argument_list|,
name|scratchFile
argument_list|)
return|;
block|}
comment|/**      * This will load a document from a file.      *      * @param filename The name of the file to load.      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|load
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|filename
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * This will load a document from a file. Allows for skipping corrupt pdf      * objects      *      * @param filename The name of the file to load.      * @param force When true, the parser will skip corrupt pdf objects and       * will continue parsing at the next object in the file      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|String
name|filename
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|load
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|filename
argument_list|)
argument_list|,
name|force
argument_list|)
return|;
block|}
comment|/**      * This will load a document from a file.      *      * @param filename The name of the file to load.      * @param scratchFile A location to store temp PDFBox data for this document.      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|String
name|filename
parameter_list|,
name|RandomAccess
name|scratchFile
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|load
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|filename
argument_list|)
argument_list|,
name|scratchFile
argument_list|)
return|;
block|}
comment|/**      * This will load a document from a file.      *      * @param file The name of the file to load.      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|load
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * This will load a document from a file.      *      * @param file The name of the file to load.      * @param scratchFile A location to store temp PDFBox data for this document.      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|File
name|file
parameter_list|,
name|RandomAccess
name|scratchFile
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|load
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|,
name|scratchFile
argument_list|)
return|;
block|}
comment|/**      * This will load a document from an input stream.      *      * @param input The stream that contains the document.      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|load
argument_list|(
name|input
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * This will load a document from an input stream.      * Allows for skipping corrupt pdf objects      *      * @param input The stream that contains the document.      * @param force When true, the parser will skip corrupt pdf objects and       * will continue parsing at the next object in the file      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|load
argument_list|(
name|input
argument_list|,
literal|null
argument_list|,
name|force
argument_list|)
return|;
block|}
comment|/**      * This will load a document from an input stream.      *      * @param input The stream that contains the document.      * @param scratchFile A location to store temp PDFBox data for this document.      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|RandomAccess
name|scratchFile
parameter_list|)
throws|throws
name|IOException
block|{
name|PDFParser
name|parser
init|=
operator|new
name|PDFParser
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|input
argument_list|)
argument_list|,
name|scratchFile
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
return|return
name|parser
operator|.
name|getPDDocument
argument_list|()
return|;
block|}
comment|/**      * This will load a document from an input stream. Allows for skipping corrupt pdf objects      *       * @param input The stream that contains the document.      * @param scratchFile A location to store temp PDFBox data for this document.      * @param force When true, the parser will skip corrupt pdf objects and       * will continue parsing at the next object in the file      *      * @return The document that was loaded.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|public
specifier|static
name|PDDocument
name|load
parameter_list|(
name|InputStream
name|input
parameter_list|,
name|RandomAccess
name|scratchFile
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|PDFParser
name|parser
init|=
operator|new
name|PDFParser
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|input
argument_list|)
argument_list|,
name|scratchFile
argument_list|,
name|force
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
return|return
name|parser
operator|.
name|getPDDocument
argument_list|()
return|;
block|}
comment|/**      * This will save this document to the filesystem.      *      * @param fileName The file to save as.      *      * @throws IOException If there is an error saving the document.      * @throws COSVisitorException If an error occurs while generating the data.      */
specifier|public
name|void
name|save
parameter_list|(
name|String
name|fileName
parameter_list|)
throws|throws
name|IOException
throws|,
name|COSVisitorException
block|{
name|save
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will save the document to an output stream.      *      * @param output The stream to write to.      *      * @throws IOException If there is an error writing the document.      * @throws COSVisitorException If an error occurs while generating the data.      */
specifier|public
name|void
name|save
parameter_list|(
name|OutputStream
name|output
parameter_list|)
throws|throws
name|IOException
throws|,
name|COSVisitorException
block|{
comment|//update the count in case any pages have been added behind the scenes.
name|getDocumentCatalog
argument_list|()
operator|.
name|getPages
argument_list|()
operator|.
name|updateCount
argument_list|()
expr_stmt|;
name|COSWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
operator|new
name|COSWriter
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This will return the total page count of the PDF document.  Note: This method      * is deprecated in favor of the getNumberOfPages method.  The getNumberOfPages is      * a required interface method of the Pageable interface.  This method will      * be removed in a future version of PDFBox!!      *      * @return The total number of pages in the PDF document.      * @deprecated Use the getNumberOfPages method instead!      */
specifier|public
name|int
name|getPageCount
parameter_list|()
block|{
return|return
name|getNumberOfPages
argument_list|()
return|;
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|int
name|getNumberOfPages
parameter_list|()
block|{
name|PDDocumentCatalog
name|cat
init|=
name|getDocumentCatalog
argument_list|()
decl_stmt|;
return|return
operator|(
name|int
operator|)
name|cat
operator|.
name|getPages
argument_list|()
operator|.
name|getCount
argument_list|()
return|;
block|}
comment|/**      * Returns the format of the page at the given index when using a      * default printer job returned by  {@link PrinterJob#getPrinterJob()}.      *      * @deprecated Use the {@link PDPageable} adapter class      * @param i page index, zero-based      * @return page format      * @throws IndexOutOfBoundsException if the page index is invalid      */
specifier|public
name|PageFormat
name|getPageFormat
parameter_list|(
name|int
name|pageIndex
parameter_list|)
block|{
try|try
block|{
name|PrinterJob
name|printerJob
init|=
name|PrinterJob
operator|.
name|getPrinterJob
argument_list|()
decl_stmt|;
return|return
operator|new
name|PDPageable
argument_list|(
name|this
argument_list|,
name|printerJob
argument_list|)
operator|.
name|getPageFormat
argument_list|(
name|pageIndex
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PrinterException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|Printable
name|getPrintable
parameter_list|(
name|int
name|pageIndex
parameter_list|)
block|{
return|return
operator|(
name|Printable
operator|)
name|getDocumentCatalog
argument_list|()
operator|.
name|getAllPages
argument_list|()
operator|.
name|get
argument_list|(
name|pageIndex
argument_list|)
return|;
block|}
comment|/**      * @see PDDocument#print()      *      * @param printJob The printer job.      *      * @throws PrinterException If there is an error while sending the PDF to      * the printer, or you do not have permissions to print this document.      */
specifier|public
name|void
name|print
parameter_list|(
name|PrinterJob
name|printJob
parameter_list|)
throws|throws
name|PrinterException
block|{
name|print
argument_list|(
name|printJob
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will send the PDF document to a printer.  The printing functionality      * depends on the org.apache.pdfbox.pdfviewer.PageDrawer functionality.  The PageDrawer      * is a work in progress and some PDFs will print correctly and some will      * not.  This is a convenience method to create the java.awt.print.PrinterJob.      * The PDDocument implements the java.awt.print.Pageable interface and      * PDPage implementes the java.awt.print.Printable interface, so advanced printing      * capabilities can be done by using those interfaces instead of this method.      *      * @throws PrinterException If there is an error while sending the PDF to      * the printer, or you do not have permissions to print this document.      */
specifier|public
name|void
name|print
parameter_list|()
throws|throws
name|PrinterException
block|{
name|print
argument_list|(
name|PrinterJob
operator|.
name|getPrinterJob
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will send the PDF to the default printer without prompting the user      * for any printer settings.      *      * @see PDDocument#print()      *      * @throws PrinterException If there is an error while printing.      */
specifier|public
name|void
name|silentPrint
parameter_list|()
throws|throws
name|PrinterException
block|{
name|silentPrint
argument_list|(
name|PrinterJob
operator|.
name|getPrinterJob
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will send the PDF to the default printer without prompting the user      * for any printer settings.      *      * @param printJob A printer job definition.      * @see PDDocument#print()      *      * @throws PrinterException If there is an error while printing.      */
specifier|public
name|void
name|silentPrint
parameter_list|(
name|PrinterJob
name|printJob
parameter_list|)
throws|throws
name|PrinterException
block|{
name|print
argument_list|(
name|printJob
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|print
parameter_list|(
name|PrinterJob
name|job
parameter_list|,
name|boolean
name|silent
parameter_list|)
throws|throws
name|PrinterException
block|{
if|if
condition|(
name|job
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|PrinterException
argument_list|(
literal|"The given printer job is null."
argument_list|)
throw|;
block|}
else|else
block|{
name|job
operator|.
name|setPageable
argument_list|(
operator|new
name|PDPageable
argument_list|(
name|this
argument_list|,
name|job
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|silent
operator|||
name|job
operator|.
name|printDialog
argument_list|()
condition|)
block|{
name|job
operator|.
name|print
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This will close the underlying COSDocument object.      *      * @throws IOException If there is an error releasing resources.      */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|document
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * Protects the document with the protection policy pp. The document content will be really encrypted      * when it will be saved. This method only marks the document for encryption.      *      * @see org.apache.pdfbox.pdmodel.encryption.StandardProtectionPolicy      * @see org.apache.pdfbox.pdmodel.encryption.PublicKeyProtectionPolicy      *      * @param pp The protection policy.      *      * @throws BadSecurityHandlerException If there is an error during protection.      */
specifier|public
name|void
name|protect
parameter_list|(
name|ProtectionPolicy
name|pp
parameter_list|)
throws|throws
name|BadSecurityHandlerException
block|{
name|SecurityHandler
name|handler
init|=
name|SecurityHandlersManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getSecurityHandler
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|securityHandler
operator|=
name|handler
expr_stmt|;
block|}
comment|/**      * Tries to decrypt the document in memory using the provided decryption material.      *      *  @see org.apache.pdfbox.pdmodel.encryption.StandardDecryptionMaterial      *  @see org.apache.pdfbox.pdmodel.encryption.PublicKeyDecryptionMaterial      *      * @param pm The decryption material (password or certificate).      *      * @throws BadSecurityHandlerException If there is an error during decryption.      * @throws IOException If there is an error reading cryptographic information.      * @throws CryptographyException If there is an error during decryption.      */
specifier|public
name|void
name|openProtection
parameter_list|(
name|DecryptionMaterial
name|pm
parameter_list|)
throws|throws
name|BadSecurityHandlerException
throws|,
name|IOException
throws|,
name|CryptographyException
block|{
name|PDEncryptionDictionary
name|dict
init|=
name|this
operator|.
name|getEncryptionDictionary
argument_list|()
decl_stmt|;
if|if
condition|(
name|dict
operator|.
name|getFilter
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|securityHandler
operator|=
name|SecurityHandlersManager
operator|.
name|getInstance
argument_list|()
operator|.
name|getSecurityHandler
argument_list|(
name|dict
operator|.
name|getFilter
argument_list|()
argument_list|)
expr_stmt|;
name|securityHandler
operator|.
name|decryptDocument
argument_list|(
name|this
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|document
operator|.
name|dereferenceObjectStreams
argument_list|()
expr_stmt|;
name|document
operator|.
name|setEncryptionDictionary
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"This document does not need to be decrypted"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns the access permissions granted when the document was decrypted.      * If the document was not decrypted this method returns the access permission      * for a document owner (ie can do everything).      * The returned object is in read only mode so that permissions cannot be changed.      * Methods providing access to content should rely on this object to verify if the current      * user is allowed to proceed.      *      * @return the access permissions for the current user on the document.      */
specifier|public
name|AccessPermission
name|getCurrentAccessPermission
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|securityHandler
operator|==
literal|null
condition|)
block|{
return|return
name|AccessPermission
operator|.
name|getOwnerAccessPermission
argument_list|()
return|;
block|}
return|return
name|securityHandler
operator|.
name|getCurrentAccessPermission
argument_list|()
return|;
block|}
comment|/**      * Get the security handler that is used for document encryption.      *      * @return The handler used to encrypt/decrypt the document.      */
specifier|public
name|SecurityHandler
name|getSecurityHandler
parameter_list|()
block|{
return|return
name|securityHandler
return|;
block|}
specifier|public
name|boolean
name|isAllSecurityToBeRemoved
parameter_list|()
block|{
return|return
name|allSecurityToBeRemoved
return|;
block|}
specifier|public
name|void
name|setAllSecurityToBeRemoved
parameter_list|(
name|boolean
name|allSecurityToBeRemoved
parameter_list|)
block|{
name|this
operator|.
name|allSecurityToBeRemoved
operator|=
name|allSecurityToBeRemoved
expr_stmt|;
block|}
block|}
end_class

end_unit

