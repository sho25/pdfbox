begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|function
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|stream
operator|.
name|ImageInputStream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|stream
operator|.
name|MemoryCacheImageInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRange
import|;
end_import

begin_comment
comment|/**  * This class represents a type 0 function in a PDF document.  *  * @author Ben Litchfield  * @author Tilman Hausherr  *   */
end_comment

begin_class
specifier|public
class|class
name|PDFunctionType0
extends|extends
name|PDFunction
block|{
comment|/**      * Log instance.      */
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PDFunctionType0
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * An array of 2 x m numbers specifying the linear mapping of input values       * into the domain of the function's sample table. Default value: [ 0 (Size0      * - 1) 0 (Size1 - 1) ...].      */
specifier|private
name|COSArray
name|encode
init|=
literal|null
decl_stmt|;
comment|/**      * An array of 2 x n numbers specifying the linear mapping of sample values       * into the range appropriate for the function's output values. Default      * value: same as the value of Range      */
specifier|private
name|COSArray
name|decode
init|=
literal|null
decl_stmt|;
comment|/**      * An array of m positive integers specifying the number of samples in each       * input dimension of the sample table.      */
specifier|private
name|COSArray
name|size
init|=
literal|null
decl_stmt|;
comment|/**      * The samples of the function.      */
specifier|private
name|int
index|[]
index|[]
name|samples
init|=
literal|null
decl_stmt|;
comment|/**      * Constructor.      *      * @param function The function.      */
specifier|public
name|PDFunctionType0
parameter_list|(
name|COSBase
name|function
parameter_list|)
block|{
name|super
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
specifier|public
name|int
name|getFunctionType
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
comment|/**      * The "Size" entry, which is the number of samples in each input dimension      * of the sample table.      *      * @return A List of java.lang.Integer objects.      */
specifier|public
name|COSArray
name|getSize
parameter_list|()
block|{
if|if
condition|(
name|size
operator|==
literal|null
condition|)
block|{
name|size
operator|=
operator|(
name|COSArray
operator|)
name|getCOSObject
argument_list|()
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|SIZE
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
comment|/**      * Get all sample values of this function.      *       * @return an array with all samples.      */
specifier|private
name|int
index|[]
index|[]
name|getSamples
parameter_list|()
block|{
if|if
condition|(
name|samples
operator|==
literal|null
condition|)
block|{
name|int
name|arraySize
init|=
literal|1
decl_stmt|;
name|int
name|numberOfInputValues
init|=
name|getNumberOfInputParameters
argument_list|()
decl_stmt|;
name|int
name|numberOfOutputValues
init|=
name|getNumberOfOutputParameters
argument_list|()
decl_stmt|;
name|COSArray
name|sizes
init|=
name|getSize
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfInputValues
condition|;
name|i
operator|++
control|)
block|{
name|arraySize
operator|*=
name|sizes
operator|.
name|getInt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|samples
operator|=
operator|new
name|int
index|[
name|arraySize
index|]
index|[
name|numberOfOutputValues
index|]
expr_stmt|;
name|int
name|bitsPerSample
init|=
name|getBitsPerSample
argument_list|()
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
try|try
block|{
comment|// PDF spec 1.7 p.171:
comment|// Each sample value is represented as a sequence of BitsPerSample bits.
comment|// Successive values are adjacent in the bit stream; there is no padding at byte boundaries.
try|try
init|(
name|ImageInputStream
name|mciis
init|=
operator|new
name|MemoryCacheImageInputStream
argument_list|(
name|getPDStream
argument_list|()
operator|.
name|createInputStream
argument_list|()
argument_list|)
init|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arraySize
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|numberOfOutputValues
condition|;
name|k
operator|++
control|)
block|{
comment|// TODO will this cast work properly for 32 bitsPerSample or should we use long[]?
name|samples
index|[
name|index
index|]
index|[
name|k
index|]
operator|=
operator|(
name|int
operator|)
name|mciis
operator|.
name|readBits
argument_list|(
name|bitsPerSample
argument_list|)
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"IOException while reading the sample values of this function."
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|samples
return|;
block|}
comment|/**      * Get the number of bits that the output value will take up.        *       * Valid values are 1,2,4,8,12,16,24,32.      *      * @return Number of bits for each output value.      */
specifier|public
name|int
name|getBitsPerSample
parameter_list|()
block|{
return|return
name|getCOSObject
argument_list|()
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|BITS_PER_SAMPLE
argument_list|)
return|;
block|}
comment|/**      * Get the order of interpolation between samples. Valid values are 1 and 3,      * specifying linear and cubic spline interpolation, respectively. Default      * is 1. See p.170 in PDF spec 1.7.      *      * @return order of interpolation.      */
specifier|public
name|int
name|getOrder
parameter_list|()
block|{
return|return
name|getCOSObject
argument_list|()
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|ORDER
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/**      * Set the number of bits that the output value will take up. Valid values      * are 1,2,4,8,12,16,24,32.      *      * @param bps The number of bits for each output value.      */
specifier|public
name|void
name|setBitsPerSample
parameter_list|(
name|int
name|bps
parameter_list|)
block|{
name|getCOSObject
argument_list|()
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|BITS_PER_SAMPLE
argument_list|,
name|bps
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns all encode values as COSArray.      *       * @return the encode array.       */
specifier|private
name|COSArray
name|getEncodeValues
parameter_list|()
block|{
if|if
condition|(
name|encode
operator|==
literal|null
condition|)
block|{
name|encode
operator|=
operator|(
name|COSArray
operator|)
name|getCOSObject
argument_list|()
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ENCODE
argument_list|)
expr_stmt|;
comment|// the default value is [0 (size[0]-1) 0 (size[1]-1) ...]
if|if
condition|(
name|encode
operator|==
literal|null
condition|)
block|{
name|encode
operator|=
operator|new
name|COSArray
argument_list|()
expr_stmt|;
name|COSArray
name|sizeValues
init|=
name|getSize
argument_list|()
decl_stmt|;
name|int
name|sizeValuesSize
init|=
name|sizeValues
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sizeValuesSize
condition|;
name|i
operator|++
control|)
block|{
name|encode
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|encode
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|get
argument_list|(
name|sizeValues
operator|.
name|getInt
argument_list|(
name|i
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|encode
return|;
block|}
comment|/**      * Returns all decode values as COSArray.      *       * @return the decode array.       */
specifier|private
name|COSArray
name|getDecodeValues
parameter_list|()
block|{
if|if
condition|(
name|decode
operator|==
literal|null
condition|)
block|{
name|decode
operator|=
operator|(
name|COSArray
operator|)
name|getCOSObject
argument_list|()
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|DECODE
argument_list|)
expr_stmt|;
comment|// if decode is null, the default values are the range values
if|if
condition|(
name|decode
operator|==
literal|null
condition|)
block|{
name|decode
operator|=
name|getRangeValues
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|decode
return|;
block|}
comment|/**      * Get the encode for the input parameter.      *      * @param paramNum The function parameter number.      *      * @return The encode parameter range or null if none is set.      */
specifier|public
name|PDRange
name|getEncodeForParameter
parameter_list|(
name|int
name|paramNum
parameter_list|)
block|{
name|PDRange
name|retval
init|=
literal|null
decl_stmt|;
name|COSArray
name|encodeValues
init|=
name|getEncodeValues
argument_list|()
decl_stmt|;
if|if
condition|(
name|encodeValues
operator|!=
literal|null
operator|&&
name|encodeValues
operator|.
name|size
argument_list|()
operator|>=
name|paramNum
operator|*
literal|2
operator|+
literal|1
condition|)
block|{
name|retval
operator|=
operator|new
name|PDRange
argument_list|(
name|encodeValues
argument_list|,
name|paramNum
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will set the encode values.      *      * @param encodeValues The new encode values.      */
specifier|public
name|void
name|setEncodeValues
parameter_list|(
name|COSArray
name|encodeValues
parameter_list|)
block|{
name|encode
operator|=
name|encodeValues
expr_stmt|;
name|getCOSObject
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ENCODE
argument_list|,
name|encodeValues
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the decode for the input parameter.      *      * @param paramNum The function parameter number.      *      * @return The decode parameter range or null if none is set.      */
specifier|public
name|PDRange
name|getDecodeForParameter
parameter_list|(
name|int
name|paramNum
parameter_list|)
block|{
name|PDRange
name|retval
init|=
literal|null
decl_stmt|;
name|COSArray
name|decodeValues
init|=
name|getDecodeValues
argument_list|()
decl_stmt|;
if|if
condition|(
name|decodeValues
operator|!=
literal|null
operator|&&
name|decodeValues
operator|.
name|size
argument_list|()
operator|>=
name|paramNum
operator|*
literal|2
operator|+
literal|1
condition|)
block|{
name|retval
operator|=
operator|new
name|PDRange
argument_list|(
name|decodeValues
argument_list|,
name|paramNum
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will set the decode values.      *      * @param decodeValues The new decode values.      */
specifier|public
name|void
name|setDecodeValues
parameter_list|(
name|COSArray
name|decodeValues
parameter_list|)
block|{
name|decode
operator|=
name|decodeValues
expr_stmt|;
name|getCOSObject
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|DECODE
argument_list|,
name|decodeValues
argument_list|)
expr_stmt|;
block|}
comment|/**      * calculate array index (structure described in p.171 PDF spec 1.7) in      * multiple dimensions.      *      * @param vector with coordinates      * @return index in flat array      */
specifier|private
name|int
name|calcSampleIndex
parameter_list|(
name|int
index|[]
name|vector
parameter_list|)
block|{
comment|// inspiration: http://stackoverflow.com/a/12113479/535646
comment|// but used in reverse
name|float
index|[]
name|sizeValues
init|=
name|getSize
argument_list|()
operator|.
name|toFloatArray
argument_list|()
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|sizeProduct
init|=
literal|1
decl_stmt|;
name|int
name|dimension
init|=
name|vector
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|dimension
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|sizeProduct
operator|*=
name|sizeValues
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|dimension
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|index
operator|+=
name|sizeProduct
operator|*
name|vector
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|-
literal|1
operator|>=
literal|0
condition|)
block|{
name|sizeProduct
operator|/=
name|sizeValues
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
return|return
name|index
return|;
block|}
comment|/**      * Inner class do to an interpolation in the Nth dimension by comparing the      * content size of N-1 dimensional objects. This is done with the help of      * recursive calls. To understand the algorithm without recursion, here is a      *<a      * href="http://harmoniccode.blogspot.de/2011/04/bilinear-color-interpolation.html">bilinear      * interpolation</a> and here's a<a      * href="https://en.wikipedia.org/wiki/Trilinear_interpolation">trilinear      * interpolation</a> (external links).      */
specifier|private
class|class
name|Rinterpol
block|{
comment|// coordinate that is to be interpolated
specifier|private
specifier|final
name|float
index|[]
name|in
decl_stmt|;
comment|// coordinate of the "ceil" point
specifier|private
specifier|final
name|int
index|[]
name|inPrev
decl_stmt|;
comment|// coordinate of the "floor" point
specifier|private
specifier|final
name|int
index|[]
name|inNext
decl_stmt|;
specifier|private
specifier|final
name|int
name|numberOfInputValues
decl_stmt|;
specifier|private
specifier|final
name|int
name|numberOfOutputValues
init|=
name|getNumberOfOutputParameters
argument_list|()
decl_stmt|;
comment|/**          * Constructor.          *          * @param input the input coordinates          * @param inputPrev coordinate of the "ceil" point          * @param inputNext coordinate of the "floor" point          *          */
name|Rinterpol
parameter_list|(
name|float
index|[]
name|input
parameter_list|,
name|int
index|[]
name|inputPrev
parameter_list|,
name|int
index|[]
name|inputNext
parameter_list|)
block|{
name|in
operator|=
name|input
expr_stmt|;
name|inPrev
operator|=
name|inputPrev
expr_stmt|;
name|inNext
operator|=
name|inputNext
expr_stmt|;
name|numberOfInputValues
operator|=
name|input
operator|.
name|length
expr_stmt|;
block|}
comment|/**          * Calculate the interpolation.          *          * @return interpolated result sample          */
name|float
index|[]
name|rinterpolate
parameter_list|()
block|{
return|return
name|rinterpol
argument_list|(
operator|new
name|int
index|[
name|numberOfInputValues
index|]
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**          * Do a linear interpolation if the two coordinates can be known, or          * call itself recursively twice.          *          * @param coord coord partially set coordinate (not set from step          * upwards); gets fully filled in the last call ("leaf"), where it is          * used to get the correct sample          * @param step between 0 (first call) and dimension - 1          * @return interpolated result sample          */
specifier|private
name|float
index|[]
name|rinterpol
parameter_list|(
name|int
index|[]
name|coord
parameter_list|,
name|int
name|step
parameter_list|)
block|{
name|float
index|[]
name|resultSample
init|=
operator|new
name|float
index|[
name|numberOfOutputValues
index|]
decl_stmt|;
if|if
condition|(
name|step
operator|==
name|in
operator|.
name|length
operator|-
literal|1
condition|)
block|{
comment|// leaf
if|if
condition|(
name|inPrev
index|[
name|step
index|]
operator|==
name|inNext
index|[
name|step
index|]
condition|)
block|{
name|coord
index|[
name|step
index|]
operator|=
name|inPrev
index|[
name|step
index|]
expr_stmt|;
name|int
index|[]
name|tmpSample
init|=
name|getSamples
argument_list|()
index|[
name|calcSampleIndex
argument_list|(
name|coord
argument_list|)
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfOutputValues
condition|;
operator|++
name|i
control|)
block|{
name|resultSample
index|[
name|i
index|]
operator|=
name|tmpSample
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|resultSample
return|;
block|}
name|coord
index|[
name|step
index|]
operator|=
name|inPrev
index|[
name|step
index|]
expr_stmt|;
name|int
index|[]
name|sample1
init|=
name|getSamples
argument_list|()
index|[
name|calcSampleIndex
argument_list|(
name|coord
argument_list|)
index|]
decl_stmt|;
name|coord
index|[
name|step
index|]
operator|=
name|inNext
index|[
name|step
index|]
expr_stmt|;
name|int
index|[]
name|sample2
init|=
name|getSamples
argument_list|()
index|[
name|calcSampleIndex
argument_list|(
name|coord
argument_list|)
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfOutputValues
condition|;
operator|++
name|i
control|)
block|{
name|resultSample
index|[
name|i
index|]
operator|=
name|interpolate
argument_list|(
name|in
index|[
name|step
index|]
argument_list|,
name|inPrev
index|[
name|step
index|]
argument_list|,
name|inNext
index|[
name|step
index|]
argument_list|,
name|sample1
index|[
name|i
index|]
argument_list|,
name|sample2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|resultSample
return|;
block|}
else|else
block|{
comment|// branch
if|if
condition|(
name|inPrev
index|[
name|step
index|]
operator|==
name|inNext
index|[
name|step
index|]
condition|)
block|{
name|coord
index|[
name|step
index|]
operator|=
name|inPrev
index|[
name|step
index|]
expr_stmt|;
return|return
name|rinterpol
argument_list|(
name|coord
argument_list|,
name|step
operator|+
literal|1
argument_list|)
return|;
block|}
name|coord
index|[
name|step
index|]
operator|=
name|inPrev
index|[
name|step
index|]
expr_stmt|;
name|float
index|[]
name|sample1
init|=
name|rinterpol
argument_list|(
name|coord
argument_list|,
name|step
operator|+
literal|1
argument_list|)
decl_stmt|;
name|coord
index|[
name|step
index|]
operator|=
name|inNext
index|[
name|step
index|]
expr_stmt|;
name|float
index|[]
name|sample2
init|=
name|rinterpol
argument_list|(
name|coord
argument_list|,
name|step
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfOutputValues
condition|;
operator|++
name|i
control|)
block|{
name|resultSample
index|[
name|i
index|]
operator|=
name|interpolate
argument_list|(
name|in
index|[
name|step
index|]
argument_list|,
name|inPrev
index|[
name|step
index|]
argument_list|,
name|inNext
index|[
name|step
index|]
argument_list|,
name|sample1
index|[
name|i
index|]
argument_list|,
name|sample2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|resultSample
return|;
block|}
block|}
block|}
comment|/**     * {@inheritDoc}     */
annotation|@
name|Override
specifier|public
name|float
index|[]
name|eval
parameter_list|(
name|float
index|[]
name|input
parameter_list|)
throws|throws
name|IOException
block|{
comment|//This involves linear interpolation based on a set of sample points.
comment|//Theoretically it's not that difficult ... see section 3.9.1 of the PDF Reference.
name|float
index|[]
name|sizeValues
init|=
name|getSize
argument_list|()
operator|.
name|toFloatArray
argument_list|()
decl_stmt|;
name|int
name|bitsPerSample
init|=
name|getBitsPerSample
argument_list|()
decl_stmt|;
name|float
name|maxSample
init|=
call|(
name|float
call|)
argument_list|(
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|bitsPerSample
argument_list|)
operator|-
literal|1.0
argument_list|)
decl_stmt|;
name|int
name|numberOfInputValues
init|=
name|input
operator|.
name|length
decl_stmt|;
name|int
name|numberOfOutputValues
init|=
name|getNumberOfOutputParameters
argument_list|()
decl_stmt|;
name|int
index|[]
name|inputPrev
init|=
operator|new
name|int
index|[
name|numberOfInputValues
index|]
decl_stmt|;
name|int
index|[]
name|inputNext
init|=
operator|new
name|int
index|[
name|numberOfInputValues
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfInputValues
condition|;
name|i
operator|++
control|)
block|{
name|PDRange
name|domain
init|=
name|getDomainForInput
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|PDRange
name|encodeValues
init|=
name|getEncodeForParameter
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|input
index|[
name|i
index|]
operator|=
name|clipToRange
argument_list|(
name|input
index|[
name|i
index|]
argument_list|,
name|domain
operator|.
name|getMin
argument_list|()
argument_list|,
name|domain
operator|.
name|getMax
argument_list|()
argument_list|)
expr_stmt|;
name|input
index|[
name|i
index|]
operator|=
name|interpolate
argument_list|(
name|input
index|[
name|i
index|]
argument_list|,
name|domain
operator|.
name|getMin
argument_list|()
argument_list|,
name|domain
operator|.
name|getMax
argument_list|()
argument_list|,
name|encodeValues
operator|.
name|getMin
argument_list|()
argument_list|,
name|encodeValues
operator|.
name|getMax
argument_list|()
argument_list|)
expr_stmt|;
name|input
index|[
name|i
index|]
operator|=
name|clipToRange
argument_list|(
name|input
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|sizeValues
index|[
name|i
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
name|inputPrev
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|inputNext
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|float
index|[]
name|outputValues
init|=
operator|new
name|Rinterpol
argument_list|(
name|input
argument_list|,
name|inputPrev
argument_list|,
name|inputNext
argument_list|)
operator|.
name|rinterpolate
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfOutputValues
condition|;
name|i
operator|++
control|)
block|{
name|PDRange
name|range
init|=
name|getRangeForOutput
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|PDRange
name|decodeValues
init|=
name|getDecodeForParameter
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputValues
index|[
name|i
index|]
operator|=
name|interpolate
argument_list|(
name|outputValues
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|maxSample
argument_list|,
name|decodeValues
operator|.
name|getMin
argument_list|()
argument_list|,
name|decodeValues
operator|.
name|getMax
argument_list|()
argument_list|)
expr_stmt|;
name|outputValues
index|[
name|i
index|]
operator|=
name|clipToRange
argument_list|(
name|outputValues
index|[
name|i
index|]
argument_list|,
name|range
operator|.
name|getMin
argument_list|()
argument_list|,
name|range
operator|.
name|getMax
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|outputValues
return|;
block|}
block|}
end_class

end_unit

