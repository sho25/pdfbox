begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|function
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRange
import|;
end_import

begin_comment
comment|/**  * This class represents a type 0 function in a PDF document.  *  * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  * @version $Revision: 1.2 $  */
end_comment

begin_class
specifier|public
class|class
name|PDFunctionType0
extends|extends
name|PDFunction
block|{
comment|/**      * Log instance.      */
specifier|private
specifier|static
specifier|final
name|Log
name|log
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PDFunctionType0
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * An array of 2 × m numbers specifying the linear mapping of input values       * into the domain of the function’s sample table.       * Default value: [ 0 (Size0 − 1) 0 (Size1 − 1) … ].      */
specifier|private
name|COSArray
name|encode
init|=
literal|null
decl_stmt|;
comment|/**      * An array of 2 × n numbers specifying the linear mapping of sample values       * into the range appropriate for the function’s output values.       * Default value: same as the value of Range      */
specifier|private
name|COSArray
name|decode
init|=
literal|null
decl_stmt|;
comment|/**      * An array of m positive integers specifying the number of samples in each       * input dimension of the sample table.      */
specifier|private
name|COSArray
name|size
init|=
literal|null
decl_stmt|;
comment|/**      * The samples of the function.      */
specifier|private
name|int
index|[]
index|[]
name|samples
init|=
literal|null
decl_stmt|;
comment|/**      * Constructor.      *      * @param functionStream The function .      */
specifier|public
name|PDFunctionType0
parameter_list|(
name|COSBase
name|function
parameter_list|)
block|{
name|super
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|int
name|getFunctionType
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
comment|/**      * The "Size" entry, which is the number of samples in      * each input dimension of the sample table.      *      * @return A List of java.lang.Integer objects.      */
specifier|public
name|COSArray
name|getSize
parameter_list|()
block|{
if|if
condition|(
name|size
operator|==
literal|null
condition|)
block|{
name|size
operator|=
operator|(
name|COSArray
operator|)
name|getDictionary
argument_list|()
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|SIZE
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
comment|/**      * Get all sample values of this function.      *       * @return an array with all samples.      */
specifier|public
name|int
index|[]
index|[]
name|getSamples
parameter_list|()
block|{
if|if
condition|(
name|samples
operator|==
literal|null
condition|)
block|{
name|int
name|arraySize
init|=
literal|1
decl_stmt|;
name|int
name|numberOfInputValues
init|=
name|getNumberOfInputParameters
argument_list|()
decl_stmt|;
name|int
name|numberOfOutputValues
init|=
name|getNumberOfOutputParameters
argument_list|()
decl_stmt|;
name|COSArray
name|sizes
init|=
name|getSize
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfInputValues
condition|;
name|i
operator|++
control|)
block|{
name|arraySize
operator|*=
name|sizes
operator|.
name|getInt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|samples
operator|=
operator|new
name|int
index|[
name|arraySize
index|]
index|[
name|getNumberOfOutputParameters
argument_list|()
index|]
expr_stmt|;
name|int
name|bitsPerSample
init|=
name|getBitsPerSample
argument_list|()
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|arrayIndex
init|=
literal|0
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|samplesArray
init|=
name|getPDStream
argument_list|()
operator|.
name|getByteArray
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfInputValues
condition|;
name|i
operator|++
control|)
block|{
name|int
name|sizeInputValues
init|=
name|sizes
operator|.
name|getInt
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|sizeInputValues
condition|;
name|j
operator|++
control|)
block|{
name|int
name|bitsLeft
init|=
literal|0
decl_stmt|;
name|int
name|bitsToRead
init|=
name|bitsPerSample
decl_stmt|;
name|int
name|currentValue
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|numberOfOutputValues
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|bitsLeft
operator|==
literal|0
condition|)
block|{
name|currentValue
operator|=
operator|(
name|samplesArray
index|[
name|arrayIndex
operator|++
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
expr_stmt|;
name|bitsLeft
operator|=
literal|8
expr_stmt|;
block|}
name|int
name|value
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bitsToRead
operator|>
literal|0
condition|)
block|{
name|int
name|bits
init|=
name|Math
operator|.
name|min
argument_list|(
name|bitsToRead
argument_list|,
name|bitsLeft
argument_list|)
decl_stmt|;
name|value
operator|=
name|value
operator|<<
name|bits
expr_stmt|;
name|int
name|valueToAdd
init|=
name|currentValue
operator|>>
operator|(
literal|8
operator|-
name|bits
operator|)
decl_stmt|;
name|value
operator||=
name|valueToAdd
expr_stmt|;
name|bitsToRead
operator|-=
name|bits
expr_stmt|;
name|bitsLeft
operator|-=
name|bits
expr_stmt|;
if|if
condition|(
name|bitsLeft
operator|==
literal|0
operator|&&
name|bitsToRead
operator|>
literal|0
condition|)
block|{
name|currentValue
operator|=
operator|(
name|samplesArray
index|[
name|arrayIndex
operator|++
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
expr_stmt|;
name|bitsLeft
operator|=
literal|8
expr_stmt|;
block|}
block|}
name|samples
index|[
name|index
index|]
index|[
name|k
index|]
operator|=
name|value
expr_stmt|;
name|bitsToRead
operator|=
name|bitsPerSample
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"IOException while reading the sample values of this function."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|samples
return|;
block|}
comment|/**      * Get the number of bits that the output value will take up.        *       * Valid values are 1,2,4,8,12,16,24,32.      *      * @return Number of bits for each output value.      */
specifier|public
name|int
name|getBitsPerSample
parameter_list|()
block|{
return|return
name|getDictionary
argument_list|()
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|BITS_PER_SAMPLE
argument_list|)
return|;
block|}
comment|/**      * Set the number of bits that the output value will take up.  Valid values      * are 1,2,4,8,12,16,24,32.      *      * @param bps The number of bits for each output value.      */
specifier|public
name|void
name|setBitsPerSample
parameter_list|(
name|int
name|bps
parameter_list|)
block|{
name|getDictionary
argument_list|()
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|BITS_PER_SAMPLE
argument_list|,
name|bps
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns all encode values as COSArray.      *       * @return the encode array.       */
specifier|private
name|COSArray
name|getEncodeValues
parameter_list|()
block|{
if|if
condition|(
name|encode
operator|==
literal|null
condition|)
block|{
name|encode
operator|=
operator|(
name|COSArray
operator|)
name|getDictionary
argument_list|()
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ENCODE
argument_list|)
expr_stmt|;
comment|// the default value is [0 (size[0]-1) 0 (size[1]-1) ...]
if|if
condition|(
name|encode
operator|==
literal|null
condition|)
block|{
name|encode
operator|=
operator|new
name|COSArray
argument_list|()
expr_stmt|;
name|COSArray
name|sizeValues
init|=
name|getSize
argument_list|()
decl_stmt|;
name|int
name|sizeValuesSize
init|=
name|sizeValues
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sizeValuesSize
condition|;
name|i
operator|++
control|)
block|{
name|encode
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|encode
operator|.
name|add
argument_list|(
name|COSInteger
operator|.
name|get
argument_list|(
name|sizeValues
operator|.
name|getInt
argument_list|(
name|i
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|encode
return|;
block|}
comment|/**      * Returns all decode values as COSArray.      *       * @return the decode array.       */
specifier|private
name|COSArray
name|getDecodeValues
parameter_list|()
block|{
if|if
condition|(
name|decode
operator|==
literal|null
condition|)
block|{
name|decode
operator|=
operator|(
name|COSArray
operator|)
name|getDictionary
argument_list|()
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|DECODE
argument_list|)
expr_stmt|;
comment|// if decode is null, the default values are the range values
if|if
condition|(
name|decode
operator|==
literal|null
condition|)
block|{
name|decode
operator|=
name|getRangeValues
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|decode
return|;
block|}
comment|/**      * Get the encode for the input parameter.      *      * @param paramNum The function parameter number.      *      * @return The encode parameter range or null if none is set.      */
specifier|public
name|PDRange
name|getEncodeForParameter
parameter_list|(
name|int
name|paramNum
parameter_list|)
block|{
name|PDRange
name|retval
init|=
literal|null
decl_stmt|;
name|COSArray
name|encodeValues
init|=
name|getEncodeValues
argument_list|()
decl_stmt|;
if|if
condition|(
name|encodeValues
operator|!=
literal|null
operator|&&
name|encodeValues
operator|.
name|size
argument_list|()
operator|>=
name|paramNum
operator|*
literal|2
operator|+
literal|1
condition|)
block|{
name|retval
operator|=
operator|new
name|PDRange
argument_list|(
name|encodeValues
argument_list|,
name|paramNum
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will set the encode values.      *      * @param range The new encode values.      */
specifier|public
name|void
name|setEncodeValues
parameter_list|(
name|COSArray
name|encodeValues
parameter_list|)
block|{
name|encode
operator|=
name|encodeValues
expr_stmt|;
name|getDictionary
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ENCODE
argument_list|,
name|encodeValues
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the decode for the input parameter.      *      * @param paramNum The function parameter number.      *      * @return The decode parameter range or null if none is set.      */
specifier|public
name|PDRange
name|getDecodeForParameter
parameter_list|(
name|int
name|paramNum
parameter_list|)
block|{
name|PDRange
name|retval
init|=
literal|null
decl_stmt|;
name|COSArray
name|decodeValues
init|=
name|getDecodeValues
argument_list|()
decl_stmt|;
if|if
condition|(
name|decodeValues
operator|!=
literal|null
operator|&&
name|decodeValues
operator|.
name|size
argument_list|()
operator|>=
name|paramNum
operator|*
literal|2
operator|+
literal|1
condition|)
block|{
name|retval
operator|=
operator|new
name|PDRange
argument_list|(
name|decodeValues
argument_list|,
name|paramNum
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will set the decode values.      *      * @param range The new decode values.      */
specifier|public
name|void
name|setDecodeValues
parameter_list|(
name|COSArray
name|decodeValues
parameter_list|)
block|{
name|decode
operator|=
name|decodeValues
expr_stmt|;
name|getDictionary
argument_list|()
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|DECODE
argument_list|,
name|decodeValues
argument_list|)
expr_stmt|;
block|}
comment|/**     * {@inheritDoc}     */
specifier|public
name|float
index|[]
name|eval
parameter_list|(
name|float
index|[]
name|input
parameter_list|)
throws|throws
name|IOException
block|{
comment|//This involves linear interpolation based on a set of sample points.
comment|//Theoretically it's not that difficult ... see section 3.9.1 of the PDF Reference.
name|float
index|[]
name|sizeValues
init|=
name|getSize
argument_list|()
operator|.
name|toFloatArray
argument_list|()
decl_stmt|;
name|int
name|bitsPerSample
init|=
name|getBitsPerSample
argument_list|()
decl_stmt|;
name|int
name|numberOfInputValues
init|=
name|input
operator|.
name|length
decl_stmt|;
name|int
name|numberOfOutputValues
init|=
name|getNumberOfOutputParameters
argument_list|()
decl_stmt|;
name|int
index|[]
name|intInputValuesPrevious
init|=
operator|new
name|int
index|[
name|numberOfInputValues
index|]
decl_stmt|;
name|int
index|[]
name|intInputValuesNext
init|=
operator|new
name|int
index|[
name|numberOfInputValues
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfInputValues
condition|;
name|i
operator|++
control|)
block|{
name|PDRange
name|domain
init|=
name|getDomainForInput
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|PDRange
name|encode
init|=
name|getEncodeForParameter
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|input
index|[
name|i
index|]
operator|=
name|clipToRange
argument_list|(
name|input
index|[
name|i
index|]
argument_list|,
name|domain
operator|.
name|getMin
argument_list|()
argument_list|,
name|domain
operator|.
name|getMax
argument_list|()
argument_list|)
expr_stmt|;
name|input
index|[
name|i
index|]
operator|=
name|interpolate
argument_list|(
name|input
index|[
name|i
index|]
argument_list|,
name|domain
operator|.
name|getMin
argument_list|()
argument_list|,
name|domain
operator|.
name|getMax
argument_list|()
argument_list|,
name|encode
operator|.
name|getMin
argument_list|()
argument_list|,
name|encode
operator|.
name|getMax
argument_list|()
argument_list|)
expr_stmt|;
name|input
index|[
name|i
index|]
operator|=
name|clipToRange
argument_list|(
name|input
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|sizeValues
index|[
name|i
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
name|intInputValuesPrevious
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|intInputValuesNext
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|float
index|[]
name|outputValuesPrevious
init|=
literal|null
decl_stmt|;
name|float
index|[]
name|outputValuesNext
init|=
literal|null
decl_stmt|;
name|outputValuesPrevious
operator|=
name|getSample
argument_list|(
name|intInputValuesPrevious
argument_list|)
expr_stmt|;
name|outputValuesNext
operator|=
name|getSample
argument_list|(
name|intInputValuesNext
argument_list|)
expr_stmt|;
name|float
index|[]
name|outputValues
init|=
operator|new
name|float
index|[
name|numberOfOutputValues
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfOutputValues
condition|;
name|i
operator|++
control|)
block|{
name|PDRange
name|range
init|=
name|getRangeForOutput
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|PDRange
name|decode
init|=
name|getDecodeForParameter
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// TODO using only a linear interpolation.
comment|// See "Order" entry in table 3.36 of the PDF reference
name|outputValues
index|[
name|i
index|]
operator|=
operator|(
name|outputValuesPrevious
index|[
name|i
index|]
operator|+
name|outputValuesNext
index|[
name|i
index|]
operator|)
operator|/
literal|2
expr_stmt|;
name|outputValues
index|[
name|i
index|]
operator|=
name|interpolate
argument_list|(
name|outputValues
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|float
operator|)
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|bitsPerSample
argument_list|)
argument_list|,
name|decode
operator|.
name|getMin
argument_list|()
argument_list|,
name|decode
operator|.
name|getMax
argument_list|()
argument_list|)
expr_stmt|;
name|outputValues
index|[
name|i
index|]
operator|=
name|clipToRange
argument_list|(
name|outputValues
index|[
name|i
index|]
argument_list|,
name|range
operator|.
name|getMin
argument_list|()
argument_list|,
name|range
operator|.
name|getMax
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|outputValues
return|;
block|}
comment|/**      * Get the samples for the given input values.      *       * @param inputValues an array containing the input values      * @return an array with the corresponding samples      */
specifier|private
name|float
index|[]
name|getSample
parameter_list|(
name|int
index|[]
name|inputValues
parameter_list|)
block|{
name|int
index|[]
index|[]
name|sampleValues
init|=
name|getSamples
argument_list|()
decl_stmt|;
name|COSArray
name|sizes
init|=
name|getSize
argument_list|()
decl_stmt|;
name|int
name|numberOfInputValues
init|=
name|getNumberOfInputParameters
argument_list|()
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|previousSize
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfInputValues
condition|;
name|i
operator|++
control|)
block|{
name|index
operator|+=
name|inputValues
index|[
name|i
index|]
expr_stmt|;
name|previousSize
operator|*=
name|sizes
operator|.
name|getInt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|numberOfOutputValues
init|=
name|getNumberOfOutputParameters
argument_list|()
decl_stmt|;
name|float
index|[]
name|result
init|=
operator|new
name|float
index|[
name|numberOfOutputValues
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfOutputValues
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|sampleValues
index|[
name|index
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_class

end_unit

