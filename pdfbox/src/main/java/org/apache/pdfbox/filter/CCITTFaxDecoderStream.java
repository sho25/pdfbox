begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2012, Harald Kuhr  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name "TwelveMonkeys" nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|filter
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_comment
comment|/**  * CCITT Modified Huffman RLE, Group 3 (T4) and Group 4 (T6) fax compression.  *  * @author<a href="mailto:harald.kuhr@gmail.com">Harald Kuhr</a>  * @author<a href="https://github.com/Schmidor">Oliver Schmidtmer</a>  * @author last modified by $Author: haraldk$  * @version $Id: CCITTFaxDecoderStream.java,v 1.0 23.05.12 15:55 haraldk Exp$  *   * Taken from commit fa0341f30237effe523e9905e672d709ffe9c6bd of 7.5.2016 from twelvemonkeys/imageio/plugins/tiff/CCITTFaxDecoderStream.java  *   * Initial changes for PDFBox, discussed in PDFBOX-3338:  * - added optionByteAligned to constructor and to each decodeRowType() method  * - removed Validate() usages  * - catch VALUE_EOL in decode1D()  */
end_comment

begin_class
specifier|final
class|class
name|CCITTFaxDecoderStream
extends|extends
name|FilterInputStream
block|{
comment|// See TIFF 6.0 Specification, Section 10: "Modified Huffman Compression", page 43.
specifier|private
specifier|final
name|int
name|columns
decl_stmt|;
specifier|private
specifier|final
name|byte
index|[]
name|decodedRow
decl_stmt|;
specifier|private
name|int
name|decodedLength
decl_stmt|;
specifier|private
name|int
name|decodedPos
decl_stmt|;
comment|// Need to take fill order into account (?) (use flip table?)
specifier|private
specifier|final
name|int
name|fillOrder
decl_stmt|;
specifier|private
specifier|final
name|int
name|type
decl_stmt|;
specifier|private
name|int
index|[]
name|changesReferenceRow
decl_stmt|;
specifier|private
name|int
index|[]
name|changesCurrentRow
decl_stmt|;
specifier|private
name|int
name|changesReferenceRowCount
decl_stmt|;
specifier|private
name|int
name|changesCurrentRowCount
decl_stmt|;
specifier|private
name|boolean
name|optionG32D
init|=
literal|false
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
comment|// Leading zeros for aligning EOL
specifier|private
name|boolean
name|optionG3Fill
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|optionUncompressed
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|optionByteAligned
init|=
literal|false
decl_stmt|;
name|CCITTFaxDecoderStream
parameter_list|(
specifier|final
name|InputStream
name|stream
parameter_list|,
specifier|final
name|int
name|columns
parameter_list|,
specifier|final
name|int
name|type
parameter_list|,
specifier|final
name|int
name|fillOrder
parameter_list|,
specifier|final
name|long
name|options
parameter_list|)
block|{
name|super
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|this
operator|.
name|columns
operator|=
name|columns
expr_stmt|;
comment|// We know this is only used for b/w (1 bit)
name|this
operator|.
name|decodedRow
operator|=
operator|new
name|byte
index|[
operator|(
name|columns
operator|+
literal|7
operator|)
operator|/
literal|8
index|]
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|fillOrder
operator|=
name|fillOrder
expr_stmt|;
name|this
operator|.
name|changesReferenceRow
operator|=
operator|new
name|int
index|[
name|columns
operator|+
literal|1
index|]
expr_stmt|;
name|this
operator|.
name|changesCurrentRow
operator|=
operator|new
name|int
index|[
name|columns
operator|+
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TIFFExtension
operator|.
name|COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE
case|:
name|optionByteAligned
operator|=
operator|(
name|options
operator|&
name|TIFFExtension
operator|.
name|GROUP3OPT_BYTEALIGNED
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|TIFFExtension
operator|.
name|COMPRESSION_CCITT_T4
case|:
name|optionG32D
operator|=
operator|(
name|options
operator|&
name|TIFFExtension
operator|.
name|GROUP3OPT_2DENCODING
operator|)
operator|!=
literal|0
expr_stmt|;
name|optionG3Fill
operator|=
operator|(
name|options
operator|&
name|TIFFExtension
operator|.
name|GROUP3OPT_FILLBITS
operator|)
operator|!=
literal|0
expr_stmt|;
name|optionUncompressed
operator|=
operator|(
name|options
operator|&
name|TIFFExtension
operator|.
name|GROUP3OPT_UNCOMPRESSED
operator|)
operator|!=
literal|0
expr_stmt|;
name|optionByteAligned
operator|=
operator|(
name|options
operator|&
name|TIFFExtension
operator|.
name|GROUP3OPT_BYTEALIGNED
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|TIFFExtension
operator|.
name|COMPRESSION_CCITT_T6
case|:
name|optionUncompressed
operator|=
operator|(
name|options
operator|&
name|TIFFExtension
operator|.
name|GROUP4OPT_UNCOMPRESSED
operator|)
operator|!=
literal|0
expr_stmt|;
name|optionByteAligned
operator|=
operator|(
name|options
operator|&
name|TIFFExtension
operator|.
name|GROUP4OPT_BYTEALIGNED
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
block|}
block|}
specifier|private
name|void
name|fetch
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|decodedPos
operator|>=
name|decodedLength
condition|)
block|{
name|decodedLength
operator|=
literal|0
expr_stmt|;
try|try
block|{
name|decodeRow
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
comment|// TODO: Rewrite to avoid throw/catch for normal flow...
if|if
condition|(
name|decodedLength
operator|!=
literal|0
condition|)
block|{
throw|throw
name|e
throw|;
block|}
comment|// ..otherwise, just client code trying to read past the end of
comment|// stream
name|decodedLength
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|decodedPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|decode1D
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|boolean
name|white
init|=
literal|true
decl_stmt|;
name|changesCurrentRowCount
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|int
name|completeRun
decl_stmt|;
if|if
condition|(
name|white
condition|)
block|{
name|completeRun
operator|=
name|decodeRun
argument_list|(
name|whiteRunTree
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|completeRun
operator|=
name|decodeRun
argument_list|(
name|blackRunTree
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|completeRun
operator|==
name|VALUE_EOL
condition|)
block|{
continue|continue;
block|}
name|index
operator|+=
name|completeRun
expr_stmt|;
name|changesCurrentRow
index|[
name|changesCurrentRowCount
operator|++
index|]
operator|=
name|index
expr_stmt|;
comment|// Flip color for next run
name|white
operator|=
operator|!
name|white
expr_stmt|;
block|}
do|while
condition|(
name|index
operator|<
name|columns
condition|)
do|;
block|}
specifier|private
name|void
name|decode2D
parameter_list|()
throws|throws
name|IOException
block|{
name|changesReferenceRowCount
operator|=
name|changesCurrentRowCount
expr_stmt|;
name|int
index|[]
name|tmp
init|=
name|changesCurrentRow
decl_stmt|;
name|changesCurrentRow
operator|=
name|changesReferenceRow
expr_stmt|;
name|changesReferenceRow
operator|=
name|tmp
expr_stmt|;
name|boolean
name|white
init|=
literal|true
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|changesCurrentRowCount
operator|=
literal|0
expr_stmt|;
name|mode
label|:
while|while
condition|(
name|index
operator|<
name|columns
condition|)
block|{
comment|// read mode
name|Node
name|n
init|=
name|codeTree
operator|.
name|root
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|n
operator|=
name|n
operator|.
name|walk
argument_list|(
name|readBit
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
block|{
continue|continue
name|mode
continue|;
block|}
elseif|else
if|if
condition|(
name|n
operator|.
name|isLeaf
condition|)
block|{
switch|switch
condition|(
name|n
operator|.
name|value
condition|)
block|{
case|case
name|VALUE_HMODE
case|:
name|int
name|runLength
decl_stmt|;
name|runLength
operator|=
name|decodeRun
argument_list|(
name|white
condition|?
name|whiteRunTree
else|:
name|blackRunTree
argument_list|)
expr_stmt|;
name|index
operator|+=
name|runLength
expr_stmt|;
name|changesCurrentRow
index|[
name|changesCurrentRowCount
operator|++
index|]
operator|=
name|index
expr_stmt|;
name|runLength
operator|=
name|decodeRun
argument_list|(
name|white
condition|?
name|blackRunTree
else|:
name|whiteRunTree
argument_list|)
expr_stmt|;
name|index
operator|+=
name|runLength
expr_stmt|;
name|changesCurrentRow
index|[
name|changesCurrentRowCount
operator|++
index|]
operator|=
name|index
expr_stmt|;
break|break;
case|case
name|VALUE_PASSMODE
case|:
name|int
name|pChangingElement
init|=
name|getNextChangingElement
argument_list|(
name|index
argument_list|,
name|white
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|pChangingElement
operator|>=
name|changesReferenceRowCount
operator|||
name|pChangingElement
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|columns
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|changesReferenceRow
index|[
name|pChangingElement
index|]
expr_stmt|;
block|}
break|break;
default|default:
comment|// Vertical mode (-3 to 3)
name|int
name|vChangingElement
init|=
name|getNextChangingElement
argument_list|(
name|index
argument_list|,
name|white
argument_list|)
decl_stmt|;
if|if
condition|(
name|vChangingElement
operator|>=
name|changesReferenceRowCount
operator|||
name|vChangingElement
operator|==
operator|-
literal|1
condition|)
block|{
name|index
operator|=
name|columns
operator|+
name|n
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|changesReferenceRow
index|[
name|vChangingElement
index|]
operator|+
name|n
operator|.
name|value
expr_stmt|;
block|}
name|changesCurrentRow
index|[
name|changesCurrentRowCount
index|]
operator|=
name|index
expr_stmt|;
name|changesCurrentRowCount
operator|++
expr_stmt|;
name|white
operator|=
operator|!
name|white
expr_stmt|;
break|break;
block|}
continue|continue
name|mode
continue|;
block|}
block|}
block|}
block|}
specifier|private
name|int
name|getNextChangingElement
parameter_list|(
specifier|final
name|int
name|a0
parameter_list|,
specifier|final
name|boolean
name|white
parameter_list|)
block|{
name|int
name|start
init|=
name|white
condition|?
literal|0
else|:
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|changesReferenceRowCount
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|a0
operator|<
name|changesReferenceRow
index|[
name|i
index|]
operator|||
operator|(
name|a0
operator|==
literal|0
operator|&&
name|changesReferenceRow
index|[
name|i
index|]
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|private
name|void
name|decodeRowType2
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|optionByteAligned
condition|)
block|{
name|resetBuffer
argument_list|()
expr_stmt|;
block|}
name|decode1D
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|decodeRowType4
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|optionByteAligned
condition|)
block|{
name|bufferPos
operator|=
operator|-
literal|1
expr_stmt|;
comment|// Skip remaining bits and fetch the next byte at row start
block|}
name|eof
label|:
while|while
condition|(
literal|true
condition|)
block|{
comment|// read till next EOL code
name|Node
name|n
init|=
name|eolOnlyTree
operator|.
name|root
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|n
operator|=
name|n
operator|.
name|walk
argument_list|(
name|readBit
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
block|{
continue|continue
name|eof
continue|;
block|}
if|if
condition|(
name|n
operator|.
name|isLeaf
condition|)
block|{
break|break
name|eof
break|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|optionG32D
operator|||
name|readBit
argument_list|()
condition|)
block|{
name|decode1D
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|decode2D
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|decodeRowType6
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|optionByteAligned
condition|)
block|{
name|bufferPos
operator|=
operator|-
literal|1
expr_stmt|;
comment|// Skip remaining bits and fetch the next byte at row start
block|}
name|decode2D
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|decodeRow
parameter_list|()
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TIFFExtension
operator|.
name|COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE
case|:
name|decodeRowType2
argument_list|()
expr_stmt|;
break|break;
case|case
name|TIFFExtension
operator|.
name|COMPRESSION_CCITT_T4
case|:
name|decodeRowType4
argument_list|()
expr_stmt|;
break|break;
case|case
name|TIFFExtension
operator|.
name|COMPRESSION_CCITT_T6
case|:
name|decodeRowType6
argument_list|()
expr_stmt|;
break|break;
block|}
name|int
name|index
init|=
literal|0
decl_stmt|;
name|boolean
name|white
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|changesCurrentRowCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nextChange
init|=
name|columns
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|changesCurrentRowCount
condition|)
block|{
name|nextChange
operator|=
name|changesCurrentRow
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|nextChange
operator|>
name|columns
condition|)
block|{
name|nextChange
operator|=
name|columns
expr_stmt|;
block|}
name|int
name|byteIndex
init|=
name|index
operator|/
literal|8
decl_stmt|;
while|while
condition|(
name|index
operator|%
literal|8
operator|!=
literal|0
operator|&&
operator|(
name|nextChange
operator|-
name|index
operator|)
operator|>
literal|0
condition|)
block|{
name|decodedRow
index|[
name|byteIndex
index|]
operator||=
operator|(
name|white
condition|?
literal|0
else|:
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
operator|(
name|index
operator|)
operator|%
literal|8
operator|)
operator|)
operator|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|%
literal|8
operator|==
literal|0
condition|)
block|{
name|byteIndex
operator|=
name|index
operator|/
literal|8
expr_stmt|;
specifier|final
name|byte
name|value
init|=
call|(
name|byte
call|)
argument_list|(
name|white
condition|?
literal|0x00
else|:
literal|0xff
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|nextChange
operator|-
name|index
operator|)
operator|>
literal|7
condition|)
block|{
name|decodedRow
index|[
name|byteIndex
index|]
operator|=
name|value
expr_stmt|;
name|index
operator|+=
literal|8
expr_stmt|;
operator|++
name|byteIndex
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|nextChange
operator|-
name|index
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|index
operator|%
literal|8
operator|==
literal|0
condition|)
block|{
name|decodedRow
index|[
name|byteIndex
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|decodedRow
index|[
name|byteIndex
index|]
operator||=
operator|(
name|white
condition|?
literal|0
else|:
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
operator|(
name|index
operator|)
operator|%
literal|8
operator|)
operator|)
operator|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
name|white
operator|=
operator|!
name|white
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|!=
name|columns
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Sum of run-lengths does not equal scan line width: "
operator|+
name|index
operator|+
literal|"> "
operator|+
name|columns
argument_list|)
throw|;
block|}
name|decodedLength
operator|=
operator|(
name|index
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
specifier|private
name|int
name|decodeRun
parameter_list|(
specifier|final
name|Tree
name|tree
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
name|Node
name|n
init|=
name|tree
operator|.
name|root
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|boolean
name|bit
init|=
name|readBit
argument_list|()
decl_stmt|;
name|n
operator|=
name|n
operator|.
name|walk
argument_list|(
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown code in Huffman RLE stream"
argument_list|)
throw|;
block|}
if|if
condition|(
name|n
operator|.
name|isLeaf
condition|)
block|{
name|total
operator|+=
name|n
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|n
operator|.
name|value
operator|<
literal|64
condition|)
block|{
return|return
name|total
return|;
block|}
else|else
block|{
name|n
operator|=
name|tree
operator|.
name|root
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|resetBuffer
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|decodedRow
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|decodedRow
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|bufferPos
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
name|readBit
argument_list|()
expr_stmt|;
block|}
block|}
name|int
name|buffer
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bufferPos
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|readBit
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|bufferPos
argument_list|<
literal|0
operator|||
name|bufferPos
argument_list|>
literal|7
condition|)
block|{
name|buffer
operator|=
name|in
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Unexpected end of Huffman RLE stream"
argument_list|)
throw|;
block|}
name|bufferPos
operator|=
literal|0
expr_stmt|;
block|}
name|boolean
name|isSet
decl_stmt|;
if|if
condition|(
name|fillOrder
operator|==
name|TIFFExtension
operator|.
name|FILL_LEFT_TO_RIGHT
condition|)
block|{
name|isSet
operator|=
operator|(
operator|(
name|buffer
operator|>>
operator|(
literal|7
operator|-
name|bufferPos
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|1
expr_stmt|;
block|}
else|else
block|{
name|isSet
operator|=
operator|(
operator|(
name|buffer
operator|>>
operator|(
name|bufferPos
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|1
expr_stmt|;
block|}
name|bufferPos
operator|++
expr_stmt|;
if|if
condition|(
name|bufferPos
operator|>
literal|7
condition|)
block|{
name|bufferPos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|isSet
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|decodedLength
operator|<
literal|0
condition|)
block|{
return|return
literal|0x0
return|;
block|}
if|if
condition|(
name|decodedPos
operator|>=
name|decodedLength
condition|)
block|{
name|fetch
argument_list|()
expr_stmt|;
if|if
condition|(
name|decodedLength
operator|<
literal|0
condition|)
block|{
return|return
literal|0x0
return|;
block|}
block|}
return|return
name|decodedRow
index|[
name|decodedPos
operator|++
index|]
operator|&
literal|0xff
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|decodedLength
operator|<
literal|0
condition|)
block|{
comment|//TODO better? Math.min(off + len, b.length)
name|Arrays
operator|.
name|fill
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|off
operator|+
name|len
argument_list|,
operator|(
name|byte
operator|)
literal|0x0
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
if|if
condition|(
name|decodedPos
operator|>=
name|decodedLength
condition|)
block|{
name|fetch
argument_list|()
expr_stmt|;
if|if
condition|(
name|decodedLength
operator|<
literal|0
condition|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|off
operator|+
name|len
argument_list|,
operator|(
name|byte
operator|)
literal|0x0
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
block|}
name|int
name|read
init|=
name|Math
operator|.
name|min
argument_list|(
name|decodedLength
operator|-
name|decodedPos
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|decodedRow
argument_list|,
name|decodedPos
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|read
argument_list|)
expr_stmt|;
name|decodedPos
operator|+=
name|read
expr_stmt|;
return|return
name|read
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|decodedLength
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|decodedPos
operator|>=
name|decodedLength
condition|)
block|{
name|fetch
argument_list|()
expr_stmt|;
if|if
condition|(
name|decodedLength
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
name|int
name|skipped
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|decodedLength
operator|-
name|decodedPos
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|decodedPos
operator|+=
name|skipped
expr_stmt|;
return|return
name|skipped
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"mark/reset not supported"
argument_list|)
throw|;
block|}
specifier|private
specifier|static
specifier|final
class|class
name|Node
block|{
name|Node
name|left
decl_stmt|;
name|Node
name|right
decl_stmt|;
name|int
name|value
decl_stmt|;
comment|//> 63 non term.
name|boolean
name|canBeFill
init|=
literal|false
decl_stmt|;
name|boolean
name|isLeaf
init|=
literal|false
decl_stmt|;
name|void
name|set
parameter_list|(
specifier|final
name|boolean
name|next
parameter_list|,
specifier|final
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|next
condition|)
block|{
name|left
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|right
operator|=
name|node
expr_stmt|;
block|}
block|}
name|Node
name|walk
parameter_list|(
specifier|final
name|boolean
name|next
parameter_list|)
block|{
return|return
name|next
condition|?
name|right
else|:
name|left
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[leaf="
operator|+
name|isLeaf
operator|+
literal|", value="
operator|+
name|value
operator|+
literal|", canBeFill="
operator|+
name|canBeFill
operator|+
literal|"]"
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
class|class
name|Tree
block|{
specifier|final
name|Node
name|root
init|=
operator|new
name|Node
argument_list|()
decl_stmt|;
name|void
name|fill
parameter_list|(
specifier|final
name|int
name|depth
parameter_list|,
specifier|final
name|int
name|path
parameter_list|,
specifier|final
name|int
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|Node
name|current
init|=
name|root
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bitPos
init|=
name|depth
operator|-
literal|1
operator|-
name|i
decl_stmt|;
name|boolean
name|isSet
init|=
operator|(
operator|(
name|path
operator|>>
name|bitPos
operator|)
operator|&
literal|1
operator|)
operator|==
literal|1
decl_stmt|;
name|Node
name|next
init|=
name|current
operator|.
name|walk
argument_list|(
name|isSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|next
operator|=
operator|new
name|Node
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|depth
operator|-
literal|1
condition|)
block|{
name|next
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|next
operator|.
name|isLeaf
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|==
literal|0
condition|)
block|{
name|next
operator|.
name|canBeFill
operator|=
literal|true
expr_stmt|;
block|}
name|current
operator|.
name|set
argument_list|(
name|isSet
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|next
operator|.
name|isLeaf
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"node is leaf, no other following"
argument_list|)
throw|;
block|}
block|}
name|current
operator|=
name|next
expr_stmt|;
block|}
block|}
name|void
name|fill
parameter_list|(
specifier|final
name|int
name|depth
parameter_list|,
specifier|final
name|int
name|path
parameter_list|,
specifier|final
name|Node
name|node
parameter_list|)
throws|throws
name|IOException
block|{
name|Node
name|current
init|=
name|root
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bitPos
init|=
name|depth
operator|-
literal|1
operator|-
name|i
decl_stmt|;
name|boolean
name|isSet
init|=
operator|(
operator|(
name|path
operator|>>
name|bitPos
operator|)
operator|&
literal|1
operator|)
operator|==
literal|1
decl_stmt|;
name|Node
name|next
init|=
name|current
operator|.
name|walk
argument_list|(
name|isSet
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|depth
operator|-
literal|1
condition|)
block|{
name|next
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
operator|new
name|Node
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|==
literal|0
condition|)
block|{
name|next
operator|.
name|canBeFill
operator|=
literal|true
expr_stmt|;
block|}
name|current
operator|.
name|set
argument_list|(
name|isSet
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|next
operator|.
name|isLeaf
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"node is leaf, no other following"
argument_list|)
throw|;
block|}
block|}
name|current
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
specifier|static
specifier|final
name|short
index|[]
index|[]
name|BLACK_CODES
init|=
block|{
block|{
comment|// 2 bits
literal|0x2
block|,
literal|0x3
block|,               }
block|,
block|{
comment|// 3 bits
literal|0x2
block|,
literal|0x3
block|,               }
block|,
block|{
comment|// 4 bits
literal|0x2
block|,
literal|0x3
block|,               }
block|,
block|{
comment|// 5 bits
literal|0x3
block|,               }
block|,
block|{
comment|// 6 bits
literal|0x4
block|,
literal|0x5
block|,               }
block|,
block|{
comment|// 7 bits
literal|0x4
block|,
literal|0x5
block|,
literal|0x7
block|,               }
block|,
block|{
comment|// 8 bits
literal|0x4
block|,
literal|0x7
block|,               }
block|,
block|{
comment|// 9 bits
literal|0x18
block|,               }
block|,
block|{
comment|// 10 bits
literal|0x17
block|,
literal|0x18
block|,
literal|0x37
block|,
literal|0x8
block|,
literal|0xf
block|,               }
block|,
block|{
comment|// 11 bits
literal|0x17
block|,
literal|0x18
block|,
literal|0x28
block|,
literal|0x37
block|,
literal|0x67
block|,
literal|0x68
block|,
literal|0x6c
block|,
literal|0x8
block|,
literal|0xc
block|,
literal|0xd
block|,               }
block|,
block|{
comment|// 12 bits
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x1c
block|,
literal|0x1d
block|,
literal|0x1e
block|,
literal|0x1f
block|,
literal|0x24
block|,
literal|0x27
block|,
literal|0x28
block|,
literal|0x2b
block|,
literal|0x2c
block|,
literal|0x33
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x37
block|,
literal|0x38
block|,
literal|0x52
block|,
literal|0x53
block|,
literal|0x54
block|,
literal|0x55
block|,
literal|0x56
block|,
literal|0x57
block|,
literal|0x58
block|,
literal|0x59
block|,
literal|0x5a
block|,
literal|0x5b
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x67
block|,
literal|0x68
block|,
literal|0x69
block|,
literal|0x6a
block|,
literal|0x6b
block|,
literal|0x6c
block|,
literal|0x6d
block|,
literal|0xc8
block|,
literal|0xc9
block|,
literal|0xca
block|,
literal|0xcb
block|,
literal|0xcc
block|,
literal|0xcd
block|,
literal|0xd2
block|,
literal|0xd3
block|,
literal|0xd4
block|,
literal|0xd5
block|,
literal|0xd6
block|,
literal|0xd7
block|,
literal|0xda
block|,
literal|0xdb
block|,               }
block|,
block|{
comment|// 13 bits
literal|0x4a
block|,
literal|0x4b
block|,
literal|0x4c
block|,
literal|0x4d
block|,
literal|0x52
block|,
literal|0x53
block|,
literal|0x54
block|,
literal|0x55
block|,
literal|0x5a
block|,
literal|0x5b
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x6c
block|,
literal|0x6d
block|,
literal|0x72
block|,
literal|0x73
block|,
literal|0x74
block|,
literal|0x75
block|,
literal|0x76
block|,
literal|0x77
block|,               }
block|}
decl_stmt|;
specifier|static
specifier|final
name|short
index|[]
index|[]
name|BLACK_RUN_LENGTHS
init|=
block|{
block|{
comment|// 2 bits
literal|3
block|,
literal|2
block|,               }
block|,
block|{
comment|// 3 bits
literal|1
block|,
literal|4
block|,               }
block|,
block|{
comment|// 4 bits
literal|6
block|,
literal|5
block|,               }
block|,
block|{
comment|// 5 bits
literal|7
block|,               }
block|,
block|{
comment|// 6 bits
literal|9
block|,
literal|8
block|,               }
block|,
block|{
comment|// 7 bits
literal|10
block|,
literal|11
block|,
literal|12
block|,               }
block|,
block|{
comment|// 8 bits
literal|13
block|,
literal|14
block|,               }
block|,
block|{
comment|// 9 bits
literal|15
block|,               }
block|,
block|{
comment|// 10 bits
literal|16
block|,
literal|17
block|,
literal|0
block|,
literal|18
block|,
literal|64
block|,               }
block|,
block|{
comment|// 11 bits
literal|24
block|,
literal|25
block|,
literal|23
block|,
literal|22
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|1792
block|,
literal|1856
block|,
literal|1920
block|,               }
block|,
block|{
comment|// 12 bits
literal|1984
block|,
literal|2048
block|,
literal|2112
block|,
literal|2176
block|,
literal|2240
block|,
literal|2304
block|,
literal|2368
block|,
literal|2432
block|,
literal|2496
block|,
literal|2560
block|,
literal|52
block|,
literal|55
block|,
literal|56
block|,
literal|59
block|,
literal|60
block|,
literal|320
block|,
literal|384
block|,
literal|448
block|,
literal|53
block|,
literal|54
block|,
literal|50
block|,
literal|51
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|57
block|,
literal|58
block|,
literal|61
block|,
literal|256
block|,
literal|48
block|,
literal|49
block|,
literal|62
block|,
literal|63
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|40
block|,
literal|41
block|,
literal|128
block|,
literal|192
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|42
block|,
literal|43
block|,               }
block|,
block|{
comment|// 13 bits
literal|640
block|,
literal|704
block|,
literal|768
block|,
literal|832
block|,
literal|1280
block|,
literal|1344
block|,
literal|1408
block|,
literal|1472
block|,
literal|1536
block|,
literal|1600
block|,
literal|1664
block|,
literal|1728
block|,
literal|512
block|,
literal|576
block|,
literal|896
block|,
literal|960
block|,
literal|1024
block|,
literal|1088
block|,
literal|1152
block|,
literal|1216
block|,               }
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|short
index|[]
index|[]
name|WHITE_CODES
init|=
block|{
block|{
comment|// 4 bits
literal|0x7
block|,
literal|0x8
block|,
literal|0xb
block|,
literal|0xc
block|,
literal|0xe
block|,
literal|0xf
block|,               }
block|,
block|{
comment|// 5 bits
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x1b
block|,
literal|0x7
block|,
literal|0x8
block|,               }
block|,
block|{
comment|// 6 bits
literal|0x17
block|,
literal|0x18
block|,
literal|0x2a
block|,
literal|0x2b
block|,
literal|0x3
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x7
block|,
literal|0x8
block|,               }
block|,
block|{
comment|// 7 bits
literal|0x13
block|,
literal|0x17
block|,
literal|0x18
block|,
literal|0x24
block|,
literal|0x27
block|,
literal|0x28
block|,
literal|0x2b
block|,
literal|0x3
block|,
literal|0x37
block|,
literal|0x4
block|,
literal|0x8
block|,
literal|0xc
block|,               }
block|,
block|{
comment|// 8 bits
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x1a
block|,
literal|0x1b
block|,
literal|0x2
block|,
literal|0x24
block|,
literal|0x25
block|,
literal|0x28
block|,
literal|0x29
block|,
literal|0x2a
block|,
literal|0x2b
block|,
literal|0x2c
block|,
literal|0x2d
block|,
literal|0x3
block|,
literal|0x32
block|,
literal|0x33
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x36
block|,
literal|0x37
block|,
literal|0x4
block|,
literal|0x4a
block|,
literal|0x4b
block|,
literal|0x5
block|,
literal|0x52
block|,
literal|0x53
block|,
literal|0x54
block|,
literal|0x55
block|,
literal|0x58
block|,
literal|0x59
block|,
literal|0x5a
block|,
literal|0x5b
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x67
block|,
literal|0x68
block|,
literal|0xa
block|,
literal|0xb
block|,               }
block|,
block|{
comment|// 9 bits
literal|0x98
block|,
literal|0x99
block|,
literal|0x9a
block|,
literal|0x9b
block|,
literal|0xcc
block|,
literal|0xcd
block|,
literal|0xd2
block|,
literal|0xd3
block|,
literal|0xd4
block|,
literal|0xd5
block|,
literal|0xd6
block|,
literal|0xd7
block|,
literal|0xd8
block|,
literal|0xd9
block|,
literal|0xda
block|,
literal|0xdb
block|,               }
block|,
block|{
comment|// 10 bits
block|}
block|,
block|{
comment|// 11 bits
literal|0x8
block|,
literal|0xc
block|,
literal|0xd
block|,               }
block|,
block|{
comment|// 12 bits
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x1c
block|,
literal|0x1d
block|,
literal|0x1e
block|,
literal|0x1f
block|,               }
block|}
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|short
index|[]
index|[]
name|WHITE_RUN_LENGTHS
init|=
block|{
block|{
comment|// 4 bits
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,               }
block|,
block|{
comment|// 5 bits
literal|128
block|,
literal|8
block|,
literal|9
block|,
literal|64
block|,
literal|10
block|,
literal|11
block|,               }
block|,
block|{
comment|// 6 bits
literal|192
block|,
literal|1664
block|,
literal|16
block|,
literal|17
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|1
block|,
literal|12
block|,               }
block|,
block|{
comment|// 7 bits
literal|26
block|,
literal|21
block|,
literal|28
block|,
literal|27
block|,
literal|18
block|,
literal|24
block|,
literal|25
block|,
literal|22
block|,
literal|256
block|,
literal|23
block|,
literal|20
block|,
literal|19
block|,               }
block|,
block|{
comment|// 8 bits
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|31
block|,
literal|32
block|,
literal|29
block|,
literal|53
block|,
literal|54
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|30
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|0
block|,
literal|320
block|,
literal|384
block|,
literal|45
block|,
literal|59
block|,
literal|60
block|,
literal|46
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|448
block|,
literal|512
block|,
literal|640
block|,
literal|576
block|,
literal|47
block|,
literal|48
block|,               }
block|,
block|{
comment|// 9 bits
literal|1472
block|,
literal|1536
block|,
literal|1600
block|,
literal|1728
block|,
literal|704
block|,
literal|768
block|,
literal|832
block|,
literal|896
block|,
literal|960
block|,
literal|1024
block|,
literal|1088
block|,
literal|1152
block|,
literal|1216
block|,
literal|1280
block|,
literal|1344
block|,
literal|1408
block|,               }
block|,
block|{
comment|// 10 bits
block|}
block|,
block|{
comment|// 11 bits
literal|1792
block|,
literal|1856
block|,
literal|1920
block|,               }
block|,
block|{
comment|// 12 bits
literal|1984
block|,
literal|2048
block|,
literal|2112
block|,
literal|2176
block|,
literal|2240
block|,
literal|2304
block|,
literal|2368
block|,
literal|2432
block|,
literal|2496
block|,
literal|2560
block|,               }
block|}
decl_stmt|;
specifier|final
specifier|static
name|Node
name|EOL
decl_stmt|;
specifier|final
specifier|static
name|Node
name|FILL
decl_stmt|;
specifier|final
specifier|static
name|Tree
name|blackRunTree
decl_stmt|;
specifier|final
specifier|static
name|Tree
name|whiteRunTree
decl_stmt|;
specifier|final
specifier|static
name|Tree
name|eolOnlyTree
decl_stmt|;
specifier|final
specifier|static
name|Tree
name|codeTree
decl_stmt|;
specifier|final
specifier|static
name|int
name|VALUE_EOL
init|=
operator|-
literal|2000
decl_stmt|;
specifier|final
specifier|static
name|int
name|VALUE_FILL
init|=
operator|-
literal|1000
decl_stmt|;
specifier|final
specifier|static
name|int
name|VALUE_PASSMODE
init|=
operator|-
literal|3000
decl_stmt|;
specifier|final
specifier|static
name|int
name|VALUE_HMODE
init|=
operator|-
literal|4000
decl_stmt|;
static|static
block|{
name|EOL
operator|=
operator|new
name|Node
argument_list|()
expr_stmt|;
name|EOL
operator|.
name|isLeaf
operator|=
literal|true
expr_stmt|;
name|EOL
operator|.
name|value
operator|=
name|VALUE_EOL
expr_stmt|;
name|FILL
operator|=
operator|new
name|Node
argument_list|()
expr_stmt|;
name|FILL
operator|.
name|value
operator|=
name|VALUE_FILL
expr_stmt|;
name|FILL
operator|.
name|left
operator|=
name|FILL
expr_stmt|;
name|FILL
operator|.
name|right
operator|=
name|EOL
expr_stmt|;
name|eolOnlyTree
operator|=
operator|new
name|Tree
argument_list|()
expr_stmt|;
try|try
block|{
name|eolOnlyTree
operator|.
name|fill
argument_list|(
literal|12
argument_list|,
literal|0
argument_list|,
name|FILL
argument_list|)
expr_stmt|;
name|eolOnlyTree
operator|.
name|fill
argument_list|(
literal|12
argument_list|,
literal|1
argument_list|,
name|EOL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|blackRunTree
operator|=
operator|new
name|Tree
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BLACK_CODES
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|BLACK_CODES
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|blackRunTree
operator|.
name|fill
argument_list|(
name|i
operator|+
literal|2
argument_list|,
name|BLACK_CODES
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|BLACK_RUN_LENGTHS
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|blackRunTree
operator|.
name|fill
argument_list|(
literal|12
argument_list|,
literal|0
argument_list|,
name|FILL
argument_list|)
expr_stmt|;
name|blackRunTree
operator|.
name|fill
argument_list|(
literal|12
argument_list|,
literal|1
argument_list|,
name|EOL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|whiteRunTree
operator|=
operator|new
name|Tree
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|WHITE_CODES
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|WHITE_CODES
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|whiteRunTree
operator|.
name|fill
argument_list|(
name|i
operator|+
literal|4
argument_list|,
name|WHITE_CODES
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|WHITE_RUN_LENGTHS
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|whiteRunTree
operator|.
name|fill
argument_list|(
literal|12
argument_list|,
literal|0
argument_list|,
name|FILL
argument_list|)
expr_stmt|;
name|whiteRunTree
operator|.
name|fill
argument_list|(
literal|12
argument_list|,
literal|1
argument_list|,
name|EOL
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|codeTree
operator|=
operator|new
name|Tree
argument_list|()
expr_stmt|;
try|try
block|{
name|codeTree
operator|.
name|fill
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|,
name|VALUE_PASSMODE
argument_list|)
expr_stmt|;
comment|// pass mode
name|codeTree
operator|.
name|fill
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|,
name|VALUE_HMODE
argument_list|)
expr_stmt|;
comment|// H mode
name|codeTree
operator|.
name|fill
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// V(0)
name|codeTree
operator|.
name|fill
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// V_R(1)
name|codeTree
operator|.
name|fill
argument_list|(
literal|6
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// V_R(2)
name|codeTree
operator|.
name|fill
argument_list|(
literal|7
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|// V_R(3)
name|codeTree
operator|.
name|fill
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// V_L(1)
name|codeTree
operator|.
name|fill
argument_list|(
literal|6
argument_list|,
literal|2
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|// V_L(2)
name|codeTree
operator|.
name|fill
argument_list|(
literal|7
argument_list|,
literal|2
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
comment|// V_L(3)
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

