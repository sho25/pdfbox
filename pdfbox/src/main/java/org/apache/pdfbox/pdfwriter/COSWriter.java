begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfwriter
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DecimalFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|ICOSVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|CryptographyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|SignatureException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
operator|.
name|PDFXRefStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|SecurityHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|digitalsignature
operator|.
name|SignatureInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|persistence
operator|.
name|util
operator|.
name|COSObjectKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|StringUtil
import|;
end_import

begin_comment
comment|/**  * this class acts on a in-memory representation of a pdf document.  *  * todo no support for incremental updates  * todo single xref section only  * todo no linearization  *  * @author Michael Traut  * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  *   */
end_comment

begin_class
specifier|public
class|class
name|COSWriter
implements|implements
name|ICOSVisitor
block|{
comment|/**      * The dictionary open token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|DICT_OPEN
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"<<"
argument_list|)
decl_stmt|;
comment|/**      * The dictionary close token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|DICT_CLOSE
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|">>"
argument_list|)
decl_stmt|;
comment|/**      * space character.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|SPACE
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
comment|/**      * The start to a PDF comment.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|COMMENT
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"%"
argument_list|)
decl_stmt|;
comment|/**      * The output version of the PDF.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|VERSION
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"PDF-1.4"
argument_list|)
decl_stmt|;
comment|/**      * Garbage bytes used to create the PDF header.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|GARBAGE
init|=
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
literal|0xf6
block|,
operator|(
name|byte
operator|)
literal|0xe4
block|,
operator|(
name|byte
operator|)
literal|0xfc
block|,
operator|(
name|byte
operator|)
literal|0xdf
block|}
decl_stmt|;
comment|/**      * The EOF constant.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|EOF
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"%%EOF"
argument_list|)
decl_stmt|;
comment|// pdf tokens
comment|/**      * The reference token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|REFERENCE
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"R"
argument_list|)
decl_stmt|;
comment|/**      * The XREF token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|XREF
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"xref"
argument_list|)
decl_stmt|;
comment|/**      * The xref free token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|XREF_FREE
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"f"
argument_list|)
decl_stmt|;
comment|/**      * The xref used token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|XREF_USED
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"n"
argument_list|)
decl_stmt|;
comment|/**      * The trailer token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|TRAILER
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"trailer"
argument_list|)
decl_stmt|;
comment|/**      * The start xref token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|STARTXREF
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"startxref"
argument_list|)
decl_stmt|;
comment|/**      * The starting object token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|OBJ
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"obj"
argument_list|)
decl_stmt|;
comment|/**      * The end object token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ENDOBJ
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"endobj"
argument_list|)
decl_stmt|;
comment|/**      * The array open token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ARRAY_OPEN
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"["
argument_list|)
decl_stmt|;
comment|/**      * The array close token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ARRAY_CLOSE
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"]"
argument_list|)
decl_stmt|;
comment|/**      * The open stream token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|STREAM
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"stream"
argument_list|)
decl_stmt|;
comment|/**      * The close stream token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ENDSTREAM
init|=
name|StringUtil
operator|.
name|getBytes
argument_list|(
literal|"endstream"
argument_list|)
decl_stmt|;
specifier|private
name|NumberFormat
name|formatXrefOffset
init|=
operator|new
name|DecimalFormat
argument_list|(
literal|"0000000000"
argument_list|)
decl_stmt|;
comment|/**      * The decimal format for the xref object generation number data.      */
specifier|private
name|NumberFormat
name|formatXrefGeneration
init|=
operator|new
name|DecimalFormat
argument_list|(
literal|"00000"
argument_list|)
decl_stmt|;
specifier|private
name|NumberFormat
name|formatDecimal
init|=
name|NumberFormat
operator|.
name|getNumberInstance
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
decl_stmt|;
comment|// the stream where we create the pdf output
specifier|private
name|OutputStream
name|output
decl_stmt|;
comment|// the stream used to write standard cos data
specifier|private
name|COSStandardOutputStream
name|standardOutput
decl_stmt|;
comment|// the start position of the x ref section
specifier|private
name|long
name|startxref
init|=
literal|0
decl_stmt|;
comment|// the current object number
specifier|private
name|long
name|number
init|=
literal|0
decl_stmt|;
comment|// maps the object to the keys generated in the writer
comment|// these are used for indirect references in other objects
comment|//A hashtable is used on purpose over a hashmap
comment|//so that null entries will not get added.
specifier|private
name|Map
argument_list|<
name|COSBase
argument_list|,
name|COSObjectKey
argument_list|>
name|objectKeys
init|=
operator|new
name|Hashtable
argument_list|<
name|COSBase
argument_list|,
name|COSObjectKey
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|COSBase
argument_list|>
name|keyObject
init|=
operator|new
name|Hashtable
argument_list|<
name|COSObjectKey
argument_list|,
name|COSBase
argument_list|>
argument_list|()
decl_stmt|;
comment|// the list of x ref entries to be made so far
specifier|private
name|List
argument_list|<
name|COSWriterXRefEntry
argument_list|>
name|xRefEntries
init|=
operator|new
name|ArrayList
argument_list|<
name|COSWriterXRefEntry
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|HashSet
argument_list|<
name|COSBase
argument_list|>
name|objectsToWriteSet
init|=
operator|new
name|HashSet
argument_list|<
name|COSBase
argument_list|>
argument_list|()
decl_stmt|;
comment|//A list of objects to write.
specifier|private
name|LinkedList
argument_list|<
name|COSBase
argument_list|>
name|objectsToWrite
init|=
operator|new
name|LinkedList
argument_list|<
name|COSBase
argument_list|>
argument_list|()
decl_stmt|;
comment|//a list of objects already written
specifier|private
name|Set
argument_list|<
name|COSBase
argument_list|>
name|writtenObjects
init|=
operator|new
name|HashSet
argument_list|<
name|COSBase
argument_list|>
argument_list|()
decl_stmt|;
comment|//An 'actual' is any COSBase that is not a COSObject.
comment|//need to keep a list of the actuals that are added
comment|//as well as the objects because there is a problem
comment|//when adding a COSObject and then later adding
comment|//the actual for that object, so we will track
comment|//actuals separately.
specifier|private
name|Set
argument_list|<
name|COSBase
argument_list|>
name|actualsAdded
init|=
operator|new
name|HashSet
argument_list|<
name|COSBase
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|COSObjectKey
name|currentObjectKey
init|=
literal|null
decl_stmt|;
specifier|private
name|PDDocument
name|document
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|willEncrypt
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|incrementalUpdate
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|reachedSignature
init|=
literal|false
decl_stmt|;
specifier|private
name|int
index|[]
name|signaturePosition
init|=
operator|new
name|int
index|[
literal|2
index|]
decl_stmt|;
specifier|private
name|int
index|[]
name|byterangePosition
init|=
operator|new
name|int
index|[
literal|2
index|]
decl_stmt|;
specifier|private
name|FileInputStream
name|in
decl_stmt|;
comment|/**      * COSWriter constructor comment.      *      * @param os The wrapped output stream.      */
specifier|public
name|COSWriter
parameter_list|(
name|OutputStream
name|os
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|setOutput
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|setStandardOutput
argument_list|(
operator|new
name|COSStandardOutputStream
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
name|formatDecimal
operator|.
name|setMaximumFractionDigits
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|formatDecimal
operator|.
name|setGroupingUsed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * COSWriter constructor for incremental updates.       *      * @param os The wrapped output stream.      * @param is input stream      */
specifier|public
name|COSWriter
parameter_list|(
name|OutputStream
name|os
parameter_list|,
name|FileInputStream
name|is
parameter_list|)
block|{
name|this
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|in
operator|=
name|is
expr_stmt|;
name|incrementalUpdate
operator|=
literal|true
expr_stmt|;
block|}
specifier|private
name|void
name|prepareIncrement
parameter_list|(
name|PDDocument
name|doc
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|COSDocument
name|cosDoc
init|=
name|doc
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|xrefTable
init|=
name|cosDoc
operator|.
name|getXrefTable
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|COSObjectKey
argument_list|>
name|keySet
init|=
name|xrefTable
operator|.
name|keySet
argument_list|()
decl_stmt|;
name|long
name|highestNumber
init|=
literal|0
decl_stmt|;
for|for
control|(
name|COSObjectKey
name|cosObjectKey
range|:
name|keySet
control|)
block|{
name|COSBase
name|object
init|=
name|cosDoc
operator|.
name|getObjectFromPool
argument_list|(
name|cosObjectKey
argument_list|)
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|object
operator|!=
literal|null
operator|&&
name|cosObjectKey
operator|!=
literal|null
operator|&&
operator|!
operator|(
name|object
operator|instanceof
name|COSNumber
operator|)
condition|)
block|{
name|objectKeys
operator|.
name|put
argument_list|(
name|object
argument_list|,
name|cosObjectKey
argument_list|)
expr_stmt|;
name|keyObject
operator|.
name|put
argument_list|(
name|cosObjectKey
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
name|long
name|num
init|=
name|cosObjectKey
operator|.
name|getNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|>
name|highestNumber
condition|)
block|{
name|highestNumber
operator|=
name|num
expr_stmt|;
block|}
block|}
name|setNumber
argument_list|(
name|highestNumber
argument_list|)
expr_stmt|;
comment|// xrefTable.clear();
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * add an entry in the x ref table for later dump.      *      * @param entry The new entry to add.      */
specifier|protected
name|void
name|addXRefEntry
parameter_list|(
name|COSWriterXRefEntry
name|entry
parameter_list|)
block|{
name|getXRefEntries
argument_list|()
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will close the stream.      *      * @throws IOException If the underlying stream throws an exception.      */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|getStandardOutput
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getStandardOutput
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|getOutput
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getOutput
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This will get the current object number.      *      * @return The current object number.      */
specifier|protected
name|long
name|getNumber
parameter_list|()
block|{
return|return
name|number
return|;
block|}
comment|/**      * This will get all available object keys.      *      * @return A map of all object keys.      */
specifier|public
name|Map
argument_list|<
name|COSBase
argument_list|,
name|COSObjectKey
argument_list|>
name|getObjectKeys
parameter_list|()
block|{
return|return
name|objectKeys
return|;
block|}
comment|/**      * This will get the output stream.      *      * @return The output stream.      */
specifier|protected
name|java
operator|.
name|io
operator|.
name|OutputStream
name|getOutput
parameter_list|()
block|{
return|return
name|output
return|;
block|}
comment|/**      * This will get the standard output stream.      *      * @return The standard output stream.      */
specifier|protected
name|COSStandardOutputStream
name|getStandardOutput
parameter_list|()
block|{
return|return
name|standardOutput
return|;
block|}
comment|/**      * This will get the current start xref.      *      * @return The current start xref.      */
specifier|protected
name|long
name|getStartxref
parameter_list|()
block|{
return|return
name|startxref
return|;
block|}
comment|/**      * This will get the xref entries.      *      * @return All available xref entries.      */
specifier|protected
name|List
argument_list|<
name|COSWriterXRefEntry
argument_list|>
name|getXRefEntries
parameter_list|()
block|{
return|return
name|xRefEntries
return|;
block|}
comment|/**      * This will set the current object number.      *      * @param newNumber The new object number.      */
specifier|protected
name|void
name|setNumber
parameter_list|(
name|long
name|newNumber
parameter_list|)
block|{
name|number
operator|=
name|newNumber
expr_stmt|;
block|}
comment|/**      * This will set the output stream.      *      * @param newOutput The new output stream.      */
specifier|private
name|void
name|setOutput
parameter_list|(
name|OutputStream
name|newOutput
parameter_list|)
block|{
name|output
operator|=
name|newOutput
expr_stmt|;
block|}
comment|/**      * This will set the standard output stream.      *      * @param newStandardOutput The new standard output stream.      */
specifier|private
name|void
name|setStandardOutput
parameter_list|(
name|COSStandardOutputStream
name|newStandardOutput
parameter_list|)
block|{
name|standardOutput
operator|=
name|newStandardOutput
expr_stmt|;
block|}
comment|/**      * This will set the start xref.      *      * @param newStartxref The new start xref attribute.      */
specifier|protected
name|void
name|setStartxref
parameter_list|(
name|long
name|newStartxref
parameter_list|)
block|{
name|startxref
operator|=
name|newStartxref
expr_stmt|;
block|}
comment|/**      * This will write the body of the document.      *      * @param doc The document to write the body for.      *      * @throws IOException If there is an error writing the data.      */
specifier|protected
name|void
name|doWriteBody
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
throws|,
name|SignatureException
block|{
name|COSDictionary
name|trailer
init|=
name|doc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|COSDictionary
name|root
init|=
operator|(
name|COSDictionary
operator|)
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|COSDictionary
name|info
init|=
operator|(
name|COSDictionary
operator|)
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|)
decl_stmt|;
name|COSDictionary
name|encrypt
init|=
operator|(
name|COSDictionary
operator|)
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
name|addObjectToWrite
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|addObjectToWrite
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|objectsToWrite
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|COSBase
name|nextObject
init|=
name|objectsToWrite
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|objectsToWriteSet
operator|.
name|remove
argument_list|(
name|nextObject
argument_list|)
expr_stmt|;
name|doWriteObject
argument_list|(
name|nextObject
argument_list|)
expr_stmt|;
block|}
name|willEncrypt
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|encrypt
operator|!=
literal|null
condition|)
block|{
name|addObjectToWrite
argument_list|(
name|encrypt
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|objectsToWrite
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|COSBase
name|nextObject
init|=
name|objectsToWrite
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|objectsToWriteSet
operator|.
name|remove
argument_list|(
name|nextObject
argument_list|)
expr_stmt|;
name|doWriteObject
argument_list|(
name|nextObject
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addObjectToWrite
parameter_list|(
name|COSBase
name|object
parameter_list|)
block|{
name|COSBase
name|actual
init|=
name|object
decl_stmt|;
if|if
condition|(
name|actual
operator|instanceof
name|COSObject
condition|)
block|{
name|actual
operator|=
operator|(
operator|(
name|COSObject
operator|)
name|actual
operator|)
operator|.
name|getObject
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|writtenObjects
operator|.
name|contains
argument_list|(
name|object
argument_list|)
operator|&&
operator|!
name|objectsToWriteSet
operator|.
name|contains
argument_list|(
name|object
argument_list|)
operator|&&
operator|!
name|actualsAdded
operator|.
name|contains
argument_list|(
name|actual
argument_list|)
condition|)
block|{
name|COSBase
name|cosBase
init|=
literal|null
decl_stmt|;
name|COSObjectKey
name|cosObjectKey
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|actual
operator|!=
literal|null
condition|)
block|{
name|cosObjectKey
operator|=
name|objectKeys
operator|.
name|get
argument_list|(
name|actual
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cosObjectKey
operator|!=
literal|null
condition|)
block|{
name|cosBase
operator|=
name|keyObject
operator|.
name|get
argument_list|(
name|cosObjectKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|actual
operator|!=
literal|null
operator|&&
name|objectKeys
operator|.
name|containsKey
argument_list|(
name|actual
argument_list|)
operator|&&
operator|!
name|object
operator|.
name|isNeedToBeUpdate
argument_list|()
operator|&&
operator|(
name|cosBase
operator|!=
literal|null
operator|&&
operator|!
name|cosBase
operator|.
name|isNeedToBeUpdate
argument_list|()
operator|)
condition|)
block|{
return|return;
block|}
name|objectsToWrite
operator|.
name|add
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|objectsToWriteSet
operator|.
name|add
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|!=
literal|null
condition|)
block|{
name|actualsAdded
operator|.
name|add
argument_list|(
name|actual
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This will write a COS object.      *      * @param obj The object to write.      *      * @throws IOException if the output cannot be written      */
specifier|public
name|void
name|doWriteObject
parameter_list|(
name|COSBase
name|obj
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
throws|,
name|SignatureException
block|{
name|writtenObjects
operator|.
name|add
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSDictionary
name|dict
init|=
operator|(
name|COSDictionary
operator|)
name|obj
decl_stmt|;
name|COSName
name|item
init|=
operator|(
name|COSName
operator|)
name|dict
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|COSName
operator|.
name|SIG
operator|.
name|equals
argument_list|(
name|item
argument_list|)
operator|||
name|COSName
operator|.
name|DOC_TIME_STAMP
operator|.
name|equals
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|reachedSignature
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// find the physical reference
name|currentObjectKey
operator|=
name|getObjectKey
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|// add a x ref entry
name|addXRefEntry
argument_list|(
operator|new
name|COSWriterXRefEntry
argument_list|(
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
argument_list|,
name|obj
argument_list|,
name|currentObjectKey
argument_list|)
argument_list|)
expr_stmt|;
comment|// write the object
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|currentObjectKey
operator|.
name|getNumber
argument_list|()
argument_list|)
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|currentObjectKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|OBJ
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|obj
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|ENDOBJ
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
block|}
comment|/**      * This will write the header to the PDF document.      *      * @param doc The document to get the data from.      *      * @throws IOException If there is an error writing to the stream.      */
specifier|protected
name|void
name|doWriteHeader
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|doc
operator|.
name|getHeaderString
argument_list|()
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|COMMENT
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|GARBAGE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
block|}
comment|/**      * This will write the trailer to the PDF document.      *      * @param doc The document to create the trailer for.      *      * @throws IOException If there is an IOError while writing the document.      */
specifier|protected
name|void
name|doWriteTrailer
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
throws|,
name|SignatureException
block|{
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|TRAILER
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|COSDictionary
name|trailer
init|=
name|doc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
comment|//sort xref, needed only if object keys not regenerated
name|Collections
operator|.
name|sort
argument_list|(
name|getXRefEntries
argument_list|()
argument_list|)
expr_stmt|;
name|COSWriterXRefEntry
name|lastEntry
init|=
name|getXRefEntries
argument_list|()
operator|.
name|get
argument_list|(
name|getXRefEntries
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|trailer
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|SIZE
argument_list|,
operator|(
name|int
operator|)
name|lastEntry
operator|.
name|getKey
argument_list|()
operator|.
name|getNumber
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Only need to stay, if an incremental update will be performed
if|if
condition|(
operator|!
name|incrementalUpdate
condition|)
block|{
name|trailer
operator|.
name|removeItem
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
expr_stmt|;
block|}
comment|// Remove a checksum if present
name|trailer
operator|.
name|removeItem
argument_list|(
name|COSName
operator|.
name|DOC_CHECKSUM
argument_list|)
expr_stmt|;
name|trailer
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * write the x ref section for the pdf file      *      * currently, the pdf is reconstructed from the scratch, so we write a single section      *      * todo support for incremental writing?      *      * @param doc The document to write the xref from.      *      * @throws IOException If there is an error writing the data to the stream.      */
specifier|protected
name|void
name|doWriteXRef
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|doc
operator|.
name|isXRefStream
argument_list|()
condition|)
block|{
comment|// sort xref, needed only if object keys not regenerated
name|Collections
operator|.
name|sort
argument_list|(
name|getXRefEntries
argument_list|()
argument_list|)
expr_stmt|;
name|COSWriterXRefEntry
name|lastEntry
init|=
name|getXRefEntries
argument_list|()
operator|.
name|get
argument_list|(
name|getXRefEntries
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// remember the position where x ref is written
name|setStartxref
argument_list|(
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
comment|//
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|XREF
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
comment|// write start object number and object count for this x ref section
comment|// we assume starting from scratch
name|writeXrefRange
argument_list|(
literal|0
argument_list|,
name|lastEntry
operator|.
name|getKey
argument_list|()
operator|.
name|getNumber
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// write initial start object with ref to first deleted object and magic generation number
name|writeXrefEntry
argument_list|(
name|COSWriterXRefEntry
operator|.
name|getNullEntry
argument_list|()
argument_list|)
expr_stmt|;
comment|// write entry for every object
name|long
name|lastObjectNumber
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|COSWriterXRefEntry
argument_list|>
name|i
init|=
name|getXRefEntries
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|COSWriterXRefEntry
name|entry
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|lastObjectNumber
operator|<
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getNumber
argument_list|()
operator|-
literal|1
condition|)
block|{
name|writeXrefEntry
argument_list|(
name|COSWriterXRefEntry
operator|.
name|getNullEntry
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|lastObjectNumber
operator|=
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getNumber
argument_list|()
expr_stmt|;
name|writeXrefEntry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|COSDictionary
name|trailer
init|=
name|doc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|doc
operator|.
name|getStartXref
argument_list|()
argument_list|)
expr_stmt|;
name|addXRefEntry
argument_list|(
name|COSWriterXRefEntry
operator|.
name|getNullEntry
argument_list|()
argument_list|)
expr_stmt|;
comment|// sort xref, needed only if object keys not regenerated
name|Collections
operator|.
name|sort
argument_list|(
name|getXRefEntries
argument_list|()
argument_list|)
expr_stmt|;
comment|// remember the position where x ref was written
name|setStartxref
argument_list|(
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|XREF
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
comment|// write start object number and object count for this x ref section
comment|// we assume starting from scratch
name|Integer
index|[]
name|xRefRanges
init|=
name|getXRefRanges
argument_list|(
name|getXRefEntries
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|xRefLength
init|=
name|xRefRanges
operator|.
name|length
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|<
name|xRefLength
operator|&&
operator|(
name|xRefLength
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|writeXrefRange
argument_list|(
name|xRefRanges
index|[
name|x
index|]
argument_list|,
name|xRefRanges
index|[
name|x
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xRefRanges
index|[
name|x
operator|+
literal|1
index|]
condition|;
operator|++
name|i
control|)
block|{
name|writeXrefEntry
argument_list|(
name|xRefEntries
operator|.
name|get
argument_list|(
name|j
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|x
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|doWriteXRefInc
parameter_list|(
name|COSDocument
name|doc
parameter_list|,
name|long
name|hybridPrev
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
throws|,
name|SignatureException
block|{
if|if
condition|(
name|doc
operator|.
name|isXRefStream
argument_list|()
operator|||
name|hybridPrev
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// the file uses XrefStreams, so we need to update
comment|// it with an xref stream. We create a new one and fill it
comment|// with data available here
comment|// first set an entry for the null entry in the xref table
comment|// this is probably not necessary
comment|// addXRefEntry(COSWriterXRefEntry.getNullEntry());
comment|// create a new XRefStrema object
name|PDFXRefStream
name|pdfxRefStream
init|=
operator|new
name|PDFXRefStream
argument_list|()
decl_stmt|;
comment|// add all entries from the incremental update.
name|List
argument_list|<
name|COSWriterXRefEntry
argument_list|>
name|xRefEntries2
init|=
name|getXRefEntries
argument_list|()
decl_stmt|;
for|for
control|(
name|COSWriterXRefEntry
name|cosWriterXRefEntry
range|:
name|xRefEntries2
control|)
block|{
name|pdfxRefStream
operator|.
name|addEntry
argument_list|(
name|cosWriterXRefEntry
argument_list|)
expr_stmt|;
block|}
name|COSDictionary
name|trailer
init|=
name|doc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
comment|//            trailer.setLong(COSName.PREV, hybridPrev == -1 ? prev : hybridPrev);
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|doc
operator|.
name|getStartXref
argument_list|()
argument_list|)
expr_stmt|;
name|pdfxRefStream
operator|.
name|addTrailerInfo
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
comment|// the size is the highest object number+1. we add one more
comment|// for the xref stream object we are going to write
name|pdfxRefStream
operator|.
name|setSize
argument_list|(
name|getNumber
argument_list|()
operator|+
literal|2
argument_list|)
expr_stmt|;
name|setStartxref
argument_list|(
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|COSStream
name|stream2
init|=
name|pdfxRefStream
operator|.
name|getStream
argument_list|()
decl_stmt|;
name|doWriteObject
argument_list|(
name|stream2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doc
operator|.
name|isXRefStream
argument_list|()
operator|||
name|hybridPrev
operator|!=
operator|-
literal|1
condition|)
block|{
name|COSDictionary
name|trailer
init|=
name|doc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|doc
operator|.
name|getStartXref
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hybridPrev
operator|!=
operator|-
literal|1
condition|)
block|{
name|COSName
name|xrefStm
init|=
name|COSName
operator|.
name|XREF_STM
decl_stmt|;
name|trailer
operator|.
name|removeItem
argument_list|(
name|xrefStm
argument_list|)
expr_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|xrefStm
argument_list|,
name|getStartxref
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|addXRefEntry
argument_list|(
name|COSWriterXRefEntry
operator|.
name|getNullEntry
argument_list|()
argument_list|)
expr_stmt|;
comment|// sort xref, needed only if object keys not regenerated
name|Collections
operator|.
name|sort
argument_list|(
name|getXRefEntries
argument_list|()
argument_list|)
expr_stmt|;
comment|// remember the position where x ref was written
name|setStartxref
argument_list|(
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|XREF
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
comment|// write start object number and object count for this x ref section
comment|// we assume starting from scratch
name|Integer
index|[]
name|xRefRanges
init|=
name|getXRefRanges
argument_list|(
name|getXRefEntries
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|xRefLength
init|=
name|xRefRanges
operator|.
name|length
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|<
name|xRefLength
operator|&&
operator|(
name|xRefLength
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|writeXrefRange
argument_list|(
name|xRefRanges
index|[
name|x
index|]
argument_list|,
name|xRefRanges
index|[
name|x
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xRefRanges
index|[
name|x
operator|+
literal|1
index|]
condition|;
operator|++
name|i
control|)
block|{
name|writeXrefEntry
argument_list|(
name|xRefEntries
operator|.
name|get
argument_list|(
name|j
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|x
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|doWriteSignature
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
throws|,
name|SignatureException
block|{
comment|// need to calculate the ByteRange
if|if
condition|(
name|signaturePosition
index|[
literal|0
index|]
operator|>
literal|0
operator|&&
name|byterangePosition
index|[
literal|1
index|]
operator|>
literal|0
condition|)
block|{
name|int
name|left
init|=
operator|(
name|int
operator|)
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
operator|-
name|signaturePosition
index|[
literal|1
index|]
decl_stmt|;
name|String
name|newByteRange
init|=
literal|"0 "
operator|+
name|signaturePosition
index|[
literal|0
index|]
operator|+
literal|" "
operator|+
name|signaturePosition
index|[
literal|1
index|]
operator|+
literal|" "
operator|+
name|left
operator|+
literal|"]"
decl_stmt|;
name|int
name|leftByterange
init|=
name|byterangePosition
index|[
literal|1
index|]
operator|-
name|byterangePosition
index|[
literal|0
index|]
operator|-
name|newByteRange
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftByterange
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't write new ByteRange, not enough space"
argument_list|)
throw|;
block|}
name|getStandardOutput
argument_list|()
operator|.
name|setPos
argument_list|(
name|byterangePosition
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|newByteRange
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftByterange
condition|;
operator|++
name|i
control|)
block|{
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
literal|0x20
argument_list|)
expr_stmt|;
block|}
name|getStandardOutput
argument_list|()
operator|.
name|setPos
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Begin - extracting document
name|InputStream
name|filterInputStream
init|=
operator|new
name|COSFilterInputStream
argument_list|(
name|in
argument_list|,
operator|new
name|int
index|[]
block|{
literal|0
block|,
name|signaturePosition
index|[
literal|0
index|]
block|,
name|signaturePosition
index|[
literal|1
index|]
block|,
name|left
block|}
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|bytes
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|filterInputStream
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|bytes
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|filterInputStream
operator|!=
literal|null
condition|)
block|{
name|filterInputStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|byte
index|[]
name|pdfContent
init|=
name|bytes
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
comment|// End - extracting document
name|SignatureInterface
name|signatureInterface
init|=
name|doc
operator|.
name|getSignatureInterface
argument_list|()
decl_stmt|;
name|byte
index|[]
name|sign
init|=
name|signatureInterface
operator|.
name|sign
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|pdfContent
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|signature
init|=
operator|new
name|COSString
argument_list|(
name|sign
argument_list|)
operator|.
name|getHexString
argument_list|()
decl_stmt|;
name|int
name|leftSignaturerange
init|=
name|signaturePosition
index|[
literal|1
index|]
operator|-
name|signaturePosition
index|[
literal|0
index|]
operator|-
name|signature
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftSignaturerange
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't write signature, not enough space"
argument_list|)
throw|;
block|}
name|getStandardOutput
argument_list|()
operator|.
name|setPos
argument_list|(
name|signaturePosition
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|signature
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|writeXrefRange
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|y
parameter_list|)
throws|throws
name|IOException
block|{
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|x
argument_list|)
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|y
argument_list|)
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|writeXrefEntry
parameter_list|(
name|COSWriterXRefEntry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|offset
init|=
name|formatXrefOffset
operator|.
name|format
argument_list|(
name|entry
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|generation
init|=
name|formatXrefGeneration
operator|.
name|format
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getGeneration
argument_list|()
argument_list|)
decl_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|offset
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|generation
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|entry
operator|.
name|isFree
argument_list|()
condition|?
name|XREF_FREE
else|:
name|XREF_USED
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeCRLF
argument_list|()
expr_stmt|;
block|}
comment|/**      * check the xref entries and write out the ranges.  The format of the      * returned array is exactly the same as the pdf specification.  See section      * 7.5.4 of ISO32000-1:2008, example 1 (page 40) for reference.      *<p>      * example: 0 1 2 5 6 7 8 10      *<p>      * will create a array with follow ranges      *<p>      * 0 3 5 4 10 1      *<p>      * this mean that the element 0 is followed by two other related numbers       * that represent a cluster of the size 3. 5 is follow by three other      * related numbers and create a cluster of size 4. etc.      *       * @param xRefEntriesList list with the xRef entries that was written      * @return a integer array with the ranges      */
specifier|protected
name|Integer
index|[]
name|getXRefRanges
parameter_list|(
name|List
argument_list|<
name|COSWriterXRefEntry
argument_list|>
name|xRefEntriesList
parameter_list|)
block|{
name|int
name|nr
init|=
literal|0
decl_stmt|;
name|int
name|last
init|=
operator|-
literal|2
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|object
range|:
name|xRefEntriesList
control|)
block|{
name|nr
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|COSWriterXRefEntry
operator|)
name|object
argument_list|)
operator|.
name|getKey
argument_list|()
operator|.
name|getNumber
argument_list|()
expr_stmt|;
if|if
condition|(
name|nr
operator|==
name|last
operator|+
literal|1
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|last
operator|=
name|nr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last
operator|==
operator|-
literal|2
condition|)
block|{
name|last
operator|=
name|nr
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|last
operator|-
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|last
operator|=
name|nr
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|// If no new entry is found, we need to write out the last result
if|if
condition|(
name|xRefEntriesList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|last
operator|-
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * This will get the object key for the object.      *      * @param obj The object to get the key for.      *      * @return The object key for the object.      */
specifier|private
name|COSObjectKey
name|getObjectKey
parameter_list|(
name|COSBase
name|obj
parameter_list|)
block|{
name|COSBase
name|actual
init|=
name|obj
decl_stmt|;
if|if
condition|(
name|actual
operator|instanceof
name|COSObject
condition|)
block|{
name|actual
operator|=
operator|(
operator|(
name|COSObject
operator|)
name|obj
operator|)
operator|.
name|getObject
argument_list|()
expr_stmt|;
block|}
name|COSObjectKey
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|actual
operator|!=
literal|null
condition|)
block|{
name|key
operator|=
name|objectKeys
operator|.
name|get
argument_list|(
name|actual
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|key
operator|=
name|objectKeys
operator|.
name|get
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|setNumber
argument_list|(
name|getNumber
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|key
operator|=
operator|new
name|COSObjectKey
argument_list|(
name|getNumber
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|objectKeys
operator|.
name|put
argument_list|(
name|obj
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|!=
literal|null
condition|)
block|{
name|objectKeys
operator|.
name|put
argument_list|(
name|actual
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|key
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromArray
parameter_list|(
name|COSArray
name|obj
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
throws|,
name|SignatureException
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|ARRAY_OPEN
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|COSBase
argument_list|>
name|i
init|=
name|obj
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|COSBase
name|current
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|instanceof
name|COSDictionary
condition|)
block|{
if|if
condition|(
name|current
operator|.
name|isDirect
argument_list|()
condition|)
block|{
name|visitFromDictionary
argument_list|(
operator|(
name|COSDictionary
operator|)
name|current
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addObjectToWrite
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|writeReference
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|current
operator|instanceof
name|COSObject
condition|)
block|{
name|COSBase
name|subValue
init|=
operator|(
operator|(
name|COSObject
operator|)
name|current
operator|)
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|subValue
operator|instanceof
name|COSDictionary
operator|||
name|subValue
operator|==
literal|null
condition|)
block|{
name|addObjectToWrite
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|writeReference
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subValue
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|COSNull
operator|.
name|NULL
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|instanceof
name|COSString
condition|)
block|{
name|COSString
name|copy
init|=
operator|new
name|COSString
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|copy
operator|.
name|append
argument_list|(
operator|(
operator|(
name|COSString
operator|)
name|current
operator|)
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|count
operator|%
literal|10
operator|==
literal|0
condition|)
block|{
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|ARRAY_CLOSE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromBoolean
parameter_list|(
name|COSBoolean
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|obj
operator|.
name|writePDF
argument_list|(
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromDictionary
parameter_list|(
name|COSDictionary
name|obj
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
throws|,
name|SignatureException
block|{
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|DICT_OPEN
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|COSName
argument_list|,
name|COSBase
argument_list|>
name|entry
range|:
name|obj
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|COSBase
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSDictionary
name|dict
init|=
operator|(
name|COSDictionary
operator|)
name|value
decl_stmt|;
comment|// write all XObjects as direct objects, this will save some size
name|COSBase
name|item
init|=
name|dict
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|XOBJECT
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
condition|)
block|{
name|item
operator|.
name|setDirect
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|item
operator|=
name|dict
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|RESOURCES
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
condition|)
block|{
name|item
operator|.
name|setDirect
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dict
operator|.
name|isDirect
argument_list|()
condition|)
block|{
comment|// If the object should be written direct, we need
comment|// to pass the dictionary to the visitor again.
name|visitFromDictionary
argument_list|(
name|dict
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addObjectToWrite
argument_list|(
name|dict
argument_list|)
expr_stmt|;
name|writeReference
argument_list|(
name|dict
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|COSObject
condition|)
block|{
name|COSBase
name|subValue
init|=
operator|(
operator|(
name|COSObject
operator|)
name|value
operator|)
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|subValue
operator|instanceof
name|COSDictionary
operator|||
name|subValue
operator|==
literal|null
condition|)
block|{
name|addObjectToWrite
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|writeReference
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subValue
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If we reach the pdf signature, we need to determinate the position of the
comment|// content and byterange
if|if
condition|(
name|reachedSignature
operator|&&
name|COSName
operator|.
name|CONTENTS
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|signaturePosition
operator|=
operator|new
name|int
index|[
literal|2
index|]
expr_stmt|;
name|signaturePosition
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
expr_stmt|;
name|value
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|signaturePosition
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reachedSignature
operator|&&
name|COSName
operator|.
name|BYTERANGE
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|byterangePosition
operator|=
operator|new
name|int
index|[
literal|2
index|]
expr_stmt|;
name|byterangePosition
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
operator|+
literal|1
expr_stmt|;
name|value
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|byterangePosition
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
operator|-
literal|1
expr_stmt|;
name|reachedSignature
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|value
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//then we won't write anything, there are a couple cases
comment|//were the value of an entry in the COSDictionary will
comment|//be a dangling reference that points to nothing
comment|//so we will just not write out the entry if that is the case
block|}
block|}
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|DICT_CLOSE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromDocument
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
throws|,
name|SignatureException
block|{
if|if
condition|(
operator|!
name|incrementalUpdate
condition|)
block|{
name|doWriteHeader
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
name|doWriteBody
argument_list|(
name|doc
argument_list|)
expr_stmt|;
comment|// get the previous trailer
name|COSDictionary
name|trailer
init|=
name|doc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|long
name|hybridPrev
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|trailer
operator|!=
literal|null
condition|)
block|{
name|hybridPrev
operator|=
name|trailer
operator|.
name|getLong
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|incrementalUpdate
condition|)
block|{
name|doWriteXRefInc
argument_list|(
name|doc
argument_list|,
name|hybridPrev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doWriteXRef
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// the trailer section should only be used for xref tables not for xref streams
if|if
condition|(
operator|!
name|incrementalUpdate
operator|||
operator|!
name|doc
operator|.
name|isXRefStream
argument_list|()
operator|||
name|hybridPrev
operator|!=
operator|-
literal|1
condition|)
block|{
name|doWriteTrailer
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// write endof
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|STARTXREF
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|getStartxref
argument_list|()
argument_list|)
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
if|if
condition|(
name|incrementalUpdate
condition|)
block|{
name|doWriteSignature
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromFloat
parameter_list|(
name|COSFloat
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|obj
operator|.
name|writePDF
argument_list|(
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromInt
parameter_list|(
name|COSInteger
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|obj
operator|.
name|writePDF
argument_list|(
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromName
parameter_list|(
name|COSName
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|obj
operator|.
name|writePDF
argument_list|(
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromNull
parameter_list|(
name|COSNull
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|obj
operator|.
name|writePDF
argument_list|(
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**      * visitFromObjRef method comment.      *      * @param obj The object that is being visited.      *      * @throws IOException If there is an exception while visiting this object.      */
specifier|public
name|void
name|writeReference
parameter_list|(
name|COSBase
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|COSObjectKey
name|key
init|=
name|getObjectKey
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|key
operator|.
name|getNumber
argument_list|()
argument_list|)
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|key
operator|.
name|getGeneration
argument_list|()
argument_list|)
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|REFERENCE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromStream
parameter_list|(
name|COSStream
name|obj
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
throws|,
name|SignatureException
block|{
if|if
condition|(
name|willEncrypt
condition|)
block|{
name|document
operator|.
name|getSecurityHandler
argument_list|()
operator|.
name|encryptStream
argument_list|(
name|obj
argument_list|,
name|currentObjectKey
operator|.
name|getNumber
argument_list|()
argument_list|,
name|currentObjectKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|COSObject
name|lengthObject
init|=
literal|null
decl_stmt|;
comment|// check if the length object is required to be direct, like in
comment|// a cross reference stream dictionary
name|COSBase
name|lengthEntry
init|=
name|obj
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|)
decl_stmt|;
name|String
name|type
init|=
name|obj
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|lengthEntry
operator|!=
literal|null
operator|&&
name|lengthEntry
operator|.
name|isDirect
argument_list|()
operator|||
literal|"XRef"
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|// the length might be the non encoded length,
comment|// set the real one as direct object
name|COSInteger
name|cosInteger
init|=
name|COSInteger
operator|.
name|get
argument_list|(
name|obj
operator|.
name|getFilteredLength
argument_list|()
argument_list|)
decl_stmt|;
name|cosInteger
operator|.
name|setDirect
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|obj
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|,
name|cosInteger
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// make the length an implicit indirect object
comment|// set the length of the stream and write stream dictionary
name|lengthObject
operator|=
operator|new
name|COSObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|obj
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|,
name|lengthObject
argument_list|)
expr_stmt|;
block|}
name|InputStream
name|input
init|=
literal|null
decl_stmt|;
try|try
block|{
name|input
operator|=
name|obj
operator|.
name|getFilteredStream
argument_list|()
expr_stmt|;
comment|//obj.accept(this);
comment|// write the stream content
name|visitFromDictionary
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|STREAM
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeCRLF
argument_list|()
expr_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|amountRead
init|=
literal|0
decl_stmt|;
name|int
name|totalAmountWritten
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|amountRead
operator|=
name|input
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
literal|1024
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|amountRead
argument_list|)
expr_stmt|;
name|totalAmountWritten
operator|+=
name|amountRead
expr_stmt|;
block|}
comment|// set the length as an indirect object
if|if
condition|(
name|lengthObject
operator|!=
literal|null
condition|)
block|{
name|lengthObject
operator|.
name|setObject
argument_list|(
name|COSInteger
operator|.
name|get
argument_list|(
name|totalAmountWritten
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|getStandardOutput
argument_list|()
operator|.
name|writeCRLF
argument_list|()
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|ENDSTREAM
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|input
operator|!=
literal|null
condition|)
block|{
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromString
parameter_list|(
name|COSString
name|obj
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
block|{
if|if
condition|(
name|willEncrypt
condition|)
block|{
name|document
operator|.
name|getSecurityHandler
argument_list|()
operator|.
name|decryptString
argument_list|(
name|obj
argument_list|,
name|currentObjectKey
operator|.
name|getNumber
argument_list|()
argument_list|,
name|currentObjectKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|obj
operator|.
name|writePDF
argument_list|(
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**      * This will write the pdf document.      *      * @throws IOException If an error occurs while generating the data.      * @param doc The document to write.      */
specifier|public
name|void
name|write
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
throws|,
name|SignatureException
throws|,
name|NoSuchAlgorithmException
block|{
name|PDDocument
name|pdDoc
init|=
operator|new
name|PDDocument
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|pdDoc
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will write the pdf document.      *      * @param doc The document to write.      *      * @throws IOException If an error occurs while generating the data.      * @throws CryptographyException If an error occurs while generating the data.      */
specifier|public
name|void
name|write
parameter_list|(
name|PDDocument
name|doc
parameter_list|)
throws|throws
name|IOException
throws|,
name|CryptographyException
throws|,
name|SignatureException
throws|,
name|NoSuchAlgorithmException
block|{
name|Long
name|idTime
init|=
name|doc
operator|.
name|getDocumentId
argument_list|()
operator|==
literal|null
condition|?
name|System
operator|.
name|currentTimeMillis
argument_list|()
else|:
name|doc
operator|.
name|getDocumentId
argument_list|()
decl_stmt|;
name|document
operator|=
name|doc
expr_stmt|;
if|if
condition|(
name|incrementalUpdate
condition|)
block|{
name|prepareIncrement
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// if the document says we should remove encryption, then we shouldn't encrypt
if|if
condition|(
name|doc
operator|.
name|isAllSecurityToBeRemoved
argument_list|()
condition|)
block|{
name|willEncrypt
operator|=
literal|false
expr_stmt|;
comment|// also need to get rid of the "Encrypt" in the trailer so readers
comment|// don't try to decrypt a document which is not encrypted
name|COSDocument
name|cosDoc
init|=
name|doc
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|COSDictionary
name|trailer
init|=
name|cosDoc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|trailer
operator|.
name|removeItem
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SecurityHandler
name|securityHandler
init|=
name|document
operator|.
name|getSecurityHandler
argument_list|()
decl_stmt|;
if|if
condition|(
name|securityHandler
operator|!=
literal|null
condition|)
block|{
name|securityHandler
operator|.
name|prepareDocumentForEncryption
argument_list|(
name|document
argument_list|)
expr_stmt|;
name|willEncrypt
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|willEncrypt
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|COSDocument
name|cosDoc
init|=
name|document
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|COSDictionary
name|trailer
init|=
name|cosDoc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|COSArray
name|idArray
init|=
operator|(
name|COSArray
operator|)
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|idArray
operator|==
literal|null
operator|||
name|incrementalUpdate
condition|)
block|{
comment|//algorithm says to use time/path/size/values in doc to generate
comment|//the id.  We don't have path or size, so do the best we can
name|MessageDigest
name|md
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
decl_stmt|;
name|md
operator|.
name|update
argument_list|(
name|Long
operator|.
name|toString
argument_list|(
name|idTime
argument_list|)
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|COSDictionary
name|info
init|=
operator|(
name|COSDictionary
operator|)
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|COSBase
argument_list|>
name|values
init|=
name|info
operator|.
name|getValues
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|values
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|md
operator|.
name|update
argument_list|(
name|values
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|idArray
operator|=
operator|new
name|COSArray
argument_list|()
expr_stmt|;
name|COSString
name|id
init|=
operator|new
name|COSString
argument_list|(
name|md
operator|.
name|digest
argument_list|()
argument_list|)
decl_stmt|;
name|idArray
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|idArray
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ID
argument_list|,
name|idArray
argument_list|)
expr_stmt|;
block|}
name|cosDoc
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

