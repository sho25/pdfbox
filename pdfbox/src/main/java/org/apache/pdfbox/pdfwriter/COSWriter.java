begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfwriter
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|SequenceInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DecimalFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DecimalFormatSymbols
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObjectKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSUpdateInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|ICOSVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccessRead
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
operator|.
name|PDFXRefStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
operator|.
name|SecurityHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|fdf
operator|.
name|FDFDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|digitalsignature
operator|.
name|COSFilterInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|digitalsignature
operator|.
name|SignatureInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|Hex
import|;
end_import

begin_comment
comment|/**  * This class acts on a in-memory representation of a PDF document.  *  * @author Michael Traut  * @author Ben Litchfield  */
end_comment

begin_class
specifier|public
class|class
name|COSWriter
implements|implements
name|ICOSVisitor
implements|,
name|Closeable
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|COSWriter
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The dictionary open token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|DICT_OPEN
init|=
literal|"<<"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The dictionary close token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|DICT_CLOSE
init|=
literal|">>"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * space character.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|SPACE
init|=
block|{
literal|' '
block|}
decl_stmt|;
comment|/**      * The start to a PDF comment.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|COMMENT
init|=
block|{
literal|'%'
block|}
decl_stmt|;
comment|/**      * The output version of the PDF.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|VERSION
init|=
literal|"PDF-1.4"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * Garbage bytes used to create the PDF header.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|GARBAGE
init|=
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
literal|0xf6
block|,
operator|(
name|byte
operator|)
literal|0xe4
block|,
operator|(
name|byte
operator|)
literal|0xfc
block|,
operator|(
name|byte
operator|)
literal|0xdf
block|}
decl_stmt|;
comment|/**      * The EOF constant.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|EOF
init|=
literal|"%%EOF"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|// pdf tokens
comment|/**      * The reference token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|REFERENCE
init|=
literal|"R"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The XREF token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|XREF
init|=
literal|"xref"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The xref free token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|XREF_FREE
init|=
literal|"f"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The xref used token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|XREF_USED
init|=
literal|"n"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The trailer token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|TRAILER
init|=
literal|"trailer"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The start xref token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|STARTXREF
init|=
literal|"startxref"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The starting object token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|OBJ
init|=
literal|"obj"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The end object token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ENDOBJ
init|=
literal|"endobj"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The array open token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ARRAY_OPEN
init|=
literal|"["
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The array close token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ARRAY_CLOSE
init|=
literal|"]"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The open stream token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|STREAM
init|=
literal|"stream"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
comment|/**      * The close stream token.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ENDSTREAM
init|=
literal|"endstream"
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|US_ASCII
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|NumberFormat
name|formatXrefOffset
init|=
operator|new
name|DecimalFormat
argument_list|(
literal|"0000000000"
argument_list|,
name|DecimalFormatSymbols
operator|.
name|getInstance
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
argument_list|)
decl_stmt|;
comment|// the decimal format for the xref object generation number data
specifier|private
specifier|final
name|NumberFormat
name|formatXrefGeneration
init|=
operator|new
name|DecimalFormat
argument_list|(
literal|"00000"
argument_list|,
name|DecimalFormatSymbols
operator|.
name|getInstance
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
argument_list|)
decl_stmt|;
comment|// the stream where we create the pdf output
specifier|private
name|OutputStream
name|output
decl_stmt|;
comment|// the stream used to write standard cos data
specifier|private
name|COSStandardOutputStream
name|standardOutput
decl_stmt|;
comment|// the start position of the x ref section
specifier|private
name|long
name|startxref
init|=
literal|0
decl_stmt|;
comment|// the current object number
specifier|private
name|long
name|number
init|=
literal|0
decl_stmt|;
comment|// maps the object to the keys generated in the writer
comment|// these are used for indirect references in other objects
comment|//A hashtable is used on purpose over a hashmap
comment|//so that null entries will not get added.
specifier|private
specifier|final
name|Map
argument_list|<
name|COSBase
argument_list|,
name|COSObjectKey
argument_list|>
name|objectKeys
init|=
operator|new
name|Hashtable
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|COSBase
argument_list|>
name|keyObject
init|=
operator|new
name|Hashtable
argument_list|<>
argument_list|()
decl_stmt|;
comment|// the list of x ref entries to be made so far
specifier|private
specifier|final
name|List
argument_list|<
name|COSWriterXRefEntry
argument_list|>
name|xRefEntries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|COSBase
argument_list|>
name|objectsToWriteSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|//A list of objects to write.
specifier|private
specifier|final
name|Deque
argument_list|<
name|COSBase
argument_list|>
name|objectsToWrite
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|//a list of objects already written
specifier|private
specifier|final
name|Set
argument_list|<
name|COSBase
argument_list|>
name|writtenObjects
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|//An 'actual' is any COSBase that is not a COSObject.
comment|//need to keep a list of the actuals that are added
comment|//as well as the objects because there is a problem
comment|//when adding a COSObject and then later adding
comment|//the actual for that object, so we will track
comment|//actuals separately.
specifier|private
specifier|final
name|Set
argument_list|<
name|COSBase
argument_list|>
name|actualsAdded
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|COSObjectKey
name|currentObjectKey
init|=
literal|null
decl_stmt|;
specifier|private
name|PDDocument
name|pdDocument
init|=
literal|null
decl_stmt|;
specifier|private
name|FDFDocument
name|fdfDocument
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|willEncrypt
init|=
literal|false
decl_stmt|;
comment|// signing
specifier|private
name|boolean
name|incrementalUpdate
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|reachedSignature
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|signatureOffset
decl_stmt|,
name|signatureLength
decl_stmt|;
specifier|private
name|long
name|byteRangeOffset
decl_stmt|,
name|byteRangeLength
decl_stmt|;
specifier|private
name|RandomAccessRead
name|incrementalInput
decl_stmt|;
specifier|private
name|OutputStream
name|incrementalOutput
decl_stmt|;
specifier|private
name|SignatureInterface
name|signatureInterface
decl_stmt|;
specifier|private
name|byte
index|[]
name|incrementPart
decl_stmt|;
specifier|private
name|COSArray
name|byteRangeArray
decl_stmt|;
comment|/**      * COSWriter constructor comment.      *      * @param os The wrapped output stream.      */
specifier|public
name|COSWriter
parameter_list|(
name|OutputStream
name|os
parameter_list|)
block|{
name|setOutput
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|setStandardOutput
argument_list|(
operator|new
name|COSStandardOutputStream
argument_list|(
name|output
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * COSWriter constructor for incremental updates.       *      * @param outputStream output stream where the new PDF data will be written      * @param inputData random access read containing source PDF data      *       * @throws IOException if something went wrong      */
specifier|public
name|COSWriter
parameter_list|(
name|OutputStream
name|outputStream
parameter_list|,
name|RandomAccessRead
name|inputData
parameter_list|)
throws|throws
name|IOException
block|{
comment|// write to buffer instead of output
name|setOutput
argument_list|(
operator|new
name|ByteArrayOutputStream
argument_list|()
argument_list|)
expr_stmt|;
name|setStandardOutput
argument_list|(
operator|new
name|COSStandardOutputStream
argument_list|(
name|output
argument_list|,
name|inputData
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|incrementalInput
operator|=
name|inputData
expr_stmt|;
name|incrementalOutput
operator|=
name|outputStream
expr_stmt|;
name|incrementalUpdate
operator|=
literal|true
expr_stmt|;
block|}
specifier|private
name|void
name|prepareIncrement
parameter_list|(
name|PDDocument
name|doc
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|COSDocument
name|cosDoc
init|=
name|doc
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|COSObjectKey
argument_list|,
name|Long
argument_list|>
name|xrefTable
init|=
name|cosDoc
operator|.
name|getXrefTable
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|COSObjectKey
argument_list|>
name|keySet
init|=
name|xrefTable
operator|.
name|keySet
argument_list|()
decl_stmt|;
name|long
name|highestNumber
init|=
literal|0
decl_stmt|;
for|for
control|(
name|COSObjectKey
name|cosObjectKey
range|:
name|keySet
control|)
block|{
name|COSBase
name|object
init|=
name|cosDoc
operator|.
name|getObjectFromPool
argument_list|(
name|cosObjectKey
argument_list|)
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|object
operator|!=
literal|null
operator|&&
name|cosObjectKey
operator|!=
literal|null
operator|&&
operator|!
operator|(
name|object
operator|instanceof
name|COSNumber
operator|)
condition|)
block|{
name|objectKeys
operator|.
name|put
argument_list|(
name|object
argument_list|,
name|cosObjectKey
argument_list|)
expr_stmt|;
name|keyObject
operator|.
name|put
argument_list|(
name|cosObjectKey
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cosObjectKey
operator|!=
literal|null
condition|)
block|{
name|long
name|num
init|=
name|cosObjectKey
operator|.
name|getNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|>
name|highestNumber
condition|)
block|{
name|highestNumber
operator|=
name|num
expr_stmt|;
block|}
block|}
block|}
name|setNumber
argument_list|(
name|highestNumber
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * add an entry in the x ref table for later dump.      *      * @param entry The new entry to add.      */
specifier|protected
name|void
name|addXRefEntry
parameter_list|(
name|COSWriterXRefEntry
name|entry
parameter_list|)
block|{
name|getXRefEntries
argument_list|()
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will close the stream.      *      * @throws IOException If the underlying stream throws an exception.      */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|getStandardOutput
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getStandardOutput
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|getOutput
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getOutput
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|incrementalOutput
operator|!=
literal|null
condition|)
block|{
name|incrementalOutput
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This will get the current object number.      *      * @return The current object number.      */
specifier|protected
name|long
name|getNumber
parameter_list|()
block|{
return|return
name|number
return|;
block|}
comment|/**      * This will get all available object keys.      *      * @return A map of all object keys.      */
specifier|public
name|Map
argument_list|<
name|COSBase
argument_list|,
name|COSObjectKey
argument_list|>
name|getObjectKeys
parameter_list|()
block|{
return|return
name|objectKeys
return|;
block|}
comment|/**      * This will get the output stream.      *      * @return The output stream.      */
specifier|protected
name|java
operator|.
name|io
operator|.
name|OutputStream
name|getOutput
parameter_list|()
block|{
return|return
name|output
return|;
block|}
comment|/**      * This will get the standard output stream.      *      * @return The standard output stream.      */
specifier|protected
name|COSStandardOutputStream
name|getStandardOutput
parameter_list|()
block|{
return|return
name|standardOutput
return|;
block|}
comment|/**      * This will get the current start xref.      *      * @return The current start xref.      */
specifier|protected
name|long
name|getStartxref
parameter_list|()
block|{
return|return
name|startxref
return|;
block|}
comment|/**      * This will get the xref entries.      *      * @return All available xref entries.      */
specifier|protected
name|List
argument_list|<
name|COSWriterXRefEntry
argument_list|>
name|getXRefEntries
parameter_list|()
block|{
return|return
name|xRefEntries
return|;
block|}
comment|/**      * This will set the current object number.      *      * @param newNumber The new object number.      */
specifier|protected
name|void
name|setNumber
parameter_list|(
name|long
name|newNumber
parameter_list|)
block|{
name|number
operator|=
name|newNumber
expr_stmt|;
block|}
comment|/**      * This will set the output stream.      *      * @param newOutput The new output stream.      */
specifier|private
name|void
name|setOutput
parameter_list|(
name|OutputStream
name|newOutput
parameter_list|)
block|{
name|output
operator|=
name|newOutput
expr_stmt|;
block|}
comment|/**      * This will set the standard output stream.      *      * @param newStandardOutput The new standard output stream.      */
specifier|private
name|void
name|setStandardOutput
parameter_list|(
name|COSStandardOutputStream
name|newStandardOutput
parameter_list|)
block|{
name|standardOutput
operator|=
name|newStandardOutput
expr_stmt|;
block|}
comment|/**      * This will set the start xref.      *      * @param newStartxref The new start xref attribute.      */
specifier|protected
name|void
name|setStartxref
parameter_list|(
name|long
name|newStartxref
parameter_list|)
block|{
name|startxref
operator|=
name|newStartxref
expr_stmt|;
block|}
comment|/**      * This will write the body of the document.      *      * @param doc The document to write the body for.      *      * @throws IOException If there is an error writing the data.      */
specifier|protected
name|void
name|doWriteBody
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|COSDictionary
name|trailer
init|=
name|doc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|COSDictionary
name|root
init|=
operator|(
name|COSDictionary
operator|)
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ROOT
argument_list|)
decl_stmt|;
name|COSDictionary
name|info
init|=
operator|(
name|COSDictionary
operator|)
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|)
decl_stmt|;
name|COSDictionary
name|encrypt
init|=
operator|(
name|COSDictionary
operator|)
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
name|addObjectToWrite
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
name|addObjectToWrite
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|doWriteObjects
argument_list|()
expr_stmt|;
name|willEncrypt
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|encrypt
operator|!=
literal|null
condition|)
block|{
name|addObjectToWrite
argument_list|(
name|encrypt
argument_list|)
expr_stmt|;
block|}
name|doWriteObjects
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|doWriteObjects
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
name|objectsToWrite
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|COSBase
name|nextObject
init|=
name|objectsToWrite
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
name|objectsToWriteSet
operator|.
name|remove
argument_list|(
name|nextObject
argument_list|)
expr_stmt|;
name|doWriteObject
argument_list|(
name|nextObject
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addObjectToWrite
parameter_list|(
name|COSBase
name|object
parameter_list|)
block|{
name|COSBase
name|actual
init|=
name|object
decl_stmt|;
if|if
condition|(
name|actual
operator|instanceof
name|COSObject
condition|)
block|{
name|actual
operator|=
operator|(
operator|(
name|COSObject
operator|)
name|actual
operator|)
operator|.
name|getObject
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|writtenObjects
operator|.
name|contains
argument_list|(
name|object
argument_list|)
operator|&&
operator|!
name|objectsToWriteSet
operator|.
name|contains
argument_list|(
name|object
argument_list|)
operator|&&
operator|!
name|actualsAdded
operator|.
name|contains
argument_list|(
name|actual
argument_list|)
condition|)
block|{
name|COSBase
name|cosBase
init|=
literal|null
decl_stmt|;
name|COSObjectKey
name|cosObjectKey
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|actual
operator|!=
literal|null
condition|)
block|{
name|cosObjectKey
operator|=
name|objectKeys
operator|.
name|get
argument_list|(
name|actual
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cosObjectKey
operator|!=
literal|null
condition|)
block|{
name|cosBase
operator|=
name|keyObject
operator|.
name|get
argument_list|(
name|cosObjectKey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|actual
operator|!=
literal|null
operator|&&
name|objectKeys
operator|.
name|containsKey
argument_list|(
name|actual
argument_list|)
operator|&&
name|object
operator|instanceof
name|COSUpdateInfo
operator|&&
operator|!
operator|(
operator|(
name|COSUpdateInfo
operator|)
name|object
operator|)
operator|.
name|isNeedToBeUpdated
argument_list|()
operator|&&
name|cosBase
operator|instanceof
name|COSUpdateInfo
operator|&&
operator|!
operator|(
operator|(
name|COSUpdateInfo
operator|)
name|cosBase
operator|)
operator|.
name|isNeedToBeUpdated
argument_list|()
condition|)
block|{
return|return;
block|}
name|objectsToWrite
operator|.
name|add
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|objectsToWriteSet
operator|.
name|add
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|!=
literal|null
condition|)
block|{
name|actualsAdded
operator|.
name|add
argument_list|(
name|actual
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This will write a COS object.      *      * @param obj The object to write.      *      * @throws IOException if the output cannot be written      */
specifier|public
name|void
name|doWriteObject
parameter_list|(
name|COSBase
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|writtenObjects
operator|.
name|add
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|// find the physical reference
name|currentObjectKey
operator|=
name|getObjectKey
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|// add a x ref entry
name|addXRefEntry
argument_list|(
operator|new
name|COSWriterXRefEntry
argument_list|(
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
argument_list|,
name|obj
argument_list|,
name|currentObjectKey
argument_list|)
argument_list|)
expr_stmt|;
comment|// write the object
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|currentObjectKey
operator|.
name|getNumber
argument_list|()
argument_list|)
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|currentObjectKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|OBJ
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|obj
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|ENDOBJ
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
block|}
comment|/**      * This will write the header to the PDF document.      *      * @param doc The document to get the data from.      *      * @throws IOException If there is an error writing to the stream.      */
specifier|protected
name|void
name|doWriteHeader
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|headerString
decl_stmt|;
if|if
condition|(
name|fdfDocument
operator|!=
literal|null
condition|)
block|{
name|headerString
operator|=
literal|"%FDF-"
operator|+
name|Float
operator|.
name|toString
argument_list|(
name|fdfDocument
operator|.
name|getDocument
argument_list|()
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|headerString
operator|=
literal|"%PDF-"
operator|+
name|Float
operator|.
name|toString
argument_list|(
name|pdDocument
operator|.
name|getDocument
argument_list|()
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|headerString
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|COMMENT
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|GARBAGE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
block|}
comment|/**      * This will write the trailer to the PDF document.      *      * @param doc The document to create the trailer for.      *      * @throws IOException If there is an IOError while writing the document.      */
specifier|protected
name|void
name|doWriteTrailer
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|TRAILER
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|COSDictionary
name|trailer
init|=
name|doc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
comment|//sort xref, needed only if object keys not regenerated
name|Collections
operator|.
name|sort
argument_list|(
name|getXRefEntries
argument_list|()
argument_list|)
expr_stmt|;
name|COSWriterXRefEntry
name|lastEntry
init|=
name|getXRefEntries
argument_list|()
operator|.
name|get
argument_list|(
name|getXRefEntries
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|SIZE
argument_list|,
name|lastEntry
operator|.
name|getKey
argument_list|()
operator|.
name|getNumber
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// Only need to stay, if an incremental update will be performed
if|if
condition|(
operator|!
name|incrementalUpdate
condition|)
block|{
name|trailer
operator|.
name|removeItem
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doc
operator|.
name|isXRefStream
argument_list|()
condition|)
block|{
name|trailer
operator|.
name|removeItem
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|)
expr_stmt|;
block|}
comment|// Remove a checksum if present
name|trailer
operator|.
name|removeItem
argument_list|(
name|COSName
operator|.
name|DOC_CHECKSUM
argument_list|)
expr_stmt|;
name|trailer
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|doWriteXRefInc
parameter_list|(
name|COSDocument
name|doc
parameter_list|,
name|long
name|hybridPrev
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|doc
operator|.
name|isXRefStream
argument_list|()
operator|||
name|hybridPrev
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// the file uses XrefStreams, so we need to update
comment|// it with an xref stream. We create a new one and fill it
comment|// with data available here
comment|// create a new XRefStrema object
name|PDFXRefStream
name|pdfxRefStream
init|=
operator|new
name|PDFXRefStream
argument_list|(
name|doc
argument_list|)
decl_stmt|;
comment|// add all entries from the incremental update.
name|List
argument_list|<
name|COSWriterXRefEntry
argument_list|>
name|xRefEntries2
init|=
name|getXRefEntries
argument_list|()
decl_stmt|;
for|for
control|(
name|COSWriterXRefEntry
name|cosWriterXRefEntry
range|:
name|xRefEntries2
control|)
block|{
name|pdfxRefStream
operator|.
name|addEntry
argument_list|(
name|cosWriterXRefEntry
argument_list|)
expr_stmt|;
block|}
name|COSDictionary
name|trailer
init|=
name|doc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
if|if
condition|(
name|incrementalUpdate
condition|)
block|{
comment|// use previous startXref value as new PREV value
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|doc
operator|.
name|getStartXref
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trailer
operator|.
name|removeItem
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|)
expr_stmt|;
block|}
name|pdfxRefStream
operator|.
name|addTrailerInfo
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
comment|// the size is the highest object number+1. we add one more
comment|// for the xref stream object we are going to write
name|pdfxRefStream
operator|.
name|setSize
argument_list|(
name|getNumber
argument_list|()
operator|+
literal|2
argument_list|)
expr_stmt|;
name|setStartxref
argument_list|(
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|COSStream
name|stream2
init|=
name|pdfxRefStream
operator|.
name|getStream
argument_list|()
decl_stmt|;
name|doWriteObject
argument_list|(
name|stream2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doc
operator|.
name|isXRefStream
argument_list|()
operator|||
name|hybridPrev
operator|!=
operator|-
literal|1
condition|)
block|{
name|COSDictionary
name|trailer
init|=
name|doc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|COSName
operator|.
name|PREV
argument_list|,
name|doc
operator|.
name|getStartXref
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|hybridPrev
operator|!=
operator|-
literal|1
condition|)
block|{
name|COSName
name|xrefStm
init|=
name|COSName
operator|.
name|XREF_STM
decl_stmt|;
name|trailer
operator|.
name|removeItem
argument_list|(
name|xrefStm
argument_list|)
expr_stmt|;
name|trailer
operator|.
name|setLong
argument_list|(
name|xrefStm
argument_list|,
name|getStartxref
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|doWriteXRefTable
argument_list|()
expr_stmt|;
name|doWriteTrailer
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
comment|// writes the "xref" table
specifier|private
name|void
name|doWriteXRefTable
parameter_list|()
throws|throws
name|IOException
block|{
name|addXRefEntry
argument_list|(
name|COSWriterXRefEntry
operator|.
name|getNullEntry
argument_list|()
argument_list|)
expr_stmt|;
comment|// sort xref, needed only if object keys not regenerated
name|Collections
operator|.
name|sort
argument_list|(
name|getXRefEntries
argument_list|()
argument_list|)
expr_stmt|;
comment|// remember the position where x ref was written
name|setStartxref
argument_list|(
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|XREF
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
comment|// write start object number and object count for this x ref section
comment|// we assume starting from scratch
name|Long
index|[]
name|xRefRanges
init|=
name|getXRefRanges
argument_list|(
name|getXRefEntries
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|xRefLength
init|=
name|xRefRanges
operator|.
name|length
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|<
name|xRefLength
operator|&&
operator|(
name|xRefLength
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|writeXrefRange
argument_list|(
name|xRefRanges
index|[
name|x
index|]
argument_list|,
name|xRefRanges
index|[
name|x
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|xRefRanges
index|[
name|x
operator|+
literal|1
index|]
condition|;
operator|++
name|i
control|)
block|{
name|writeXrefEntry
argument_list|(
name|xRefEntries
operator|.
name|get
argument_list|(
name|j
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|x
operator|+=
literal|2
expr_stmt|;
block|}
block|}
comment|/**      * Write an incremental update for a non signature case. This can be used for e.g. augmenting signatures.      *       * @throws IOException      */
specifier|private
name|void
name|doWriteIncrement
parameter_list|()
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|byteOut
init|=
operator|(
name|ByteArrayOutputStream
operator|)
name|output
decl_stmt|;
name|byteOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|byte
index|[]
name|buffer
init|=
name|byteOut
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|SequenceInputStream
name|signStream
init|=
operator|new
name|SequenceInputStream
argument_list|(
operator|new
name|RandomAccessInputStream
argument_list|(
name|incrementalInput
argument_list|)
argument_list|,
operator|new
name|ByteArrayInputStream
argument_list|(
name|buffer
argument_list|)
argument_list|)
decl_stmt|;
comment|// write the data to the incremental output stream
name|IOUtils
operator|.
name|copy
argument_list|(
name|signStream
argument_list|,
name|incrementalOutput
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|doWriteSignature
parameter_list|()
throws|throws
name|IOException
block|{
comment|// calculate the ByteRange values
name|long
name|inLength
init|=
name|incrementalInput
operator|.
name|length
argument_list|()
decl_stmt|;
name|long
name|beforeLength
init|=
name|signatureOffset
decl_stmt|;
name|long
name|afterOffset
init|=
name|signatureOffset
operator|+
name|signatureLength
decl_stmt|;
name|long
name|afterLength
init|=
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
operator|-
operator|(
name|inLength
operator|+
name|signatureLength
operator|)
operator|-
operator|(
name|signatureOffset
operator|-
name|inLength
operator|)
decl_stmt|;
name|String
name|byteRange
init|=
literal|"0 "
operator|+
name|beforeLength
operator|+
literal|" "
operator|+
name|afterOffset
operator|+
literal|" "
operator|+
name|afterLength
operator|+
literal|"]"
decl_stmt|;
comment|// Assign the values to the actual COSArray, so that the user can access it before closing
name|byteRangeArray
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|COSInteger
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|byteRangeArray
operator|.
name|set
argument_list|(
literal|1
argument_list|,
name|COSInteger
operator|.
name|get
argument_list|(
name|beforeLength
argument_list|)
argument_list|)
expr_stmt|;
name|byteRangeArray
operator|.
name|set
argument_list|(
literal|2
argument_list|,
name|COSInteger
operator|.
name|get
argument_list|(
name|afterOffset
argument_list|)
argument_list|)
expr_stmt|;
name|byteRangeArray
operator|.
name|set
argument_list|(
literal|3
argument_list|,
name|COSInteger
operator|.
name|get
argument_list|(
name|afterLength
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|byteRange
operator|.
name|length
argument_list|()
operator|>
name|byteRangeLength
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't write new byteRange '"
operator|+
name|byteRange
operator|+
literal|"' not enough space: byteRange.length(): "
operator|+
name|byteRange
operator|.
name|length
argument_list|()
operator|+
literal|", byteRangeLength: "
operator|+
name|byteRangeLength
argument_list|)
throw|;
block|}
comment|// copy the new incremental data into a buffer (e.g. signature dict, trailer)
name|ByteArrayOutputStream
name|byteOut
init|=
operator|(
name|ByteArrayOutputStream
operator|)
name|output
decl_stmt|;
name|byteOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|incrementPart
operator|=
name|byteOut
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
comment|// overwrite the ByteRange in the buffer
name|byte
index|[]
name|byteRangeBytes
init|=
name|byteRange
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|byteRangeLength
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|byteRangeBytes
operator|.
name|length
condition|)
block|{
name|incrementPart
index|[
call|(
name|int
call|)
argument_list|(
name|byteRangeOffset
operator|+
name|i
operator|-
name|inLength
argument_list|)
index|]
operator|=
literal|0x20
expr_stmt|;
comment|// SPACE
block|}
else|else
block|{
name|incrementPart
index|[
call|(
name|int
call|)
argument_list|(
name|byteRangeOffset
operator|+
name|i
operator|-
name|inLength
argument_list|)
index|]
operator|=
name|byteRangeBytes
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|signatureInterface
operator|!=
literal|null
condition|)
block|{
comment|// data to be signed
specifier|final
name|InputStream
name|dataToSign
init|=
name|getDataToSign
argument_list|()
decl_stmt|;
comment|// sign the bytes
name|byte
index|[]
name|signatureBytes
init|=
name|signatureInterface
operator|.
name|sign
argument_list|(
name|dataToSign
argument_list|)
decl_stmt|;
name|writeExternalSignature
argument_list|(
name|signatureBytes
argument_list|)
expr_stmt|;
block|}
comment|// else signature should created externally and set via writeSignature()
block|}
comment|/**      * Return the stream of PDF data to be signed. Clients should use this method only to create      * signatures externally. {@link #write(PDDocument)} method should have been called prior. The      * created signature should be set using {@link #writeExternalSignature(byte[])}.      *<p>      * When {@link SignatureInterface} instance is used, COSWriter obtains and writes the signature      * itself.      *</p>      *      * @return data stream to be signed      * @throws IllegalStateException if PDF is not prepared for external signing      * @throws IOException if input data is closed      */
specifier|public
name|InputStream
name|getDataToSign
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|incrementPart
operator|==
literal|null
operator|||
name|incrementalInput
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"PDF not prepared for signing"
argument_list|)
throw|;
block|}
comment|// range of incremental bytes to be signed (includes /ByteRange but not /Contents)
name|int
name|incPartSigOffset
init|=
call|(
name|int
call|)
argument_list|(
name|signatureOffset
operator|-
name|incrementalInput
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|afterSigOffset
init|=
name|incPartSigOffset
operator|+
operator|(
name|int
operator|)
name|signatureLength
decl_stmt|;
name|int
index|[]
name|range
init|=
block|{
literal|0
block|,
name|incPartSigOffset
block|,
name|afterSigOffset
block|,
name|incrementPart
operator|.
name|length
operator|-
name|afterSigOffset
block|}
decl_stmt|;
return|return
operator|new
name|SequenceInputStream
argument_list|(
operator|new
name|RandomAccessInputStream
argument_list|(
name|incrementalInput
argument_list|)
argument_list|,
operator|new
name|COSFilterInputStream
argument_list|(
name|incrementPart
argument_list|,
name|range
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Write externally created signature of PDF data obtained via {@link #getDataToSign()} method.      *      * @param cmsSignature CMS signature byte array      * @throws IllegalStateException if PDF is not prepared for external signing      * @throws IOException if source data stream is closed      */
specifier|public
name|void
name|writeExternalSignature
parameter_list|(
name|byte
index|[]
name|cmsSignature
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|incrementPart
operator|==
literal|null
operator|||
name|incrementalInput
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"PDF not prepared for setting signature"
argument_list|)
throw|;
block|}
name|byte
index|[]
name|signatureBytes
init|=
name|Hex
operator|.
name|getBytes
argument_list|(
name|cmsSignature
argument_list|)
decl_stmt|;
comment|// substract 2 bytes because of the enclosing "<>"
if|if
condition|(
name|signatureBytes
operator|.
name|length
operator|>
name|signatureLength
operator|-
literal|2
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't write signature, not enough space"
argument_list|)
throw|;
block|}
comment|// overwrite the signature Contents in the buffer
name|int
name|incPartSigOffset
init|=
call|(
name|int
call|)
argument_list|(
name|signatureOffset
operator|-
name|incrementalInput
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|signatureBytes
argument_list|,
literal|0
argument_list|,
name|incrementPart
argument_list|,
name|incPartSigOffset
operator|+
literal|1
argument_list|,
name|signatureBytes
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// write the data to the incremental output stream
name|IOUtils
operator|.
name|copy
argument_list|(
operator|new
name|RandomAccessInputStream
argument_list|(
name|incrementalInput
argument_list|)
argument_list|,
name|incrementalOutput
argument_list|)
expr_stmt|;
name|incrementalOutput
operator|.
name|write
argument_list|(
name|incrementPart
argument_list|)
expr_stmt|;
comment|// prevent further use
name|incrementPart
operator|=
literal|null
expr_stmt|;
block|}
specifier|private
name|void
name|writeXrefRange
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|y
parameter_list|)
throws|throws
name|IOException
block|{
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|x
argument_list|)
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|y
argument_list|)
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|writeXrefEntry
parameter_list|(
name|COSWriterXRefEntry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|offset
init|=
name|formatXrefOffset
operator|.
name|format
argument_list|(
name|entry
operator|.
name|getOffset
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|generation
init|=
name|formatXrefGeneration
operator|.
name|format
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getGeneration
argument_list|()
argument_list|)
decl_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|offset
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|generation
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|entry
operator|.
name|isFree
argument_list|()
condition|?
name|XREF_FREE
else|:
name|XREF_USED
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeCRLF
argument_list|()
expr_stmt|;
block|}
comment|/**      * check the xref entries and write out the ranges.  The format of the      * returned array is exactly the same as the pdf specification.  See section      * 7.5.4 of ISO32000-1:2008, example 1 (page 40) for reference.      *<p>      * example: 0 1 2 5 6 7 8 10      *<p>      * will create a array with follow ranges      *<p>      * 0 3 5 4 10 1      *<p>      * this mean that the element 0 is followed by two other related numbers       * that represent a cluster of the size 3. 5 is follow by three other      * related numbers and create a cluster of size 4. etc.      *       * @param xRefEntriesList list with the xRef entries that was written      * @return a integer array with the ranges      */
specifier|protected
name|Long
index|[]
name|getXRefRanges
parameter_list|(
name|List
argument_list|<
name|COSWriterXRefEntry
argument_list|>
name|xRefEntriesList
parameter_list|)
block|{
name|long
name|last
init|=
operator|-
literal|2
decl_stmt|;
name|long
name|count
init|=
literal|1
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|object
range|:
name|xRefEntriesList
control|)
block|{
name|long
name|nr
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|COSWriterXRefEntry
operator|)
name|object
argument_list|)
operator|.
name|getKey
argument_list|()
operator|.
name|getNumber
argument_list|()
decl_stmt|;
if|if
condition|(
name|nr
operator|==
name|last
operator|+
literal|1
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|last
operator|=
name|nr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last
operator|==
operator|-
literal|2
condition|)
block|{
name|last
operator|=
name|nr
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|last
operator|-
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|last
operator|=
name|nr
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|// If no new entry is found, we need to write out the last result
if|if
condition|(
name|xRefEntriesList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|last
operator|-
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|Long
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * This will get the object key for the object.      *      * @param obj The object to get the key for.      *      * @return The object key for the object.      */
specifier|private
name|COSObjectKey
name|getObjectKey
parameter_list|(
name|COSBase
name|obj
parameter_list|)
block|{
name|COSBase
name|actual
init|=
name|obj
decl_stmt|;
if|if
condition|(
name|actual
operator|instanceof
name|COSObject
condition|)
block|{
name|actual
operator|=
operator|(
operator|(
name|COSObject
operator|)
name|obj
operator|)
operator|.
name|getObject
argument_list|()
expr_stmt|;
block|}
name|COSObjectKey
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|actual
operator|!=
literal|null
condition|)
block|{
name|key
operator|=
name|objectKeys
operator|.
name|get
argument_list|(
name|actual
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|key
operator|=
name|objectKeys
operator|.
name|get
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|setNumber
argument_list|(
name|getNumber
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|key
operator|=
operator|new
name|COSObjectKey
argument_list|(
name|getNumber
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|objectKeys
operator|.
name|put
argument_list|(
name|obj
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|!=
literal|null
condition|)
block|{
name|objectKeys
operator|.
name|put
argument_list|(
name|actual
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|key
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromArray
parameter_list|(
name|COSArray
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|ARRAY_OPEN
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|COSBase
argument_list|>
name|i
init|=
name|obj
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|COSBase
name|current
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|instanceof
name|COSDictionary
condition|)
block|{
if|if
condition|(
name|current
operator|.
name|isDirect
argument_list|()
condition|)
block|{
name|visitFromDictionary
argument_list|(
operator|(
name|COSDictionary
operator|)
name|current
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addObjectToWrite
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|writeReference
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|current
operator|instanceof
name|COSObject
condition|)
block|{
name|COSBase
name|subValue
init|=
operator|(
operator|(
name|COSObject
operator|)
name|current
operator|)
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|incrementalUpdate
operator|||
name|subValue
operator|instanceof
name|COSDictionary
operator|||
name|subValue
operator|==
literal|null
condition|)
block|{
name|addObjectToWrite
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|writeReference
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subValue
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|COSNull
operator|.
name|NULL
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|count
operator|%
literal|10
operator|==
literal|0
condition|)
block|{
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|ARRAY_CLOSE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromBoolean
parameter_list|(
name|COSBoolean
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|obj
operator|.
name|writePDF
argument_list|(
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromDictionary
parameter_list|(
name|COSDictionary
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|reachedSignature
condition|)
block|{
name|COSBase
name|itemType
init|=
name|obj
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|COSName
operator|.
name|SIG
operator|.
name|equals
argument_list|(
name|itemType
argument_list|)
operator|||
name|COSName
operator|.
name|DOC_TIME_STAMP
operator|.
name|equals
argument_list|(
name|itemType
argument_list|)
condition|)
block|{
name|reachedSignature
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|DICT_OPEN
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|COSName
argument_list|,
name|COSBase
argument_list|>
name|entry
range|:
name|obj
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|COSBase
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSDictionary
name|dict
init|=
operator|(
name|COSDictionary
operator|)
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|incrementalUpdate
condition|)
block|{
comment|// write all XObjects as direct objects, this will save some size
comment|// PDFBOX-3684: but avoid dictionary that references itself
name|COSBase
name|item
init|=
name|dict
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|XOBJECT
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
operator|!
name|COSName
operator|.
name|XOBJECT
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|item
operator|.
name|setDirect
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|item
operator|=
name|dict
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|RESOURCES
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
operator|!
name|COSName
operator|.
name|RESOURCES
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|item
operator|.
name|setDirect
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dict
operator|.
name|isDirect
argument_list|()
condition|)
block|{
comment|// If the object should be written direct, we need
comment|// to pass the dictionary to the visitor again.
name|visitFromDictionary
argument_list|(
name|dict
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addObjectToWrite
argument_list|(
name|dict
argument_list|)
expr_stmt|;
name|writeReference
argument_list|(
name|dict
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|COSObject
condition|)
block|{
name|COSBase
name|subValue
init|=
operator|(
operator|(
name|COSObject
operator|)
name|value
operator|)
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|incrementalUpdate
operator|||
name|subValue
operator|instanceof
name|COSDictionary
operator|||
name|subValue
operator|==
literal|null
condition|)
block|{
name|addObjectToWrite
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|writeReference
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subValue
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If we reach the pdf signature, we need to determinate the position of the
comment|// content and byterange
if|if
condition|(
name|reachedSignature
operator|&&
name|COSName
operator|.
name|CONTENTS
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|signatureOffset
operator|=
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
expr_stmt|;
name|value
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|signatureLength
operator|=
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
operator|-
name|signatureOffset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reachedSignature
operator|&&
name|COSName
operator|.
name|BYTERANGE
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|byteRangeArray
operator|=
operator|(
name|COSArray
operator|)
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|byteRangeOffset
operator|=
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
operator|+
literal|1
expr_stmt|;
name|value
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|byteRangeLength
operator|=
name|getStandardOutput
argument_list|()
operator|.
name|getPos
argument_list|()
operator|-
literal|1
operator|-
name|byteRangeOffset
expr_stmt|;
name|reachedSignature
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|value
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//then we won't write anything, there are a couple cases
comment|//were the value of an entry in the COSDictionary will
comment|//be a dangling reference that points to nothing
comment|//so we will just not write out the entry if that is the case
block|}
block|}
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|DICT_CLOSE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromDocument
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|incrementalUpdate
condition|)
block|{
name|doWriteHeader
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Sometimes the original file will be missing a newline at the end
comment|// In order to avoid having %%EOF the first object on the same line
comment|// as the %%EOF, we put a newline here. If there's already one at
comment|// the end of the file, an extra one won't hurt. PDFBOX-1051
name|getStandardOutput
argument_list|()
operator|.
name|writeCRLF
argument_list|()
expr_stmt|;
block|}
name|doWriteBody
argument_list|(
name|doc
argument_list|)
expr_stmt|;
comment|// get the previous trailer
name|COSDictionary
name|trailer
init|=
name|doc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|long
name|hybridPrev
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|trailer
operator|!=
literal|null
condition|)
block|{
name|hybridPrev
operator|=
name|trailer
operator|.
name|getLong
argument_list|(
name|COSName
operator|.
name|XREF_STM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|incrementalUpdate
operator|||
name|doc
operator|.
name|isXRefStream
argument_list|()
condition|)
block|{
name|doWriteXRefInc
argument_list|(
name|doc
argument_list|,
name|hybridPrev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doWriteXRefTable
argument_list|()
expr_stmt|;
name|doWriteTrailer
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// write endof
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|STARTXREF
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|getStartxref
argument_list|()
argument_list|)
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
if|if
condition|(
name|incrementalUpdate
condition|)
block|{
if|if
condition|(
name|signatureOffset
operator|==
literal|0
operator|||
name|byteRangeOffset
operator|==
literal|0
condition|)
block|{
name|doWriteIncrement
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|doWriteSignature
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromFloat
parameter_list|(
name|COSFloat
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|obj
operator|.
name|writePDF
argument_list|(
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromInt
parameter_list|(
name|COSInteger
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|obj
operator|.
name|writePDF
argument_list|(
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromName
parameter_list|(
name|COSName
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|obj
operator|.
name|writePDF
argument_list|(
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromNull
parameter_list|(
name|COSNull
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|obj
operator|.
name|writePDF
argument_list|(
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**      * visitFromObjRef method comment.      *      * @param obj The object that is being visited.      *      * @throws IOException If there is an exception while visiting this object.      */
specifier|public
name|void
name|writeReference
parameter_list|(
name|COSBase
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
name|COSObjectKey
name|key
init|=
name|getObjectKey
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|key
operator|.
name|getNumber
argument_list|()
argument_list|)
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|key
operator|.
name|getGeneration
argument_list|()
argument_list|)
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|REFERENCE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromStream
parameter_list|(
name|COSStream
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|willEncrypt
condition|)
block|{
name|pdDocument
operator|.
name|getEncryption
argument_list|()
operator|.
name|getSecurityHandler
argument_list|()
operator|.
name|encryptStream
argument_list|(
name|obj
argument_list|,
name|currentObjectKey
operator|.
name|getNumber
argument_list|()
argument_list|,
name|currentObjectKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|InputStream
name|input
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// write the stream content
name|visitFromDictionary
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|STREAM
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeCRLF
argument_list|()
expr_stmt|;
name|input
operator|=
name|obj
operator|.
name|createRawInputStream
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|input
argument_list|,
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeCRLF
argument_list|()
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|write
argument_list|(
name|ENDSTREAM
argument_list|)
expr_stmt|;
name|getStandardOutput
argument_list|()
operator|.
name|writeEOL
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|input
operator|!=
literal|null
condition|)
block|{
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|Object
name|visitFromString
parameter_list|(
name|COSString
name|obj
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|willEncrypt
condition|)
block|{
name|pdDocument
operator|.
name|getEncryption
argument_list|()
operator|.
name|getSecurityHandler
argument_list|()
operator|.
name|encryptString
argument_list|(
name|obj
argument_list|,
name|currentObjectKey
operator|.
name|getNumber
argument_list|()
argument_list|,
name|currentObjectKey
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|COSWriter
operator|.
name|writeString
argument_list|(
name|obj
argument_list|,
name|getStandardOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**      * This will write the pdf document.      *      * @throws IOException If an error occurs while generating the data.      * @param doc The document to write.      */
specifier|public
name|void
name|write
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|PDDocument
name|pdDoc
init|=
operator|new
name|PDDocument
argument_list|(
name|doc
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|pdDoc
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will write the pdf document. If signature should be created externally,      * {@link #writeExternalSignature(byte[])} should be invoked to set signature after calling this method.      *      * @param doc The document to write.      *      * @throws IOException If an error occurs while generating the data.      */
specifier|public
name|void
name|write
parameter_list|(
name|PDDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|doc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will write the pdf document. If signature should be created externally,      * {@link #writeExternalSignature(byte[])} should be invoked to set signature after calling this method.      *      * @param doc The document to write.      * @param signInterface class to be used for signing; {@code null} if external signing would be performed      *                      or there will be no signing at all      *      * @throws IOException If an error occurs while generating the data.      * @throws IllegalStateException If the document has an encryption dictionary but no protection      * policy.      */
specifier|public
name|void
name|write
parameter_list|(
name|PDDocument
name|doc
parameter_list|,
name|SignatureInterface
name|signInterface
parameter_list|)
throws|throws
name|IOException
block|{
name|Long
name|idTime
init|=
name|doc
operator|.
name|getDocumentId
argument_list|()
operator|==
literal|null
condition|?
name|System
operator|.
name|currentTimeMillis
argument_list|()
else|:
name|doc
operator|.
name|getDocumentId
argument_list|()
decl_stmt|;
name|pdDocument
operator|=
name|doc
expr_stmt|;
name|signatureInterface
operator|=
name|signInterface
expr_stmt|;
if|if
condition|(
name|incrementalUpdate
condition|)
block|{
name|prepareIncrement
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
comment|// if the document says we should remove encryption, then we shouldn't encrypt
if|if
condition|(
name|doc
operator|.
name|isAllSecurityToBeRemoved
argument_list|()
condition|)
block|{
name|willEncrypt
operator|=
literal|false
expr_stmt|;
comment|// also need to get rid of the "Encrypt" in the trailer so readers
comment|// don't try to decrypt a document which is not encrypted
name|COSDocument
name|cosDoc
init|=
name|doc
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|COSDictionary
name|trailer
init|=
name|cosDoc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|trailer
operator|.
name|removeItem
argument_list|(
name|COSName
operator|.
name|ENCRYPT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pdDocument
operator|.
name|getEncryption
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|incrementalUpdate
condition|)
block|{
name|SecurityHandler
name|securityHandler
init|=
name|pdDocument
operator|.
name|getEncryption
argument_list|()
operator|.
name|getSecurityHandler
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|securityHandler
operator|.
name|hasProtectionPolicy
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"PDF contains an encryption dictionary, please remove it with "
operator|+
literal|"setAllSecurityToBeRemoved() or set a protection policy with protect()"
argument_list|)
throw|;
block|}
name|securityHandler
operator|.
name|prepareDocumentForEncryption
argument_list|(
name|pdDocument
argument_list|)
expr_stmt|;
block|}
name|willEncrypt
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|willEncrypt
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|COSDocument
name|cosDoc
init|=
name|pdDocument
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|COSDictionary
name|trailer
init|=
name|cosDoc
operator|.
name|getTrailer
argument_list|()
decl_stmt|;
name|COSArray
name|idArray
init|=
literal|null
decl_stmt|;
name|boolean
name|missingID
init|=
literal|true
decl_stmt|;
name|COSBase
name|base
init|=
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|instanceof
name|COSArray
condition|)
block|{
name|idArray
operator|=
operator|(
name|COSArray
operator|)
name|base
expr_stmt|;
if|if
condition|(
name|idArray
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|missingID
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// check for an existing documentID
if|if
condition|(
name|idArray
operator|!=
literal|null
operator|&&
name|idArray
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|missingID
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|missingID
operator|||
name|incrementalUpdate
condition|)
block|{
name|MessageDigest
name|md5
decl_stmt|;
try|try
block|{
name|md5
operator|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
comment|// should never happen
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// algorithm says to use time/path/size/values in doc to generate the id.
comment|// we don't have path or size, so do the best we can
name|md5
operator|.
name|update
argument_list|(
name|Long
operator|.
name|toString
argument_list|(
name|idTime
argument_list|)
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
name|COSDictionary
name|info
init|=
operator|(
name|COSDictionary
operator|)
name|trailer
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|INFO
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|COSBase
name|cosBase
range|:
name|info
operator|.
name|getValues
argument_list|()
control|)
block|{
name|md5
operator|.
name|update
argument_list|(
name|cosBase
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|ISO_8859_1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// reuse origin documentID if available as first value
name|COSString
name|firstID
init|=
name|missingID
condition|?
operator|new
name|COSString
argument_list|(
name|md5
operator|.
name|digest
argument_list|()
argument_list|)
else|:
operator|(
name|COSString
operator|)
name|idArray
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// it's ok to use the same ID for the second part if the ID is created for the first time
name|COSString
name|secondID
init|=
name|missingID
condition|?
name|firstID
else|:
operator|new
name|COSString
argument_list|(
name|md5
operator|.
name|digest
argument_list|()
argument_list|)
decl_stmt|;
name|idArray
operator|=
operator|new
name|COSArray
argument_list|()
expr_stmt|;
name|idArray
operator|.
name|add
argument_list|(
name|firstID
argument_list|)
expr_stmt|;
name|idArray
operator|.
name|add
argument_list|(
name|secondID
argument_list|)
expr_stmt|;
name|trailer
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ID
argument_list|,
name|idArray
argument_list|)
expr_stmt|;
block|}
name|cosDoc
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will write the fdf document.      *      * @param doc The document to write.      *      * @throws IOException If an error occurs while generating the data.      */
specifier|public
name|void
name|write
parameter_list|(
name|FDFDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|fdfDocument
operator|=
name|doc
expr_stmt|;
name|willEncrypt
operator|=
literal|false
expr_stmt|;
name|COSDocument
name|cosDoc
init|=
name|fdfDocument
operator|.
name|getDocument
argument_list|()
decl_stmt|;
name|cosDoc
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will output the given byte getString as a PDF object.      *      * @param string COSString to be written      * @param output The stream to write to.      * @throws IOException If there is an error writing to the stream.      */
specifier|public
specifier|static
name|void
name|writeString
parameter_list|(
name|COSString
name|string
parameter_list|,
name|OutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|writeString
argument_list|(
name|string
operator|.
name|getBytes
argument_list|()
argument_list|,
name|string
operator|.
name|getForceHexForm
argument_list|()
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will output the given text/byte getString as a PDF object.      *      * @param bytes byte array representation of a string to be written      * @param output The stream to write to.      * @throws IOException If there is an error writing to the stream.      */
specifier|public
specifier|static
name|void
name|writeString
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|OutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|writeString
argument_list|(
name|bytes
argument_list|,
literal|false
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will output the given text/byte string as a PDF object.      *      * @param output The stream to write to.      * @throws IOException If there is an error writing to the stream.      */
specifier|private
specifier|static
name|void
name|writeString
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|boolean
name|forceHex
parameter_list|,
name|OutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
comment|// check for non-ASCII characters
name|boolean
name|isASCII
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|!
name|forceHex
condition|)
block|{
for|for
control|(
name|byte
name|b
range|:
name|bytes
control|)
block|{
comment|// if the byte is negative then it is an eight bit byte and is outside the ASCII range
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
name|isASCII
operator|=
literal|false
expr_stmt|;
break|break;
block|}
comment|// PDFBOX-3107 EOL markers within a string are troublesome
if|if
condition|(
name|b
operator|==
literal|0x0d
operator|||
name|b
operator|==
literal|0x0a
condition|)
block|{
name|isASCII
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|isASCII
operator|&&
operator|!
name|forceHex
condition|)
block|{
comment|// write ASCII string
name|output
operator|.
name|write
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|byte
name|b
range|:
name|bytes
control|)
block|{
switch|switch
condition|(
name|b
condition|)
block|{
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'\\'
case|:
name|output
operator|.
name|write
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|output
operator|.
name|write
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// write hex string
name|output
operator|.
name|write
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|Hex
operator|.
name|writeHexBytes
argument_list|(
name|bytes
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

