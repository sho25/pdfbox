begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*     Licensed to the Apache Software Foundation (ASF) under one or more    contributor license agreements.  See the NOTICE file distributed with    this work for additional information regarding copyright ownership.    The ASF licenses this file to You under the Apache License, Version 2.0    (the "License"); you may not use this file except in compliance with    the License.  You may obtain a copy of the License at         http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an "AS IS" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.   */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfviewer
operator|.
name|font
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|AffineTransform
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|GeneralPath
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|cmap
operator|.
name|CMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|CMAPEncodingEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|CMAPTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|GlyfDescript
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|GlyphData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|GlyphDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|HeaderTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|TrueTypeFont
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|Encoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|MacOSRomanEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDCIDFontType2Font
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDFont
import|;
end_import

begin_comment
comment|/**  * This class provides a glyph to GeneralPath conversion for true type fonts.  *   * This class is based on code from Apache Batik a subproject of Apache XMLGraphics. see  * http://xmlgraphics.apache.org/batik/ for further details.  *   */
end_comment

begin_class
specifier|public
class|class
name|TTFGlyph2D
implements|implements
name|Glyph2D
block|{
comment|/**      * Log instance.      */
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TTFGlyph2D
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Start of coderanges.      */
specifier|private
specifier|static
specifier|final
name|int
name|START_RANGE_F000
init|=
literal|0xF000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|START_RANGE_F100
init|=
literal|0xF100
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|START_RANGE_F200
init|=
literal|0xF200
decl_stmt|;
specifier|private
name|TrueTypeFont
name|font
decl_stmt|;
specifier|private
name|PDCIDFontType2Font
name|descendantFont
decl_stmt|;
specifier|private
name|String
name|name
decl_stmt|;
specifier|private
name|float
name|scale
init|=
literal|1.0f
decl_stmt|;
specifier|private
name|boolean
name|hasScaling
init|=
literal|false
decl_stmt|;
specifier|private
name|CMAPEncodingEntry
name|cmapWinUnicode
init|=
literal|null
decl_stmt|;
specifier|private
name|CMAPEncodingEntry
name|cmapWinSymbol
init|=
literal|null
decl_stmt|;
specifier|private
name|CMAPEncodingEntry
name|cmapMacintoshSymbol
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|isSymbol
init|=
literal|false
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|GeneralPath
argument_list|>
name|glyphs
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|GeneralPath
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Encoding
name|fontEncoding
init|=
literal|null
decl_stmt|;
specifier|private
name|CMap
name|fontCMap
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|isCIDFont
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|hasIdentityCIDMapping
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|hasCID2GIDMapping
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|hasTwoByteMappings
init|=
literal|false
decl_stmt|;
comment|/**      * Constructor.      *       * @param trueTypeFont the true type font containing the glyphs      * @param pdFont the given PDFont      */
specifier|public
name|TTFGlyph2D
parameter_list|(
name|TrueTypeFont
name|trueTypeFont
parameter_list|,
name|PDFont
name|pdFont
parameter_list|)
block|{
name|this
argument_list|(
name|trueTypeFont
argument_list|,
name|pdFont
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *       * @param trueTypeFont the true type font containing the glyphs      * @param pdFont the given PDFont      * @param descFont the descendant font of a Type0Font      */
specifier|public
name|TTFGlyph2D
parameter_list|(
name|TrueTypeFont
name|trueTypeFont
parameter_list|,
name|PDFont
name|pdFont
parameter_list|,
name|PDCIDFontType2Font
name|descFont
parameter_list|)
block|{
name|font
operator|=
name|trueTypeFont
expr_stmt|;
comment|// get units per em, which is used as scaling factor
name|HeaderTable
name|header
init|=
name|font
operator|.
name|getHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|header
operator|!=
literal|null
operator|&&
name|header
operator|.
name|getUnitsPerEm
argument_list|()
operator|!=
literal|1000
condition|)
block|{
comment|// in most case the scaling factor is set to 1.0f
comment|// due to the fact that units per em is set to 1000
name|scale
operator|=
literal|1000f
operator|/
name|header
operator|.
name|getUnitsPerEm
argument_list|()
expr_stmt|;
name|hasScaling
operator|=
literal|true
expr_stmt|;
block|}
name|extractCMaps
argument_list|()
expr_stmt|;
name|extractFontSpecifics
argument_list|(
name|pdFont
argument_list|,
name|descFont
argument_list|)
expr_stmt|;
block|}
comment|/**      * extract all useful CMaps.      */
specifier|private
name|void
name|extractCMaps
parameter_list|()
block|{
name|CMAPTable
name|cmapTable
init|=
name|font
operator|.
name|getCMAP
argument_list|()
decl_stmt|;
if|if
condition|(
name|cmapTable
operator|!=
literal|null
condition|)
block|{
comment|// get all relevant CMaps
name|CMAPEncodingEntry
index|[]
name|cmaps
init|=
name|cmapTable
operator|.
name|getCmaps
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cmaps
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CMAPTable
operator|.
name|PLATFORM_WINDOWS
operator|==
name|cmaps
index|[
name|i
index|]
operator|.
name|getPlatformId
argument_list|()
condition|)
block|{
if|if
condition|(
name|CMAPTable
operator|.
name|ENCODING_UNICODE
operator|==
name|cmaps
index|[
name|i
index|]
operator|.
name|getPlatformEncodingId
argument_list|()
condition|)
block|{
name|cmapWinUnicode
operator|=
name|cmaps
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CMAPTable
operator|.
name|ENCODING_SYMBOL
operator|==
name|cmaps
index|[
name|i
index|]
operator|.
name|getPlatformEncodingId
argument_list|()
condition|)
block|{
name|cmapWinSymbol
operator|=
name|cmaps
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CMAPTable
operator|.
name|PLATFORM_MACINTOSH
operator|==
name|cmaps
index|[
name|i
index|]
operator|.
name|getPlatformId
argument_list|()
condition|)
block|{
if|if
condition|(
name|CMAPTable
operator|.
name|ENCODING_SYMBOL
operator|==
name|cmaps
index|[
name|i
index|]
operator|.
name|getPlatformEncodingId
argument_list|()
condition|)
block|{
name|cmapMacintoshSymbol
operator|=
name|cmaps
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Extract all font specific information.      *       * @param pdFont the given PDFont      */
specifier|private
name|void
name|extractFontSpecifics
parameter_list|(
name|PDFont
name|pdFont
parameter_list|,
name|PDCIDFontType2Font
name|descFont
parameter_list|)
block|{
name|isSymbol
operator|=
name|pdFont
operator|.
name|isSymbolicFont
argument_list|()
expr_stmt|;
name|name
operator|=
name|pdFont
operator|.
name|getBaseFont
argument_list|()
expr_stmt|;
name|fontEncoding
operator|=
name|pdFont
operator|.
name|getFontEncoding
argument_list|()
expr_stmt|;
if|if
condition|(
name|descFont
operator|!=
literal|null
condition|)
block|{
name|isCIDFont
operator|=
literal|true
expr_stmt|;
name|descendantFont
operator|=
name|descFont
expr_stmt|;
name|hasIdentityCIDMapping
operator|=
name|descendantFont
operator|.
name|hasIdentityCIDToGIDMap
argument_list|()
expr_stmt|;
name|hasCID2GIDMapping
operator|=
name|descendantFont
operator|.
name|hasCIDToGIDMap
argument_list|()
expr_stmt|;
name|fontCMap
operator|=
name|pdFont
operator|.
name|getCMap
argument_list|()
expr_stmt|;
if|if
condition|(
name|fontCMap
operator|!=
literal|null
condition|)
block|{
name|hasTwoByteMappings
operator|=
name|fontCMap
operator|.
name|hasTwoByteMappings
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Set the points of a glyph from the GlyphDescription.      */
specifier|private
name|Point
index|[]
name|describe
parameter_list|(
name|GlyphDescription
name|gd
parameter_list|)
block|{
name|int
name|endPtIndex
init|=
literal|0
decl_stmt|;
name|Point
index|[]
name|points
init|=
operator|new
name|Point
index|[
name|gd
operator|.
name|getPointCount
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gd
operator|.
name|getPointCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|endPt
init|=
name|gd
operator|.
name|getEndPtOfContours
argument_list|(
name|endPtIndex
argument_list|)
operator|==
name|i
decl_stmt|;
if|if
condition|(
name|endPt
condition|)
block|{
name|endPtIndex
operator|++
expr_stmt|;
block|}
name|points
index|[
name|i
index|]
operator|=
operator|new
name|Point
argument_list|(
name|gd
operator|.
name|getXCoordinate
argument_list|(
name|i
argument_list|)
argument_list|,
name|gd
operator|.
name|getYCoordinate
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|gd
operator|.
name|getFlags
argument_list|(
name|i
argument_list|)
operator|&
name|GlyfDescript
operator|.
name|ON_CURVE
operator|)
operator|!=
literal|0
argument_list|,
name|endPt
argument_list|)
expr_stmt|;
block|}
return|return
name|points
return|;
block|}
comment|/**      * Returns the path describing the glyph for the given glyphId.      *      * @param glyphId the glyphId      *      * @return the GeneralPath for the given glyphId      */
specifier|public
name|GeneralPath
name|getPathForGlyphId
parameter_list|(
name|int
name|glyphId
parameter_list|)
block|{
name|GeneralPath
name|glyphPath
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|glyphs
operator|.
name|containsKey
argument_list|(
name|glyphId
argument_list|)
condition|)
block|{
name|glyphPath
operator|=
name|glyphs
operator|.
name|get
argument_list|(
name|glyphId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GlyphData
index|[]
name|glyphData
init|=
name|font
operator|.
name|getGlyph
argument_list|()
operator|.
name|getGlyphs
argument_list|()
decl_stmt|;
if|if
condition|(
name|glyphId
operator|<
name|glyphData
operator|.
name|length
operator|&&
name|glyphData
index|[
name|glyphId
index|]
operator|!=
literal|null
condition|)
block|{
name|GlyphData
name|glyph
init|=
name|glyphData
index|[
name|glyphId
index|]
decl_stmt|;
name|GlyphDescription
name|gd
init|=
name|glyph
operator|.
name|getDescription
argument_list|()
decl_stmt|;
name|Point
index|[]
name|points
init|=
name|describe
argument_list|(
name|gd
argument_list|)
decl_stmt|;
name|glyphPath
operator|=
name|calculatePath
argument_list|(
name|points
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasScaling
condition|)
block|{
name|AffineTransform
name|atScale
init|=
name|AffineTransform
operator|.
name|getScaleInstance
argument_list|(
name|scale
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|glyphPath
operator|.
name|transform
argument_list|(
name|atScale
argument_list|)
expr_stmt|;
block|}
name|glyphs
operator|.
name|put
argument_list|(
name|glyphId
argument_list|,
name|glyphPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|": Glyph not found:"
operator|+
name|glyphId
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|glyphPath
operator|!=
literal|null
condition|?
operator|(
name|GeneralPath
operator|)
name|glyphPath
operator|.
name|clone
argument_list|()
else|:
literal|null
return|;
block|}
comment|/*      * Try to map the given code to the corresponding glyph-ID      */
specifier|private
name|int
name|getGlyphcode
parameter_list|(
name|int
name|code
parameter_list|)
block|{
if|if
condition|(
name|isCIDFont
condition|)
block|{
return|return
name|getGID
argument_list|(
name|code
argument_list|)
return|;
block|}
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fontEncoding
operator|!=
literal|null
operator|&&
operator|!
name|isSymbol
condition|)
block|{
try|try
block|{
name|String
name|charactername
init|=
name|fontEncoding
operator|.
name|getName
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|charactername
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cmapWinUnicode
operator|!=
literal|null
condition|)
block|{
name|String
name|unicode
init|=
name|Encoding
operator|.
name|getCharacterForName
argument_list|(
name|charactername
argument_list|)
decl_stmt|;
if|if
condition|(
name|unicode
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|unicode
operator|.
name|codePointAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|cmapWinUnicode
operator|.
name|getGlyphId
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmapMacintoshSymbol
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|MacOSRomanEncoding
operator|.
name|INSTANCE
operator|.
name|getCode
argument_list|(
name|charactername
argument_list|)
expr_stmt|;
name|result
operator|=
name|cmapMacintoshSymbol
operator|.
name|getGlyphId
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught an exception getGlyhcode: "
operator|+
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fontEncoding
operator|==
literal|null
operator|||
name|isSymbol
condition|)
block|{
if|if
condition|(
name|cmapWinSymbol
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|cmapWinSymbol
operator|.
name|getGlyphId
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
operator|&&
name|code
operator|<=
literal|0xFF
condition|)
block|{
comment|// the CMap may use one of the following code ranges,
comment|// so that we have to add the high byte to get the
comment|// mapped value
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|// F000 - F0FF
name|result
operator|=
name|cmapWinSymbol
operator|.
name|getGlyphId
argument_list|(
name|code
operator|+
name|START_RANGE_F000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|// F100 - F1FF
name|result
operator|=
name|cmapWinSymbol
operator|.
name|getGlyphId
argument_list|(
name|code
operator|+
name|START_RANGE_F100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|// F200 - F2FF
name|result
operator|=
name|cmapWinSymbol
operator|.
name|getGlyphId
argument_list|(
name|code
operator|+
name|START_RANGE_F200
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|cmapMacintoshSymbol
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
name|cmapMacintoshSymbol
operator|.
name|getGlyphId
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Get the GID for the given CIDFont.      *       * @param code the given CID      * @return the mapped GID      */
specifier|private
name|int
name|getGID
parameter_list|(
name|int
name|code
parameter_list|)
block|{
if|if
condition|(
name|hasIdentityCIDMapping
condition|)
block|{
comment|// identity mapping
return|return
name|code
return|;
block|}
if|if
condition|(
name|hasCID2GIDMapping
condition|)
block|{
comment|// use the provided CID2GID mapping
return|return
name|descendantFont
operator|.
name|mapCIDToGID
argument_list|(
name|code
argument_list|)
return|;
block|}
if|if
condition|(
name|fontCMap
operator|!=
literal|null
condition|)
block|{
name|String
name|string
init|=
name|fontCMap
operator|.
name|lookup
argument_list|(
name|code
argument_list|,
name|hasTwoByteMappings
condition|?
literal|2
else|:
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|string
operator|!=
literal|null
condition|)
block|{
return|return
name|string
operator|.
name|codePointAt
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
return|return
name|code
return|;
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
specifier|public
name|GeneralPath
name|getPathForCharacterCode
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|int
name|glyphId
init|=
name|getGlyphcode
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|glyphId
operator|>
literal|0
condition|)
block|{
return|return
name|getPathForGlyphId
argument_list|(
name|glyphId
argument_list|)
return|;
block|}
name|glyphId
operator|=
name|code
expr_stmt|;
comment|// there isn't any mapping, but probably an optional CMap
if|if
condition|(
name|fontCMap
operator|!=
literal|null
condition|)
block|{
name|String
name|string
init|=
name|fontCMap
operator|.
name|lookup
argument_list|(
name|code
argument_list|,
name|hasTwoByteMappings
condition|?
literal|2
else|:
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|string
operator|!=
literal|null
condition|)
block|{
name|glyphId
operator|=
name|string
operator|.
name|codePointAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|getPathForGlyphId
argument_list|(
name|glyphId
argument_list|)
return|;
block|}
comment|/**      * Use the given points to calculate a GeneralPath.      *       * @param points the points to be used to generate the GeneralPath      *       * @return the calculated GeneralPath      */
specifier|private
name|GeneralPath
name|calculatePath
parameter_list|(
name|Point
index|[]
name|points
parameter_list|)
block|{
name|GeneralPath
name|path
init|=
operator|new
name|GeneralPath
argument_list|()
decl_stmt|;
name|int
name|numberOfPoints
init|=
name|points
operator|.
name|length
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|boolean
name|endOfContour
init|=
literal|true
decl_stmt|;
name|Point
name|startingPoint
init|=
literal|null
decl_stmt|;
name|Point
name|offCurveStartPoint
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|numberOfPoints
condition|)
block|{
name|Point
name|point
init|=
name|points
index|[
name|i
operator|%
name|numberOfPoints
index|]
decl_stmt|;
name|Point
name|nextPoint1
init|=
name|points
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|numberOfPoints
index|]
decl_stmt|;
name|Point
name|nextPoint2
init|=
name|points
index|[
operator|(
name|i
operator|+
literal|2
operator|)
operator|%
name|numberOfPoints
index|]
decl_stmt|;
comment|// new contour
if|if
condition|(
name|endOfContour
condition|)
block|{
comment|// skip endOfContour points
if|if
condition|(
name|point
operator|.
name|endOfContour
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|// move to the starting point
name|moveTo
argument_list|(
name|path
argument_list|,
name|point
argument_list|)
expr_stmt|;
name|endOfContour
operator|=
literal|false
expr_stmt|;
name|startingPoint
operator|=
name|point
expr_stmt|;
name|offCurveStartPoint
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|point
operator|.
name|onCurve
operator|&&
operator|!
name|nextPoint1
operator|.
name|onCurve
condition|)
block|{
comment|// off curve start
name|offCurveStartPoint
operator|=
name|point
expr_stmt|;
name|startingPoint
operator|=
name|midValue
argument_list|(
name|point
argument_list|,
name|nextPoint1
argument_list|)
expr_stmt|;
name|moveTo
argument_list|(
name|path
argument_list|,
name|startingPoint
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|point
operator|.
name|onCurve
condition|)
block|{
name|offCurveStartPoint
operator|=
literal|null
expr_stmt|;
block|}
comment|// lineTo
if|if
condition|(
name|point
operator|.
name|onCurve
operator|&&
name|nextPoint1
operator|.
name|onCurve
condition|)
block|{
name|lineTo
argument_list|(
name|path
argument_list|,
name|nextPoint1
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|point
operator|.
name|endOfContour
operator|||
name|nextPoint1
operator|.
name|endOfContour
condition|)
block|{
name|endOfContour
operator|=
literal|true
expr_stmt|;
name|closePath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|// quadratic bezier
if|if
condition|(
name|point
operator|.
name|onCurve
operator|&&
operator|!
name|nextPoint1
operator|.
name|onCurve
operator|&&
name|nextPoint2
operator|.
name|onCurve
condition|)
block|{
if|if
condition|(
name|nextPoint1
operator|.
name|endOfContour
condition|)
block|{
comment|// use the starting point as end point
name|quadTo
argument_list|(
name|path
argument_list|,
name|nextPoint1
argument_list|,
name|startingPoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|quadTo
argument_list|(
name|path
argument_list|,
name|nextPoint1
argument_list|,
name|nextPoint2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextPoint1
operator|.
name|endOfContour
operator|||
name|nextPoint2
operator|.
name|endOfContour
condition|)
block|{
name|endOfContour
operator|=
literal|true
expr_stmt|;
name|closePath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
comment|// TH segment for curves that start with an off-curve point
if|if
condition|(
name|offCurveStartPoint
operator|!=
literal|null
operator|&&
operator|!
name|nextPoint1
operator|.
name|onCurve
operator|&&
operator|!
name|nextPoint2
operator|.
name|onCurve
condition|)
block|{
comment|// interpolate endPoint
name|quadTo
argument_list|(
name|path
argument_list|,
name|nextPoint1
argument_list|,
name|midValue
argument_list|(
name|nextPoint1
argument_list|,
name|nextPoint2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|.
name|endOfContour
operator|||
name|nextPoint1
operator|.
name|endOfContour
operator|||
name|nextPoint2
operator|.
name|endOfContour
condition|)
block|{
name|quadTo
argument_list|(
name|path
argument_list|,
name|nextPoint2
argument_list|,
name|midValue
argument_list|(
name|nextPoint2
argument_list|,
name|offCurveStartPoint
argument_list|)
argument_list|)
expr_stmt|;
name|quadTo
argument_list|(
name|path
argument_list|,
name|offCurveStartPoint
argument_list|,
name|startingPoint
argument_list|)
expr_stmt|;
name|endOfContour
operator|=
literal|true
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|point
operator|.
name|onCurve
operator|&&
operator|!
name|nextPoint1
operator|.
name|onCurve
operator|&&
operator|!
name|nextPoint2
operator|.
name|onCurve
condition|)
block|{
comment|// interpolate endPoint
name|quadTo
argument_list|(
name|path
argument_list|,
name|nextPoint1
argument_list|,
name|midValue
argument_list|(
name|nextPoint1
argument_list|,
name|nextPoint2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|.
name|endOfContour
operator|||
name|nextPoint1
operator|.
name|endOfContour
operator|||
name|nextPoint2
operator|.
name|endOfContour
condition|)
block|{
name|quadTo
argument_list|(
name|path
argument_list|,
name|nextPoint2
argument_list|,
name|startingPoint
argument_list|)
expr_stmt|;
name|endOfContour
operator|=
literal|true
expr_stmt|;
name|closePath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
comment|// TH the control point is never interpolated
if|if
condition|(
operator|!
name|point
operator|.
name|onCurve
operator|&&
operator|!
name|nextPoint1
operator|.
name|onCurve
condition|)
block|{
name|quadTo
argument_list|(
name|path
argument_list|,
name|point
argument_list|,
name|midValue
argument_list|(
name|point
argument_list|,
name|nextPoint1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|.
name|endOfContour
operator|||
name|nextPoint1
operator|.
name|endOfContour
condition|)
block|{
name|endOfContour
operator|=
literal|true
expr_stmt|;
name|quadTo
argument_list|(
name|path
argument_list|,
name|nextPoint1
argument_list|,
name|startingPoint
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|point
operator|.
name|onCurve
operator|&&
name|nextPoint1
operator|.
name|onCurve
condition|)
block|{
name|quadTo
argument_list|(
name|path
argument_list|,
name|point
argument_list|,
name|nextPoint1
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|.
name|endOfContour
operator|||
name|nextPoint1
operator|.
name|endOfContour
condition|)
block|{
name|endOfContour
operator|=
literal|true
expr_stmt|;
name|closePath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Unknown glyph command!!"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|path
return|;
block|}
specifier|private
name|void
name|closePath
parameter_list|(
name|GeneralPath
name|path
parameter_list|)
block|{
name|path
operator|.
name|closePath
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"closePath"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|moveTo
parameter_list|(
name|GeneralPath
name|path
parameter_list|,
name|Point
name|point
parameter_list|)
block|{
name|path
operator|.
name|moveTo
argument_list|(
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"moveTo: "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%d,%d"
argument_list|,
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|lineTo
parameter_list|(
name|GeneralPath
name|path
parameter_list|,
name|Point
name|point
parameter_list|)
block|{
name|path
operator|.
name|lineTo
argument_list|(
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"lineTo: "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%d,%d"
argument_list|,
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|quadTo
parameter_list|(
name|GeneralPath
name|path
parameter_list|,
name|Point
name|ctrlPoint
parameter_list|,
name|Point
name|point
parameter_list|)
block|{
name|path
operator|.
name|quadTo
argument_list|(
name|ctrlPoint
operator|.
name|x
argument_list|,
name|ctrlPoint
operator|.
name|y
argument_list|,
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"quadTo: "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"%d,%d %d,%d"
argument_list|,
name|ctrlPoint
operator|.
name|x
argument_list|,
name|ctrlPoint
operator|.
name|y
argument_list|,
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|midValue
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|+
operator|(
name|b
operator|-
name|a
operator|)
operator|/
literal|2
return|;
block|}
specifier|private
name|Point
name|midValue
parameter_list|(
name|Point
name|point1
parameter_list|,
name|Point
name|point2
parameter_list|)
block|{
return|return
operator|new
name|Point
argument_list|(
name|midValue
argument_list|(
name|point1
operator|.
name|x
argument_list|,
name|point2
operator|.
name|x
argument_list|)
argument_list|,
name|midValue
argument_list|(
name|point1
operator|.
name|y
argument_list|,
name|point2
operator|.
name|y
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * This class represents one point of a glyph.      *       */
specifier|private
class|class
name|Point
block|{
specifier|private
name|int
name|x
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|y
init|=
literal|0
decl_stmt|;
specifier|private
name|boolean
name|onCurve
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|endOfContour
init|=
literal|false
decl_stmt|;
specifier|public
name|Point
parameter_list|(
name|int
name|xValue
parameter_list|,
name|int
name|yValue
parameter_list|,
name|boolean
name|onCurveValue
parameter_list|,
name|boolean
name|endOfContourValue
parameter_list|)
block|{
name|x
operator|=
name|xValue
expr_stmt|;
name|y
operator|=
name|yValue
expr_stmt|;
name|onCurve
operator|=
name|onCurveValue
expr_stmt|;
name|endOfContour
operator|=
name|endOfContourValue
expr_stmt|;
block|}
specifier|public
name|Point
parameter_list|(
name|int
name|xValue
parameter_list|,
name|int
name|yValue
parameter_list|)
block|{
name|this
argument_list|(
name|xValue
argument_list|,
name|yValue
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"Point(%d,%d,%s,%s)"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|onCurve
condition|?
literal|"onCurve"
else|:
literal|""
argument_list|,
name|endOfContour
condition|?
literal|"endOfContour"
else|:
literal|""
argument_list|)
return|;
block|}
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
specifier|public
name|int
name|getNumberOfGlyphs
parameter_list|()
block|{
return|return
name|font
operator|!=
literal|null
condition|?
name|font
operator|.
name|getGlyph
argument_list|()
operator|.
name|getGlyphs
argument_list|()
operator|.
name|length
else|:
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|dispose
parameter_list|()
block|{
name|cmapMacintoshSymbol
operator|=
literal|null
expr_stmt|;
name|cmapWinSymbol
operator|=
literal|null
expr_stmt|;
name|cmapWinUnicode
operator|=
literal|null
expr_stmt|;
name|font
operator|=
literal|null
expr_stmt|;
name|descendantFont
operator|=
literal|null
expr_stmt|;
name|fontCMap
operator|=
literal|null
expr_stmt|;
name|fontEncoding
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|glyphs
operator|!=
literal|null
condition|)
block|{
name|glyphs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

