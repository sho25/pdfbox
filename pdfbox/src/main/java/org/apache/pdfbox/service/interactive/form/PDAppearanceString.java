begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|service
operator|.
name|interactive
operator|.
name|form
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
operator|.
name|PDFStreamParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfwriter
operator|.
name|COSWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfwriter
operator|.
name|ContentStreamWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDResources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|COSObjectable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRectangle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDFont
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDFontDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|action
operator|.
name|PDFormFieldAdditionalActions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|annotation
operator|.
name|PDAppearanceDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|annotation
operator|.
name|PDAppearanceEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|annotation
operator|.
name|PDAppearanceStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|annotation
operator|.
name|PDAnnotationWidget
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|form
operator|.
name|PDAcroForm
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|form
operator|.
name|PDField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|form
operator|.
name|PDTextField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|form
operator|.
name|PDVariableText
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|contentstream
operator|.
name|operator
operator|.
name|Operator
import|;
end_import

begin_comment
comment|/**  * A default appearance string contains any graphics state or text state operators needed to  * establish the graphics state parameters, such as text size and colour, for displaying the field's  * variable text. Only operators that are allowed within text objects shall occur in this string.  *  * @author Stephan Gerhard  * @author Ben Litchfield  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|PDAppearanceString
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PDAppearanceString
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|PDVariableText
name|parent
decl_stmt|;
specifier|private
name|String
name|value
decl_stmt|;
specifier|private
specifier|final
name|DefaultAppearanceHandler
name|defaultAppearanceHandler
decl_stmt|;
specifier|private
specifier|final
name|PDAcroForm
name|acroForm
decl_stmt|;
specifier|private
name|List
argument_list|<
name|COSObjectable
argument_list|>
name|widgets
init|=
operator|new
name|ArrayList
argument_list|<
name|COSObjectable
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Constructs a COSAppearance from the given field.      *      * @param theAcroForm the AcroForm that this field is part of.      * @param field the field which you wish to control the appearance of      * @throws IOException       */
specifier|public
name|PDAppearanceString
parameter_list|(
name|PDAcroForm
name|theAcroForm
parameter_list|,
name|PDVariableText
name|field
parameter_list|)
throws|throws
name|IOException
block|{
name|acroForm
operator|=
name|theAcroForm
expr_stmt|;
name|parent
operator|=
name|field
expr_stmt|;
name|widgets
operator|=
name|field
operator|.
name|getKids
argument_list|()
expr_stmt|;
if|if
condition|(
name|widgets
operator|==
literal|null
condition|)
block|{
name|widgets
operator|=
operator|new
name|ArrayList
argument_list|<
name|COSObjectable
argument_list|>
argument_list|()
expr_stmt|;
name|widgets
operator|.
name|add
argument_list|(
name|field
operator|.
name|getWidget
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|defaultAppearanceHandler
operator|=
operator|new
name|DefaultAppearanceHandler
argument_list|(
name|getDefaultAppearance
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the default appearance of a textbox. If the textbox does not have one,      * then it will be taken from the AcroForm.      *       * @return The DA element      */
specifier|private
name|String
name|getDefaultAppearance
parameter_list|()
block|{
return|return
name|parent
operator|.
name|getDefaultAppearance
argument_list|()
return|;
block|}
specifier|private
name|int
name|getQ
parameter_list|()
block|{
return|return
name|parent
operator|.
name|getQ
argument_list|()
return|;
block|}
comment|/**      * Extracts the original appearance stream into a list of tokens.      *      * @return The tokens in the original appearance stream      */
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|getStreamTokens
parameter_list|(
name|PDAppearanceStream
name|appearanceStream
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|tokens
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|appearanceStream
operator|!=
literal|null
condition|)
block|{
name|tokens
operator|=
name|getStreamTokens
argument_list|(
name|appearanceStream
operator|.
name|getCOSStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|tokens
return|;
block|}
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|getStreamTokens
parameter_list|(
name|COSStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|tokens
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|stream
operator|!=
literal|null
condition|)
block|{
name|PDFStreamParser
name|parser
init|=
operator|new
name|PDFStreamParser
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
name|tokens
operator|=
name|parser
operator|.
name|getTokens
argument_list|()
expr_stmt|;
name|parser
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|tokens
return|;
block|}
comment|/**      * Tests if the appearance stream already contains content.      *       * @param streamTokens individual tokens within the appearance stream      *      * @return true if it contains any content      */
specifier|private
name|boolean
name|containsMarkedContent
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|streamTokens
parameter_list|)
block|{
return|return
name|streamTokens
operator|.
name|contains
argument_list|(
name|Operator
operator|.
name|getOperator
argument_list|(
literal|"BMC"
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * This is the public method for setting the appearance stream.      *      * @param apValue the String value which the appearance should represent      *      * @throws IOException If there is an error creating the stream.      */
specifier|public
name|void
name|setAppearanceValue
parameter_list|(
name|String
name|apValue
parameter_list|)
throws|throws
name|IOException
block|{
name|value
operator|=
name|apValue
expr_stmt|;
name|Iterator
argument_list|<
name|COSObjectable
argument_list|>
name|widgetIter
init|=
name|widgets
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|widgetIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|COSObjectable
name|next
init|=
name|widgetIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|PDField
name|field
init|=
literal|null
decl_stmt|;
name|PDAnnotationWidget
name|widget
decl_stmt|;
if|if
condition|(
name|next
operator|instanceof
name|PDField
condition|)
block|{
name|field
operator|=
operator|(
name|PDField
operator|)
name|next
expr_stmt|;
name|widget
operator|=
name|field
operator|.
name|getWidget
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|widget
operator|=
operator|(
name|PDAnnotationWidget
operator|)
name|next
expr_stmt|;
block|}
name|PDFormFieldAdditionalActions
name|actions
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
name|actions
operator|=
name|field
operator|.
name|getActions
argument_list|()
expr_stmt|;
block|}
comment|// in case all tests fail the field will be formatted by acrobat
comment|// when it is opened. See FreedomExpressions.pdf for an example of this.
if|if
condition|(
name|actions
operator|==
literal|null
operator|||
name|actions
operator|.
name|getF
argument_list|()
operator|==
literal|null
operator|||
name|widget
operator|.
name|getDictionary
argument_list|()
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|AP
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|PDAppearanceDictionary
name|appearance
init|=
name|widget
operator|.
name|getAppearance
argument_list|()
decl_stmt|;
if|if
condition|(
name|appearance
operator|==
literal|null
condition|)
block|{
name|appearance
operator|=
operator|new
name|PDAppearanceDictionary
argument_list|()
expr_stmt|;
name|widget
operator|.
name|setAppearance
argument_list|(
name|appearance
argument_list|)
expr_stmt|;
block|}
name|PDAppearanceEntry
name|normalAppearance
init|=
name|appearance
operator|.
name|getNormalAppearance
argument_list|()
decl_stmt|;
comment|// TODO support more than one appearance stream
name|PDAppearanceStream
name|appearanceStream
init|=
name|normalAppearance
operator|.
name|isStream
argument_list|()
condition|?
name|normalAppearance
operator|.
name|getAppearanceStream
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|appearanceStream
operator|==
literal|null
condition|)
block|{
name|COSStream
name|cosStream
init|=
name|acroForm
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocument
argument_list|()
operator|.
name|createCOSStream
argument_list|()
decl_stmt|;
name|appearanceStream
operator|=
operator|new
name|PDAppearanceStream
argument_list|(
name|cosStream
argument_list|)
expr_stmt|;
name|appearanceStream
operator|.
name|setBBox
argument_list|(
name|widget
operator|.
name|getRectangle
argument_list|()
operator|.
name|createRetranslatedRectangle
argument_list|()
argument_list|)
expr_stmt|;
name|appearance
operator|.
name|setNormalAppearance
argument_list|(
name|appearanceStream
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|tokens
init|=
name|getStreamTokens
argument_list|(
name|appearanceStream
argument_list|)
decl_stmt|;
name|PDFont
name|pdFont
init|=
name|getFontAndUpdateResources
argument_list|(
name|appearanceStream
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|containsMarkedContent
argument_list|(
name|tokens
argument_list|)
condition|)
block|{
name|ByteArrayOutputStream
name|output
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
comment|// BJL 9/25/2004 Must prepend existing stream
comment|// because it might have operators to draw things like
comment|// rectangles and such
name|ContentStreamWriter
name|writer
init|=
operator|new
name|ContentStreamWriter
argument_list|(
name|output
argument_list|)
decl_stmt|;
name|writer
operator|.
name|writeTokens
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
literal|"/Tx BMC\n"
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|insertGeneratedAppearance
argument_list|(
name|widget
argument_list|,
name|output
argument_list|,
name|pdFont
argument_list|,
name|tokens
argument_list|,
name|appearanceStream
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
literal|"EMC"
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|writeToStream
argument_list|(
name|output
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|appearanceStream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|defaultAppearanceHandler
operator|.
name|getTokens
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|bmcIndex
init|=
name|tokens
operator|.
name|indexOf
argument_list|(
name|Operator
operator|.
name|getOperator
argument_list|(
literal|"BMC"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|emcIndex
init|=
name|tokens
operator|.
name|indexOf
argument_list|(
name|Operator
operator|.
name|getOperator
argument_list|(
literal|"EMC"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bmcIndex
operator|!=
operator|-
literal|1
operator|&&
name|emcIndex
operator|!=
operator|-
literal|1
operator|&&
name|emcIndex
operator|==
name|bmcIndex
operator|+
literal|1
condition|)
block|{
comment|// if the EMC immediately follows the BMC index then should
comment|// insert the daTokens inbetween the two markers.
name|tokens
operator|.
name|addAll
argument_list|(
name|emcIndex
argument_list|,
name|defaultAppearanceHandler
operator|.
name|getTokens
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|ByteArrayOutputStream
name|output
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|ContentStreamWriter
name|writer
init|=
operator|new
name|ContentStreamWriter
argument_list|(
name|output
argument_list|)
decl_stmt|;
name|float
name|fontSize
init|=
name|calculateFontSize
argument_list|(
name|pdFont
argument_list|,
name|appearanceStream
operator|.
name|getBBox
argument_list|()
argument_list|,
name|tokens
argument_list|)
decl_stmt|;
name|int
name|setFontIndex
init|=
name|tokens
operator|.
name|indexOf
argument_list|(
name|Operator
operator|.
name|getOperator
argument_list|(
literal|"Tf"
argument_list|)
argument_list|)
decl_stmt|;
name|tokens
operator|.
name|set
argument_list|(
name|setFontIndex
operator|-
literal|1
argument_list|,
operator|new
name|COSFloat
argument_list|(
name|fontSize
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|bmcIndex
init|=
name|tokens
operator|.
name|indexOf
argument_list|(
name|Operator
operator|.
name|getOperator
argument_list|(
literal|"BMC"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|emcIndex
init|=
name|tokens
operator|.
name|indexOf
argument_list|(
name|Operator
operator|.
name|getOperator
argument_list|(
literal|"EMC"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bmcIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|writer
operator|.
name|writeTokens
argument_list|(
name|tokens
argument_list|,
literal|0
argument_list|,
name|bmcIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|writeTokens
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|write
argument_list|(
literal|"\n"
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|)
expr_stmt|;
name|insertGeneratedAppearance
argument_list|(
name|widget
argument_list|,
name|output
argument_list|,
name|pdFont
argument_list|,
name|tokens
argument_list|,
name|appearanceStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|emcIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|writer
operator|.
name|writeTokens
argument_list|(
name|tokens
argument_list|,
name|emcIndex
argument_list|,
name|tokens
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writeToStream
argument_list|(
name|output
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|appearanceStream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|insertGeneratedAppearance
parameter_list|(
name|PDAnnotationWidget
name|fieldWidget
parameter_list|,
name|OutputStream
name|output
parameter_list|,
name|PDFont
name|font
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|tokens
parameter_list|,
name|PDAppearanceStream
name|appearanceStream
parameter_list|)
throws|throws
name|IOException
block|{
name|PrintWriter
name|printWriter
init|=
operator|new
name|PrintWriter
argument_list|(
name|output
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|float
name|fontSize
init|=
literal|0.0f
decl_stmt|;
name|PDRectangle
name|boundingBox
init|=
name|appearanceStream
operator|.
name|getBBox
argument_list|()
decl_stmt|;
if|if
condition|(
name|boundingBox
operator|==
literal|null
condition|)
block|{
name|boundingBox
operator|=
name|fieldWidget
operator|.
name|getRectangle
argument_list|()
operator|.
name|createRetranslatedRectangle
argument_list|()
expr_stmt|;
block|}
name|printWriter
operator|.
name|println
argument_list|(
literal|"BT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|defaultAppearanceHandler
operator|.
name|getTokens
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fontSize
operator|=
name|calculateFontSize
argument_list|(
name|font
argument_list|,
name|boundingBox
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
name|defaultAppearanceHandler
operator|.
name|setFontSize
argument_list|(
name|fontSize
argument_list|)
expr_stmt|;
name|ContentStreamWriter
name|daWriter
init|=
operator|new
name|ContentStreamWriter
argument_list|(
name|output
argument_list|)
decl_stmt|;
name|daWriter
operator|.
name|writeTokens
argument_list|(
name|defaultAppearanceHandler
operator|.
name|getTokens
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|PDRectangle
name|borderEdge
init|=
name|getSmallestDrawnRectangle
argument_list|(
name|boundingBox
argument_list|,
name|tokens
argument_list|)
decl_stmt|;
comment|// Acrobat calculates the left and right padding dependent on the offset of the border edge
comment|// This calculation works for forms having been generated by Acrobat.
comment|// Need to revisit this for forms being generated with other software.
name|float
name|paddingLeft
init|=
name|Math
operator|.
name|max
argument_list|(
literal|2
argument_list|,
name|Math
operator|.
name|round
argument_list|(
literal|4
operator|*
name|borderEdge
operator|.
name|getLowerLeftX
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|paddingRight
init|=
name|Math
operator|.
name|max
argument_list|(
literal|2
argument_list|,
name|Math
operator|.
name|round
argument_list|(
literal|4
operator|*
operator|(
name|boundingBox
operator|.
name|getUpperRightX
argument_list|()
operator|-
name|borderEdge
operator|.
name|getUpperRightX
argument_list|()
operator|)
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|verticalOffset
init|=
name|getVerticalOffset
argument_list|(
name|boundingBox
argument_list|,
name|font
argument_list|,
name|fontSize
argument_list|,
name|tokens
argument_list|)
decl_stmt|;
comment|// Acrobat shifts the value so it aligns to the bottom if
comment|// the font's caps are larger than the height of the borderEdge
comment|//
comment|// This is based on a small sample of test files and might not be generally the case.
comment|// The fontHeight calculation has been taken from getVerticalOffset().
comment|// We potentially need to revisit that calculation
name|float
name|fontHeight
init|=
name|boundingBox
operator|.
name|getHeight
argument_list|()
operator|-
name|verticalOffset
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|fontHeight
operator|+
literal|2
operator|*
name|borderEdge
operator|.
name|getLowerLeftX
argument_list|()
operator|>
name|borderEdge
operator|.
name|getHeight
argument_list|()
condition|)
block|{
name|verticalOffset
operator|=
name|font
operator|.
name|getBoundingBox
argument_list|()
operator|.
name|getHeight
argument_list|()
operator|/
literal|1000
operator|*
name|fontSize
operator|-
name|borderEdge
operator|.
name|getHeight
argument_list|()
expr_stmt|;
block|}
name|float
name|leftOffset
init|=
literal|0f
decl_stmt|;
comment|// Acrobat aligns left regardless of the quadding if the text is wider than the remaining width
name|float
name|stringWidth
init|=
operator|(
name|font
operator|.
name|getStringWidth
argument_list|(
name|value
argument_list|)
operator|/
literal|1000
operator|)
operator|*
name|fontSize
decl_stmt|;
name|int
name|q
init|=
name|getQ
argument_list|()
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|PDTextField
operator|.
name|QUADDING_LEFT
operator|||
name|stringWidth
operator|>
name|borderEdge
operator|.
name|getWidth
argument_list|()
operator|-
name|paddingLeft
operator|-
name|paddingRight
condition|)
block|{
name|leftOffset
operator|=
name|paddingLeft
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|==
name|PDTextField
operator|.
name|QUADDING_CENTERED
condition|)
block|{
name|leftOffset
operator|=
operator|(
name|boundingBox
operator|.
name|getWidth
argument_list|()
operator|-
name|stringWidth
operator|)
operator|/
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|==
name|PDTextField
operator|.
name|QUADDING_RIGHT
condition|)
block|{
name|leftOffset
operator|=
name|boundingBox
operator|.
name|getWidth
argument_list|()
operator|-
name|stringWidth
operator|-
name|paddingRight
expr_stmt|;
block|}
else|else
block|{
comment|// Unknown quadding value - default to left
name|printWriter
operator|.
name|println
argument_list|(
name|paddingLeft
operator|+
literal|" "
operator|+
name|verticalOffset
operator|+
literal|" Td"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unknown justification value, defaulting to left: "
operator|+
name|q
argument_list|)
expr_stmt|;
block|}
name|printWriter
operator|.
name|println
argument_list|(
name|leftOffset
operator|+
literal|" "
operator|+
name|verticalOffset
operator|+
literal|" Td"
argument_list|)
expr_stmt|;
comment|// show the text
if|if
condition|(
operator|!
name|isMultiLineValue
argument_list|(
name|value
argument_list|)
operator|||
name|stringWidth
operator|>
name|borderEdge
operator|.
name|getWidth
argument_list|()
operator|-
name|paddingLeft
operator|-
name|paddingRight
condition|)
block|{
name|printWriter
operator|.
name|flush
argument_list|()
expr_stmt|;
name|COSWriter
operator|.
name|writeString
argument_list|(
name|font
operator|.
name|encode
argument_list|(
name|value
argument_list|)
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|printWriter
operator|.
name|println
argument_list|(
literal|" Tj"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|paragraphs
init|=
name|value
operator|.
name|split
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paragraphs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|lastLine
init|=
name|i
operator|==
name|paragraphs
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|printWriter
operator|.
name|flush
argument_list|()
expr_stmt|;
name|COSWriter
operator|.
name|writeString
argument_list|(
name|font
operator|.
name|encode
argument_list|(
name|value
argument_list|)
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|printWriter
operator|.
name|println
argument_list|(
name|lastLine
condition|?
literal|" Tj\n"
else|:
literal|"> Tj 0 -13 Td"
argument_list|)
expr_stmt|;
block|}
block|}
name|printWriter
operator|.
name|println
argument_list|(
literal|"ET"
argument_list|)
expr_stmt|;
name|printWriter
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/*      * To update an existing appearance stream first copy any needed resources from the      * document’s DR dictionary into the stream’s Resources dictionary.      * If the DR and Resources dictionaries contain resources with the same name,      * the one already in the Resources dictionary shall be left intact,      * not replaced with the corresponding value from the DR dictionary.       */
specifier|private
name|PDFont
name|getFontAndUpdateResources
parameter_list|(
name|PDAppearanceStream
name|appearanceStream
parameter_list|)
throws|throws
name|IOException
block|{
name|PDFont
name|font
init|=
literal|null
decl_stmt|;
name|PDResources
name|streamResources
init|=
name|appearanceStream
operator|.
name|getResources
argument_list|()
decl_stmt|;
name|PDResources
name|formResources
init|=
name|acroForm
operator|.
name|getDefaultResources
argument_list|()
decl_stmt|;
if|if
condition|(
name|streamResources
operator|==
literal|null
operator|&&
name|formResources
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to generate field appearance - missing required resources"
argument_list|)
throw|;
block|}
name|COSName
name|cosFontName
init|=
name|defaultAppearanceHandler
operator|.
name|getFontName
argument_list|()
decl_stmt|;
if|if
condition|(
name|streamResources
operator|!=
literal|null
condition|)
block|{
name|font
operator|=
name|streamResources
operator|.
name|getFont
argument_list|(
name|cosFontName
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|!=
literal|null
condition|)
block|{
return|return
name|font
return|;
block|}
block|}
else|else
block|{
name|streamResources
operator|=
operator|new
name|PDResources
argument_list|()
expr_stmt|;
name|appearanceStream
operator|.
name|setResources
argument_list|(
name|streamResources
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|formResources
operator|!=
literal|null
condition|)
block|{
name|font
operator|=
name|formResources
operator|.
name|getFont
argument_list|(
name|cosFontName
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|!=
literal|null
condition|)
block|{
name|streamResources
operator|.
name|put
argument_list|(
name|cosFontName
argument_list|,
name|font
argument_list|)
expr_stmt|;
return|return
name|font
return|;
block|}
block|}
comment|// if we get here the font might be there but under a different name
comment|// which is incorrect but try to treat the resource name as the font name
name|font
operator|=
name|resolveFont
argument_list|(
name|streamResources
argument_list|,
name|formResources
argument_list|,
name|cosFontName
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|!=
literal|null
condition|)
block|{
name|streamResources
operator|.
name|put
argument_list|(
name|cosFontName
argument_list|,
name|font
argument_list|)
expr_stmt|;
return|return
name|font
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to generate field appearance - missing required font resources: "
operator|+
name|cosFontName
argument_list|)
throw|;
block|}
block|}
comment|/**      * Get the font from the resources.      * @return the retrieved font      * @throws IOException       */
specifier|private
name|PDFont
name|resolveFont
parameter_list|(
name|PDResources
name|streamResources
parameter_list|,
name|PDResources
name|formResources
parameter_list|,
name|COSName
name|cosFontName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// if the font couldn't be retrieved it might be because the font name
comment|// in the DA string didn't point to the font resources dictionary entry but
comment|// is the name of the font itself. So try to resolve that.
name|PDFont
name|font
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|streamResources
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|COSName
name|fontName
range|:
name|streamResources
operator|.
name|getFontNames
argument_list|()
control|)
block|{
name|font
operator|=
name|streamResources
operator|.
name|getFont
argument_list|(
name|fontName
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|cosFontName
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|font
return|;
block|}
block|}
block|}
if|if
condition|(
name|formResources
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|COSName
name|fontName
range|:
name|formResources
operator|.
name|getFontNames
argument_list|()
control|)
block|{
name|font
operator|=
name|formResources
operator|.
name|getFont
argument_list|(
name|fontName
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|cosFontName
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|font
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|boolean
name|isMultiLineValue
parameter_list|(
name|String
name|multiLineValue
parameter_list|)
block|{
return|return
operator|(
name|parent
operator|instanceof
name|PDTextField
operator|&&
operator|(
operator|(
name|PDTextField
operator|)
name|parent
operator|)
operator|.
name|isMultiline
argument_list|()
operator|&&
name|multiLineValue
operator|.
name|contains
argument_list|(
literal|"\n"
argument_list|)
operator|)
return|;
block|}
comment|/**      * Writes the stream to the actual stream in the COSStream.      *      * @throws IOException If there is an error writing to the stream      */
specifier|private
name|void
name|writeToStream
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|PDAppearanceStream
name|appearanceStream
parameter_list|)
throws|throws
name|IOException
block|{
name|OutputStream
name|out
init|=
name|appearanceStream
operator|.
name|getCOSStream
argument_list|()
operator|.
name|createUnfilteredStream
argument_list|()
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * w in an appearance stream represents the lineWidth.      *       * @return the linewidth      */
specifier|private
name|float
name|getLineWidth
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|tokens
parameter_list|)
block|{
name|float
name|retval
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|tokens
operator|!=
literal|null
condition|)
block|{
name|int
name|btIndex
init|=
name|tokens
operator|.
name|indexOf
argument_list|(
name|Operator
operator|.
name|getOperator
argument_list|(
literal|"BT"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|wIndex
init|=
name|tokens
operator|.
name|indexOf
argument_list|(
name|Operator
operator|.
name|getOperator
argument_list|(
literal|"w"
argument_list|)
argument_list|)
decl_stmt|;
comment|// the w should only be used if it is before the first BT.
if|if
condition|(
operator|(
name|wIndex
operator|>
literal|0
operator|)
operator|&&
operator|(
name|wIndex
operator|<
name|btIndex
operator|)
condition|)
block|{
name|retval
operator|=
operator|(
operator|(
name|COSNumber
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|wIndex
operator|-
literal|1
argument_list|)
operator|)
operator|.
name|floatValue
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
specifier|private
name|PDRectangle
name|getSmallestDrawnRectangle
parameter_list|(
name|PDRectangle
name|boundingBox
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|tokens
parameter_list|)
block|{
name|PDRectangle
name|smallest
init|=
name|boundingBox
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tokens
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|next
init|=
name|tokens
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|Operator
operator|.
name|getOperator
argument_list|(
literal|"re"
argument_list|)
condition|)
block|{
name|COSNumber
name|x
init|=
operator|(
name|COSNumber
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|i
operator|-
literal|4
argument_list|)
decl_stmt|;
name|COSNumber
name|y
init|=
operator|(
name|COSNumber
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|i
operator|-
literal|3
argument_list|)
decl_stmt|;
name|COSNumber
name|width
init|=
operator|(
name|COSNumber
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|i
operator|-
literal|2
argument_list|)
decl_stmt|;
name|COSNumber
name|height
init|=
operator|(
name|COSNumber
operator|)
name|tokens
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
name|PDRectangle
name|potentialSmallest
init|=
operator|new
name|PDRectangle
argument_list|()
decl_stmt|;
name|potentialSmallest
operator|.
name|setLowerLeftX
argument_list|(
name|x
operator|.
name|floatValue
argument_list|()
argument_list|)
expr_stmt|;
name|potentialSmallest
operator|.
name|setLowerLeftY
argument_list|(
name|y
operator|.
name|floatValue
argument_list|()
argument_list|)
expr_stmt|;
name|potentialSmallest
operator|.
name|setUpperRightX
argument_list|(
name|x
operator|.
name|floatValue
argument_list|()
operator|+
name|width
operator|.
name|floatValue
argument_list|()
argument_list|)
expr_stmt|;
name|potentialSmallest
operator|.
name|setUpperRightY
argument_list|(
name|y
operator|.
name|floatValue
argument_list|()
operator|+
name|height
operator|.
name|floatValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|smallest
operator|==
literal|null
operator|||
name|smallest
operator|.
name|getLowerLeftX
argument_list|()
operator|<
name|potentialSmallest
operator|.
name|getLowerLeftX
argument_list|()
operator|||
name|smallest
operator|.
name|getUpperRightY
argument_list|()
operator|>
name|potentialSmallest
operator|.
name|getUpperRightY
argument_list|()
condition|)
block|{
name|smallest
operator|=
name|potentialSmallest
expr_stmt|;
block|}
block|}
block|}
return|return
name|smallest
return|;
block|}
comment|/**      * My "not so great" method for calculating the fontsize. It does not work superb, but it      * handles ok.      *       * @return the calculated font-size      *      * @throws IOException If there is an error getting the font height.      */
specifier|private
name|float
name|calculateFontSize
parameter_list|(
name|PDFont
name|pdFont
parameter_list|,
name|PDRectangle
name|boundingBox
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|tokens
parameter_list|)
throws|throws
name|IOException
block|{
name|float
name|fontSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|defaultAppearanceHandler
operator|.
name|getTokens
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fontSize
operator|=
name|defaultAppearanceHandler
operator|.
name|getFontSize
argument_list|()
expr_stmt|;
block|}
name|float
name|widthBasedFontSize
init|=
name|Float
operator|.
name|MAX_VALUE
decl_stmt|;
comment|// TODO review the calculation as this seems to not reflect how Acrobat calculates the font size
if|if
condition|(
name|parent
operator|instanceof
name|PDTextField
operator|&&
operator|(
operator|(
name|PDTextField
operator|)
name|parent
operator|)
operator|.
name|doNotScroll
argument_list|()
condition|)
block|{
comment|// if we don't scroll then we will shrink the font to fit into the text area.
name|float
name|widthAtFontSize1
init|=
name|pdFont
operator|.
name|getStringWidth
argument_list|(
name|value
argument_list|)
operator|/
literal|1000.f
decl_stmt|;
name|float
name|availableWidth
init|=
name|getAvailableWidth
argument_list|(
name|boundingBox
argument_list|,
name|getLineWidth
argument_list|(
name|tokens
argument_list|)
argument_list|)
decl_stmt|;
name|widthBasedFontSize
operator|=
name|availableWidth
operator|/
name|widthAtFontSize1
expr_stmt|;
block|}
if|if
condition|(
name|fontSize
operator|==
literal|0
condition|)
block|{
name|float
name|lineWidth
init|=
name|getLineWidth
argument_list|(
name|tokens
argument_list|)
decl_stmt|;
name|float
name|height
init|=
name|pdFont
operator|.
name|getFontDescriptor
argument_list|()
operator|.
name|getFontBoundingBox
argument_list|()
operator|.
name|getHeight
argument_list|()
operator|/
literal|1000f
decl_stmt|;
name|float
name|availHeight
init|=
name|getAvailableHeight
argument_list|(
name|boundingBox
argument_list|,
name|lineWidth
argument_list|)
decl_stmt|;
name|fontSize
operator|=
name|Math
operator|.
name|min
argument_list|(
operator|(
name|availHeight
operator|/
name|height
operator|)
argument_list|,
name|widthBasedFontSize
argument_list|)
expr_stmt|;
block|}
return|return
name|fontSize
return|;
block|}
comment|/**      * Calculates where to start putting the text in the box. The positioning is not quite as      * accurate as when Acrobat places the elements, but it works though.      *      * @return the sting for representing the start position of the text      *      * @throws IOException If there is an error calculating the text position.      */
specifier|private
name|float
name|getVerticalOffset
parameter_list|(
name|PDRectangle
name|boundingBox
parameter_list|,
name|PDFont
name|pdFont
parameter_list|,
name|float
name|fontSize
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|tokens
parameter_list|)
throws|throws
name|IOException
block|{
name|float
name|lineWidth
init|=
name|getLineWidth
argument_list|(
name|tokens
argument_list|)
decl_stmt|;
name|float
name|verticalOffset
decl_stmt|;
if|if
condition|(
name|parent
operator|instanceof
name|PDTextField
operator|&&
operator|(
operator|(
name|PDTextField
operator|)
name|parent
operator|)
operator|.
name|isMultiline
argument_list|()
condition|)
block|{
name|int
name|rows
init|=
call|(
name|int
call|)
argument_list|(
name|getAvailableHeight
argument_list|(
name|boundingBox
argument_list|,
name|lineWidth
argument_list|)
operator|/
operator|(
operator|(
name|int
operator|)
name|fontSize
operator|)
argument_list|)
decl_stmt|;
name|verticalOffset
operator|=
operator|(
operator|(
name|rows
operator|)
operator|*
name|fontSize
operator|)
operator|-
name|fontSize
expr_stmt|;
block|}
else|else
block|{
comment|// BJL 9/25/2004
comment|// This algorithm is a little bit of black magic. It does
comment|// not appear to be documented anywhere. Through examining a few
comment|// PDF documents and the value that Acrobat places in there I
comment|// have determined that the below method of computing the position
comment|// is correct for certain documents, but maybe not all. It does
comment|// work f1040ez.pdf and Form_1.pdf
name|PDFontDescriptor
name|fd
init|=
name|pdFont
operator|.
name|getFontDescriptor
argument_list|()
decl_stmt|;
name|float
name|bBoxHeight
init|=
name|boundingBox
operator|.
name|getHeight
argument_list|()
decl_stmt|;
name|float
name|fontHeight
init|=
name|fd
operator|.
name|getFontBoundingBox
argument_list|()
operator|.
name|getHeight
argument_list|()
operator|+
literal|2
operator|*
name|fd
operator|.
name|getDescent
argument_list|()
decl_stmt|;
name|fontHeight
operator|=
operator|(
name|fontHeight
operator|/
literal|1000
operator|)
operator|*
name|fontSize
expr_stmt|;
name|verticalOffset
operator|=
operator|(
name|bBoxHeight
operator|-
name|fontHeight
operator|)
operator|/
literal|2
expr_stmt|;
block|}
return|return
name|verticalOffset
return|;
block|}
comment|/**      * calculates the available width of the box.      *       * @return the calculated available width of the box      */
specifier|private
name|float
name|getAvailableWidth
parameter_list|(
name|PDRectangle
name|boundingBox
parameter_list|,
name|float
name|lineWidth
parameter_list|)
block|{
return|return
name|boundingBox
operator|.
name|getWidth
argument_list|()
operator|-
literal|2
operator|*
name|lineWidth
return|;
block|}
comment|/**      * calculates the available height of the box.      *       * @return the calculated available height of the box      */
specifier|private
name|float
name|getAvailableHeight
parameter_list|(
name|PDRectangle
name|boundingBox
parameter_list|,
name|float
name|lineWidth
parameter_list|)
block|{
return|return
name|boundingBox
operator|.
name|getHeight
argument_list|()
operator|-
literal|2
operator|*
name|lineWidth
return|;
block|}
block|}
end_class

end_unit

