begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|ParsePosition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|GregorianCalendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SimpleTimeZone
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_comment
comment|/*  * Date format is described in PDF Reference 1.7 section 3.8.2  * (www.adobe.com/devnet/acrobat/pdfs/pdf_reference_1-7.pdf)  * and also in PDF 32000-1:2008  * (http://www.adobe.com/devnet/acrobat/pdfs/PDF32000_2008.pdf))  * although the latter inexplicably omits the trailing apostrophe.  *  * The interpretation of dates without timezones is unclear.  * The code below assumes that such dates are in UTC+00 (aka GMT).  * This is in keeping with the PDF Reference's assertion that:  *      numerical fields default to zero values.  * However, the Reference does go on to make the cryptic remark:  *      If no UT information is specified, the relationship of the specified  *      time to UT is considered to be unknown. Whether or not the time  *      zone is known, the rest of the date should be specified in local time.  * I understand this to refer to _creating_ a pdf date value. That is,  * code that can get the wall clock time and cannot get the timezone  * should write the wall clock time with a time zone of zero.  * When _parsing_ a PDF date, the statement talks about "the rest of the date"  * being local time, thus explicitly excluding the use of the local time  * for the time zone. */
end_comment

begin_comment
comment|/**  * Converts dates to strings and back using the PDF date standard  * in section 3.8.2 of PDF Reference 1.7.  *  * @author Ben Litchfield  * @author Fred Hansen  *   * TODO Move members of this class elsewhere for shared use in pdfbox and xmpbox.  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|DateConverter
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DateConverter
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|DateConverter
parameter_list|()
block|{     }
comment|// milliseconds/1000 = seconds; seconds / 60 = minutes; minutes/60 = hours
specifier|private
specifier|static
specifier|final
name|int
name|MINUTES_PER_HOUR
init|=
literal|60
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SECONDS_PER_MINUTE
init|=
literal|60
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MILLIS_PER_MINUTE
init|=
name|SECONDS_PER_MINUTE
operator|*
literal|1000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MILLIS_PER_HOUR
init|=
name|MINUTES_PER_HOUR
operator|*
name|MILLIS_PER_MINUTE
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|HALF_DAY
init|=
literal|12
operator|*
name|MINUTES_PER_HOUR
operator|*
name|MILLIS_PER_MINUTE
decl_stmt|,
name|DAY
init|=
literal|2
operator|*
name|HALF_DAY
decl_stmt|;
comment|/*      * The Date format is supposed to be the PDF_DATE_FORMAT, but other      * forms appear. These lists offer alternatives to be tried       * if parseBigEndianDate fails.        *       * The time zone offset generally trails the date string, so it is processed      * separately with parseTZoffset. (This does not preclude having time      * zones in the elements below; one does.)      *       * Alas, SimpleDateFormat is badly non-reentrant -- it modifies its       * calendar field (PDFBox-402), so these lists are strings to create      * SimpleDate format as needed.      *       * Some past entries have been elided because they duplicate existing       * entries. See the API for SimpleDateFormat, which says       *      "For parsing, the number of pattern letters is ignored       *      unless it's needed to separate two adjacent fields."      *       * toCalendar(String, String[]) tests to see that the entire input text      * has been consumed. Therefore the ordering of formats is important.       * If one format begins with the entirety of another, the longer      * must precede the other in the list.      *       * HH is for 0-23 hours and hh for 1-12 hours; an "a" field must follow "hh"      * Where year is yy, four digit years are accepted       * and two digit years are converted to four digits in the range      *      [thisyear-79...thisyear+20]      */
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|ALPHA_START_FORMATS
init|=
block|{
literal|"EEEE, dd MMM yy hh:mm:ss a"
block|,
literal|"EEEE, MMM dd, yy hh:mm:ss a"
block|,
literal|"EEEE, MMM dd, yy 'at' hh:mma"
block|,
comment|// Acrobat Net Distiller 1.0 for Windows
literal|"EEEE, MMM dd, yy"
block|,
comment|// Acrobat Distiller 1.0.2 for Macintosh&& PDFBOX-465
literal|"EEEE MMM dd, yy HH:mm:ss"
block|,
comment|// ECMP5
literal|"EEEE MMM dd HH:mm:ss z yy"
block|,
comment|// GNU Ghostscript 7.0.7
literal|"EEEE MMM dd HH:mm:ss yy"
block|,
comment|// GNU Ghostscript 7.0.7 variant
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|DIGIT_START_FORMATS
init|=
block|{
literal|"dd MMM yy HH:mm:ss"
block|,
comment|// for 26 May 2000 11:25:00
literal|"dd MMM yy HH:mm"
block|,
comment|// for 26 May 2000 11:25
literal|"yyyy MMM d"
block|,
comment|// ambiguity resolved only by omitting time
literal|"yyyymmddhh:mm:ss"
block|,
comment|// test case "200712172:2:3"
literal|"H:m M/d/yy"
block|,
comment|// test case "9:47 5/12/2008"
literal|"M/d/yy HH:mm:ss"
block|,
literal|"M/d/yy HH:mm"
block|,
literal|"M/d/yy"
block|,
comment|// proposed rule that is unreachable due to "dd MMM yy HH:mm:ss"
comment|//     "yyyy MMM d HH:mm:ss",
comment|// rules made unreachable by "M/d/yy HH:mm:ss" "M/d/yy HH:mm"  "M/d/yy",
comment|// (incoming digit strings do not mark themselves as y, m, or d!)
comment|// "d/MM/yyyy HH:mm:ss", // PDFBOX-164 and PDFBOX-170
comment|// "M/dd/yyyy hh:mm:ss",
comment|// "MM/d/yyyy hh:mm:ss",
comment|// "M/d/yyyy HH:mm:ss",
comment|// "M/dd/yyyy",
comment|// "MM/d/yyyy",
comment|// "M/d/yyyy",
comment|// "M/d/yyyy HH:mm:ss",
comment|// "M/d/yy HH:mm:ss",
comment|// subsumed by big-endian parse
comment|// "yyyy-MM-dd'T'HH:mm:ss",
comment|// "yyyy-MM-dd'T'HH:mm:ss",
comment|// "yyyymmdd hh:mm:ss",
comment|// "yyyymmdd",
comment|// "yyyymmddX''00''",  // covers 24 cases
comment|//    (originally the above ended with '+00''00''';
comment|//      the first apostrophe quoted the plus,
comment|//      '' mapped to a single ', and the ''' was invalid)
block|}
decl_stmt|;
comment|/**      * Converts a Calendar to a string formatted as:      *     D:yyyyMMddHHmmss#hh'mm'  where # is Z, +, or -.      *       * @param cal The date to convert to a string. May be null.      * The DST_OFFSET is included when computing the output time zone.      *      * @return The date as a String to be used in a PDF document,       *      or null if the cal value is null      */
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Calendar
name|cal
parameter_list|)
block|{
if|if
condition|(
name|cal
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|offset
init|=
name|formatTZoffset
argument_list|(
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ZONE_OFFSET
argument_list|)
operator|+
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|DST_OFFSET
argument_list|)
argument_list|,
literal|"'"
argument_list|)
decl_stmt|;
return|return
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|US
argument_list|,
literal|"D:"
operator|+
literal|"%1$4tY%1$2tm%1$2td"
comment|// yyyyMMdd
operator|+
literal|"%1$2tH%1$2tM%1$2tS"
comment|// HHmmss
operator|+
literal|"%2$s"
comment|// time zone
operator|+
literal|"'"
argument_list|,
comment|// trailing apostrophe
name|cal
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/**      * Converts the date to ISO 8601 string format:      *     yyyy-mm-ddThh:MM:ss#hh:mm    (where '#" is '+' or '-').      *      * @param cal The date to convert.  Must not be null.      * The DST_OFFSET is included in the output value.      *       * @return The date represented as an ISO 8601 string.      */
specifier|public
specifier|static
name|String
name|toISO8601
parameter_list|(
name|Calendar
name|cal
parameter_list|)
block|{
name|String
name|offset
init|=
name|formatTZoffset
argument_list|(
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ZONE_OFFSET
argument_list|)
operator|+
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|DST_OFFSET
argument_list|)
argument_list|,
literal|":"
argument_list|)
decl_stmt|;
return|return
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|US
argument_list|,
literal|"%1$4tY"
comment|// yyyy
operator|+
literal|"-%1$2tm"
comment|// -mm  (%tm adds one to cal month value)
operator|+
literal|"-%1$2td"
comment|// -dd  (%tm adds one to cal month value)
operator|+
literal|"T"
comment|// T
operator|+
literal|"%1$2tH:%1$2tM:%1$2tS"
comment|// HHmmss
operator|+
literal|"%2$s"
argument_list|,
comment|// time zone
name|cal
argument_list|,
name|offset
argument_list|)
return|;
block|}
comment|/*      * Constrain a timezone offset to the range [-14:00 thru +14:00].      * by adding or subtracting multiples of a full day.      */
specifier|private
specifier|static
name|int
name|restrainTZoffset
parameter_list|(
name|long
name|proposedOffset
parameter_list|)
block|{
if|if
condition|(
name|proposedOffset
operator|<=
literal|14
operator|*
name|MILLIS_PER_HOUR
operator|&&
name|proposedOffset
operator|>=
operator|-
literal|14
operator|*
name|MILLIS_PER_HOUR
condition|)
block|{
comment|// https://www.w3.org/TR/xmlschema-2/#dateTime-timezones
comment|// Timezones between 14:00 and -14:00 are valid
return|return
operator|(
name|int
operator|)
name|proposedOffset
return|;
block|}
comment|// Constrain a timezone offset to the range  [-11:59 thru +12:00].
name|proposedOffset
operator|=
operator|(
operator|(
name|proposedOffset
operator|+
name|HALF_DAY
operator|)
operator|%
name|DAY
operator|+
name|DAY
operator|)
operator|%
name|DAY
expr_stmt|;
if|if
condition|(
name|proposedOffset
operator|==
literal|0
condition|)
block|{
return|return
name|HALF_DAY
return|;
block|}
comment|// 0<= proposedOffset< DAY
name|proposedOffset
operator|=
operator|(
name|proposedOffset
operator|-
name|HALF_DAY
operator|)
operator|%
name|HALF_DAY
expr_stmt|;
comment|// -HALF_DAY< proposedOffset< HALF_DAY
return|return
operator|(
name|int
operator|)
name|proposedOffset
return|;
block|}
comment|/*      * Formats a time zone offset as #hh^mm      * where # is + or -, hh is hours, ^ is a separator, and mm is minutes.      * Any separator may be specified by the second argument;      * the usual values are ":" (ISO 8601), "" (RFC 822), and "'" (PDF).      * The returned value is constrained to the range -11:59 ... 11:59.      * For offset of 0 millis, the String returned is "+00^00", never "Z".      * To get a "general" offset in form GMT#hh:mm, write      *      "GMT"+DateConverter.formatTZoffset(offset, ":");      *      * Take thought in choosing the source for the millis value.       * It can come from calendarValue.getTimeZone() or from       * calendarValue.get(Calendar.ZONE_OFFSET).  If a TimeZone was created      * from a valid time zone ID, then it may have a daylight savings rule.      * (As of July 4, 2013, the data base at http://www.iana.org/time-zones       * recognized 629 time zone regions. But a TimeZone created as       *      new SimpleTimeZone(millisOffset, "ID"),       * will not have a daylight savings rule. (Not even if there is a      * known time zone with the given ID. To get the TimeZone named "xDT"      * with its DST rule, use an ID of EST5EDT, CST6CDT, MST7MDT, or PST8PDT.      *      * When parsing PDF dates, the incoming values DOES NOT have a TIMEZONE value.      * At most it has an OFFSET value like -04'00'. It is generally impossible to       * determine what TIMEZONE corresponds to a given OFFSET. If the date is      * in the summer when daylight savings is in effect, an offset of -0400      * might correspond to any one of the 38 regions (of 53) with standard time       * offset -0400 and no daylight saving. Or it might correspond to       * any one of the 31 regions (out of 43) that observe daylight savings       * and have standard time offset of -0500.      *      * If a Calendar has not been assigned a TimeZone with setTimeZone(),       * it will have by default the local TIMEZONE, not just the OFFSET.  In the      * USA, this TimeZone will have a daylight savings rule.      *      * The offset assigned with calVal.set(Calendar.ZONE_OFFSET) differs      * from the offset in the TimeZone set by Calendar.setTimeZone(). Example:      * Suppose my local TimeZone is America/New_York. It has an offset of -05'00'.      * And suppose I set a GregorianCalendar's ZONE_OFFSET to -07'00'      *     calVal = new GregorianCalendar();   // TimeZone is the local default      *     calVal.set(Calendar.ZONE_OFFSET, -7* MILLIS_PER_HOUR);      * Four different offsets can be computed from calVal:      *     calVal.get(Calendar.ZONE_OFFSET)  =>  -07:00      *     calVal.get(Calendar.ZONE_OFFSET) + calVal.get(Calendar.DST_OFFSET) => -06:00      *     calVal.getTimeZone().getRawOffset()  =>  -05:00      *     calVal.getTimeZone().getOffset(calVal.getTimeInMillis())  =>  -04:00      *      * Which is correct??? I dunno, though setTimeZone() does seem to affect      * ZONE_OFFSET, and not vice versa.  One cannot even test whether TimeZone       * or ZONE_OFFSET has been set; both have been set by initialization code.      * TimeZone is initialized to the local default time zone       * and ZONE_OFFSET is set from it.      *       * My choice in this DateConverter class has been to set the       * initial TimeZone of a GregorianCalendar to GMT. Thereafter      * the TimeZone is modified with {@link #adjustTimeZoneNicely}.      *      * package-private for testing      */
specifier|static
name|String
name|formatTZoffset
parameter_list|(
name|long
name|millis
parameter_list|,
name|String
name|sep
parameter_list|)
block|{
name|SimpleDateFormat
name|sdf
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"Z"
argument_list|)
decl_stmt|;
comment|// #hhmm
name|sdf
operator|.
name|setTimeZone
argument_list|(
operator|new
name|SimpleTimeZone
argument_list|(
name|restrainTZoffset
argument_list|(
name|millis
argument_list|)
argument_list|,
literal|"unknown"
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|tz
init|=
name|sdf
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|tz
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
operator|+
name|sep
operator|+
name|tz
operator|.
name|substring
argument_list|(
literal|3
argument_list|)
return|;
block|}
comment|/*      * Parses an integer from a string, starting at and advancing a ParsePosition.      * Returns The integer that was at the given parse position, or the remedy value      * if no digits were found.      *      * The ParsePosition will be incremented by the number of digits found, but no      * more than maxlen. That is, the ParsePosition will advance across at most      * maxlen initial digits in text. The error index is ignored and unchanged.      *      * maxlen is the maximum length of the integer to parse, usually 2, but 4 for      * year fields. If the field of length maxlen begins with a digit, but contains      * a non-digit, no error is signaled and the integer value is returned.      */
specifier|private
specifier|static
name|int
name|parseTimeField
parameter_list|(
name|String
name|text
parameter_list|,
name|ParsePosition
name|where
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|int
name|remedy
parameter_list|)
block|{
if|if
condition|(
name|text
operator|==
literal|null
condition|)
block|{
return|return
name|remedy
return|;
block|}
comment|// it would seem that DecimalFormat.parse() would be simpler;
comment|// but that class blithely ignores setMaximumIntegerDigits
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|index
init|=
name|where
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|int
name|limit
init|=
name|index
operator|+
name|Math
operator|.
name|min
argument_list|(
name|maxlen
argument_list|,
name|text
operator|.
name|length
argument_list|()
operator|-
name|index
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|index
operator|<
name|limit
condition|;
name|index
operator|++
control|)
block|{
comment|// convert digit to integer
name|int
name|cval
init|=
name|text
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|-
literal|'0'
decl_stmt|;
comment|// test to see if we got a digit
if|if
condition|(
name|cval
argument_list|<
literal|0
operator|||
name|cval
argument_list|>
literal|9
condition|)
block|{
comment|// no digit at index
break|break;
block|}
comment|// append the digit to the return value
name|retval
operator|=
name|retval
operator|*
literal|10
operator|+
name|cval
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
name|where
operator|.
name|getIndex
argument_list|()
condition|)
block|{
return|return
name|remedy
return|;
block|}
name|where
operator|.
name|setIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/*      * Advances the ParsePosition past any and all the characters that match      * those in the optionals list. In particular, a space will skip all spaces.      *      * The start value is incremented by the number of optionals found. The error      * index is ignored and unchanged.      *      * Returns the last non-space character passed over (even if space is not in      * the optionals list.)      */
specifier|private
specifier|static
name|char
name|skipOptionals
parameter_list|(
name|String
name|text
parameter_list|,
name|ParsePosition
name|where
parameter_list|,
name|String
name|optionals
parameter_list|)
block|{
name|char
name|retval
init|=
literal|' '
decl_stmt|;
name|char
name|currch
decl_stmt|;
while|while
condition|(
name|where
operator|.
name|getIndex
argument_list|()
operator|<
name|text
operator|.
name|length
argument_list|()
operator|&&
name|optionals
operator|.
name|indexOf
argument_list|(
operator|(
name|currch
operator|=
name|text
operator|.
name|charAt
argument_list|(
name|where
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|retval
operator|=
operator|(
name|currch
operator|!=
literal|' '
operator|)
condition|?
name|currch
else|:
name|retval
expr_stmt|;
name|where
operator|.
name|setIndex
argument_list|(
name|where
operator|.
name|getIndex
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/*      * If the victim string is at the given position in the text, this method      * advances the position past that string.      *      * `where` is the initial position to look at. After return, this will have      * been incremented by the length of the victim if it was found. The error      * index is ignored and unchanged.      */
specifier|private
specifier|static
name|boolean
name|skipString
parameter_list|(
name|String
name|text
parameter_list|,
name|String
name|victim
parameter_list|,
name|ParsePosition
name|where
parameter_list|)
block|{
if|if
condition|(
name|text
operator|.
name|startsWith
argument_list|(
name|victim
argument_list|,
name|where
operator|.
name|getIndex
argument_list|()
argument_list|)
condition|)
block|{
name|where
operator|.
name|setIndex
argument_list|(
name|where
operator|.
name|getIndex
argument_list|()
operator|+
name|victim
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/*      * Construct a new GregorianCalendar and set defaults.      * Locale is ENGLISH.      * TimeZone is "UTC" (zero offset and no DST).      * Parsing is NOT lenient. Milliseconds are zero.      *      * package-private for testing      */
specifier|static
name|GregorianCalendar
name|newGreg
parameter_list|()
block|{
name|GregorianCalendar
name|retCal
init|=
operator|new
name|GregorianCalendar
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
decl_stmt|;
name|retCal
operator|.
name|setTimeZone
argument_list|(
operator|new
name|SimpleTimeZone
argument_list|(
literal|0
argument_list|,
literal|"UTC"
argument_list|)
argument_list|)
expr_stmt|;
name|retCal
operator|.
name|setLenient
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|retCal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|retCal
return|;
block|}
comment|/*      * Install a TimeZone on a GregorianCalendar without changing the       * hours value. A plain GregorianCalendat.setTimeZone()       * adjusts the Calendar.HOUR value to compensate. This is *BAD*      * (not to say *EVIL*) when we have already set the time.      */
specifier|private
specifier|static
name|void
name|adjustTimeZoneNicely
parameter_list|(
name|GregorianCalendar
name|cal
parameter_list|,
name|TimeZone
name|tz
parameter_list|)
block|{
name|cal
operator|.
name|setTimeZone
argument_list|(
name|tz
argument_list|)
expr_stmt|;
name|int
name|offset
init|=
operator|(
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|ZONE_OFFSET
argument_list|)
operator|+
name|cal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|DST_OFFSET
argument_list|)
operator|)
operator|/
name|MILLIS_PER_MINUTE
decl_stmt|;
name|cal
operator|.
name|add
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/*      * Parses the end of a date string for a time zone and, if one is found,      * sets the time zone of the GregorianCalendar. Otherwise the calendar       * time zone is unchanged.      *       * The text is parsed as      *      (Z|GMT|UTC)? [+- ]* h [': ]? m '?      * where the leading String is optional, h is two digits by default,       * but may be a single digit if followed by one of space, apostrophe,       * colon, or the end of string. Similarly, m is one or two digits.       * This scheme accepts the format of PDF, RFC 822, and ISO8601.       * If none of these applies (as for a time zone name), we try      * TimeZone.getTimeZone().      *      * Scanning begins at where.index. After success, the returned index      * is that of the next character after the recognized string.      *      * package-private for testing      */
specifier|static
name|boolean
name|parseTZoffset
parameter_list|(
name|String
name|text
parameter_list|,
name|GregorianCalendar
name|cal
parameter_list|,
name|ParsePosition
name|initialWhere
parameter_list|)
block|{
name|ParsePosition
name|where
init|=
operator|new
name|ParsePosition
argument_list|(
name|initialWhere
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|TimeZone
name|tz
init|=
operator|new
name|SimpleTimeZone
argument_list|(
literal|0
argument_list|,
literal|"GMT"
argument_list|)
decl_stmt|;
name|int
name|tzHours
decl_stmt|,
name|tzMin
decl_stmt|;
name|char
name|sign
init|=
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|"Z+- "
argument_list|)
decl_stmt|;
name|boolean
name|hadGMT
init|=
operator|(
name|sign
operator|==
literal|'Z'
operator|||
name|skipString
argument_list|(
name|text
argument_list|,
literal|"GMT"
argument_list|,
name|where
argument_list|)
operator|||
name|skipString
argument_list|(
name|text
argument_list|,
literal|"UTC"
argument_list|,
name|where
argument_list|)
operator|)
decl_stmt|;
name|sign
operator|=
operator|(
operator|!
name|hadGMT
operator|)
condition|?
name|sign
else|:
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|"+- "
argument_list|)
expr_stmt|;
name|tzHours
operator|=
name|parseTimeField
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
operator|-
literal|999
argument_list|)
expr_stmt|;
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|"\': "
argument_list|)
expr_stmt|;
name|tzMin
operator|=
name|parseTimeField
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|"\' "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzHours
operator|!=
operator|-
literal|999
condition|)
block|{
comment|// we parsed a time zone in default format
name|int
name|hrSign
init|=
operator|(
name|sign
operator|==
literal|'-'
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
decl_stmt|;
name|tz
operator|.
name|setRawOffset
argument_list|(
name|restrainTZoffset
argument_list|(
name|hrSign
operator|*
operator|(
name|tzHours
operator|*
name|MILLIS_PER_HOUR
operator|+
name|tzMin
operator|*
operator|(
name|long
operator|)
name|MILLIS_PER_MINUTE
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|updateZoneId
argument_list|(
name|tz
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hadGMT
condition|)
block|{
comment|// try to process as a name; "GMT" or "UTC" has already been processed
name|String
name|tzText
init|=
name|text
operator|.
name|substring
argument_list|(
name|initialWhere
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|tz
operator|=
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
name|tzText
argument_list|)
expr_stmt|;
comment|// getTimeZone returns "GMT" for unknown ids
if|if
condition|(
literal|"GMT"
operator|.
name|equals
argument_list|(
name|tz
operator|.
name|getID
argument_list|()
argument_list|)
condition|)
block|{
comment|// no timezone in text, cal amd initialWhere are unchanged
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// we got a tz by name; use it
name|where
operator|.
name|setIndex
argument_list|(
name|text
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|adjustTimeZoneNicely
argument_list|(
name|cal
argument_list|,
name|tz
argument_list|)
expr_stmt|;
name|initialWhere
operator|.
name|setIndex
argument_list|(
name|where
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Update the zone ID based on the raw offset. This is either GMT, GMT+hh:mm or GMT-hh:mm, where      * n is between 1 and 14. The highest negative hour is -14, the highest positive hour is 12.      * Zones that don't fit in this schema are set to zone ID "unknown".      *      * @param tz the time zone to update.      */
specifier|private
specifier|static
name|void
name|updateZoneId
parameter_list|(
name|TimeZone
name|tz
parameter_list|)
block|{
name|int
name|offset
init|=
name|tz
operator|.
name|getRawOffset
argument_list|()
decl_stmt|;
name|char
name|pm
init|=
literal|'+'
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|pm
operator|=
literal|'-'
expr_stmt|;
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
name|int
name|hh
init|=
name|offset
operator|/
literal|3600000
decl_stmt|;
name|int
name|mm
init|=
name|offset
operator|%
literal|3600000
operator|/
literal|60000
decl_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|tz
operator|.
name|setID
argument_list|(
literal|"GMT"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pm
operator|==
literal|'+'
operator|&&
name|hh
operator|<=
literal|12
condition|)
block|{
name|tz
operator|.
name|setID
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|US
argument_list|,
literal|"GMT+%02d:%02d"
argument_list|,
name|hh
argument_list|,
name|mm
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pm
operator|==
literal|'-'
operator|&&
name|hh
operator|<=
literal|14
condition|)
block|{
name|tz
operator|.
name|setID
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|US
argument_list|,
literal|"GMT-%02d:%02d"
argument_list|,
name|hh
argument_list|,
name|mm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tz
operator|.
name|setID
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Parses a big-endian date: year month day hour min sec.      * The year must be four digits. Other fields may be adjacent      * and delimited by length or they may follow appropriate delimiters.      *     year [ -/]* month [ -/]* dayofmonth [ T]* hour [:] min [:] sec [.secFraction]      * If any numeric field is omitted, all following fields must also be omitted.      * No time zone is processed.      *       * Ambiguous dates can produce unexpected results. For example:      *      1970 12 23:08 will parse as 1970 December 23 00:08:00       *       * The parse begins at `where, on return the index      * is advanced to just beyond the last character processed.      * The error index is ignored and unchanged.      */
specifier|private
specifier|static
name|GregorianCalendar
name|parseBigEndianDate
parameter_list|(
name|String
name|text
parameter_list|,
name|ParsePosition
name|initialWhere
parameter_list|)
block|{
name|ParsePosition
name|where
init|=
operator|new
name|ParsePosition
argument_list|(
name|initialWhere
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|year
init|=
name|parseTimeField
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|where
operator|.
name|getIndex
argument_list|()
operator|!=
literal|4
operator|+
name|initialWhere
operator|.
name|getIndex
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|"/- "
argument_list|)
expr_stmt|;
name|int
name|month
init|=
name|parseTimeField
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|// Calendar months are 0...11
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|"/- "
argument_list|)
expr_stmt|;
name|int
name|day
init|=
name|parseTimeField
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|" T"
argument_list|)
expr_stmt|;
name|int
name|hour
init|=
name|parseTimeField
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|int
name|minute
init|=
name|parseTimeField
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|int
name|second
init|=
name|parseTimeField
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
name|nextC
init|=
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|"."
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextC
operator|==
literal|'.'
condition|)
block|{
comment|// fractions of a second: skip up to 19 digits
name|parseTimeField
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|19
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|GregorianCalendar
name|dest
init|=
name|newGreg
argument_list|()
decl_stmt|;
try|try
block|{
name|dest
operator|.
name|set
argument_list|(
name|year
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|)
expr_stmt|;
comment|// trigger limit tests
name|dest
operator|.
name|getTimeInMillis
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ill
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Couldn't parse arguments text:"
operator|+
name|text
operator|+
literal|" initialWhere:"
operator|+
name|initialWhere
argument_list|,
name|ill
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|initialWhere
operator|.
name|setIndex
argument_list|(
name|where
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|initialWhere
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|// dest has at least a year value
return|return
name|dest
return|;
block|}
comment|/*      * See if text can be parsed as a date according to any of a list of      * formats. The time zone may be included as part of the format, or      * omitted in favor of later testing for a trailing time zone.      *       * The parse starts at `where`, upon return it will have been      * incremented to refer to the next non-space character after the date.      * If no date was found, the value is unchanged.      * The error index is ignored and unchanged.      *       * If there is a failure to find a date, or the GregorianCalendar      * for the date that was found. Unless a time zone was      * part of the format, the time zone will be GMT+0      */
specifier|private
specifier|static
name|GregorianCalendar
name|parseSimpleDate
parameter_list|(
name|String
name|text
parameter_list|,
name|String
index|[]
name|fmts
parameter_list|,
name|ParsePosition
name|initialWhere
parameter_list|)
block|{
for|for
control|(
name|String
name|fmt
range|:
name|fmts
control|)
block|{
name|ParsePosition
name|where
init|=
operator|new
name|ParsePosition
argument_list|(
name|initialWhere
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|SimpleDateFormat
name|sdf
init|=
operator|new
name|SimpleDateFormat
argument_list|(
name|fmt
argument_list|,
name|Locale
operator|.
name|ENGLISH
argument_list|)
decl_stmt|;
name|GregorianCalendar
name|retCal
init|=
name|newGreg
argument_list|()
decl_stmt|;
name|sdf
operator|.
name|setCalendar
argument_list|(
name|retCal
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdf
operator|.
name|parse
argument_list|(
name|text
argument_list|,
name|where
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|initialWhere
operator|.
name|setIndex
argument_list|(
name|where
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|initialWhere
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
return|return
name|retCal
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/*      * Parses a String to see if it begins with a date, and if so,       * returns that date. The date must be strictly correct--no       * field may exceed the appropriate limit.      * (That is, the Calendar has setLenient(false).)       * Skips initial spaces, but does NOT check for "D:"      *       * The scan first tries parseBigEndianDate and parseTZoffset      * and then tries parseSimpleDate with appropriate formats,       * again followed by parseTZoffset. If at any stage the entire       * text is consumed, that date value is returned immediately.       * Otherwise the date that consumes the longest initial part      * of the text is returned.      *       * - PDF format dates are among those recognized by parseBigEndianDate.      * - The formats tried are alphaStartFormats or digitStartFormat and      * any listed in the value of moreFmts.      */
specifier|private
specifier|static
name|Calendar
name|parseDate
parameter_list|(
name|String
name|text
parameter_list|,
name|ParsePosition
name|initialWhere
parameter_list|)
block|{
if|if
condition|(
name|text
operator|==
literal|null
operator|||
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// remember longestr date string
name|int
name|longestLen
init|=
operator|-
literal|999999
decl_stmt|;
comment|// theorem: the above value will never be used
comment|// proof: longestLen is only used if longestDate is not null
name|GregorianCalendar
name|longestDate
init|=
literal|null
decl_stmt|;
comment|// null says no date found yet
name|int
name|whereLen
decl_stmt|;
comment|// tempcopy of where.getIndex()
name|ParsePosition
name|where
init|=
operator|new
name|ParsePosition
argument_list|(
name|initialWhere
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
comment|// check for null (throws exception) and trim off surrounding spaces
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|int
name|startPosition
init|=
name|where
operator|.
name|getIndex
argument_list|()
decl_stmt|;
comment|// try big-endian parse
name|GregorianCalendar
name|retCal
init|=
name|parseBigEndianDate
argument_list|(
name|text
argument_list|,
name|where
argument_list|)
decl_stmt|;
comment|// check for success and a timezone
if|if
condition|(
name|retCal
operator|!=
literal|null
operator|&&
operator|(
name|where
operator|.
name|getIndex
argument_list|()
operator|==
name|text
operator|.
name|length
argument_list|()
operator|||
name|parseTZoffset
argument_list|(
name|text
argument_list|,
name|retCal
argument_list|,
name|where
argument_list|)
operator|)
condition|)
block|{
comment|// if text is fully consumed, return the date else remember it and its length
name|whereLen
operator|=
name|where
operator|.
name|getIndex
argument_list|()
expr_stmt|;
if|if
condition|(
name|whereLen
operator|==
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
name|initialWhere
operator|.
name|setIndex
argument_list|(
name|whereLen
argument_list|)
expr_stmt|;
return|return
name|retCal
return|;
block|}
name|longestLen
operator|=
name|whereLen
expr_stmt|;
name|longestDate
operator|=
name|retCal
expr_stmt|;
block|}
comment|// try one of the sets of standard formats
name|where
operator|.
name|setIndex
argument_list|(
name|startPosition
argument_list|)
expr_stmt|;
name|String
index|[]
name|formats
init|=
name|Character
operator|.
name|isDigit
argument_list|(
name|text
operator|.
name|charAt
argument_list|(
name|startPosition
argument_list|)
argument_list|)
condition|?
name|DIGIT_START_FORMATS
else|:
name|ALPHA_START_FORMATS
decl_stmt|;
name|retCal
operator|=
name|parseSimpleDate
argument_list|(
name|text
argument_list|,
name|formats
argument_list|,
name|where
argument_list|)
expr_stmt|;
comment|// check for success and a timezone
if|if
condition|(
name|retCal
operator|!=
literal|null
operator|&&
operator|(
name|where
operator|.
name|getIndex
argument_list|()
operator|==
name|text
operator|.
name|length
argument_list|()
operator|||
name|parseTZoffset
argument_list|(
name|text
argument_list|,
name|retCal
argument_list|,
name|where
argument_list|)
operator|)
condition|)
block|{
comment|// if text is fully consumed, return the date else remember it and its length
name|whereLen
operator|=
name|where
operator|.
name|getIndex
argument_list|()
expr_stmt|;
if|if
condition|(
name|whereLen
operator|==
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
name|initialWhere
operator|.
name|setIndex
argument_list|(
name|whereLen
argument_list|)
expr_stmt|;
return|return
name|retCal
return|;
block|}
if|if
condition|(
name|whereLen
operator|>
name|longestLen
condition|)
block|{
name|longestLen
operator|=
name|whereLen
expr_stmt|;
name|longestDate
operator|=
name|retCal
expr_stmt|;
block|}
block|}
if|if
condition|(
name|longestDate
operator|!=
literal|null
condition|)
block|{
name|initialWhere
operator|.
name|setIndex
argument_list|(
name|longestLen
argument_list|)
expr_stmt|;
return|return
name|longestDate
return|;
block|}
return|return
name|retCal
return|;
block|}
comment|/**      * Returns the Calendar for a given COS string containing a date,      * or {@code null} if it cannot be parsed.      *      * The returned value will have 0 for DST_OFFSET.      *       * @param text A COS string containing a date.      * @return The Calendar that the text string represents, or {@code null} if it cannot be parsed.      */
specifier|public
specifier|static
name|Calendar
name|toCalendar
parameter_list|(
name|COSString
name|text
parameter_list|)
block|{
if|if
condition|(
name|text
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|toCalendar
argument_list|(
name|text
operator|.
name|getString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns the Calendar for a given string containing a date,      * or {@code null} if it cannot be parsed.      *      * The returned value will have 0 for DST_OFFSET.      *      * @param text A COS string containing a date.      * @return The Calendar that the text string represents, or {@code null} if it cannot be parsed.      */
specifier|public
specifier|static
name|Calendar
name|toCalendar
parameter_list|(
name|String
name|text
parameter_list|)
block|{
if|if
condition|(
name|text
operator|==
literal|null
operator|||
name|text
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ParsePosition
name|where
init|=
operator|new
name|ParsePosition
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|skipOptionals
argument_list|(
name|text
argument_list|,
name|where
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|skipString
argument_list|(
name|text
argument_list|,
literal|"D:"
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|Calendar
name|calendar
init|=
name|parseDate
argument_list|(
name|text
argument_list|,
name|where
argument_list|)
decl_stmt|;
if|if
condition|(
name|calendar
operator|==
literal|null
operator|||
name|where
operator|.
name|getIndex
argument_list|()
operator|!=
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// the date string is invalid
return|return
literal|null
return|;
block|}
return|return
name|calendar
return|;
block|}
block|}
end_class

end_unit

