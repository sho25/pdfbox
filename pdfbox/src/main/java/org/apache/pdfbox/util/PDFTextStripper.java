begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|CryptographyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|InvalidPasswordException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|WrappedIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDPage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|COSObjectable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRectangle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|documentnavigation
operator|.
name|outline
operator|.
name|PDOutlineItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|pagenavigation
operator|.
name|PDThreadBead
import|;
end_import

begin_comment
comment|/**  * This class will take a pdf document and strip out all of the text and ignore the  * formatting and such.  Please note; it is up to clients of this class to verify that  * a specific user has the correct permissions to extract text from the  * PDF document.  *   * The basic flow of this process is that we get a document and use a series of   * processXXX() functions that work on smaller and smaller chunks of the page.    * Eventually, we fully process each page and then print it.   *  * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  * @version $Revision: 1.70 $  */
end_comment

begin_class
specifier|public
class|class
name|PDFTextStripper
extends|extends
name|PDFStreamEngine
block|{
specifier|private
specifier|static
specifier|final
name|String
name|thisClassName
init|=
name|PDFTextStripper
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|float
name|DEFAULT_INDENT_THRESHOLD
init|=
literal|2.0f
decl_stmt|;
specifier|private
specifier|static
name|float
name|DEFAULT_DROP_THRESHOLD
init|=
literal|2.5f
decl_stmt|;
comment|//enable the ability to set the default indent/drop thresholds
comment|//with -D system properties:
comment|//    pdftextstripper.indent
comment|//    pdftextstripper.drop
static|static
block|{
name|String
name|prop
init|=
name|thisClassName
operator|+
literal|".indent"
decl_stmt|;
name|String
name|s
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|prop
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
operator|&&
name|s
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|float
name|f
init|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|DEFAULT_INDENT_THRESHOLD
operator|=
name|f
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
comment|//ignore and use default
block|}
block|}
name|prop
operator|=
name|thisClassName
operator|+
literal|".drop"
expr_stmt|;
name|s
operator|=
name|System
operator|.
name|getProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
operator|&&
name|s
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|float
name|f
init|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|DEFAULT_DROP_THRESHOLD
operator|=
name|f
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
comment|//ignore and use default
block|}
block|}
block|}
comment|/**      * The platforms line separator.      */
specifier|protected
specifier|final
name|String
name|systemLineSeparator
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
specifier|private
name|String
name|lineSeparator
init|=
name|systemLineSeparator
decl_stmt|;
specifier|private
name|String
name|pageSeparator
init|=
name|systemLineSeparator
decl_stmt|;
specifier|private
name|String
name|wordSeparator
init|=
literal|" "
decl_stmt|;
specifier|private
name|String
name|paragraphStart
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|paragraphEnd
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|pageStart
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|pageEnd
init|=
name|pageSeparator
decl_stmt|;
specifier|private
name|String
name|articleStart
init|=
literal|""
decl_stmt|;
specifier|private
name|String
name|articleEnd
init|=
literal|""
decl_stmt|;
specifier|private
name|int
name|currentPageNo
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|startPage
init|=
literal|1
decl_stmt|;
specifier|private
name|int
name|endPage
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
name|PDOutlineItem
name|startBookmark
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|startBookmarkPageNumber
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|PDOutlineItem
name|endBookmark
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|endBookmarkPageNumber
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|suppressDuplicateOverlappingText
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|shouldSeparateByBeads
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|sortByPosition
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|addMoreFormatting
init|=
literal|false
decl_stmt|;
specifier|private
name|float
name|indentThreshold
init|=
name|DEFAULT_INDENT_THRESHOLD
decl_stmt|;
specifier|private
name|float
name|dropThreshold
init|=
name|DEFAULT_DROP_THRESHOLD
decl_stmt|;
comment|// We will need to estimate where to add spaces.
comment|// These are used to help guess.
specifier|private
name|float
name|spacingTolerance
init|=
literal|.5f
decl_stmt|;
specifier|private
name|float
name|averageCharTolerance
init|=
literal|.3f
decl_stmt|;
specifier|private
name|List
argument_list|<
name|PDThreadBead
argument_list|>
name|pageArticles
init|=
literal|null
decl_stmt|;
comment|/**      * The charactersByArticle is used to extract text by article divisions.  For example      * a PDF that has two columns like a newspaper, we want to extract the first column and      * then the second column.  In this example the PDF would have 2 beads(or articles), one for      * each column.  The size of the charactersByArticle would be 5, because not all text on the      * screen will fall into one of the articles.  The five divisions are shown below      *      * Text before first article      * first article text      * text between first article and second article      * second article text      * text after second article      *      * Most PDFs won't have any beads, so charactersByArticle will contain a single entry.      */
specifier|protected
name|Vector
argument_list|<
name|List
argument_list|<
name|TextPosition
argument_list|>
argument_list|>
name|charactersByArticle
init|=
operator|new
name|Vector
argument_list|<
name|List
argument_list|<
name|TextPosition
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|TreeMap
argument_list|<
name|Float
argument_list|,
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|>
argument_list|>
name|characterListMapping
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|TreeMap
argument_list|<
name|Float
argument_list|,
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * encoding that text will be written in (or null).      */
specifier|protected
name|String
name|outputEncoding
decl_stmt|;
comment|/**      * The document to read.      */
specifier|protected
name|PDDocument
name|document
decl_stmt|;
comment|/**      * The stream to write the output to.      */
specifier|protected
name|Writer
name|output
decl_stmt|;
comment|/**      * The normalizer is used to remove text ligatures/presentation forms      * and to correct the direction of right to left text, such as Arabic and Hebrew.      */
specifier|private
name|TextNormalize
name|normalize
init|=
literal|null
decl_stmt|;
comment|/**      * True if we started a paragraph but haven't ended it      * yet.      */
specifier|private
name|boolean
name|inParagraph
decl_stmt|;
comment|/**      * Instantiate a new PDFTextStripper object. This object will load      * properties from PDFTextStripper.properties and will not do      * anything special to convert the text to a more encoding-specific      * output.      *      * @throws IOException If there is an error loading the properties.      */
specifier|public
name|PDFTextStripper
parameter_list|()
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|ResourceLoader
operator|.
name|loadProperties
argument_list|(
literal|"org/apache/pdfbox/resources/PDFTextStripper.properties"
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputEncoding
operator|=
literal|null
expr_stmt|;
name|normalize
operator|=
operator|new
name|TextNormalize
argument_list|(
name|this
operator|.
name|outputEncoding
argument_list|)
expr_stmt|;
block|}
comment|/**      * Instantiate a new PDFTextStripper object.  Loading all of the operator mappings      * from the properties object that is passed in.  Does not convert the text      * to more encoding-specific output.      *      * @param props The properties containing the mapping of operators to PDFOperator      * classes.      *      * @throws IOException If there is an error reading the properties.      */
specifier|public
name|PDFTextStripper
parameter_list|(
name|Properties
name|props
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputEncoding
operator|=
literal|null
expr_stmt|;
name|normalize
operator|=
operator|new
name|TextNormalize
argument_list|(
name|this
operator|.
name|outputEncoding
argument_list|)
expr_stmt|;
block|}
comment|/**      * Instantiate a new PDFTextStripper object. This object will load      * properties from PDFTextStripper.properties and will apply      * encoding-specific conversions to the output text.      *      * @param encoding The encoding that the output will be written in.      * @throws IOException If there is an error reading the properties.      */
specifier|public
name|PDFTextStripper
parameter_list|(
name|String
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|ResourceLoader
operator|.
name|loadProperties
argument_list|(
literal|"org/apache/pdfbox/resources/PDFTextStripper.properties"
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|outputEncoding
operator|=
name|encoding
expr_stmt|;
name|normalize
operator|=
operator|new
name|TextNormalize
argument_list|(
name|this
operator|.
name|outputEncoding
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will return the text of a document.  See writeText.<br />      * NOTE: The document must not be encrypted when coming into this method.      *      * @param doc The document to get the text from.      *      * @return The text of the PDF document.      *      * @throws IOException if the doc state is invalid or it is encrypted.      */
specifier|public
name|String
name|getText
parameter_list|(
name|PDDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|StringWriter
name|outputStream
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|writeText
argument_list|(
name|doc
argument_list|,
name|outputStream
argument_list|)
expr_stmt|;
return|return
name|outputStream
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * @deprecated      * @see PDFTextStripper#getText( PDDocument )      * @param doc The document to extract the text from.      * @return The document text.      * @throws IOException If there is an error extracting the text.      */
specifier|public
name|String
name|getText
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getText
argument_list|(
operator|new
name|PDDocument
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * @deprecated      * @see PDFTextStripper#writeText( PDDocument, Writer )      * @param doc The document to extract the text.      * @param outputStream The stream to write the text to.      * @throws IOException If there is an error extracting the text.      */
specifier|public
name|void
name|writeText
parameter_list|(
name|COSDocument
name|doc
parameter_list|,
name|Writer
name|outputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|writeText
argument_list|(
operator|new
name|PDDocument
argument_list|(
name|doc
argument_list|)
argument_list|,
name|outputStream
argument_list|)
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|void
name|resetEngine
parameter_list|()
block|{
name|super
operator|.
name|resetEngine
argument_list|()
expr_stmt|;
name|currentPageNo
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * This will take a PDDocument and write the text of that document to the print writer.      *      * @param doc The document to get the data from.      * @param outputStream The location to put the text.      *      * @throws IOException If the doc is in an invalid state.      */
specifier|public
name|void
name|writeText
parameter_list|(
name|PDDocument
name|doc
parameter_list|,
name|Writer
name|outputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|resetEngine
argument_list|()
expr_stmt|;
name|document
operator|=
name|doc
expr_stmt|;
name|output
operator|=
name|outputStream
expr_stmt|;
if|if
condition|(
name|getAddMoreFormatting
argument_list|()
condition|)
block|{
name|paragraphEnd
operator|=
name|lineSeparator
expr_stmt|;
name|pageStart
operator|=
name|lineSeparator
expr_stmt|;
name|articleStart
operator|=
name|lineSeparator
expr_stmt|;
name|articleEnd
operator|=
name|lineSeparator
expr_stmt|;
block|}
name|startDocument
argument_list|(
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|document
operator|.
name|isEncrypted
argument_list|()
condition|)
block|{
comment|// We are expecting non-encrypted documents here, but it is common
comment|// for users to pass in a document that is encrypted with an empty
comment|// password (such a document appears to not be encrypted by
comment|// someone viewing the document, thus the confusion).  We will
comment|// attempt to decrypt with the empty password to handle this case.
comment|//
try|try
block|{
name|document
operator|.
name|decrypt
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CryptographyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|WrappedIOException
argument_list|(
literal|"Error decrypting document, details: "
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvalidPasswordException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|WrappedIOException
argument_list|(
literal|"Error: document is encrypted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|processPages
argument_list|(
name|document
operator|.
name|getDocumentCatalog
argument_list|()
operator|.
name|getAllPages
argument_list|()
argument_list|)
expr_stmt|;
name|endDocument
argument_list|(
name|document
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will process all of the pages and the text that is in them.      *      * @param pages The pages object in the document.      *      * @throws IOException If there is an error parsing the text.      */
specifier|protected
name|void
name|processPages
parameter_list|(
name|List
argument_list|<
name|COSObjectable
argument_list|>
name|pages
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startBookmark
operator|!=
literal|null
condition|)
block|{
name|startBookmarkPageNumber
operator|=
name|getPageNumber
argument_list|(
name|startBookmark
argument_list|,
name|pages
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endBookmark
operator|!=
literal|null
condition|)
block|{
name|endBookmarkPageNumber
operator|=
name|getPageNumber
argument_list|(
name|endBookmark
argument_list|,
name|pages
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|startBookmarkPageNumber
operator|==
operator|-
literal|1
operator|&&
name|startBookmark
operator|!=
literal|null
operator|&&
name|endBookmarkPageNumber
operator|==
operator|-
literal|1
operator|&&
name|endBookmark
operator|!=
literal|null
operator|&&
name|startBookmark
operator|.
name|getCOSObject
argument_list|()
operator|==
name|endBookmark
operator|.
name|getCOSObject
argument_list|()
condition|)
block|{
comment|//this is a special case where both the start and end bookmark
comment|//are the same but point to nothing.  In this case
comment|//we will not extract any text.
name|startBookmarkPageNumber
operator|=
literal|0
expr_stmt|;
name|endBookmarkPageNumber
operator|=
literal|0
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|COSObjectable
argument_list|>
name|pageIter
init|=
name|pages
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|pageIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|PDPage
name|nextPage
init|=
operator|(
name|PDPage
operator|)
name|pageIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|PDStream
name|contentStream
init|=
name|nextPage
operator|.
name|getContents
argument_list|()
decl_stmt|;
name|currentPageNo
operator|++
expr_stmt|;
if|if
condition|(
name|contentStream
operator|!=
literal|null
condition|)
block|{
name|COSStream
name|contents
init|=
name|contentStream
operator|.
name|getStream
argument_list|()
decl_stmt|;
name|processPage
argument_list|(
name|nextPage
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|int
name|getPageNumber
parameter_list|(
name|PDOutlineItem
name|bookmark
parameter_list|,
name|List
argument_list|<
name|COSObjectable
argument_list|>
name|allPages
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|pageNumber
init|=
operator|-
literal|1
decl_stmt|;
name|PDPage
name|page
init|=
name|bookmark
operator|.
name|findDestinationPage
argument_list|(
name|document
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
name|pageNumber
operator|=
name|allPages
operator|.
name|indexOf
argument_list|(
name|page
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|//use one based indexing
block|}
return|return
name|pageNumber
return|;
block|}
comment|/**      * This method is available for subclasses of this class.  It will be called before processing      * of the document start.      *      * @param pdf The PDF document that is being processed.      * @throws IOException If an IO error occurs.      */
specifier|protected
name|void
name|startDocument
parameter_list|(
name|PDDocument
name|pdf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// no default implementation, but available for subclasses
block|}
comment|/**      * This method is available for subclasses of this class.  It will be called after processing      * of the document finishes.      *      * @param pdf The PDF document that is being processed.      * @throws IOException If an IO error occurs.      */
specifier|protected
name|void
name|endDocument
parameter_list|(
name|PDDocument
name|pdf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// no default implementation, but available for subclasses
block|}
comment|/**      * This will process the contents of a page.      *      * @param page The page to process.      * @param content The contents of the page.      *      * @throws IOException If there is an error processing the page.      */
specifier|protected
name|void
name|processPage
parameter_list|(
name|PDPage
name|page
parameter_list|,
name|COSStream
name|content
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentPageNo
operator|>=
name|startPage
operator|&&
name|currentPageNo
operator|<=
name|endPage
operator|&&
operator|(
name|startBookmarkPageNumber
operator|==
operator|-
literal|1
operator|||
name|currentPageNo
operator|>=
name|startBookmarkPageNumber
operator|)
operator|&&
operator|(
name|endBookmarkPageNumber
operator|==
operator|-
literal|1
operator|||
name|currentPageNo
operator|<=
name|endBookmarkPageNumber
operator|)
condition|)
block|{
name|startPage
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|pageArticles
operator|=
name|page
operator|.
name|getThreadBeads
argument_list|()
expr_stmt|;
name|int
name|numberOfArticleSections
init|=
literal|1
operator|+
name|pageArticles
operator|.
name|size
argument_list|()
operator|*
literal|2
decl_stmt|;
if|if
condition|(
operator|!
name|shouldSeparateByBeads
condition|)
block|{
name|numberOfArticleSections
operator|=
literal|1
expr_stmt|;
block|}
name|int
name|originalSize
init|=
name|charactersByArticle
operator|.
name|size
argument_list|()
decl_stmt|;
name|charactersByArticle
operator|.
name|setSize
argument_list|(
name|numberOfArticleSections
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfArticleSections
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|numberOfArticleSections
operator|<
name|originalSize
condition|)
block|{
operator|(
operator|(
name|List
argument_list|<
name|TextPosition
argument_list|>
operator|)
name|charactersByArticle
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|charactersByArticle
operator|.
name|set
argument_list|(
name|i
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|TextPosition
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|characterListMapping
operator|.
name|clear
argument_list|()
expr_stmt|;
name|processStream
argument_list|(
name|page
argument_list|,
name|page
operator|.
name|findResources
argument_list|()
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|writePage
argument_list|()
expr_stmt|;
name|endPage
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Start a new article, which is typically defined as a column      * on a single page (also referred to as a bead).  This assumes      * that the primary direction of text is left to right.        * Default implementation is to do nothing.  Subclasses      * may provide additional information.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|startArticle
parameter_list|()
throws|throws
name|IOException
block|{
name|startArticle
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Start a new article, which is typically defined as a column      * on a single page (also referred to as a bead).        * Default implementation is to do nothing.  Subclasses      * may provide additional information.      *      * @param isltr true if primary direction of text is left to right.      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|startArticle
parameter_list|(
name|boolean
name|isltr
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getArticleStart
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * End an article.  Default implementation is to do nothing.  Subclasses      * may provide additional information.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|endArticle
parameter_list|()
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getArticleEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Start a new page.  Default implementation is to do nothing.  Subclasses      * may provide additional information.      *      * @param page The page we are about to process.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|startPage
parameter_list|(
name|PDPage
name|page
parameter_list|)
throws|throws
name|IOException
block|{
comment|//default is to do nothing.
block|}
comment|/**      * End a page.  Default implementation is to do nothing.  Subclasses      * may provide additional information.      *      * @param page The page we are about to process.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|endPage
parameter_list|(
name|PDPage
name|page
parameter_list|)
throws|throws
name|IOException
block|{
comment|//default is to do nothing
block|}
specifier|private
specifier|static
specifier|final
name|float
name|ENDOFLASTTEXTX_RESET_VALUE
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|MAXYFORLINE_RESET_VALUE
init|=
operator|-
name|Float
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|EXPECTEDSTARTOFNEXTWORDX_RESET_VALUE
init|=
operator|-
name|Float
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|MAXHEIGHTFORLINE_RESET_VALUE
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|MINYTOPFORLINE_RESET_VALUE
init|=
name|Float
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|LASTWORDSPACING_RESET_VALUE
init|=
operator|-
literal|1
decl_stmt|;
comment|/**      * This will print the text of the processed page to "output".      * It will estimate, based on the coordinates of the text, where      * newlines and word spacings should be placed. The text will be      * sorted only if that feature was enabled.       *      * @throws IOException If there is an error writing the text.      */
specifier|protected
name|void
name|writePage
parameter_list|()
throws|throws
name|IOException
block|{
name|float
name|maxYForLine
init|=
name|MAXYFORLINE_RESET_VALUE
decl_stmt|;
name|float
name|minYTopForLine
init|=
name|MINYTOPFORLINE_RESET_VALUE
decl_stmt|;
name|float
name|endOfLastTextX
init|=
name|ENDOFLASTTEXTX_RESET_VALUE
decl_stmt|;
name|float
name|lastWordSpacing
init|=
name|LASTWORDSPACING_RESET_VALUE
decl_stmt|;
name|float
name|maxHeightForLine
init|=
name|MAXHEIGHTFORLINE_RESET_VALUE
decl_stmt|;
name|PositionWrapper
name|lastPosition
init|=
literal|null
decl_stmt|;
name|PositionWrapper
name|lastLineStartPosition
init|=
literal|null
decl_stmt|;
name|boolean
name|startOfPage
init|=
literal|true
decl_stmt|;
comment|//flag to indicate start of page
name|boolean
name|startOfArticle
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|charactersByArticle
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|writePageStart
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|charactersByArticle
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|TextPosition
argument_list|>
name|textList
init|=
name|charactersByArticle
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|getSortByPosition
argument_list|()
condition|)
block|{
name|TextPositionComparator
name|comparator
init|=
operator|new
name|TextPositionComparator
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|textList
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|TextPosition
argument_list|>
name|textIter
init|=
name|textList
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|/* Before we can display the text, we need to do some normalizing.              * Arabic and Hebrew text is right to left and is typically stored              * in its logical format, which means that the rightmost character is              * stored first, followed by the second character from the right etc.              * However, PDF stores the text in presentation form, which is left to              * right.  We need to do some normalization to convert the PDF data to              * the proper logical output format.              *              * Note that if we did not sort the text, then the output of reversing the              * text is undefined and can sometimes produce worse output then not trying              * to reverse the order.  Sorting should be done for these languages.              * */
comment|/* First step is to determine if we have any right to left text, and              * if so, is it dominant. */
name|int
name|ltrCnt
init|=
literal|0
decl_stmt|;
name|int
name|rtlCnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|textIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|TextPosition
name|position
init|=
operator|(
name|TextPosition
operator|)
name|textIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|stringValue
init|=
name|position
operator|.
name|getCharacter
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|stringValue
operator|.
name|length
argument_list|()
condition|;
name|a
operator|++
control|)
block|{
name|byte
name|dir
init|=
name|Character
operator|.
name|getDirectionality
argument_list|(
name|stringValue
operator|.
name|charAt
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dir
operator|==
name|Character
operator|.
name|DIRECTIONALITY_LEFT_TO_RIGHT
operator|)
operator|||
operator|(
name|dir
operator|==
name|Character
operator|.
name|DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING
operator|)
operator|||
operator|(
name|dir
operator|==
name|Character
operator|.
name|DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE
operator|)
condition|)
block|{
name|ltrCnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dir
operator|==
name|Character
operator|.
name|DIRECTIONALITY_RIGHT_TO_LEFT
operator|)
operator|||
operator|(
name|dir
operator|==
name|Character
operator|.
name|DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC
operator|)
operator|||
operator|(
name|dir
operator|==
name|Character
operator|.
name|DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING
operator|)
operator|||
operator|(
name|dir
operator|==
name|Character
operator|.
name|DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE
operator|)
condition|)
block|{
name|rtlCnt
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|// choose the dominant direction
name|boolean
name|isRtlDominant
init|=
name|rtlCnt
operator|>
name|ltrCnt
decl_stmt|;
name|startArticle
argument_list|(
operator|!
name|isRtlDominant
argument_list|)
expr_stmt|;
name|startOfArticle
operator|=
literal|true
expr_stmt|;
comment|// we will later use this to skip reordering
name|boolean
name|hasRtl
init|=
name|rtlCnt
operator|>
literal|0
decl_stmt|;
comment|/* Now cycle through to print the text.              * We queue up a line at a time before we print so that we can convert              * the line from presentation form to logical form (if needed).               */
name|List
argument_list|<
name|TextPosition
argument_list|>
name|line
init|=
operator|new
name|ArrayList
argument_list|<
name|TextPosition
argument_list|>
argument_list|()
decl_stmt|;
name|textIter
operator|=
name|textList
operator|.
name|iterator
argument_list|()
expr_stmt|;
comment|// start from the beginning again
comment|/* PDF files don't always store spaces. We will need to guess where we should add              * spaces based on the distances between TextPositions. Historically, this was done              * based on the size of the space character provided by the font. In general, this worked              * but there were cases where it did not work. Calculating the average character width              * and using that as a metric works better in some cases but fails in some cases where the              * spacing worked. So we use both. NOTE: Adobe reader also fails on some of these examples.              */
comment|//Keeps track of the previous average character width
name|float
name|previousAveCharWidth
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|textIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|TextPosition
name|position
init|=
operator|(
name|TextPosition
operator|)
name|textIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|PositionWrapper
name|current
init|=
operator|new
name|PositionWrapper
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|String
name|characterValue
init|=
name|position
operator|.
name|getCharacter
argument_list|()
decl_stmt|;
comment|//Resets the average character width when we see a change in font
comment|// or a change in the font size
if|if
condition|(
name|lastPosition
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|position
operator|.
name|getFont
argument_list|()
operator|!=
name|lastPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getFont
argument_list|()
operator|)
operator|||
operator|(
name|position
operator|.
name|getFontSize
argument_list|()
operator|!=
name|lastPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getFontSize
argument_list|()
operator|)
operator|)
condition|)
block|{
name|previousAveCharWidth
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|float
name|positionX
decl_stmt|;
name|float
name|positionY
decl_stmt|;
name|float
name|positionWidth
decl_stmt|;
name|float
name|positionHeight
decl_stmt|;
comment|/* If we are sorting, then we need to use the text direction                  * adjusted coordinates, because they were used in the sorting. */
if|if
condition|(
name|getSortByPosition
argument_list|()
condition|)
block|{
name|positionX
operator|=
name|position
operator|.
name|getXDirAdj
argument_list|()
expr_stmt|;
name|positionY
operator|=
name|position
operator|.
name|getYDirAdj
argument_list|()
expr_stmt|;
name|positionWidth
operator|=
name|position
operator|.
name|getWidthDirAdj
argument_list|()
expr_stmt|;
name|positionHeight
operator|=
name|position
operator|.
name|getHeightDir
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|positionX
operator|=
name|position
operator|.
name|getX
argument_list|()
expr_stmt|;
name|positionY
operator|=
name|position
operator|.
name|getY
argument_list|()
expr_stmt|;
name|positionWidth
operator|=
name|position
operator|.
name|getWidth
argument_list|()
expr_stmt|;
name|positionHeight
operator|=
name|position
operator|.
name|getHeight
argument_list|()
expr_stmt|;
block|}
comment|//The current amount of characters in a word
name|int
name|wordCharCount
init|=
name|position
operator|.
name|getIndividualWidths
argument_list|()
operator|.
name|length
decl_stmt|;
comment|/* Estimate the expected width of the space based on the                  * space character with some margin. */
name|float
name|wordSpacing
init|=
name|position
operator|.
name|getWidthOfSpace
argument_list|()
decl_stmt|;
name|float
name|deltaSpace
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|wordSpacing
operator|==
literal|0
operator|)
operator|||
operator|(
name|wordSpacing
operator|==
name|Float
operator|.
name|NaN
operator|)
condition|)
block|{
name|deltaSpace
operator|=
name|Float
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lastWordSpacing
operator|<
literal|0
condition|)
block|{
name|deltaSpace
operator|=
operator|(
name|wordSpacing
operator|*
name|getSpacingTolerance
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
block|{
name|deltaSpace
operator|=
operator|(
operator|(
operator|(
name|wordSpacing
operator|+
name|lastWordSpacing
operator|)
operator|/
literal|2f
operator|)
operator|*
name|getSpacingTolerance
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
comment|/* Estimate the expected width of the space based on the                  * average character width with some margin. This calculation does not                  * make a true average (average of averages) but we found that it gave the                  * best results after numerous experiments. Based on experiments we also found that                  * .3 worked well. */
name|float
name|averageCharWidth
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|previousAveCharWidth
operator|<
literal|0
condition|)
block|{
name|averageCharWidth
operator|=
operator|(
name|positionWidth
operator|/
name|wordCharCount
operator|)
expr_stmt|;
block|}
else|else
block|{
name|averageCharWidth
operator|=
operator|(
name|previousAveCharWidth
operator|+
operator|(
name|positionWidth
operator|/
name|wordCharCount
operator|)
operator|)
operator|/
literal|2f
expr_stmt|;
block|}
name|float
name|deltaCharWidth
init|=
operator|(
name|averageCharWidth
operator|*
name|getAverageCharTolerance
argument_list|()
operator|)
decl_stmt|;
comment|//Compares the values obtained by the average method and the wordSpacing method and picks
comment|//the smaller number.
name|float
name|expectedStartOfNextWordX
init|=
name|EXPECTEDSTARTOFNEXTWORDX_RESET_VALUE
decl_stmt|;
if|if
condition|(
name|endOfLastTextX
operator|!=
name|ENDOFLASTTEXTX_RESET_VALUE
condition|)
block|{
if|if
condition|(
name|deltaCharWidth
operator|>
name|deltaSpace
condition|)
block|{
name|expectedStartOfNextWordX
operator|=
name|endOfLastTextX
operator|+
name|deltaSpace
expr_stmt|;
block|}
else|else
block|{
name|expectedStartOfNextWordX
operator|=
name|endOfLastTextX
operator|+
name|deltaCharWidth
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lastPosition
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|startOfArticle
condition|)
block|{
name|lastPosition
operator|.
name|setArticleStart
argument_list|()
expr_stmt|;
name|startOfArticle
operator|=
literal|false
expr_stmt|;
block|}
comment|// RDD - Here we determine whether this text object is on the current
comment|// line.  We use the lastBaselineFontSize to handle the superscript
comment|// case, and the size of the current font to handle the subscript case.
comment|// Text must overlap with the last rendered baseline text by at least
comment|// a small amount in order to be considered as being on the same line.
comment|/* XXX BC: In theory, this check should really check if the next char is in full range                      * seen in this line. This is what I tried to do with minYTopForLine, but this caused a lot                      * of regression test failures.  So, I'm leaving it be for now. */
if|if
condition|(
operator|!
name|overlap
argument_list|(
name|positionY
argument_list|,
name|positionHeight
argument_list|,
name|maxYForLine
argument_list|,
name|maxHeightForLine
argument_list|)
condition|)
block|{
name|writeLine
argument_list|(
name|normalize
argument_list|(
name|line
argument_list|,
name|isRtlDominant
argument_list|,
name|hasRtl
argument_list|)
argument_list|,
name|isRtlDominant
argument_list|)
expr_stmt|;
name|line
operator|.
name|clear
argument_list|()
expr_stmt|;
name|lastLineStartPosition
operator|=
name|handleLineSeparation
argument_list|(
name|current
argument_list|,
name|lastPosition
argument_list|,
name|lastLineStartPosition
argument_list|,
name|maxHeightForLine
argument_list|)
expr_stmt|;
name|endOfLastTextX
operator|=
name|ENDOFLASTTEXTX_RESET_VALUE
expr_stmt|;
name|expectedStartOfNextWordX
operator|=
name|EXPECTEDSTARTOFNEXTWORDX_RESET_VALUE
expr_stmt|;
name|maxYForLine
operator|=
name|MAXYFORLINE_RESET_VALUE
expr_stmt|;
name|maxHeightForLine
operator|=
name|MAXHEIGHTFORLINE_RESET_VALUE
expr_stmt|;
name|minYTopForLine
operator|=
name|MINYTOPFORLINE_RESET_VALUE
expr_stmt|;
block|}
comment|//Test if our TextPosition starts after a new word would be expected to start.
if|if
condition|(
name|expectedStartOfNextWordX
operator|!=
name|EXPECTEDSTARTOFNEXTWORDX_RESET_VALUE
operator|&&
name|expectedStartOfNextWordX
operator|<
name|positionX
operator|&&
comment|//only bother adding a space if the last character was not a space
name|lastPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getCharacter
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|lastPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getCharacter
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|" "
argument_list|)
condition|)
block|{
name|line
operator|.
name|add
argument_list|(
name|WordSeparator
operator|.
name|getSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|positionY
operator|>=
name|maxYForLine
condition|)
block|{
name|maxYForLine
operator|=
name|positionY
expr_stmt|;
block|}
comment|// RDD - endX is what PDF considers to be the x coordinate of the
comment|// end position of the text.  We use it in computing our metrics below.
name|endOfLastTextX
operator|=
name|positionX
operator|+
name|positionWidth
expr_stmt|;
comment|// add it to the list
if|if
condition|(
name|characterValue
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|startOfPage
operator|&&
name|lastPosition
operator|==
literal|null
condition|)
block|{
name|writeParagraphStart
argument_list|()
expr_stmt|;
comment|//not sure this is correct for RTL?
block|}
name|line
operator|.
name|add
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
name|maxHeightForLine
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxHeightForLine
argument_list|,
name|positionHeight
argument_list|)
expr_stmt|;
name|minYTopForLine
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minYTopForLine
argument_list|,
name|positionY
operator|-
name|positionHeight
argument_list|)
expr_stmt|;
name|lastPosition
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|startOfPage
condition|)
block|{
name|lastPosition
operator|.
name|setParagraphStart
argument_list|()
expr_stmt|;
name|lastPosition
operator|.
name|setLineStart
argument_list|()
expr_stmt|;
name|lastLineStartPosition
operator|=
name|lastPosition
expr_stmt|;
name|startOfPage
operator|=
literal|false
expr_stmt|;
block|}
name|lastWordSpacing
operator|=
name|wordSpacing
expr_stmt|;
name|previousAveCharWidth
operator|=
name|averageCharWidth
expr_stmt|;
block|}
comment|// print the final line
if|if
condition|(
name|line
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|writeLine
argument_list|(
name|normalize
argument_list|(
name|line
argument_list|,
name|isRtlDominant
argument_list|,
name|hasRtl
argument_list|)
argument_list|,
name|isRtlDominant
argument_list|)
expr_stmt|;
name|writeParagraphEnd
argument_list|()
expr_stmt|;
block|}
name|endArticle
argument_list|()
expr_stmt|;
block|}
name|writePageEnd
argument_list|()
expr_stmt|;
block|}
specifier|private
name|boolean
name|overlap
parameter_list|(
name|float
name|y1
parameter_list|,
name|float
name|height1
parameter_list|,
name|float
name|y2
parameter_list|,
name|float
name|height2
parameter_list|)
block|{
return|return
name|within
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|,
literal|.1f
argument_list|)
operator|||
operator|(
name|y2
operator|<=
name|y1
operator|&&
name|y2
operator|>=
name|y1
operator|-
name|height1
operator|)
operator|||
operator|(
name|y1
operator|<=
name|y2
operator|&&
name|y1
operator|>=
name|y2
operator|-
name|height2
operator|)
return|;
block|}
comment|/**      * Write the page separator value to the output stream.      * @throws IOException      *             If there is a problem writing out the pageseparator to the document.      */
specifier|protected
name|void
name|writePageSeperator
parameter_list|()
throws|throws
name|IOException
block|{
comment|// RDD - newline at end of flush - required for end of page (so that the top
comment|// of the next page starts on its own line.
comment|//
name|output
operator|.
name|write
argument_list|(
name|getPageSeparator
argument_list|()
argument_list|)
expr_stmt|;
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * Write the line separator value to the output stream.      * @throws IOException      *             If there is a problem writing out the lineseparator to the document.      */
specifier|protected
name|void
name|writeLineSeparator
parameter_list|( )
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getLineSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the word separator value to the output stream.      * @throws IOException      *             If there is a problem writing out the wordseparator to the document.      */
specifier|protected
name|void
name|writeWordSeparator
parameter_list|()
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getWordSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the string in TextPosition to the output stream.      *      * @param text The text to write to the stream.      * @throws IOException If there is an error when writing the text.      */
specifier|protected
name|void
name|writeCharacters
parameter_list|(
name|TextPosition
name|text
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|text
operator|.
name|getCharacter
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write a Java string to the output stream.      *      * @param text The text to write to the stream.      * @throws IOException If there is an error when writing the text.      */
specifier|protected
name|void
name|writeString
parameter_list|(
name|String
name|text
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will determine of two floating point numbers are within a specified variance.      *      * @param first The first number to compare to.      * @param second The second number to compare to.      * @param variance The allowed variance.      */
specifier|private
name|boolean
name|within
parameter_list|(
name|float
name|first
parameter_list|,
name|float
name|second
parameter_list|,
name|float
name|variance
parameter_list|)
block|{
return|return
name|second
argument_list|<
name|first
operator|+
name|variance
operator|&&
name|second
argument_list|>
name|first
operator|-
name|variance
return|;
block|}
comment|/**      * This will process a TextPosition object and add the      * text to the list of characters on a page.  It takes care of      * overlapping text.      *      * @param text The text to process.      */
specifier|protected
name|void
name|processTextPosition
parameter_list|(
name|TextPosition
name|text
parameter_list|)
block|{
name|boolean
name|showCharacter
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|suppressDuplicateOverlappingText
condition|)
block|{
name|showCharacter
operator|=
literal|false
expr_stmt|;
name|String
name|textCharacter
init|=
name|text
operator|.
name|getCharacter
argument_list|()
decl_stmt|;
name|float
name|textX
init|=
name|text
operator|.
name|getX
argument_list|()
decl_stmt|;
name|float
name|textY
init|=
name|text
operator|.
name|getY
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Float
argument_list|,
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|>
name|sameTextCharacters
init|=
name|characterListMapping
operator|.
name|get
argument_list|(
name|textCharacter
argument_list|)
decl_stmt|;
if|if
condition|(
name|sameTextCharacters
operator|==
literal|null
condition|)
block|{
name|sameTextCharacters
operator|=
operator|new
name|TreeMap
argument_list|<
name|Float
argument_list|,
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|characterListMapping
operator|.
name|put
argument_list|(
name|textCharacter
argument_list|,
name|sameTextCharacters
argument_list|)
expr_stmt|;
block|}
comment|// RDD - Here we compute the value that represents the end of the rendered
comment|// text.  This value is used to determine whether subsequent text rendered
comment|// on the same line overwrites the current text.
comment|//
comment|// We subtract any positive padding to handle cases where extreme amounts
comment|// of padding are applied, then backed off (not sure why this is done, but there
comment|// are cases where the padding is on the order of 10x the character width, and
comment|// the TJ just backs up to compensate after each character).  Also, we subtract
comment|// an amount to allow for kerning (a percentage of the width of the last
comment|// character).
comment|//
name|boolean
name|suppressCharacter
init|=
literal|false
decl_stmt|;
name|float
name|tolerance
init|=
operator|(
name|text
operator|.
name|getWidth
argument_list|()
operator|/
name|textCharacter
operator|.
name|length
argument_list|()
operator|)
operator|/
literal|3.0f
decl_stmt|;
name|SortedMap
argument_list|<
name|Float
argument_list|,
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|>
name|xMatches
init|=
name|sameTextCharacters
operator|.
name|subMap
argument_list|(
name|textX
operator|-
name|tolerance
argument_list|,
name|textX
operator|+
name|tolerance
argument_list|)
decl_stmt|;
for|for
control|(
name|TreeSet
argument_list|<
name|Float
argument_list|>
name|xMatch
range|:
name|xMatches
operator|.
name|values
argument_list|()
control|)
block|{
name|SortedSet
argument_list|<
name|Float
argument_list|>
name|yMatches
init|=
name|xMatch
operator|.
name|subSet
argument_list|(
name|textY
operator|-
name|tolerance
argument_list|,
name|textY
operator|+
name|tolerance
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|yMatches
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|suppressCharacter
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|suppressCharacter
condition|)
block|{
name|TreeSet
argument_list|<
name|Float
argument_list|>
name|ySet
init|=
name|sameTextCharacters
operator|.
name|get
argument_list|(
name|textX
argument_list|)
decl_stmt|;
if|if
condition|(
name|ySet
operator|==
literal|null
condition|)
block|{
name|ySet
operator|=
operator|new
name|TreeSet
argument_list|<
name|Float
argument_list|>
argument_list|()
expr_stmt|;
name|sameTextCharacters
operator|.
name|put
argument_list|(
name|textX
argument_list|,
name|ySet
argument_list|)
expr_stmt|;
block|}
name|ySet
operator|.
name|add
argument_list|(
name|textY
argument_list|)
expr_stmt|;
name|showCharacter
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|showCharacter
condition|)
block|{
comment|//if we are showing the character then we need to determine which
comment|//article it belongs to.
name|int
name|foundArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|notFoundButFirstLeftArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|notFoundButFirstAboveArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|float
name|x
init|=
name|text
operator|.
name|getX
argument_list|()
decl_stmt|;
name|float
name|y
init|=
name|text
operator|.
name|getY
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldSeparateByBeads
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pageArticles
operator|.
name|size
argument_list|()
operator|&&
name|foundArticleDivisionIndex
operator|==
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|PDThreadBead
name|bead
init|=
operator|(
name|PDThreadBead
operator|)
name|pageArticles
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bead
operator|!=
literal|null
condition|)
block|{
name|PDRectangle
name|rect
init|=
name|bead
operator|.
name|getRectangle
argument_list|()
decl_stmt|;
if|if
condition|(
name|rect
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|foundArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|<
name|rect
operator|.
name|getLowerLeftX
argument_list|()
operator|||
name|y
operator|<
name|rect
operator|.
name|getUpperRightY
argument_list|()
operator|)
operator|&&
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
name|rect
operator|.
name|getLowerLeftX
argument_list|()
operator|&&
name|notFoundButFirstLeftArticleDivisionIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|notFoundButFirstLeftArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|<
name|rect
operator|.
name|getUpperRightY
argument_list|()
operator|&&
name|notFoundButFirstAboveArticleDivisionIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|notFoundButFirstAboveArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|foundArticleDivisionIndex
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|foundArticleDivisionIndex
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|articleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|foundArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|foundArticleDivisionIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notFoundButFirstLeftArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|notFoundButFirstLeftArticleDivisionIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notFoundButFirstAboveArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|notFoundButFirstAboveArticleDivisionIndex
expr_stmt|;
block|}
else|else
block|{
name|articleDivisionIndex
operator|=
name|charactersByArticle
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
name|List
argument_list|<
name|TextPosition
argument_list|>
name|textList
init|=
operator|(
name|List
argument_list|<
name|TextPosition
argument_list|>
operator|)
name|charactersByArticle
operator|.
name|get
argument_list|(
name|articleDivisionIndex
argument_list|)
decl_stmt|;
comment|/* In the wild, some PDF encoded documents put diacritics (accents on              * top of characters) into a separate Tj element.  When displaying them              * graphically, the two chunks get overlayed.  With text output though,              * we need to do the overlay. This code recombines the diacritic with              * its associated character if the two are consecutive.              */
if|if
condition|(
name|textList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|textList
operator|.
name|add
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* test if we overlap the previous entry.                    * Note that we are making an assumption that we need to only look back                  * one TextPosition to find what we are overlapping.                    * This may not always be true. */
name|TextPosition
name|previousTextPosition
init|=
operator|(
name|TextPosition
operator|)
name|textList
operator|.
name|get
argument_list|(
name|textList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|isDiacritic
argument_list|()
operator|&&
name|previousTextPosition
operator|.
name|contains
argument_list|(
name|text
argument_list|)
condition|)
block|{
name|previousTextPosition
operator|.
name|mergeDiacritic
argument_list|(
name|text
argument_list|,
name|normalize
argument_list|)
expr_stmt|;
block|}
comment|/* If the previous TextPosition was the diacritic, merge it into this                  * one and remove it from the list. */
elseif|else
if|if
condition|(
name|previousTextPosition
operator|.
name|isDiacritic
argument_list|()
operator|&&
name|text
operator|.
name|contains
argument_list|(
name|previousTextPosition
argument_list|)
condition|)
block|{
name|text
operator|.
name|mergeDiacritic
argument_list|(
name|previousTextPosition
argument_list|,
name|normalize
argument_list|)
expr_stmt|;
name|textList
operator|.
name|remove
argument_list|(
name|textList
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|textList
operator|.
name|add
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|textList
operator|.
name|add
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * This is the page that the text extraction will start on.  The pages start      * at page 1.  For example in a 5 page PDF document, if the start page is 1      * then all pages will be extracted.  If the start page is 4 then pages 4 and 5      * will be extracted.  The default value is 1.      *      * @return Value of property startPage.      */
specifier|public
name|int
name|getStartPage
parameter_list|()
block|{
return|return
name|startPage
return|;
block|}
comment|/**      * This will set the first page to be extracted by this class.      *      * @param startPageValue New value of property startPage.      */
specifier|public
name|void
name|setStartPage
parameter_list|(
name|int
name|startPageValue
parameter_list|)
block|{
name|startPage
operator|=
name|startPageValue
expr_stmt|;
block|}
comment|/**      * This will get the last page that will be extracted.  This is inclusive,      * for example if a 5 page PDF an endPage value of 5 would extract the      * entire document, an end page of 2 would extract pages 1 and 2.  This defaults      * to Integer.MAX_VALUE such that all pages of the pdf will be extracted.      *      * @return Value of property endPage.      */
specifier|public
name|int
name|getEndPage
parameter_list|()
block|{
return|return
name|endPage
return|;
block|}
comment|/**      * This will set the last page to be extracted by this class.      *      * @param endPageValue New value of property endPage.      */
specifier|public
name|void
name|setEndPage
parameter_list|(
name|int
name|endPageValue
parameter_list|)
block|{
name|endPage
operator|=
name|endPageValue
expr_stmt|;
block|}
comment|/**      * Set the desired line separator for output text.  The line.separator      * system property is used if the line separator preference is not set      * explicitly using this method.      *      * @param separator The desired line separator string.      */
specifier|public
name|void
name|setLineSeparator
parameter_list|(
name|String
name|separator
parameter_list|)
block|{
name|lineSeparator
operator|=
name|separator
expr_stmt|;
block|}
comment|/**      * This will get the line separator.      *      * @return The desired line separator string.      */
specifier|public
name|String
name|getLineSeparator
parameter_list|()
block|{
return|return
name|lineSeparator
return|;
block|}
comment|/**      * Set the desired page separator for output text.  The line.separator      * system property is used if the page separator preference is not set      * explicitly using this method.      *      * @param separator The desired page separator string.      */
specifier|public
name|void
name|setPageSeparator
parameter_list|(
name|String
name|separator
parameter_list|)
block|{
name|pageSeparator
operator|=
name|separator
expr_stmt|;
block|}
comment|/**      * This will get the word separator.      *      * @return The desired word separator string.      */
specifier|public
name|String
name|getWordSeparator
parameter_list|()
block|{
return|return
name|wordSeparator
return|;
block|}
comment|/**      * Set the desired word separator for output text.  The PDFBox text extraction      * algorithm will output a space character if there is enough space between      * two words.  By default a space character is used.  If you need and accurate      * count of characters that are found in a PDF document then you might want to      * set the word separator to the empty string.      *      * @param separator The desired page separator string.      */
specifier|public
name|void
name|setWordSeparator
parameter_list|(
name|String
name|separator
parameter_list|)
block|{
name|wordSeparator
operator|=
name|separator
expr_stmt|;
block|}
comment|/**      * This will get the page separator.      *      * @return The page separator string.      */
specifier|public
name|String
name|getPageSeparator
parameter_list|()
block|{
return|return
name|pageSeparator
return|;
block|}
comment|/**      * @return Returns the suppressDuplicateOverlappingText.      */
specifier|public
name|boolean
name|getSuppressDuplicateOverlappingText
parameter_list|()
block|{
return|return
name|suppressDuplicateOverlappingText
return|;
block|}
comment|/**      * Get the current page number that is being processed.      *      * @return A 1 based number representing the current page.      */
specifier|protected
name|int
name|getCurrentPageNo
parameter_list|()
block|{
return|return
name|currentPageNo
return|;
block|}
comment|/**      * The output stream that is being written to.      *      * @return The stream that output is being written to.      */
specifier|protected
name|Writer
name|getOutput
parameter_list|()
block|{
return|return
name|output
return|;
block|}
comment|/**      * Character strings are grouped by articles.  It is quite common that there      * will only be a single article.  This returns a List that contains List objects,      * the inner lists will contain TextPosition objects.      *      * @return A double List of TextPositions for all text strings on the page.      */
specifier|protected
name|Vector
argument_list|<
name|List
argument_list|<
name|TextPosition
argument_list|>
argument_list|>
name|getCharactersByArticle
parameter_list|()
block|{
return|return
name|charactersByArticle
return|;
block|}
comment|/**      * By default the text stripper will attempt to remove text that overlapps each other.      * Word paints the same character several times in order to make it look bold.  By setting      * this to false all text will be extracted, which means that certain sections will be      * duplicated, but better performance will be noticed.      *      * @param suppressDuplicateOverlappingTextValue The suppressDuplicateOverlappingText to set.      */
specifier|public
name|void
name|setSuppressDuplicateOverlappingText
parameter_list|(
name|boolean
name|suppressDuplicateOverlappingTextValue
parameter_list|)
block|{
name|this
operator|.
name|suppressDuplicateOverlappingText
operator|=
name|suppressDuplicateOverlappingTextValue
expr_stmt|;
block|}
comment|/**      * This will tell if the text stripper should separate by beads.      *      * @return If the text will be grouped by beads.      */
specifier|public
name|boolean
name|getSeparateByBeads
parameter_list|()
block|{
return|return
name|shouldSeparateByBeads
return|;
block|}
comment|/**      * Set if the text stripper should group the text output by a list of beads.  The default value is true!      *      * @param aShouldSeparateByBeads The new grouping of beads.      */
specifier|public
name|void
name|setShouldSeparateByBeads
parameter_list|(
name|boolean
name|aShouldSeparateByBeads
parameter_list|)
block|{
name|this
operator|.
name|shouldSeparateByBeads
operator|=
name|aShouldSeparateByBeads
expr_stmt|;
block|}
comment|/**      * Get the bookmark where text extraction should end, inclusive.  Default is null.      *      * @return The ending bookmark.      */
specifier|public
name|PDOutlineItem
name|getEndBookmark
parameter_list|()
block|{
return|return
name|endBookmark
return|;
block|}
comment|/**      * Set the bookmark where the text extraction should stop.      *      * @param aEndBookmark The ending bookmark.      */
specifier|public
name|void
name|setEndBookmark
parameter_list|(
name|PDOutlineItem
name|aEndBookmark
parameter_list|)
block|{
name|endBookmark
operator|=
name|aEndBookmark
expr_stmt|;
block|}
comment|/**      * Get the bookmark where text extraction should start, inclusive.  Default is null.      *      * @return The starting bookmark.      */
specifier|public
name|PDOutlineItem
name|getStartBookmark
parameter_list|()
block|{
return|return
name|startBookmark
return|;
block|}
comment|/**      * Set the bookmark where text extraction should start, inclusive.      *      * @param aStartBookmark The starting bookmark.      */
specifier|public
name|void
name|setStartBookmark
parameter_list|(
name|PDOutlineItem
name|aStartBookmark
parameter_list|)
block|{
name|startBookmark
operator|=
name|aStartBookmark
expr_stmt|;
block|}
comment|/**      * This will tell if the text stripper should add some more text formatting.      * @return true if some more text formatting will be added      */
specifier|public
name|boolean
name|getAddMoreFormatting
parameter_list|()
block|{
return|return
name|addMoreFormatting
return|;
block|}
comment|/**      * There will some additional text formatting be added if addMoreFormatting      * is set to true. Default is false.       * @param newAddMoreFormatting Tell PDFBox to add some more text formatting      */
specifier|public
name|void
name|setAddMoreFormatting
parameter_list|(
name|boolean
name|newAddMoreFormatting
parameter_list|)
block|{
name|addMoreFormatting
operator|=
name|newAddMoreFormatting
expr_stmt|;
block|}
comment|/**      * This will tell if the text stripper should sort the text tokens      * before writing to the stream.      *      * @return true If the text tokens will be sorted before being written.      */
specifier|public
name|boolean
name|getSortByPosition
parameter_list|()
block|{
return|return
name|sortByPosition
return|;
block|}
comment|/**      * The order of the text tokens in a PDF file may not be in the same      * as they appear visually on the screen.  For example, a PDF writer may      * write out all text by font, so all bold or larger text, then make a second      * pass and write out the normal text.<br/>      * The default is to<b>not</b> sort by position.<br/>      *<br/>      * A PDF writer could choose to write each character in a different order.  By      * default PDFBox does<b>not</b> sort the text tokens before processing them due to      * performance reasons.      *      * @param newSortByPosition Tell PDFBox to sort the text positions.      */
specifier|public
name|void
name|setSortByPosition
parameter_list|(
name|boolean
name|newSortByPosition
parameter_list|)
block|{
name|sortByPosition
operator|=
name|newSortByPosition
expr_stmt|;
block|}
comment|/**      * Get the current space width-based tolerance value that is being used      * to estimate where spaces in text should be added.  Note that the      * default value for this has been determined from trial and error.       *       * @return The current tolerance / scaling factor      */
specifier|public
name|float
name|getSpacingTolerance
parameter_list|()
block|{
return|return
name|spacingTolerance
return|;
block|}
comment|/**      * Set the space width-based tolerance value that is used      * to estimate where spaces in text should be added.  Note that the      * default value for this has been determined from trial and error.      * Setting this value larger will reduce the number of spaces added.       *       * @param spacingToleranceValue tolerance / scaling factor to use      */
specifier|public
name|void
name|setSpacingTolerance
parameter_list|(
name|float
name|spacingToleranceValue
parameter_list|)
block|{
name|this
operator|.
name|spacingTolerance
operator|=
name|spacingToleranceValue
expr_stmt|;
block|}
comment|/**      * Get the current character width-based tolerance value that is being used      * to estimate where spaces in text should be added.  Note that the      * default value for this has been determined from trial and error.      *       * @return The current tolerance / scaling factor      */
specifier|public
name|float
name|getAverageCharTolerance
parameter_list|()
block|{
return|return
name|averageCharTolerance
return|;
block|}
comment|/**      * Set the character width-based tolerance value that is used      * to estimate where spaces in text should be added.  Note that the      * default value for this has been determined from trial and error.      * Setting this value larger will reduce the number of spaces added.       *       * @param averageCharToleranceValue average tolerance / scaling factor to use      */
specifier|public
name|void
name|setAverageCharTolerance
parameter_list|(
name|float
name|averageCharToleranceValue
parameter_list|)
block|{
name|this
operator|.
name|averageCharTolerance
operator|=
name|averageCharToleranceValue
expr_stmt|;
block|}
comment|/**      * returns the multiple of whitespace character widths      * for the current text which the current      * line start can be indented from the previous line start      * beyond which the current line start is considered      * to be a paragraph start.      * @return the number of whitespace character widths to use      * when detecting paragraph indents.      */
specifier|public
name|float
name|getIndentThreshold
parameter_list|()
block|{
return|return
name|indentThreshold
return|;
block|}
comment|/**      * sets the multiple of whitespace character widths      * for the current text which the current      * line start can be indented from the previous line start      * beyond which the current line start is considered      * to be a paragraph start.  The default value is 2.0.      *      * @param indentThresholdValue the number of whitespace character widths to use      * when detecting paragraph indents.      */
specifier|public
name|void
name|setIndentThreshold
parameter_list|(
name|float
name|indentThresholdValue
parameter_list|)
block|{
name|indentThreshold
operator|=
name|indentThresholdValue
expr_stmt|;
block|}
comment|/**      * the minimum whitespace, as a multiple      * of the max height of the current characters      * beyond which the current line start is considered      * to be a paragraph start.      * @return the character height multiple for      * max allowed whitespace between lines in      * the same paragraph.      */
specifier|public
name|float
name|getDropThreshold
parameter_list|()
block|{
return|return
name|dropThreshold
return|;
block|}
comment|/**      * sets the minimum whitespace, as a multiple      * of the max height of the current characters      * beyond which the current line start is considered      * to be a paragraph start.  The default value is 2.5.      *      * @param dropThresholdValue the character height multiple for      * max allowed whitespace between lines in      * the same paragraph.      */
specifier|public
name|void
name|setDropThreshold
parameter_list|(
name|float
name|dropThresholdValue
parameter_list|)
block|{
name|dropThreshold
operator|=
name|dropThresholdValue
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the beginning of a paragraph.      * @return the paragraph start string      */
specifier|public
name|String
name|getParagraphStart
parameter_list|()
block|{
return|return
name|paragraphStart
return|;
block|}
comment|/**      * Sets the string which will be used at the beginning of a paragraph.      * @param s the paragraph start string      */
specifier|public
name|void
name|setParagraphStart
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|this
operator|.
name|paragraphStart
operator|=
name|s
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the end of a paragraph.      * @return the paragraph end string      */
specifier|public
name|String
name|getParagraphEnd
parameter_list|()
block|{
return|return
name|paragraphEnd
return|;
block|}
comment|/**      * Sets the string which will be used at the end of a paragraph.      * @param s the paragraph end string      */
specifier|public
name|void
name|setParagraphEnd
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|this
operator|.
name|paragraphEnd
operator|=
name|s
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the beginning of a page.      * @return the page start string      */
specifier|public
name|String
name|getPageStart
parameter_list|()
block|{
return|return
name|pageStart
return|;
block|}
comment|/**      * Sets the string which will be used at the beginning of a page.      * @param pageStartValue the page start string      */
specifier|public
name|void
name|setPageStart
parameter_list|(
name|String
name|pageStartValue
parameter_list|)
block|{
name|pageStart
operator|=
name|pageStartValue
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the end of a page.      * @return the page end string      */
specifier|public
name|String
name|getPageEnd
parameter_list|()
block|{
return|return
name|pageEnd
return|;
block|}
comment|/**      * Sets the string which will be used at the end of a page.      * @param pageEndValue the page end string      */
specifier|public
name|void
name|setPageEnd
parameter_list|(
name|String
name|pageEndValue
parameter_list|)
block|{
name|pageEnd
operator|=
name|pageEndValue
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the beginning of an article.      * @return the article start string      */
specifier|public
name|String
name|getArticleStart
parameter_list|()
block|{
return|return
name|articleStart
return|;
block|}
comment|/**      * Sets the string which will be used at the beginning of an article.      * @param articleStartValue the article start string      */
specifier|public
name|void
name|setArticleStart
parameter_list|(
name|String
name|articleStartValue
parameter_list|)
block|{
name|articleStart
operator|=
name|articleStartValue
expr_stmt|;
block|}
comment|/**      * Returns the string which will be used at the end of an article.      * @return the article end string      */
specifier|public
name|String
name|getArticleEnd
parameter_list|()
block|{
return|return
name|articleEnd
return|;
block|}
comment|/**      * Sets the string which will be used at the end of an article.      * @param articleEndValue the article end string      */
specifier|public
name|void
name|setArticleEnd
parameter_list|(
name|String
name|articleEndValue
parameter_list|)
block|{
name|articleEnd
operator|=
name|articleEndValue
expr_stmt|;
block|}
comment|/**      * Reverse characters of a compound Arabic glyph.      * When getSortByPosition() is true, inspect the sequence encoded      * by one glyph. If the glyph encodes two or more Arabic characters,      * reverse these characters from a logical order to a visual order.      * This ensures that the bidirectional algorithm that runs later will      * convert them back to a logical order.      *       * @param str a string obtained from font.encoding()      *       * @return the reversed string      */
specifier|public
name|String
name|inspectFontEncoding
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sortByPosition
operator|||
name|str
operator|==
literal|null
operator|||
name|str
operator|.
name|length
argument_list|()
operator|<
literal|2
condition|)
block|{
return|return
name|str
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|Character
operator|.
name|getDirectionality
argument_list|(
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|Character
operator|.
name|DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC
condition|)
block|{
return|return
name|str
return|;
block|}
block|}
name|StringBuilder
name|reversed
init|=
operator|new
name|StringBuilder
argument_list|(
name|str
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|str
operator|.
name|length
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|reversed
operator|.
name|append
argument_list|(
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|reversed
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * handles the line separator for a new line given      * the specified current and previous TextPositions.      * @param current the current text position      * @param lastPosition the previous text position      * @param lastLineStartPosition the last text position that followed a line      *        separator.      * @param maxHeightForLine max height for positions since lastLineStartPosition      * @return start position of the last line      * @throws IOException if something went wrong      */
specifier|protected
name|PositionWrapper
name|handleLineSeparation
parameter_list|(
name|PositionWrapper
name|current
parameter_list|,
name|PositionWrapper
name|lastPosition
parameter_list|,
name|PositionWrapper
name|lastLineStartPosition
parameter_list|,
name|float
name|maxHeightForLine
parameter_list|)
throws|throws
name|IOException
block|{
name|current
operator|.
name|setLineStart
argument_list|()
expr_stmt|;
name|isParagraphSeparation
argument_list|(
name|current
argument_list|,
name|lastPosition
argument_list|,
name|lastLineStartPosition
argument_list|,
name|maxHeightForLine
argument_list|)
expr_stmt|;
name|lastLineStartPosition
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|isParagraphStart
argument_list|()
condition|)
block|{
if|if
condition|(
name|lastPosition
operator|.
name|isArticleStart
argument_list|()
condition|)
block|{
name|writeParagraphStart
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writeLineSeparator
argument_list|()
expr_stmt|;
name|writeParagraphSeparator
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|writeLineSeparator
argument_list|()
expr_stmt|;
block|}
return|return
name|lastLineStartPosition
return|;
block|}
comment|/**      * tests the relationship between the last text position, the current text      * position and the last text position that followed a line separator to      * decide if the gap represents a paragraph separation. This should      *<i>only</i> be called for consecutive text positions that first pass the      * line separation test.      *<p>      * This base implementation tests to see if the lastLineStartPosition is      * null OR if the current vertical position has dropped below the last text      * vertical position by at least 2.5 times the current text height OR if the      * current horizontal position is indented by at least 2 times the current      * width of a space character.</p>      *<p>      * This also attempts to identify text that is indented under a hanging indent.</p>      *<p>      * This method sets the isParagraphStart and isHangingIndent flags on the current      * position object.</p>      *      * @param position the current text position.  This may have its isParagraphStart      * or isHangingIndent flags set upon return.      * @param lastPosition the previous text position (should not be null).      * @param lastLineStartPosition the last text position that followed a line      *            separator. May be null.      * @param maxHeightForLine max height for text positions since lasLineStartPosition.      */
specifier|protected
name|void
name|isParagraphSeparation
parameter_list|(
name|PositionWrapper
name|position
parameter_list|,
name|PositionWrapper
name|lastPosition
parameter_list|,
name|PositionWrapper
name|lastLineStartPosition
parameter_list|,
name|float
name|maxHeightForLine
parameter_list|)
block|{
name|boolean
name|result
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|lastLineStartPosition
operator|==
literal|null
condition|)
block|{
name|result
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|float
name|yGap
init|=
name|Math
operator|.
name|abs
argument_list|(
name|position
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getYDirAdj
argument_list|()
operator|-
name|lastPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getYDirAdj
argument_list|()
argument_list|)
decl_stmt|;
name|float
name|xGap
init|=
operator|(
name|position
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getXDirAdj
argument_list|()
operator|-
name|lastLineStartPosition
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getXDirAdj
argument_list|()
operator|)
decl_stmt|;
comment|//do we need to flip this for rtl?
if|if
condition|(
name|yGap
operator|>
operator|(
name|getDropThreshold
argument_list|()
operator|*
name|maxHeightForLine
operator|)
condition|)
block|{
name|result
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xGap
operator|>
operator|(
name|getIndentThreshold
argument_list|()
operator|*
name|position
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getWidthOfSpace
argument_list|()
operator|)
condition|)
block|{
comment|//text is indented, but try to screen for hanging indent
if|if
condition|(
operator|!
name|lastLineStartPosition
operator|.
name|isParagraphStart
argument_list|()
condition|)
block|{
name|result
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|position
operator|.
name|setHangingIndent
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|xGap
operator|<
operator|-
name|position
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getWidthOfSpace
argument_list|()
condition|)
block|{
comment|//text is left of previous line. Was it a hanging indent?
if|if
condition|(
operator|!
name|lastLineStartPosition
operator|.
name|isParagraphStart
argument_list|()
condition|)
block|{
name|result
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|xGap
argument_list|)
operator|<
operator|(
literal|0.25
operator|*
name|position
operator|.
name|getTextPosition
argument_list|()
operator|.
name|getWidth
argument_list|()
operator|)
condition|)
block|{
comment|//current horizontal position is within 1/4 a char of the last
comment|//linestart.  We'll treat them as lined up.
if|if
condition|(
name|lastLineStartPosition
operator|.
name|isHangingIndent
argument_list|()
condition|)
block|{
name|position
operator|.
name|setHangingIndent
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastLineStartPosition
operator|.
name|isParagraphStart
argument_list|()
condition|)
block|{
comment|//check to see if the previous line looks like
comment|//any of a number of standard list item formats
name|Pattern
name|liPattern
init|=
name|matchListItemPattern
argument_list|(
name|lastLineStartPosition
argument_list|)
decl_stmt|;
if|if
condition|(
name|liPattern
operator|!=
literal|null
condition|)
block|{
name|Pattern
name|currentPattern
init|=
name|matchListItemPattern
argument_list|(
name|position
argument_list|)
decl_stmt|;
if|if
condition|(
name|liPattern
operator|==
name|currentPattern
condition|)
block|{
name|result
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|result
condition|)
block|{
name|position
operator|.
name|setParagraphStart
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * writes the paragraph separator string to the output.      * @throws IOException if something went wrong      */
specifier|protected
name|void
name|writeParagraphSeparator
parameter_list|()
throws|throws
name|IOException
block|{
name|writeParagraphEnd
argument_list|()
expr_stmt|;
name|writeParagraphStart
argument_list|()
expr_stmt|;
block|}
comment|/**      * Write something (if defined) at the start of a paragraph.      * @throws IOException if something went wrong      */
specifier|protected
name|void
name|writeParagraphStart
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inParagraph
condition|)
block|{
name|writeParagraphEnd
argument_list|()
expr_stmt|;
name|inParagraph
operator|=
literal|false
expr_stmt|;
block|}
name|output
operator|.
name|write
argument_list|(
name|getParagraphStart
argument_list|()
argument_list|)
expr_stmt|;
name|inParagraph
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Write something (if defined) at the end of a paragraph.      * @throws IOException if something went wrong      */
specifier|protected
name|void
name|writeParagraphEnd
parameter_list|()
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getParagraphEnd
argument_list|()
argument_list|)
expr_stmt|;
name|inParagraph
operator|=
literal|false
expr_stmt|;
block|}
comment|/**      * Write something (if defined) at the start of a page.      * @throws IOException if something went wrong      */
specifier|protected
name|void
name|writePageStart
parameter_list|()
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getPageStart
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write something (if defined) at the end of a page.      * @throws IOException if something went wrong      */
specifier|protected
name|void
name|writePageEnd
parameter_list|()
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getPageEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * returns the list item Pattern object that matches      * the text at the specified PositionWrapper or null      * if the text does not match such a pattern.  The list      * of Patterns tested against is given by the      * {@link #getListItemPatterns()} method.  To add to      * the list, simply override that method (if sub-classing)      * or explicitly supply your own list using      * {@link #setListItemPatterns(List)}.      * @param pw      * @return      */
specifier|protected
name|Pattern
name|matchListItemPattern
parameter_list|(
name|PositionWrapper
name|pw
parameter_list|)
block|{
name|TextPosition
name|tp
init|=
name|pw
operator|.
name|getTextPosition
argument_list|()
decl_stmt|;
name|String
name|txt
init|=
name|tp
operator|.
name|getCharacter
argument_list|()
decl_stmt|;
name|Pattern
name|p
init|=
name|matchPattern
argument_list|(
name|txt
argument_list|,
name|getListItemPatterns
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|p
return|;
block|}
comment|/**      * a list of regular expressions that match commonly used      * list item formats, i.e. bullets, numbers, letters,      * Roman numerals, etc.  Not meant to be      * comprehensive.      */
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|LIST_ITEM_EXPRESSIONS
init|=
block|{
literal|"\\."
block|,
literal|"\\d+\\."
block|,
literal|"\\[\\d+\\]"
block|,
literal|"\\d+\\)"
block|,
literal|"[A-Z]\\."
block|,
literal|"[a-z]\\."
block|,
literal|"[A-Z]\\)"
block|,
literal|"[a-z]\\)"
block|,
literal|"[IVXL]+\\."
block|,
literal|"[ivxl]+\\."
block|,      }
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Pattern
argument_list|>
name|liPatterns
init|=
literal|null
decl_stmt|;
comment|/**      * use to supply a different set of regular expression      * patterns for matching list item starts.      *      * @param patterns      */
specifier|protected
name|void
name|setListItemPatterns
parameter_list|(
name|List
argument_list|<
name|Pattern
argument_list|>
name|patterns
parameter_list|)
block|{
name|liPatterns
operator|=
name|patterns
expr_stmt|;
block|}
comment|/**      * returns a list of regular expression Patterns representing      * different common list item formats.  For example      * numbered items of form:      *<ol>      *<li>some text</li>      *<li>more text</li>      *</ol>      * or      *<ul>      *<li>some text</li>      *<li>more text</li>      *</ul>      * etc., all begin with some character pattern. The pattern "\\d+\." (matches "1.", "2.", ...)      * or "\[\\d+\]" (matches "[1]", "[2]", ...).      *<p>      * This method returns a list of such regular expression Patterns.      * @return a list of Pattern objects.      */
specifier|protected
name|List
argument_list|<
name|Pattern
argument_list|>
name|getListItemPatterns
parameter_list|()
block|{
if|if
condition|(
name|liPatterns
operator|==
literal|null
condition|)
block|{
name|liPatterns
operator|=
operator|new
name|ArrayList
argument_list|<
name|Pattern
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|expression
range|:
name|LIST_ITEM_EXPRESSIONS
control|)
block|{
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|expression
argument_list|)
decl_stmt|;
name|liPatterns
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|liPatterns
return|;
block|}
comment|/**      * iterates over the specified list of Patterns until      * it finds one that matches the specified string.  Then      * returns the Pattern.      *<p>      * Order of the supplied list of patterns is important as      * most common patterns should come first.  Patterns      * should be strict in general, and all will be      * used with case sensitivity on.      *</p>      * @param s      * @param patterns      * @return      */
specifier|protected
specifier|static
specifier|final
name|Pattern
name|matchPattern
parameter_list|(
name|String
name|s
parameter_list|,
name|List
argument_list|<
name|Pattern
argument_list|>
name|patterns
parameter_list|)
block|{
name|Pattern
name|matchedPattern
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Pattern
name|p
range|:
name|patterns
control|)
block|{
if|if
condition|(
name|p
operator|.
name|matcher
argument_list|(
name|s
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
return|return
name|matchedPattern
return|;
block|}
comment|/**      * Write a list of string containing a whole line of a document.      * @param line a list with the words of the given line      * @param isRtlDominant determines if rtl or ltl is dominant      * @throws IOException if something went wrong      */
specifier|private
name|void
name|writeLine
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|line
parameter_list|,
name|boolean
name|isRtlDominant
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|numberOfStrings
init|=
name|line
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|isRtlDominant
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|numberOfStrings
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|<
name|numberOfStrings
operator|-
literal|1
condition|)
block|{
name|writeWordSeparator
argument_list|()
expr_stmt|;
block|}
name|writeString
argument_list|(
name|line
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfStrings
condition|;
name|i
operator|++
control|)
block|{
name|writeString
argument_list|(
name|line
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRtlDominant
operator|&&
name|i
operator|<
name|numberOfStrings
operator|-
literal|1
condition|)
block|{
name|writeWordSeparator
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Normalize the given list of TextPositions.      * @param line list of TextPositions      * @param isRtlDominant determines if rtl or ltl is dominant       * @param hasRtl determines if lines contains rtl formatted text(parts)      * @return a list of strings, one string for every word      */
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|normalize
parameter_list|(
name|List
argument_list|<
name|TextPosition
argument_list|>
name|line
parameter_list|,
name|boolean
name|isRtlDominant
parameter_list|,
name|boolean
name|hasRtl
parameter_list|)
block|{
name|LinkedList
argument_list|<
name|String
argument_list|>
name|normalized
init|=
operator|new
name|LinkedList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|lineBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|TextPosition
name|text
range|:
name|line
control|)
block|{
if|if
condition|(
name|text
operator|instanceof
name|WordSeparator
condition|)
block|{
name|String
name|lineStr
init|=
name|lineBuilder
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasRtl
condition|)
block|{
name|lineStr
operator|=
name|normalize
operator|.
name|makeLineLogicalOrder
argument_list|(
name|lineStr
argument_list|,
name|isRtlDominant
argument_list|)
expr_stmt|;
block|}
name|lineStr
operator|=
name|normalize
operator|.
name|normalizePres
argument_list|(
name|lineStr
argument_list|)
expr_stmt|;
name|normalized
operator|.
name|add
argument_list|(
name|lineStr
argument_list|)
expr_stmt|;
name|lineBuilder
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|lineBuilder
operator|.
name|append
argument_list|(
name|text
operator|.
name|getCharacter
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lineBuilder
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|lineStr
init|=
name|lineBuilder
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasRtl
condition|)
block|{
name|lineStr
operator|=
name|normalize
operator|.
name|makeLineLogicalOrder
argument_list|(
name|lineStr
argument_list|,
name|isRtlDominant
argument_list|)
expr_stmt|;
block|}
name|lineStr
operator|=
name|normalize
operator|.
name|normalizePres
argument_list|(
name|lineStr
argument_list|)
expr_stmt|;
name|normalized
operator|.
name|add
argument_list|(
name|lineStr
argument_list|)
expr_stmt|;
block|}
return|return
name|normalized
return|;
block|}
comment|/**      * internal marker class.  Used as a place holder in      * a line of TextPositions.      * @author ME21969      *      */
specifier|private
specifier|static
specifier|final
class|class
name|WordSeparator
extends|extends
name|TextPosition
block|{
specifier|private
specifier|static
specifier|final
name|WordSeparator
name|separator
init|=
operator|new
name|WordSeparator
argument_list|()
decl_stmt|;
specifier|private
name|WordSeparator
parameter_list|()
block|{         }
specifier|public
specifier|static
specifier|final
name|WordSeparator
name|getSeparator
parameter_list|()
block|{
return|return
name|separator
return|;
block|}
block|}
block|}
end_class

end_unit

