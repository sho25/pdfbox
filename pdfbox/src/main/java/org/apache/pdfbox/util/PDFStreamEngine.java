begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|GeneralPath
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|Point2D
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
operator|.
name|PDFStreamParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDResources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDMatrix
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRectangle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDFont
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDType3Font
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|state
operator|.
name|PDExtendedGraphicsState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|state
operator|.
name|PDGraphicsState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|PDXObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|text
operator|.
name|TextPosition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|operator
operator|.
name|OperatorProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|operator
operator|.
name|PDFOperator
import|;
end_import

begin_comment
comment|/**  * Processes a PDF content stream and executes certain operations.  * Provides a callback interface for clients that want to do things with the stream.  *  * @see org.apache.pdfbox.util.PDFTextStripper  *   * @author Ben Litchfield  */
end_comment

begin_class
specifier|public
class|class
name|PDFStreamEngine
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|PDFStreamEngine
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|unsupportedOperators
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|OperatorProcessor
argument_list|>
name|operators
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|OperatorProcessor
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Matrix
name|textMatrix
decl_stmt|;
specifier|private
name|Matrix
name|textLineMatrix
decl_stmt|;
specifier|private
specifier|final
name|Stack
argument_list|<
name|PDGraphicsState
argument_list|>
name|graphicsStack
init|=
operator|new
name|Stack
argument_list|<
name|PDGraphicsState
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Stack
argument_list|<
name|PDResources
argument_list|>
name|streamResourcesStack
init|=
operator|new
name|Stack
argument_list|<
name|PDResources
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|pageRotation
decl_stmt|;
specifier|private
name|PDRectangle
name|drawingRectangle
decl_stmt|;
comment|// skip malformed or otherwise unparseable input where possible
specifier|private
name|boolean
name|forceParsing
decl_stmt|;
comment|/**      * Creates a new PDFStreamEngine.      */
specifier|public
name|PDFStreamEngine
parameter_list|()
block|{     }
comment|/**      * Constructor with engine properties. The property keys are all PDF operators, the values are      * class names used to execute those operators. An empty value means that the operator will be      * silently ignored.      *       * @param properties The engine properties.      */
specifier|public
name|PDFStreamEngine
parameter_list|(
name|Properties
name|properties
parameter_list|)
block|{
if|if
condition|(
name|properties
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"properties cannot be null"
argument_list|)
throw|;
block|}
name|Enumeration
argument_list|<
name|?
argument_list|>
name|names
init|=
name|properties
operator|.
name|propertyNames
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|name
range|:
name|Collections
operator|.
name|list
argument_list|(
name|names
argument_list|)
control|)
block|{
name|String
name|operator
init|=
name|name
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|processorClassName
init|=
name|properties
operator|.
name|getProperty
argument_list|(
name|operator
argument_list|)
decl_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|processorClassName
argument_list|)
condition|)
block|{
name|unsupportedOperators
operator|.
name|add
argument_list|(
name|operator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|cls
init|=
name|Class
operator|.
name|forName
argument_list|(
name|processorClassName
argument_list|)
decl_stmt|;
name|OperatorProcessor
name|processor
init|=
operator|(
name|OperatorProcessor
operator|)
name|cls
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|registerOperatorProcessor
argument_list|(
name|operator
argument_list|,
name|processor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// should not happen
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
comment|// should not happen
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
comment|// should not happen
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * Indicates if force parsing is activated.      *       * @return true if force parsing is active      */
specifier|public
name|boolean
name|isForceParsing
parameter_list|()
block|{
return|return
name|forceParsing
return|;
block|}
comment|/**      * Enable/Disable force parsing.      *       * @param forceParsingValue true activates force parsing      */
specifier|public
name|void
name|setForceParsing
parameter_list|(
name|boolean
name|forceParsingValue
parameter_list|)
block|{
name|forceParsing
operator|=
name|forceParsingValue
expr_stmt|;
block|}
comment|/**      * Register a custom operator processor with the engine.      *       * @param operator The operator as a string.      * @param op Processor instance.      */
specifier|public
name|void
name|registerOperatorProcessor
parameter_list|(
name|String
name|operator
parameter_list|,
name|OperatorProcessor
name|op
parameter_list|)
block|{
name|op
operator|.
name|setContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|operators
operator|.
name|put
argument_list|(
name|operator
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method must be called between processing documents. The PDFStreamEngine caches      * information for the document between pages and this will release the cached information.      * This only needs to be called if processing a new document.      */
specifier|public
name|void
name|resetEngine
parameter_list|()
block|{
comment|// overridden in subclasses
block|}
comment|/**      * Initialises a stream for processing.      *      * @param drawingSize the size of the page      * @param rotation the page rotation      */
specifier|protected
name|void
name|initStream
parameter_list|(
name|PDRectangle
name|drawingSize
parameter_list|,
name|int
name|rotation
parameter_list|)
block|{
name|drawingRectangle
operator|=
name|drawingSize
expr_stmt|;
name|pageRotation
operator|=
name|rotation
expr_stmt|;
name|graphicsStack
operator|.
name|clear
argument_list|()
expr_stmt|;
name|graphicsStack
operator|.
name|push
argument_list|(
operator|new
name|PDGraphicsState
argument_list|(
name|drawingRectangle
argument_list|)
argument_list|)
expr_stmt|;
name|textMatrix
operator|=
literal|null
expr_stmt|;
name|textLineMatrix
operator|=
literal|null
expr_stmt|;
name|streamResourcesStack
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * This will initialise and process the contents of the stream.      *       * @param resources The location to retrieve resources.      * @param cosStream the Stream to execute.      * @param drawingSize the size of the page      * @param rotation the page rotation      * @throws IOException if there is an error accessing the stream.      */
specifier|public
name|void
name|processStream
parameter_list|(
name|PDResources
name|resources
parameter_list|,
name|COSStream
name|cosStream
parameter_list|,
name|PDRectangle
name|drawingSize
parameter_list|,
name|int
name|rotation
parameter_list|)
throws|throws
name|IOException
block|{
name|initStream
argument_list|(
name|drawingSize
argument_list|,
name|rotation
argument_list|)
expr_stmt|;
name|processSubStream
argument_list|(
name|resources
argument_list|,
name|cosStream
argument_list|)
expr_stmt|;
block|}
comment|/**      * Process a sub stream of the current stream.      *       * @param resources The resources used when processing the stream.      * @param cosStream The stream to process.      * @throws IOException If there is an exception while processing the stream.      */
specifier|public
name|void
name|processSubStream
parameter_list|(
name|PDResources
name|resources
parameter_list|,
name|COSStream
name|cosStream
parameter_list|)
throws|throws
name|IOException
block|{
comment|// sanity check
if|if
condition|(
name|drawingRectangle
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Call to processSubStream() before processStream() "
operator|+
literal|"or initStream()"
argument_list|)
throw|;
block|}
if|if
condition|(
name|resources
operator|!=
literal|null
condition|)
block|{
name|streamResourcesStack
operator|.
name|push
argument_list|(
name|resources
argument_list|)
expr_stmt|;
try|try
block|{
name|processSubStream
argument_list|(
name|cosStream
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|streamResourcesStack
operator|.
name|pop
argument_list|()
operator|.
name|clearCache
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|processSubStream
argument_list|(
name|cosStream
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|processSubStream
parameter_list|(
name|COSStream
name|cosStream
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|COSBase
argument_list|>
name|arguments
init|=
operator|new
name|ArrayList
argument_list|<
name|COSBase
argument_list|>
argument_list|()
decl_stmt|;
name|PDFStreamParser
name|parser
init|=
operator|new
name|PDFStreamParser
argument_list|(
name|cosStream
argument_list|,
name|forceParsing
argument_list|)
decl_stmt|;
try|try
block|{
name|Iterator
argument_list|<
name|Object
argument_list|>
name|iter
init|=
name|parser
operator|.
name|getTokenIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|next
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"processing substream token: "
operator|+
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|instanceof
name|COSObject
condition|)
block|{
name|arguments
operator|.
name|add
argument_list|(
operator|(
operator|(
name|COSObject
operator|)
name|next
operator|)
operator|.
name|getObject
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next
operator|instanceof
name|PDFOperator
condition|)
block|{
name|processOperator
argument_list|(
operator|(
name|PDFOperator
operator|)
name|next
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
name|arguments
operator|=
operator|new
name|ArrayList
argument_list|<
name|COSBase
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|arguments
operator|.
name|add
argument_list|(
operator|(
name|COSBase
operator|)
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|parser
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Process encoded text from the PDF Stream. You should override this method if you want to      * perform an action when encoded text is being processed.      *       * @param string The encoded text      * @throws IOException If there is an error processing the string      */
specifier|public
name|void
name|processEncodedText
parameter_list|(
name|byte
index|[]
name|string
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Note on variable names. There are three different units being used in this code.
comment|// Character sizes are given in glyph units, text locations are initially given in text
comment|// units, and we want to save the data in display units. The variable names should end with
comment|// Text or Disp to represent if the values are in text or disp units (no glyph units are
comment|// saved).
name|PDGraphicsState
name|graphicsState
init|=
name|getGraphicsState
argument_list|()
decl_stmt|;
specifier|final
name|float
name|fontSizeText
init|=
name|graphicsState
operator|.
name|getTextState
argument_list|()
operator|.
name|getFontSize
argument_list|()
decl_stmt|;
specifier|final
name|float
name|horizontalScalingText
init|=
name|graphicsState
operator|.
name|getTextState
argument_list|()
operator|.
name|getHorizontalScaling
argument_list|()
operator|/
literal|100f
decl_stmt|;
specifier|final
name|float
name|riseText
init|=
name|graphicsState
operator|.
name|getTextState
argument_list|()
operator|.
name|getRise
argument_list|()
decl_stmt|;
specifier|final
name|float
name|wordSpacingText
init|=
name|graphicsState
operator|.
name|getTextState
argument_list|()
operator|.
name|getWordSpacing
argument_list|()
decl_stmt|;
specifier|final
name|float
name|characterSpacingText
init|=
name|graphicsState
operator|.
name|getTextState
argument_list|()
operator|.
name|getCharacterSpacing
argument_list|()
decl_stmt|;
comment|// We won't know the actual number of characters until
comment|// we process the byte data(could be two bytes each) but
comment|// it won't ever be more than string.length*2(there are some cases
comment|// were a single byte will result in two output characters "fi"
specifier|final
name|PDFont
name|font
init|=
name|graphicsState
operator|.
name|getTextState
argument_list|()
operator|.
name|getFont
argument_list|()
decl_stmt|;
comment|// all fonts have the width/height of a character in thousandths of a unit of text space
name|float
name|fontMatrixXScaling
init|=
literal|1
operator|/
literal|1000f
decl_stmt|;
name|float
name|fontMatrixYScaling
init|=
literal|1
operator|/
literal|1000f
decl_stmt|;
name|float
name|glyphSpaceToTextSpaceFactor
init|=
literal|1
operator|/
literal|1000f
decl_stmt|;
comment|// expect Type3 fonts, those are providing the width of a character in glyph space units
if|if
condition|(
name|font
operator|instanceof
name|PDType3Font
condition|)
block|{
name|PDMatrix
name|fontMatrix
init|=
name|font
operator|.
name|getFontMatrix
argument_list|()
decl_stmt|;
name|fontMatrixXScaling
operator|=
name|fontMatrix
operator|.
name|getValue
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fontMatrixYScaling
operator|=
name|fontMatrix
operator|.
name|getValue
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// This will typically be 1000 but in the case of a type3 font
comment|// this might be a different number
name|glyphSpaceToTextSpaceFactor
operator|=
literal|1f
operator|/
name|fontMatrix
operator|.
name|getValue
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|float
name|spaceWidthText
init|=
literal|0
decl_stmt|;
try|try
block|{
comment|// to avoid crash as described in PDFBOX-614, see what the space displacement should be
name|spaceWidthText
operator|=
name|font
operator|.
name|getSpaceWidth
argument_list|()
operator|*
name|glyphSpaceToTextSpaceFactor
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|exception
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spaceWidthText
operator|==
literal|0
condition|)
block|{
name|spaceWidthText
operator|=
name|font
operator|.
name|getAverageFontWidth
argument_list|()
operator|*
name|glyphSpaceToTextSpaceFactor
expr_stmt|;
comment|// the average space width appears to be higher than necessary so make it smaller
name|spaceWidthText
operator|*=
literal|.80f
expr_stmt|;
block|}
if|if
condition|(
name|spaceWidthText
operator|==
literal|0
condition|)
block|{
name|spaceWidthText
operator|=
literal|1.0f
expr_stmt|;
comment|// if could not find font, use a generic value
block|}
name|float
name|maxVerticalDisplacementText
init|=
literal|0
decl_stmt|;
name|Matrix
name|textStateParameters
init|=
operator|new
name|Matrix
argument_list|()
decl_stmt|;
name|textStateParameters
operator|.
name|setValue
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|fontSizeText
operator|*
name|horizontalScalingText
argument_list|)
expr_stmt|;
name|textStateParameters
operator|.
name|setValue
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|fontSizeText
argument_list|)
expr_stmt|;
name|textStateParameters
operator|.
name|setValue
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|riseText
argument_list|)
expr_stmt|;
name|float
name|pageHeight
init|=
name|drawingRectangle
operator|.
name|getHeight
argument_list|()
decl_stmt|;
name|float
name|pageWidth
init|=
name|drawingRectangle
operator|.
name|getWidth
argument_list|()
decl_stmt|;
name|Matrix
name|ctm
init|=
name|getGraphicsState
argument_list|()
operator|.
name|getCurrentTransformationMatrix
argument_list|()
decl_stmt|;
name|Matrix
name|textXctm
init|=
operator|new
name|Matrix
argument_list|()
decl_stmt|;
name|Matrix
name|textMatrixEnd
init|=
operator|new
name|Matrix
argument_list|()
decl_stmt|;
name|Matrix
name|td
init|=
operator|new
name|Matrix
argument_list|()
decl_stmt|;
name|Matrix
name|tempMatrix
init|=
operator|new
name|Matrix
argument_list|()
decl_stmt|;
name|int
name|codeLength
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|string
operator|.
name|length
condition|;
name|i
operator|+=
name|codeLength
control|)
block|{
comment|// Decode the value to a Unicode character
name|codeLength
operator|=
literal|1
expr_stmt|;
name|String
name|c
init|=
name|font
operator|.
name|encode
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
name|codeLength
argument_list|)
decl_stmt|;
name|int
index|[]
name|codePoints
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
operator|&&
name|i
operator|+
literal|1
operator|<
name|string
operator|.
name|length
condition|)
block|{
comment|// maybe a multibyte encoding
name|codeLength
operator|++
expr_stmt|;
name|c
operator|=
name|font
operator|.
name|encode
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
name|codeLength
argument_list|)
expr_stmt|;
name|codePoints
operator|=
operator|new
name|int
index|[]
block|{
name|font
operator|.
name|getCodeFromArray
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
name|codeLength
argument_list|)
block|}
expr_stmt|;
block|}
else|else
block|{
name|codePoints
operator|=
operator|new
name|int
index|[]
block|{
name|font
operator|.
name|getCodeFromArray
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
name|codeLength
argument_list|)
block|}
expr_stmt|;
block|}
comment|// the space width has to be transformed into display units
name|float
name|spaceWidthDisp
init|=
name|spaceWidthText
operator|*
name|fontSizeText
operator|*
name|horizontalScalingText
operator|*
name|textMatrix
operator|.
name|getXScale
argument_list|()
operator|*
name|ctm
operator|.
name|getXScale
argument_list|()
decl_stmt|;
comment|// TODO: handle horizontal displacement
comment|// get the width and height of this character in text units
name|float
name|charHorizontalDisplacementText
init|=
name|font
operator|.
name|getFontWidth
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
name|codeLength
argument_list|)
decl_stmt|;
name|float
name|charVerticalDisplacementText
init|=
name|font
operator|.
name|getFontHeight
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
name|codeLength
argument_list|)
decl_stmt|;
comment|// multiply the width/height with the scaling factor
name|charHorizontalDisplacementText
operator|=
name|charHorizontalDisplacementText
operator|*
name|fontMatrixXScaling
expr_stmt|;
name|charVerticalDisplacementText
operator|=
name|charVerticalDisplacementText
operator|*
name|fontMatrixYScaling
expr_stmt|;
name|maxVerticalDisplacementText
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxVerticalDisplacementText
argument_list|,
name|charVerticalDisplacementText
argument_list|)
expr_stmt|;
comment|// PDF Spec - 5.5.2 Word Spacing
comment|//
comment|// Word spacing works the same was as character spacing, but applies
comment|// only to the space character, code 32.
comment|//
comment|// Note: Word spacing is applied to every occurrence of the single-byte
comment|// character code 32 in a string. This can occur when using a simple
comment|// font or a composite font that defines code 32 as a single-byte code.
comment|// It does not apply to occurrences of the byte value 32 in multiple-byte
comment|// codes.
comment|//
comment|// RDD - My interpretation of this is that only character code 32's that
comment|// encode to spaces should have word spacing applied. Cases have been
comment|// observed where a font has a space character with a character code
comment|// other than 32, and where word spacing (Tw) was used. In these cases,
comment|// applying word spacing to either the non-32 space or to the character
comment|// code 32 non-space resulted in errors consistent with this interpretation.
comment|//
name|float
name|spacingText
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|0x20
operator|&&
name|codeLength
operator|==
literal|1
condition|)
block|{
name|spacingText
operator|+=
name|wordSpacingText
expr_stmt|;
block|}
name|textMatrix
operator|.
name|multiply
argument_list|(
name|ctm
argument_list|,
name|textXctm
argument_list|)
expr_stmt|;
comment|// Convert textMatrix to display units
comment|// We need to instantiate a new Matrix instance here as it is passed to the TextPosition
comment|// constructor below
name|Matrix
name|textMatrixStart
init|=
name|textStateParameters
operator|.
name|multiply
argument_list|(
name|textXctm
argument_list|)
decl_stmt|;
comment|// TODO: tx should be set for horizontal text and ty for vertical text
comment|// which seems to be specified in the font (not the direction in the matrix).
name|float
name|tx
init|=
name|charHorizontalDisplacementText
operator|*
name|fontSizeText
operator|*
name|horizontalScalingText
decl_stmt|;
name|float
name|ty
init|=
literal|0
decl_stmt|;
comment|// reset the matrix instead of creating a new one
name|td
operator|.
name|reset
argument_list|()
expr_stmt|;
name|td
operator|.
name|setValue
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|td
operator|.
name|setValue
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|ty
argument_list|)
expr_stmt|;
comment|// The text matrix gets updated after each glyph is placed. The updated
comment|// version will have the X and Y coordinates for the next glyph.
comment|// textMatrixEnd contains the coordinates of the end of the last glyph without
comment|// taking characterSpacingText and spacintText into account, otherwise it'll be
comment|// impossible to detect new words within text extraction
name|textStateParameters
operator|.
name|multiply
argument_list|(
name|td
argument_list|,
name|tempMatrix
argument_list|)
expr_stmt|;
name|tempMatrix
operator|.
name|multiply
argument_list|(
name|textXctm
argument_list|,
name|textMatrixEnd
argument_list|)
expr_stmt|;
specifier|final
name|float
name|endXPosition
init|=
name|textMatrixEnd
operator|.
name|getXPosition
argument_list|()
decl_stmt|;
specifier|final
name|float
name|endYPosition
init|=
name|textMatrixEnd
operator|.
name|getYPosition
argument_list|()
decl_stmt|;
comment|// add some spacing to the text matrix (see comment above)
name|tx
operator|=
operator|(
name|charHorizontalDisplacementText
operator|*
name|fontSizeText
operator|+
name|characterSpacingText
operator|+
name|spacingText
operator|)
operator|*
name|horizontalScalingText
expr_stmt|;
name|td
operator|.
name|setValue
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|td
operator|.
name|multiply
argument_list|(
name|textMatrix
argument_list|,
name|textMatrix
argument_list|)
expr_stmt|;
comment|// determine the width of this character
comment|// XXX: Note that if we handled vertical text, we should be using Y here
name|float
name|startXPosition
init|=
name|textMatrixStart
operator|.
name|getXPosition
argument_list|()
decl_stmt|;
name|float
name|widthText
init|=
name|endXPosition
operator|-
name|startXPosition
decl_stmt|;
comment|// PDFBOX-373: Replace a null entry with "?" so it is not printed as "(null)"
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
name|c
operator|=
literal|"?"
expr_stmt|;
block|}
name|float
name|totalVerticalDisplacementDisp
init|=
name|maxVerticalDisplacementText
operator|*
name|fontSizeText
operator|*
name|textXctm
operator|.
name|getYScale
argument_list|()
decl_stmt|;
comment|// process the decoded text
name|processTextPosition
argument_list|(
operator|new
name|TextPosition
argument_list|(
name|pageRotation
argument_list|,
name|pageWidth
argument_list|,
name|pageHeight
argument_list|,
name|textMatrixStart
argument_list|,
name|endXPosition
argument_list|,
name|endYPosition
argument_list|,
name|totalVerticalDisplacementDisp
argument_list|,
name|widthText
argument_list|,
name|spaceWidthDisp
argument_list|,
name|c
argument_list|,
name|codePoints
argument_list|,
name|font
argument_list|,
name|fontSizeText
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fontSizeText
operator|*
name|textMatrix
operator|.
name|getXScale
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * A method provided as an event interface to allow a subclass to perform some specific      * functionality when text needs to be processed.      *      * @param text The text to be processed.      */
specifier|protected
name|void
name|processTextPosition
parameter_list|(
name|TextPosition
name|text
parameter_list|)
block|{
comment|// subclasses can override to provide specific functionality.
block|}
comment|/**      * This is used to handle an operation.      *       * @param operation The operation to perform.      * @param arguments The list of arguments.      * @throws IOException If there is an error processing the operation.      */
specifier|public
name|void
name|processOperator
parameter_list|(
name|String
name|operation
parameter_list|,
name|List
argument_list|<
name|COSBase
argument_list|>
name|arguments
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|PDFOperator
name|operator
init|=
name|PDFOperator
operator|.
name|getOperator
argument_list|(
name|operation
argument_list|)
decl_stmt|;
name|processOperator
argument_list|(
name|operator
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This is used to handle an operation.      *       * @param operator The operation to perform.      * @param arguments The list of arguments.      * @throws IOException If there is an error processing the operation.      */
specifier|protected
name|void
name|processOperator
parameter_list|(
name|PDFOperator
name|operator
parameter_list|,
name|List
argument_list|<
name|COSBase
argument_list|>
name|arguments
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|operation
init|=
name|operator
operator|.
name|getOperation
argument_list|()
decl_stmt|;
name|OperatorProcessor
name|processor
init|=
name|operators
operator|.
name|get
argument_list|(
name|operation
argument_list|)
decl_stmt|;
if|if
condition|(
name|processor
operator|!=
literal|null
condition|)
block|{
name|processor
operator|.
name|setContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|processor
operator|.
name|process
argument_list|(
name|operator
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|unsupportedOperators
operator|.
name|contains
argument_list|(
name|operation
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"unsupported/disabled operation: "
operator|+
name|operation
argument_list|)
expr_stmt|;
name|unsupportedOperators
operator|.
name|add
argument_list|(
name|operation
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * @return Returns the XObjects.      */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|PDXObject
argument_list|>
name|getXObjects
parameter_list|()
block|{
return|return
name|streamResourcesStack
operator|.
name|peek
argument_list|()
operator|.
name|getXObjects
argument_list|()
return|;
block|}
comment|/**      * @return Returns the fonts.      */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|PDFont
argument_list|>
name|getFonts
parameter_list|()
block|{
if|if
condition|(
name|streamResourcesStack
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
return|return
name|streamResourcesStack
operator|.
name|peek
argument_list|()
operator|.
name|getFonts
argument_list|()
return|;
block|}
comment|/**      * @param value The fonts to set.      */
specifier|public
name|void
name|setFonts
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|PDFont
argument_list|>
name|value
parameter_list|)
block|{
name|streamResourcesStack
operator|.
name|peek
argument_list|()
operator|.
name|setFonts
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**      * Pushes the current graphics state to the stack.      */
specifier|public
name|void
name|saveGraphicsState
parameter_list|()
block|{
name|graphicsStack
operator|.
name|push
argument_list|(
name|graphicsStack
operator|.
name|peek
argument_list|()
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Pops the current graphics state from the stack.      */
specifier|public
name|void
name|restoreGraphicsState
parameter_list|()
block|{
name|graphicsStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
comment|/**      * @return Returns the size of the graphicsStack.      */
specifier|public
name|int
name|getGraphicsStackSize
parameter_list|()
block|{
return|return
name|graphicsStack
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * @return Returns the graphicsState.      */
specifier|public
name|PDGraphicsState
name|getGraphicsState
parameter_list|()
block|{
return|return
name|graphicsStack
operator|.
name|peek
argument_list|()
return|;
block|}
comment|/**      * @return Returns the graphicsStates.      */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|PDExtendedGraphicsState
argument_list|>
name|getGraphicsStates
parameter_list|()
block|{
return|return
name|streamResourcesStack
operator|.
name|peek
argument_list|()
operator|.
name|getGraphicsStates
argument_list|()
return|;
block|}
comment|/**      * @return Returns the textLineMatrix.      */
specifier|public
name|Matrix
name|getTextLineMatrix
parameter_list|()
block|{
return|return
name|textLineMatrix
return|;
block|}
comment|/**      * @param value The textLineMatrix to set.      */
specifier|public
name|void
name|setTextLineMatrix
parameter_list|(
name|Matrix
name|value
parameter_list|)
block|{
name|textLineMatrix
operator|=
name|value
expr_stmt|;
block|}
comment|/**      * @return Returns the textMatrix.      */
specifier|public
name|Matrix
name|getTextMatrix
parameter_list|()
block|{
return|return
name|textMatrix
return|;
block|}
comment|/**      * @param value The textMatrix to set.      */
specifier|public
name|void
name|setTextMatrix
parameter_list|(
name|Matrix
name|value
parameter_list|)
block|{
name|textMatrix
operator|=
name|value
expr_stmt|;
block|}
comment|/**      * @return Returns the resources.      */
specifier|public
name|PDResources
name|getResources
parameter_list|()
block|{
return|return
name|streamResourcesStack
operator|.
name|peek
argument_list|()
return|;
block|}
comment|/**      * use the current transformation matrix to transform a single point.      *      * @param x x-coordinate of the point to be transform      * @param y y-coordinate of the point to be transform      * @return the transformed coordinates as Point2D.Double      */
specifier|public
name|Point2D
operator|.
name|Double
name|transformedPoint
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
block|{
name|double
index|[]
name|position
init|=
block|{
name|x
block|,
name|y
block|}
decl_stmt|;
name|getGraphicsState
argument_list|()
operator|.
name|getCurrentTransformationMatrix
argument_list|()
operator|.
name|createAffineTransform
argument_list|()
operator|.
name|transform
argument_list|(
name|position
argument_list|,
literal|0
argument_list|,
name|position
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|new
name|Point2D
operator|.
name|Double
argument_list|(
name|position
index|[
literal|0
index|]
argument_list|,
name|position
index|[
literal|1
index|]
argument_list|)
return|;
block|}
comment|/**      * use the current transformation matrix to transform a PDRectangle.      *       * @param rect the PDRectangle to transform      * @return the transformed coordinates as a GeneralPath      */
specifier|public
name|GeneralPath
name|transformedPDRectanglePath
parameter_list|(
name|PDRectangle
name|rect
parameter_list|)
block|{
name|float
name|x1
init|=
name|rect
operator|.
name|getLowerLeftX
argument_list|()
decl_stmt|;
name|float
name|y1
init|=
name|rect
operator|.
name|getLowerLeftY
argument_list|()
decl_stmt|;
name|float
name|x2
init|=
name|rect
operator|.
name|getUpperRightX
argument_list|()
decl_stmt|;
name|float
name|y2
init|=
name|rect
operator|.
name|getUpperRightY
argument_list|()
decl_stmt|;
name|Point2D
name|p0
init|=
name|transformedPoint
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
decl_stmt|;
name|Point2D
name|p1
init|=
name|transformedPoint
argument_list|(
name|x2
argument_list|,
name|y1
argument_list|)
decl_stmt|;
name|Point2D
name|p2
init|=
name|transformedPoint
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|)
decl_stmt|;
name|Point2D
name|p3
init|=
name|transformedPoint
argument_list|(
name|x1
argument_list|,
name|y2
argument_list|)
decl_stmt|;
name|GeneralPath
name|path
init|=
operator|new
name|GeneralPath
argument_list|()
decl_stmt|;
name|path
operator|.
name|moveTo
argument_list|(
operator|(
name|float
operator|)
name|p0
operator|.
name|getX
argument_list|()
argument_list|,
operator|(
name|float
operator|)
name|p0
operator|.
name|getY
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|lineTo
argument_list|(
operator|(
name|float
operator|)
name|p1
operator|.
name|getX
argument_list|()
argument_list|,
operator|(
name|float
operator|)
name|p1
operator|.
name|getY
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|lineTo
argument_list|(
operator|(
name|float
operator|)
name|p2
operator|.
name|getX
argument_list|()
argument_list|,
operator|(
name|float
operator|)
name|p2
operator|.
name|getY
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|lineTo
argument_list|(
operator|(
name|float
operator|)
name|p3
operator|.
name|getX
argument_list|()
argument_list|,
operator|(
name|float
operator|)
name|p3
operator|.
name|getY
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|.
name|closePath
argument_list|()
expr_stmt|;
return|return
name|path
return|;
block|}
comment|// transforms a width using the CTM
specifier|protected
name|float
name|transformWidth
parameter_list|(
name|float
name|width
parameter_list|)
block|{
name|Matrix
name|ctm
init|=
name|getGraphicsState
argument_list|()
operator|.
name|getCurrentTransformationMatrix
argument_list|()
decl_stmt|;
name|float
name|x
init|=
name|ctm
operator|.
name|getValue
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|+
name|ctm
operator|.
name|getValue
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|float
name|y
init|=
name|ctm
operator|.
name|getValue
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|+
name|ctm
operator|.
name|getValue
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
name|width
operator|*
operator|(
name|float
operator|)
name|Math
operator|.
name|sqrt
argument_list|(
operator|(
name|x
operator|*
name|x
operator|+
name|y
operator|*
name|y
operator|)
operator|*
literal|0.5
argument_list|)
return|;
block|}
block|}
end_class

end_unit

