begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDFontDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|text
operator|.
name|PDFTextStripper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|text
operator|.
name|TextPosition
import|;
end_import

begin_comment
comment|/**  * Wrap stripped text in simple HTML, trying to form HTML paragraphs. Paragraphs  * broken by pages, columns, or figures are not mended.  *  * @author John J Barton  *   */
end_comment

begin_class
specifier|public
class|class
name|PDFText2HTML
extends|extends
name|PDFTextStripper
block|{
specifier|private
specifier|static
specifier|final
name|int
name|INITIAL_PDF_TO_HTML_BYTES
init|=
literal|8192
decl_stmt|;
specifier|private
specifier|final
name|FontState
name|fontState
init|=
operator|new
name|FontState
argument_list|()
decl_stmt|;
comment|/**      * Constructor.      * @throws IOException If there is an error during initialization.      */
specifier|public
name|PDFText2HTML
parameter_list|()
throws|throws
name|IOException
block|{
name|super
argument_list|()
expr_stmt|;
name|setLineSeparator
argument_list|(
name|LINE_SEPARATOR
argument_list|)
expr_stmt|;
name|setParagraphStart
argument_list|(
literal|"<p>"
argument_list|)
expr_stmt|;
name|setParagraphEnd
argument_list|(
literal|"</p>"
operator|+
name|LINE_SEPARATOR
argument_list|)
expr_stmt|;
name|setPageStart
argument_list|(
literal|"<div style=\"page-break-before:always; page-break-after:always\">"
argument_list|)
expr_stmt|;
name|setPageEnd
argument_list|(
literal|"</div>"
operator|+
name|LINE_SEPARATOR
argument_list|)
expr_stmt|;
name|setArticleStart
argument_list|(
name|LINE_SEPARATOR
argument_list|)
expr_stmt|;
name|setArticleEnd
argument_list|(
name|LINE_SEPARATOR
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the header to the output document. Now also writes the tag defining      * the character encoding.      *      * @throws IOException      *             If there is a problem writing out the header to the document.      * @deprecated deprecated, use {@link #startDocument(PDDocument)}      */
specifier|protected
name|void
name|writeHeader
parameter_list|()
throws|throws
name|IOException
block|{     }
annotation|@
name|Override
specifier|protected
name|void
name|startDocument
parameter_list|(
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|INITIAL_PDF_TO_HTML_BYTES
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\""
operator|+
literal|"\n"
operator|+
literal|"\"http://www.w3.org/TR/html4/loose.dtd\">\n"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"<html><head>"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"<title>"
argument_list|)
operator|.
name|append
argument_list|(
name|escape
argument_list|(
name|getTitle
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"</title>\n"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=\"UTF-8\">\n"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"</head>\n"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"<body>\n"
argument_list|)
expr_stmt|;
name|super
operator|.
name|writeString
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
specifier|public
name|void
name|endDocument
parameter_list|(
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeString
argument_list|(
literal|"</body></html>"
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method will attempt to guess the title of the document using      * either the document properties or the first lines of text.      *      * @return returns the title.      */
specifier|protected
name|String
name|getTitle
parameter_list|()
block|{
name|String
name|titleGuess
init|=
name|document
operator|.
name|getDocumentInformation
argument_list|()
operator|.
name|getTitle
argument_list|()
decl_stmt|;
if|if
condition|(
name|titleGuess
operator|!=
literal|null
operator|&&
name|titleGuess
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|titleGuess
return|;
block|}
else|else
block|{
name|Iterator
argument_list|<
name|List
argument_list|<
name|TextPosition
argument_list|>
argument_list|>
name|textIter
init|=
name|getCharactersByArticle
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|float
name|lastFontSize
init|=
operator|-
literal|1.0f
decl_stmt|;
name|StringBuilder
name|titleText
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|textIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
for|for
control|(
name|TextPosition
name|position
range|:
name|textIter
operator|.
name|next
argument_list|()
control|)
block|{
name|float
name|currentFontSize
init|=
name|position
operator|.
name|getFontSize
argument_list|()
decl_stmt|;
comment|//If we're past 64 chars we will assume that we're past the title
comment|//64 is arbitrary
if|if
condition|(
name|currentFontSize
operator|!=
name|lastFontSize
operator|||
name|titleText
operator|.
name|length
argument_list|()
operator|>
literal|64
condition|)
block|{
if|if
condition|(
name|titleText
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
name|titleText
operator|.
name|toString
argument_list|()
return|;
block|}
name|lastFontSize
operator|=
name|currentFontSize
expr_stmt|;
block|}
if|if
condition|(
name|currentFontSize
operator|>
literal|13.0f
condition|)
block|{
comment|// most body text is 12pt
name|titleText
operator|.
name|append
argument_list|(
name|position
operator|.
name|getUnicode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|""
return|;
block|}
comment|/**      * Write out the article separator (div tag) with proper text direction      * information.      *      * @param isLTR true if direction of text is left to right      * @throws IOException      *             If there is an error writing to the stream.      */
annotation|@
name|Override
specifier|protected
name|void
name|startArticle
parameter_list|(
name|boolean
name|isLTR
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isLTR
condition|)
block|{
name|super
operator|.
name|writeString
argument_list|(
literal|"<div>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|super
operator|.
name|writeString
argument_list|(
literal|"<div dir=\"RTL\">"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Write out the article separator.      *      * @throws IOException      *             If there is an error writing to the stream.      */
annotation|@
name|Override
specifier|protected
name|void
name|endArticle
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|endArticle
argument_list|()
expr_stmt|;
name|super
operator|.
name|writeString
argument_list|(
literal|"</div>"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write a string to the output stream, maintain font state, and escape some HTML characters.      * The font state is only preserved per word.      *      * @param text The text to write to the stream.      * @param textPositions the corresponding text positions      * @throws IOException If there is an error writing to the stream.      */
annotation|@
name|Override
specifier|protected
name|void
name|writeString
parameter_list|(
name|String
name|text
parameter_list|,
name|List
argument_list|<
name|TextPosition
argument_list|>
name|textPositions
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeString
argument_list|(
name|fontState
operator|.
name|push
argument_list|(
name|text
argument_list|,
name|textPositions
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write a string to the output stream and escape some HTML characters.      *      * @param chars String to be written to the stream      * @throws IOException      *             If there is an error writing to the stream.      */
annotation|@
name|Override
specifier|protected
name|void
name|writeString
parameter_list|(
name|String
name|chars
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeString
argument_list|(
name|escape
argument_list|(
name|chars
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes the paragraph end "&lt;/p&gt;" to the output. Furthermore, it will also clear the font state.      *       * {@inheritDoc}      */
annotation|@
name|Override
specifier|protected
name|void
name|writeParagraphEnd
parameter_list|()
throws|throws
name|IOException
block|{
comment|// do not escape HTML
name|super
operator|.
name|writeString
argument_list|(
name|fontState
operator|.
name|clear
argument_list|()
argument_list|)
expr_stmt|;
name|super
operator|.
name|writeParagraphEnd
argument_list|()
expr_stmt|;
block|}
comment|/**      * Escape some HTML characters.      *      * @param chars String to be escaped      * @return returns escaped String.      */
specifier|private
specifier|static
name|String
name|escape
parameter_list|(
name|String
name|chars
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|chars
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|chars
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|appendEscaped
argument_list|(
name|builder
argument_list|,
name|chars
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|appendEscaped
parameter_list|(
name|StringBuilder
name|builder
parameter_list|,
name|char
name|character
parameter_list|)
block|{
comment|// write non-ASCII as named entities
if|if
condition|(
operator|(
name|character
operator|<
literal|32
operator|)
operator|||
operator|(
name|character
operator|>
literal|126
operator|)
condition|)
block|{
name|int
name|charAsInt
init|=
name|character
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"&#"
argument_list|)
operator|.
name|append
argument_list|(
name|charAsInt
argument_list|)
operator|.
name|append
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|34
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"&quot;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|38
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|60
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|62
case|:
name|builder
operator|.
name|append
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|builder
operator|.
name|append
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|character
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * A helper class to maintain the current font state. It's public methods will emit opening and      * closing tags as needed, and in the correct order.      *      * @author Axel Dörfler      */
specifier|private
specifier|static
class|class
name|FontState
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|stateList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|stateSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**          * Pushes new {@link TextPosition TextPositions} into the font state. The state is only          * preserved correctly for each letter if the number of letters in<code>text</code> matches          * the number of {@link TextPosition} objects. Otherwise, it's done once for the complete          * array (just by looking at its first entry).          *          * @return A string that contains the text including tag changes caused by its font state.          */
specifier|public
name|String
name|push
parameter_list|(
name|String
name|text
parameter_list|,
name|List
argument_list|<
name|TextPosition
argument_list|>
name|textPositions
parameter_list|)
block|{
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|text
operator|.
name|length
argument_list|()
operator|==
name|textPositions
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// There is a 1:1 mapping, and we can use the TextPositions directly
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|text
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|push
argument_list|(
name|buffer
argument_list|,
name|text
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|,
name|textPositions
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// The normalized text does not match the number of TextPositions, so we'll just
comment|// have a look at its first entry.
comment|// TODO change PDFTextStripper.normalize() such that it maintains the 1:1 relation
if|if
condition|(
name|textPositions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|text
return|;
block|}
name|push
argument_list|(
name|buffer
argument_list|,
name|text
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|,
name|textPositions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|escape
argument_list|(
name|text
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**          * Closes all open states.          * @return A string that contains the closing tags of all currently open states.          */
specifier|public
name|String
name|clear
parameter_list|()
block|{
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|closeUntil
argument_list|(
name|buffer
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|stateList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|stateSet
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
name|String
name|push
parameter_list|(
name|StringBuilder
name|buffer
parameter_list|,
name|char
name|character
parameter_list|,
name|TextPosition
name|textPosition
parameter_list|)
block|{
name|boolean
name|bold
init|=
literal|false
decl_stmt|;
name|boolean
name|italics
init|=
literal|false
decl_stmt|;
name|PDFontDescriptor
name|descriptor
init|=
name|textPosition
operator|.
name|getFont
argument_list|()
operator|.
name|getFontDescriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|descriptor
operator|!=
literal|null
condition|)
block|{
name|bold
operator|=
name|isBold
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
name|italics
operator|=
name|isItalic
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|.
name|append
argument_list|(
name|bold
condition|?
name|open
argument_list|(
literal|"b"
argument_list|)
else|:
name|close
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|italics
condition|?
name|open
argument_list|(
literal|"i"
argument_list|)
else|:
name|close
argument_list|(
literal|"i"
argument_list|)
argument_list|)
expr_stmt|;
name|appendEscaped
argument_list|(
name|buffer
argument_list|,
name|character
argument_list|)
expr_stmt|;
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|String
name|open
parameter_list|(
name|String
name|tag
parameter_list|)
block|{
if|if
condition|(
name|stateSet
operator|.
name|contains
argument_list|(
name|tag
argument_list|)
condition|)
block|{
return|return
literal|""
return|;
block|}
name|stateList
operator|.
name|add
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|stateSet
operator|.
name|add
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
name|openTag
argument_list|(
name|tag
argument_list|)
return|;
block|}
specifier|private
name|String
name|close
parameter_list|(
name|String
name|tag
parameter_list|)
block|{
if|if
condition|(
operator|!
name|stateSet
operator|.
name|contains
argument_list|(
name|tag
argument_list|)
condition|)
block|{
return|return
literal|""
return|;
block|}
comment|// Close all tags until (but including) the one we should close
name|StringBuilder
name|tagsBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|closeUntil
argument_list|(
name|tagsBuilder
argument_list|,
name|tag
argument_list|)
decl_stmt|;
comment|// Remove from state
name|stateList
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|stateSet
operator|.
name|remove
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|// Now open the states that were closed but should remain open again
for|for
control|(
init|;
name|index
operator|<
name|stateList
operator|.
name|size
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|tagsBuilder
operator|.
name|append
argument_list|(
name|openTag
argument_list|(
name|stateList
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|tagsBuilder
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|int
name|closeUntil
parameter_list|(
name|StringBuilder
name|tagsBuilder
parameter_list|,
name|String
name|endTag
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|stateList
operator|.
name|size
argument_list|()
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|String
name|tag
init|=
name|stateList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|tagsBuilder
operator|.
name|append
argument_list|(
name|closeTag
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|endTag
operator|!=
literal|null
operator|&&
name|tag
operator|.
name|equals
argument_list|(
name|endTag
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|private
name|String
name|openTag
parameter_list|(
name|String
name|tag
parameter_list|)
block|{
return|return
literal|"<"
operator|+
name|tag
operator|+
literal|">"
return|;
block|}
specifier|private
name|String
name|closeTag
parameter_list|(
name|String
name|tag
parameter_list|)
block|{
return|return
literal|"</"
operator|+
name|tag
operator|+
literal|">"
return|;
block|}
specifier|private
name|boolean
name|isBold
parameter_list|(
name|PDFontDescriptor
name|descriptor
parameter_list|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|isForceBold
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|descriptor
operator|.
name|getFontName
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Bold"
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isItalic
parameter_list|(
name|PDFontDescriptor
name|descriptor
parameter_list|)
block|{
if|if
condition|(
name|descriptor
operator|.
name|isItalic
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|descriptor
operator|.
name|getFontName
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Italic"
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

