begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|xobject
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|image
operator|.
name|BufferedImage
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|imageio
operator|.
name|ImageIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|graphics
operator|.
name|color
operator|.
name|PDDeviceGray
import|;
end_import

begin_comment
comment|/**  * An image class for CCITT Fax.  *  * @author<a href="ben@benlitchfield.com">Ben Litchfield</a>  * @author paul king  * @version $Revision: 1.6 $  */
end_comment

begin_class
specifier|public
class|class
name|PDCcitt
extends|extends
name|PDXObjectImage
block|{
specifier|private
specifier|static
specifier|final
name|List
name|FAX_FILTERS
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
static|static
block|{
name|FAX_FILTERS
operator|.
name|add
argument_list|(
name|COSName
operator|.
name|CCITTFAX_DECODE
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|FAX_FILTERS
operator|.
name|add
argument_list|(
name|COSName
operator|.
name|CCITTFAX_DECODE_ABBREVIATION
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Standard constructor.      *      * @param ccitt The PDStream that already contains all ccitt information.      */
specifier|public
name|PDCcitt
parameter_list|(
name|PDStream
name|ccitt
parameter_list|)
block|{
name|super
argument_list|(
name|ccitt
argument_list|,
literal|"tiff"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Construct from a tiff file.      *      * @param doc The document to create the image as part of.      * @param raf The random access TIFF file which contains a suitable CCITT compressed image      * @throws IOException If there is an error reading the tiff data.      */
specifier|public
name|PDCcitt
parameter_list|(
name|PDDocument
name|doc
parameter_list|,
name|RandomAccess
name|raf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
operator|new
name|PDStream
argument_list|(
name|doc
argument_list|)
argument_list|,
literal|"tiff"
argument_list|)
expr_stmt|;
comment|// super( new PDStream( doc, null, true ), "tiff" );
name|COSDictionary
name|decodeParms
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|COSDictionary
name|dic
init|=
name|getCOSStream
argument_list|()
decl_stmt|;
name|extractFromTiff
argument_list|(
name|raf
argument_list|,
name|getCOSStream
argument_list|()
operator|.
name|createFilteredStream
argument_list|()
argument_list|,
name|decodeParms
argument_list|)
expr_stmt|;
name|dic
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|FILTER
argument_list|,
name|COSName
operator|.
name|CCITTFAX_DECODE
argument_list|)
expr_stmt|;
name|dic
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|SUBTYPE
argument_list|,
name|COSName
operator|.
name|IMAGE
argument_list|)
expr_stmt|;
name|dic
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|,
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"XObject"
argument_list|)
argument_list|)
expr_stmt|;
name|dic
operator|.
name|setItem
argument_list|(
literal|"DecodeParms"
argument_list|,
name|decodeParms
argument_list|)
expr_stmt|;
name|setBitsPerComponent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setColorSpace
argument_list|(
operator|new
name|PDDeviceGray
argument_list|()
argument_list|)
expr_stmt|;
name|setWidth
argument_list|(
name|decodeParms
operator|.
name|getInt
argument_list|(
literal|"Columns"
argument_list|)
argument_list|)
expr_stmt|;
name|setHeight
argument_list|(
name|decodeParms
operator|.
name|getInt
argument_list|(
literal|"Rows"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns an image of the CCITT Fax, or null if TIFFs are not supported. (Requires additional JAI Image filters )      *      * {@inheritDoc}      */
specifier|public
name|BufferedImage
name|getRGBImage
parameter_list|()
throws|throws
name|IOException
block|{
name|InputStream
name|tiff
init|=
operator|new
name|TiffWrapper
argument_list|(
name|getPDStream
argument_list|()
operator|.
name|getPartiallyFilteredStream
argument_list|(
name|FAX_FILTERS
argument_list|)
argument_list|,
name|getCOSStream
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|ImageIO
operator|.
name|read
argument_list|(
name|tiff
argument_list|)
return|;
block|}
finally|finally
block|{
name|tiff
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This writes a tiff to out.      *      * {@inheritDoc}      */
specifier|public
name|void
name|write2OutputStream
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|data
init|=
operator|new
name|TiffWrapper
argument_list|(
name|getPDStream
argument_list|()
operator|.
name|getPartiallyFilteredStream
argument_list|(
name|FAX_FILTERS
argument_list|)
argument_list|,
name|getCOSStream
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|amountRead
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|amountRead
operator|=
name|data
operator|.
name|read
argument_list|(
name|buf
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|amountRead
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Extract the ccitt stream from the tiff file.      *      * @param raf  - TIFF File      * @param os   - Stream to write raw ccitt data two      * @param parms - COSDictionary which the encoding parameters are added to      * @throws IOException If there is an error reading/writing to/from the stream      */
specifier|private
name|void
name|extractFromTiff
parameter_list|(
name|RandomAccess
name|raf
parameter_list|,
name|OutputStream
name|os
parameter_list|,
name|COSDictionary
name|parms
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// First check the basic tiff header
name|raf
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|char
name|endianess
init|=
operator|(
name|char
operator|)
name|raf
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|char
operator|)
name|raf
operator|.
name|read
argument_list|()
operator|!=
name|endianess
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not a valid tiff file"
argument_list|)
throw|;
block|}
comment|//ensure that endianess is either M or I
if|if
condition|(
name|endianess
operator|!=
literal|'M'
operator|&&
name|endianess
operator|!=
literal|'I'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not a valid tiff file"
argument_list|)
throw|;
block|}
name|int
name|magicNumber
init|=
name|readshort
argument_list|(
name|endianess
argument_list|,
name|raf
argument_list|)
decl_stmt|;
if|if
condition|(
name|magicNumber
operator|!=
literal|42
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not a valid tiff file"
argument_list|)
throw|;
block|}
comment|// Relocate to the first set of tags
name|raf
operator|.
name|seek
argument_list|(
name|readlong
argument_list|(
name|endianess
argument_list|,
name|raf
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numtags
init|=
name|readshort
argument_list|(
name|endianess
argument_list|,
name|raf
argument_list|)
decl_stmt|;
comment|//    The number 50 is somewhat arbitary, it just stops us load up junk from somewhere and tramping on
if|if
condition|(
name|numtags
operator|>
literal|50
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not a valid tiff file"
argument_list|)
throw|;
block|}
comment|// Loop through the tags, some will convert to items in the parms dictionary
comment|// Other point us to where to find the data stream
comment|// The only parm which might change as a result of other options is K, so
comment|// We'll deal with that as a special;
name|int
name|k
init|=
operator|-
literal|1000
decl_stmt|;
comment|// Default Non CCITT compression
name|int
name|dataoffset
init|=
literal|0
decl_stmt|;
name|int
name|datalength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numtags
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tag
init|=
name|readshort
argument_list|(
name|endianess
argument_list|,
name|raf
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|readshort
argument_list|(
name|endianess
argument_list|,
name|raf
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|readlong
argument_list|(
name|endianess
argument_list|,
name|raf
argument_list|)
decl_stmt|;
name|int
name|val
init|=
name|readlong
argument_list|(
name|endianess
argument_list|,
name|raf
argument_list|)
decl_stmt|;
comment|// See note
comment|// Note, we treated that value as a long. The value always occupies 4 bytes
comment|// But it might only use the first byte or two. Depending on endianess we might need to correct
comment|// Note we ignore all other types, they are of little interest for PDFs/CCITT Fax
if|if
condition|(
name|endianess
operator|==
literal|'M'
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|1
case|:
block|{
name|val
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
break|break;
comment|// byte value
block|}
case|case
literal|3
case|:
block|{
name|val
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
break|break;
comment|// short value
block|}
case|case
literal|4
case|:
block|{
break|break;
comment|// long value
block|}
default|default:
block|{
comment|//do nothing
block|}
block|}
block|}
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
literal|256
case|:
block|{
name|parms
operator|.
name|setInt
argument_list|(
literal|"Columns"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|257
case|:
block|{
name|parms
operator|.
name|setInt
argument_list|(
literal|"Rows"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|259
case|:
block|{
if|if
condition|(
name|val
operator|==
literal|4
condition|)
block|{
name|k
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
literal|3
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
block|}
break|break;
comment|// T6/T4 Compression
block|}
case|case
literal|262
case|:
block|{
if|if
condition|(
name|val
operator|==
literal|1
condition|)
block|{
name|parms
operator|.
name|setBoolean
argument_list|(
literal|"BlackIs1"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|273
case|:
block|{
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
name|dataoffset
operator|=
name|val
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|279
case|:
block|{
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
name|datalength
operator|=
name|val
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|292
case|:
block|{
if|if
condition|(
name|val
operator|==
literal|1
condition|)
block|{
name|k
operator|=
literal|50
expr_stmt|;
comment|// T4 2D - arbitary K value
block|}
break|break;
block|}
case|case
literal|324
case|:
block|{
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
name|dataoffset
operator|=
name|val
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|325
case|:
block|{
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
name|datalength
operator|=
name|val
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
comment|//do nothing
block|}
block|}
block|}
if|if
condition|(
name|k
operator|==
operator|-
literal|1000
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"First image in tiff is not CCITT T4 or T6 compressed"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dataoffset
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"First image in tiff is not a single tile/strip"
argument_list|)
throw|;
block|}
name|parms
operator|.
name|setInt
argument_list|(
literal|"K"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|raf
operator|.
name|seek
argument_list|(
name|dataoffset
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|amountRead
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|amountRead
operator|=
name|raf
operator|.
name|read
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
literal|8192
argument_list|,
name|datalength
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|datalength
operator|-=
name|amountRead
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|amountRead
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|readshort
parameter_list|(
name|char
name|endianess
parameter_list|,
name|RandomAccess
name|raf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|endianess
operator|==
literal|'I'
condition|)
block|{
return|return
name|raf
operator|.
name|read
argument_list|()
operator||
operator|(
name|raf
operator|.
name|read
argument_list|()
operator|<<
literal|8
operator|)
return|;
block|}
return|return
operator|(
name|raf
operator|.
name|read
argument_list|()
operator|<<
literal|8
operator|)
operator||
name|raf
operator|.
name|read
argument_list|()
return|;
block|}
specifier|private
name|int
name|readlong
parameter_list|(
name|char
name|endianess
parameter_list|,
name|RandomAccess
name|raf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|endianess
operator|==
literal|'I'
condition|)
block|{
return|return
name|raf
operator|.
name|read
argument_list|()
operator||
operator|(
name|raf
operator|.
name|read
argument_list|()
operator|<<
literal|8
operator|)
operator||
operator|(
name|raf
operator|.
name|read
argument_list|()
operator|<<
literal|16
operator|)
operator||
operator|(
name|raf
operator|.
name|read
argument_list|()
operator|<<
literal|24
operator|)
return|;
block|}
return|return
operator|(
name|raf
operator|.
name|read
argument_list|()
operator|<<
literal|24
operator|)
operator||
operator|(
name|raf
operator|.
name|read
argument_list|()
operator|<<
literal|16
operator|)
operator||
operator|(
name|raf
operator|.
name|read
argument_list|()
operator|<<
literal|8
operator|)
operator||
name|raf
operator|.
name|read
argument_list|()
return|;
block|}
comment|/**      * Extends InputStream to wrap the data from the CCITT Fax with a suitable TIFF Header.      * For details see www.tiff.org, which contains useful information including pointers to the      * TIFF 6.0 Specification      *      */
specifier|private
class|class
name|TiffWrapper
extends|extends
name|InputStream
block|{
specifier|private
name|int
name|currentOffset
decl_stmt|;
comment|// When reading, where in the tiffheader are we.
specifier|private
name|byte
index|[]
name|tiffheader
decl_stmt|;
comment|// Byte array to store tiff header data
specifier|private
name|InputStream
name|datastream
decl_stmt|;
comment|// Original InputStream
specifier|private
name|TiffWrapper
parameter_list|(
name|InputStream
name|rawstream
parameter_list|,
name|COSDictionary
name|options
parameter_list|)
block|{
name|buildHeader
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|currentOffset
operator|=
literal|0
expr_stmt|;
name|datastream
operator|=
name|rawstream
expr_stmt|;
block|}
comment|// Implement basic methods from InputStream
comment|/**          * {@inheritDoc}          */
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**          * {@inheritDoc}          */
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"reset not supported"
argument_list|)
throw|;
block|}
comment|/**          * For simple read, take a byte from the tiffheader array or pass through.          *          * {@inheritDoc}          */
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentOffset
operator|<
name|tiffheader
operator|.
name|length
condition|)
block|{
return|return
name|tiffheader
index|[
name|currentOffset
operator|++
index|]
return|;
block|}
return|return
name|datastream
operator|.
name|read
argument_list|()
return|;
block|}
comment|/**          * For read methods only return as many bytes as we have left in the header          * if we've exhausted the header, pass through to the InputStream of the raw CCITT data.          *          * {@inheritDoc}          */
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentOffset
operator|<
name|tiffheader
operator|.
name|length
condition|)
block|{
name|int
name|length
init|=
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|min
argument_list|(
name|tiffheader
operator|.
name|length
operator|-
name|currentOffset
argument_list|,
name|data
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|tiffheader
argument_list|,
name|currentOffset
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|currentOffset
operator|+=
name|length
expr_stmt|;
return|return
name|length
return|;
block|}
else|else
block|{
return|return
name|datastream
operator|.
name|read
argument_list|(
name|data
argument_list|)
return|;
block|}
block|}
comment|/**          * For read methods only return as many bytes as we have left in the header          * if we've exhausted the header, pass through to the InputStream of the raw CCITT data.          *          *  {@inheritDoc}          */
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentOffset
operator|<
name|tiffheader
operator|.
name|length
condition|)
block|{
name|int
name|length
init|=
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|min
argument_list|(
name|tiffheader
operator|.
name|length
operator|-
name|currentOffset
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|tiffheader
argument_list|,
name|currentOffset
argument_list|,
name|data
argument_list|,
name|off
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|currentOffset
operator|+=
name|length
expr_stmt|;
return|return
name|length
return|;
block|}
else|else
block|{
return|return
name|datastream
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
comment|/**          * When skipping if any header data not yet read, only allow to skip what we've in the buffer          * Otherwise just pass through.          *          * {@inheritDoc}          */
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentOffset
operator|<
name|tiffheader
operator|.
name|length
condition|)
block|{
name|long
name|length
init|=
name|Math
operator|.
name|min
argument_list|(
name|tiffheader
operator|.
name|length
operator|-
name|currentOffset
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|currentOffset
operator|+=
name|length
expr_stmt|;
return|return
name|length
return|;
block|}
else|else
block|{
return|return
name|datastream
operator|.
name|skip
argument_list|(
name|n
argument_list|)
return|;
block|}
block|}
comment|// Static data for the beginning of the TIFF header
specifier|private
specifier|final
name|byte
index|[]
name|basicHeader
init|=
block|{
literal|'I'
block|,
literal|'I'
block|,
literal|42
block|,
literal|0
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// File introducer and pointer to first IFD
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|// Number of tags start with two
specifier|private
name|int
name|additionalOffset
decl_stmt|;
comment|// Offset in header to additional data
comment|// Builds up the tiffheader based on the options passed through.
specifier|private
name|void
name|buildHeader
parameter_list|(
name|COSDictionary
name|options
parameter_list|)
block|{
specifier|final
name|int
name|numOfTags
init|=
literal|10
decl_stmt|;
comment|// The maximum tags we'll fill
specifier|final
name|int
name|maxAdditionalData
init|=
literal|24
decl_stmt|;
comment|// The maximum amount of additional data
comment|// outside the IFDs. (bytes)
comment|// The length of the header will be the length of the basic header (10)
comment|// plus 12 bytes for each IFD, 4 bytes as a pointer to the next IFD (will be 0)
comment|// plus the length of the additional data
name|tiffheader
operator|=
operator|new
name|byte
index|[
literal|10
operator|+
operator|(
literal|12
operator|*
name|numOfTags
operator|)
operator|+
literal|4
operator|+
name|maxAdditionalData
index|]
expr_stmt|;
name|java
operator|.
name|util
operator|.
name|Arrays
operator|.
name|fill
argument_list|(
name|tiffheader
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|basicHeader
argument_list|,
literal|0
argument_list|,
name|tiffheader
argument_list|,
literal|0
argument_list|,
name|basicHeader
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Additional data outside the IFD starts after the IFD's and pointer to the next IFD (0)
name|additionalOffset
operator|=
literal|10
operator|+
operator|(
literal|12
operator|*
name|numOfTags
operator|)
operator|+
literal|4
expr_stmt|;
comment|// Now work out the variable values from TIFF defaults,
comment|// PDF Defaults and the Dictionary for this XObject
name|short
name|cols
init|=
literal|1728
decl_stmt|;
name|short
name|rows
init|=
literal|0
decl_stmt|;
name|short
name|blackis1
init|=
literal|0
decl_stmt|;
name|short
name|comptype
init|=
literal|3
decl_stmt|;
comment|// T4 compression
name|long
name|t4options
init|=
literal|0
decl_stmt|;
comment|// Will set if 1d or 2d T4
name|COSBase
name|dicOrArrayParms
init|=
name|options
operator|.
name|getDictionaryObject
argument_list|(
literal|"DecodeParms"
argument_list|)
decl_stmt|;
name|COSDictionary
name|decodeParms
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|dicOrArrayParms
operator|instanceof
name|COSDictionary
condition|)
block|{
name|decodeParms
operator|=
operator|(
name|COSDictionary
operator|)
name|dicOrArrayParms
expr_stmt|;
block|}
else|else
block|{
name|COSArray
name|parmsArray
init|=
operator|(
name|COSArray
operator|)
name|dicOrArrayParms
decl_stmt|;
if|if
condition|(
name|parmsArray
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|decodeParms
operator|=
operator|(
name|COSDictionary
operator|)
name|parmsArray
operator|.
name|getObject
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//else find the first dictionary with Row/Column info and use that.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parmsArray
operator|.
name|size
argument_list|()
operator|&&
name|decodeParms
operator|==
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|COSDictionary
name|dic
init|=
operator|(
name|COSDictionary
operator|)
name|parmsArray
operator|.
name|getObject
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|dic
operator|.
name|getDictionaryObject
argument_list|(
literal|"Columns"
argument_list|)
operator|!=
literal|null
operator|||
name|dic
operator|.
name|getDictionaryObject
argument_list|(
literal|"Rows"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|decodeParms
operator|=
name|dic
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|decodeParms
operator|!=
literal|null
condition|)
block|{
name|cols
operator|=
operator|(
name|short
operator|)
name|decodeParms
operator|.
name|getInt
argument_list|(
literal|"Columns"
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|rows
operator|=
operator|(
name|short
operator|)
name|decodeParms
operator|.
name|getInt
argument_list|(
literal|"Rows"
argument_list|,
name|rows
argument_list|)
expr_stmt|;
if|if
condition|(
name|decodeParms
operator|.
name|getBoolean
argument_list|(
literal|"BlackIs1"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|blackis1
operator|=
literal|1
expr_stmt|;
block|}
name|int
name|k
init|=
name|decodeParms
operator|.
name|getInt
argument_list|(
literal|"K"
argument_list|)
decl_stmt|;
comment|// Mandatory parm
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
comment|//T6
name|comptype
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
comment|//T4 2D
name|comptype
operator|=
literal|3
expr_stmt|;
name|t4options
operator|=
literal|1
expr_stmt|;
block|}
comment|// else k = 0, leave as default T4 1D compression
block|}
comment|// If we couldn't get the number of rows, use the main item from XObject
if|if
condition|(
name|rows
operator|==
literal|0
condition|)
block|{
name|rows
operator|=
operator|(
name|short
operator|)
name|options
operator|.
name|getInt
argument_list|(
literal|"Height"
argument_list|,
name|rows
argument_list|)
expr_stmt|;
block|}
comment|// Now put the tags into the tiffheader
comment|// These musn't exceed the maximum set above, and by TIFF spec should be sorted into
comment|// Numeric sequence.
name|addTag
argument_list|(
literal|256
argument_list|,
name|cols
argument_list|)
expr_stmt|;
comment|// Columns
name|addTag
argument_list|(
literal|257
argument_list|,
name|rows
argument_list|)
expr_stmt|;
comment|// Rows
name|addTag
argument_list|(
literal|259
argument_list|,
name|comptype
argument_list|)
expr_stmt|;
comment|// T6
name|addTag
argument_list|(
literal|262
argument_list|,
name|blackis1
argument_list|)
expr_stmt|;
comment|// Photometric Interpretation
name|addTag
argument_list|(
literal|273
argument_list|,
name|tiffheader
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Offset to start of image data - updated below
name|addTag
argument_list|(
literal|279
argument_list|,
name|options
operator|.
name|getInt
argument_list|(
literal|"Length"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Length of image data
name|addTag
argument_list|(
literal|282
argument_list|,
literal|300
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// X Resolution 300 (default unit Inches) This is arbitary
name|addTag
argument_list|(
literal|283
argument_list|,
literal|300
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Y Resolution 300 (default unit Inches) This is arbitary
if|if
condition|(
name|comptype
operator|==
literal|3
condition|)
block|{
name|addTag
argument_list|(
literal|292
argument_list|,
name|t4options
argument_list|)
expr_stmt|;
block|}
name|addTag
argument_list|(
literal|305
argument_list|,
literal|"PDFBOX"
argument_list|)
expr_stmt|;
comment|// Software generating image
block|}
comment|/* Tiff types 1 = byte, 2=ascii, 3=short, 4=ulong 5=rational */
specifier|private
name|void
name|addTag
parameter_list|(
name|int
name|tag
parameter_list|,
name|long
name|value
parameter_list|)
block|{
comment|// Adds a tag of type 4 (ulong)
name|int
name|count
init|=
operator|++
name|tiffheader
index|[
literal|8
index|]
decl_stmt|;
name|int
name|offset
init|=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|12
operator|+
literal|10
decl_stmt|;
name|tiffheader
index|[
name|offset
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|tag
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|4
expr_stmt|;
comment|// Type Long
name|tiffheader
index|[
name|offset
operator|+
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|// One Value
name|tiffheader
index|[
name|offset
operator|+
literal|8
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|9
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|10
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|11
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addTag
parameter_list|(
name|int
name|tag
parameter_list|,
name|short
name|value
parameter_list|)
block|{
comment|// Adds a tag of type 3 (short)
name|int
name|count
init|=
operator|++
name|tiffheader
index|[
literal|8
index|]
decl_stmt|;
name|int
name|offset
init|=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|12
operator|+
literal|10
decl_stmt|;
name|tiffheader
index|[
name|offset
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|tag
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|3
expr_stmt|;
comment|// Type Short
name|tiffheader
index|[
name|offset
operator|+
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|// One Value
name|tiffheader
index|[
name|offset
operator|+
literal|8
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|9
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addTag
parameter_list|(
name|int
name|tag
parameter_list|,
name|String
name|value
parameter_list|)
block|{
comment|// Adds a tag of type 2 (ascii)
name|int
name|count
init|=
operator|++
name|tiffheader
index|[
literal|8
index|]
decl_stmt|;
name|int
name|offset
init|=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|12
operator|+
literal|10
decl_stmt|;
name|tiffheader
index|[
name|offset
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|tag
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|2
expr_stmt|;
comment|// Type Ascii
name|tiffheader
index|[
name|offset
operator|+
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|// One Value
name|tiffheader
index|[
name|offset
operator|+
literal|8
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|additionalOffset
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|9
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|10
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|11
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|value
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|tiffheader
argument_list|,
name|additionalOffset
argument_list|,
name|value
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|additionalOffset
operator|+=
name|value
operator|.
name|length
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
specifier|private
name|void
name|addTag
parameter_list|(
name|int
name|tag
parameter_list|,
name|long
name|numerator
parameter_list|,
name|long
name|denominator
parameter_list|)
block|{
comment|// Adds a tag of type 5 (rational)
name|int
name|count
init|=
operator|++
name|tiffheader
index|[
literal|8
index|]
decl_stmt|;
name|int
name|offset
init|=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|12
operator|+
literal|10
decl_stmt|;
name|tiffheader
index|[
name|offset
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|tag
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|5
expr_stmt|;
comment|// Type Rational
name|tiffheader
index|[
name|offset
operator|+
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|// One Value
name|tiffheader
index|[
name|offset
operator|+
literal|8
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|additionalOffset
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|9
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|10
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|offset
operator|+
literal|11
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|additionalOffset
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|numerator
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|numerator
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|numerator
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|numerator
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|denominator
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|denominator
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|denominator
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|tiffheader
index|[
name|additionalOffset
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|denominator
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

