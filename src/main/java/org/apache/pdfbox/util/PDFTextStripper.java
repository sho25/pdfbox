begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|CryptographyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|InvalidPasswordException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|WrappedIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDPage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRectangle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|documentnavigation
operator|.
name|outline
operator|.
name|PDOutlineItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|pagenavigation
operator|.
name|PDThreadBead
import|;
end_import

begin_comment
comment|/**  * This class will take a pdf document and strip out all of the text and ignore the  * formatting and such.  Please note; it is up to clients of this class to verify that  * a specific user has the correct permissions to extract text from the  * PDF document.  *  * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  * @version $Revision: 1.70 $  */
end_comment

begin_class
specifier|public
class|class
name|PDFTextStripper
extends|extends
name|PDFStreamEngine
block|{
specifier|private
name|int
name|currentPageNo
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|startPage
init|=
literal|1
decl_stmt|;
specifier|private
name|int
name|endPage
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
name|PDOutlineItem
name|startBookmark
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|startBookmarkPageNumber
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|PDOutlineItem
name|endBookmark
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|endBookmarkPageNumber
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|PDDocument
name|document
decl_stmt|;
specifier|private
name|boolean
name|suppressDuplicateOverlappingText
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|shouldSeparateByBeads
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|sortByPosition
init|=
literal|false
decl_stmt|;
specifier|private
name|List
name|pageArticles
init|=
literal|null
decl_stmt|;
comment|/**      * The charactersByArticle is used to extract text by article divisions.  For example      * a PDF that has two columns like a newspaper, we want to extract the first column and      * then the second column.  In this example the PDF would have 2 beads(or articles), one for      * each column.  The size of the charactersByArticle would be 5, because not all text on the      * screen will fall into one of the articles.  The five divisions are shown below      *      * Text before first article      * first article text      * text between first article and second article      * second article text      * text after second article      *      * Most PDFs won't have any beads, so charactersByArticle will contain a single entry.      */
specifier|protected
name|Vector
name|charactersByArticle
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
specifier|private
name|Map
name|characterListMapping
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
specifier|private
name|String
name|lineSeparator
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
specifier|private
name|String
name|pageSeparator
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
specifier|private
name|String
name|wordSeparator
init|=
literal|" "
decl_stmt|;
comment|/**      * The stream to write the output to.      */
specifier|protected
name|Writer
name|output
decl_stmt|;
comment|/**      * Instantiate a new PDFTextStripper object.  This object will load properties from      * Resources/PDFTextStripper.properties.      * @throws IOException If there is an error loading the properties.      */
specifier|public
name|PDFTextStripper
parameter_list|()
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|ResourceLoader
operator|.
name|loadProperties
argument_list|(
literal|"Resources/PDFTextStripper.properties"
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Instantiate a new PDFTextStripper object.  Loading all of the operator mappings      * from the properties object that is passed in.      *      * @param props The properties containing the mapping of operators to PDFOperator      * classes.      *      * @throws IOException If there is an error reading the properties.      */
specifier|public
name|PDFTextStripper
parameter_list|(
name|Properties
name|props
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will return the text of a document.  See writeText.<br />      * NOTE: The document must not be encrypted when coming into this method.      *      * @param doc The document to get the text from.      *      * @return The text of the PDF document.      *      * @throws IOException if the doc state is invalid or it is encrypted.      */
specifier|public
name|String
name|getText
parameter_list|(
name|PDDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
name|StringWriter
name|outputStream
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|writeText
argument_list|(
name|doc
argument_list|,
name|outputStream
argument_list|)
expr_stmt|;
return|return
name|outputStream
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * @deprecated      * @see PDFTextStripper#getText( PDDocument )      * @param doc The document to extract the text from.      * @return The document text.      * @throws IOException If there is an error extracting the text.      */
specifier|public
name|String
name|getText
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getText
argument_list|(
operator|new
name|PDDocument
argument_list|(
name|doc
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * @deprecated      * @see PDFTextStripper#writeText( PDDocument, Writer )      * @param doc The document to extract the text.      * @param outputStream The stream to write the text to.      * @throws IOException If there is an error extracting the text.      */
specifier|public
name|void
name|writeText
parameter_list|(
name|COSDocument
name|doc
parameter_list|,
name|Writer
name|outputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|writeText
argument_list|(
operator|new
name|PDDocument
argument_list|(
name|doc
argument_list|)
argument_list|,
name|outputStream
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will take a PDDocument and write the text of that document to the print writer.      *      * @param doc The document to get the data from.      * @param outputStream The location to put the text.      *      * @throws IOException If the doc is in an invalid state.      */
specifier|public
name|void
name|writeText
parameter_list|(
name|PDDocument
name|doc
parameter_list|,
name|Writer
name|outputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|resetEngine
argument_list|()
expr_stmt|;
name|currentPageNo
operator|=
literal|0
expr_stmt|;
name|document
operator|=
name|doc
expr_stmt|;
name|output
operator|=
name|outputStream
expr_stmt|;
name|startDocument
argument_list|(
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|document
operator|.
name|isEncrypted
argument_list|()
condition|)
block|{
comment|// We are expecting non-encrypted documents here, but it is common
comment|// for users to pass in a document that is encrypted with an empty
comment|// password (such a document appears to not be encrypted by
comment|// someone viewing the document, thus the confusion).  We will
comment|// attempt to decrypt with the empty password to handle this case.
comment|//
try|try
block|{
name|document
operator|.
name|decrypt
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CryptographyException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|WrappedIOException
argument_list|(
literal|"Error decrypting document, details: "
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvalidPasswordException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|WrappedIOException
argument_list|(
literal|"Error: document is encrypted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|processPages
argument_list|(
name|document
operator|.
name|getDocumentCatalog
argument_list|()
operator|.
name|getAllPages
argument_list|()
argument_list|)
expr_stmt|;
name|endDocument
argument_list|(
name|document
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will process all of the pages and the text that is in them.      *      * @param pages The pages object in the document.      *      * @throws IOException If there is an error parsing the text.      */
specifier|protected
name|void
name|processPages
parameter_list|(
name|List
name|pages
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startBookmark
operator|!=
literal|null
condition|)
block|{
name|startBookmarkPageNumber
operator|=
name|getPageNumber
argument_list|(
name|startBookmark
argument_list|,
name|pages
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endBookmark
operator|!=
literal|null
condition|)
block|{
name|endBookmarkPageNumber
operator|=
name|getPageNumber
argument_list|(
name|endBookmark
argument_list|,
name|pages
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|startBookmarkPageNumber
operator|==
operator|-
literal|1
operator|&&
name|startBookmark
operator|!=
literal|null
operator|&&
name|endBookmarkPageNumber
operator|==
operator|-
literal|1
operator|&&
name|endBookmark
operator|!=
literal|null
operator|&&
name|startBookmark
operator|.
name|getCOSObject
argument_list|()
operator|==
name|endBookmark
operator|.
name|getCOSObject
argument_list|()
condition|)
block|{
comment|//this is a special case where both the start and end bookmark
comment|//are the same but point to nothing.  In this case
comment|//we will not extract any text.
name|startBookmarkPageNumber
operator|=
literal|0
expr_stmt|;
name|endBookmarkPageNumber
operator|=
literal|0
expr_stmt|;
block|}
name|Iterator
name|pageIter
init|=
name|pages
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|pageIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|PDPage
name|nextPage
init|=
operator|(
name|PDPage
operator|)
name|pageIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|PDStream
name|contentStream
init|=
name|nextPage
operator|.
name|getContents
argument_list|()
decl_stmt|;
name|currentPageNo
operator|++
expr_stmt|;
if|if
condition|(
name|contentStream
operator|!=
literal|null
condition|)
block|{
name|COSStream
name|contents
init|=
name|contentStream
operator|.
name|getStream
argument_list|()
decl_stmt|;
name|processPage
argument_list|(
name|nextPage
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|int
name|getPageNumber
parameter_list|(
name|PDOutlineItem
name|bookmark
parameter_list|,
name|List
name|allPages
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|pageNumber
init|=
operator|-
literal|1
decl_stmt|;
name|PDPage
name|page
init|=
name|bookmark
operator|.
name|findDestinationPage
argument_list|(
name|document
argument_list|)
decl_stmt|;
if|if
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
name|pageNumber
operator|=
name|allPages
operator|.
name|indexOf
argument_list|(
name|page
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|//use one based indexing
block|}
return|return
name|pageNumber
return|;
block|}
comment|/**      * This method is available for subclasses of this class.  It will be called before processing      * of the document start.      *      * @param pdf The PDF document that is being processed.      * @throws IOException If an IO error occurs.      */
specifier|protected
name|void
name|startDocument
parameter_list|(
name|PDDocument
name|pdf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// no default implementation, but available for subclasses
block|}
comment|/**      * This method is available for subclasses of this class.  It will be called after processing      * of the document finishes.      *      * @param pdf The PDF document that is being processed.      * @throws IOException If an IO error occurs.      */
specifier|protected
name|void
name|endDocument
parameter_list|(
name|PDDocument
name|pdf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// no default implementation, but available for subclasses
block|}
comment|/**      * This will process the contents of a page.      *      * @param page The page to process.      * @param content The contents of the page.      *      * @throws IOException If there is an error processing the page.      */
specifier|protected
name|void
name|processPage
parameter_list|(
name|PDPage
name|page
parameter_list|,
name|COSStream
name|content
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentPageNo
operator|>=
name|startPage
operator|&&
name|currentPageNo
operator|<=
name|endPage
operator|&&
operator|(
name|startBookmarkPageNumber
operator|==
operator|-
literal|1
operator|||
name|currentPageNo
operator|>=
name|startBookmarkPageNumber
operator|)
operator|&&
operator|(
name|endBookmarkPageNumber
operator|==
operator|-
literal|1
operator|||
name|currentPageNo
operator|<=
name|endBookmarkPageNumber
operator|)
condition|)
block|{
name|startPage
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|pageArticles
operator|=
name|page
operator|.
name|getThreadBeads
argument_list|()
expr_stmt|;
name|int
name|numberOfArticleSections
init|=
literal|1
operator|+
name|pageArticles
operator|.
name|size
argument_list|()
operator|*
literal|2
decl_stmt|;
if|if
condition|(
operator|!
name|shouldSeparateByBeads
condition|)
block|{
name|numberOfArticleSections
operator|=
literal|1
expr_stmt|;
block|}
name|int
name|originalSize
init|=
name|charactersByArticle
operator|.
name|size
argument_list|()
decl_stmt|;
name|charactersByArticle
operator|.
name|setSize
argument_list|(
name|numberOfArticleSections
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfArticleSections
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|numberOfArticleSections
operator|<
name|originalSize
condition|)
block|{
operator|(
operator|(
name|List
operator|)
name|charactersByArticle
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|charactersByArticle
operator|.
name|set
argument_list|(
name|i
argument_list|,
operator|new
name|ArrayList
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|characterListMapping
operator|.
name|clear
argument_list|()
expr_stmt|;
name|processStream
argument_list|(
name|page
argument_list|,
name|page
operator|.
name|findResources
argument_list|()
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|flushText
argument_list|()
expr_stmt|;
name|endPage
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Start a new paragraph.  Default implementation is to do nothing.  Subclasses      * may provide additional information.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|startParagraph
parameter_list|()
throws|throws
name|IOException
block|{
comment|//default is to do nothing.
block|}
comment|/**      * End a paragraph.  Default implementation is to do nothing.  Subclasses      * may provide additional information.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|endParagraph
parameter_list|()
throws|throws
name|IOException
block|{
comment|//default is to do nothing
block|}
comment|/**      * Start a new page.  Default implementation is to do nothing.  Subclasses      * may provide additional information.      *      * @param page The page we are about to process.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|startPage
parameter_list|(
name|PDPage
name|page
parameter_list|)
throws|throws
name|IOException
block|{
comment|//default is to do nothing.
block|}
comment|/**      * End a page.  Default implementation is to do nothing.  Subclasses      * may provide additional information.      *      * @param page The page we are about to process.      *      * @throws IOException If there is any error writing to the stream.      */
specifier|protected
name|void
name|endPage
parameter_list|(
name|PDPage
name|page
parameter_list|)
throws|throws
name|IOException
block|{
comment|//default is to do nothing
block|}
comment|/**      * This will print the text to the output stream.      *      * @throws IOException If there is an error writing the text.      */
specifier|protected
name|void
name|flushText
parameter_list|()
throws|throws
name|IOException
block|{
name|float
name|maxYForLine
init|=
operator|-
literal|1
decl_stmt|;
name|float
name|minYTopForLine
init|=
name|Float
operator|.
name|MAX_VALUE
decl_stmt|;
comment|//float lastBaselineFontSize = -1;
name|float
name|endOfLastTextX
init|=
operator|-
literal|1
decl_stmt|;
comment|//float endOfLastTextY = -1;
name|float
name|expectedStartOfNextWordX
init|=
operator|-
literal|1
decl_stmt|;
name|float
name|lastWordSpacing
init|=
operator|-
literal|1
decl_stmt|;
name|float
name|maxHeightForLine
init|=
operator|-
literal|1
decl_stmt|;
comment|//float lastHeightForLine = -1;
name|TextPosition
name|lastPosition
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|charactersByArticle
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|startParagraph
argument_list|()
expr_stmt|;
name|List
name|textList
init|=
operator|(
name|List
operator|)
name|charactersByArticle
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortByPosition
condition|)
block|{
name|TextPositionComparator
name|comparator
init|=
operator|new
name|TextPositionComparator
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|textList
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
name|Iterator
name|textIter
init|=
name|textList
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|textIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|TextPosition
name|position
init|=
operator|(
name|TextPosition
operator|)
name|textIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|characterValue
init|=
name|position
operator|.
name|getCharacter
argument_list|()
decl_stmt|;
name|float
name|positionX
decl_stmt|;
name|float
name|positionY
decl_stmt|;
name|float
name|positionWidth
decl_stmt|;
name|float
name|positionHeight
decl_stmt|;
comment|/* If we are sorting, then we need to use the text direction                  * adjusted coordinates, because they were used in the sorting. */
if|if
condition|(
name|sortByPosition
condition|)
block|{
name|positionX
operator|=
name|position
operator|.
name|getXDirAdj
argument_list|()
expr_stmt|;
name|positionY
operator|=
name|position
operator|.
name|getYDirAdj
argument_list|()
expr_stmt|;
name|positionWidth
operator|=
name|position
operator|.
name|getWidthDirAdj
argument_list|()
expr_stmt|;
name|positionHeight
operator|=
name|position
operator|.
name|getHeightDir
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|positionX
operator|=
name|position
operator|.
name|getX
argument_list|()
expr_stmt|;
name|positionY
operator|=
name|position
operator|.
name|getY
argument_list|()
expr_stmt|;
name|positionWidth
operator|=
name|position
operator|.
name|getWidth
argument_list|()
expr_stmt|;
name|positionHeight
operator|=
name|position
operator|.
name|getHeight
argument_list|()
expr_stmt|;
block|}
name|float
name|wordSpacing
init|=
literal|0
decl_stmt|;
comment|/* float wordSpacing = position.getWordSpacing();	BC: When I re-enabled this for a a test, lots of extra spaces were added                 if( wordSpacing == 0 )                 {                 */
comment|//try to get width of a space character
name|wordSpacing
operator|=
name|position
operator|.
name|getWidthOfSpace
argument_list|()
expr_stmt|;
comment|//if still zero fall back to getting the width of the current
comment|//character
if|if
condition|(
name|wordSpacing
operator|==
literal|0
condition|)
block|{
name|wordSpacing
operator|=
name|positionWidth
expr_stmt|;
block|}
comment|//}
comment|// RDD - We add a conservative approximation for space determination.
comment|// basically if there is a blank area between two characters that is
comment|//equal to some percentage of the word spacing then that will be the
comment|//start of the next word
if|if
condition|(
name|lastWordSpacing
operator|<=
literal|0
condition|)
block|{
name|expectedStartOfNextWordX
operator|=
name|endOfLastTextX
operator|+
operator|(
name|wordSpacing
operator|*
literal|0.50f
operator|)
expr_stmt|;
block|}
else|else
block|{
name|expectedStartOfNextWordX
operator|=
name|endOfLastTextX
operator|+
operator|(
operator|(
operator|(
name|wordSpacing
operator|+
name|lastWordSpacing
operator|)
operator|/
literal|2f
operator|)
operator|*
literal|0.50f
operator|)
expr_stmt|;
block|}
comment|// RDD - We will suppress text that is very close to the current line
comment|// and which overwrites previously rendered text on this line.
comment|// This is done specifically to handle a reasonably common situation
comment|// where an application (MS Word, in the case of my examples) renders
comment|// text four times at small (1 point) offsets in order to accomplish
comment|// bold printing.  You would not want to do this step if you were
comment|// going to render the TextPosition objects graphically.
comment|//
comment|/*if ((endOfLastTextX != -1&& position.getX()< endOfLastTextX)&&                     (currentY != -1&& Math.abs(position.getY() - currentY)< 1))                 {                     if (log.isDebugEnabled())                     {                         log.debug("Suppressing text overwrite" +                                   " x: " + position.getX() +                                   " endOfLastTextX: " + endOfLastTextX +                                   " string: " + position.getCharacter());                     }                     continue;                 }*/
comment|// RDD - Here we determine whether this text object is on the current
comment|// line.  We use the lastBaselineFontSize to handle the superscript
comment|// case, and the size of the current font to handle the subscript case.
comment|// Text must overlap with the last rendered baseline text by at least
comment|// a small amount in order to be considered as being on the same line.
comment|//
comment|//int verticalScaling = 1;
comment|//if( lastBaselineFontSize< 0 || position.getFontSize()< 0 )
comment|//{
comment|//    verticalScaling = -1;
comment|//}
if|if
condition|(
name|lastPosition
operator|!=
literal|null
condition|)
block|{
comment|//if (currentY != -1&&
comment|//    ((position.getY()< (currentY - (lastBaselineFontSize * 0.9f * verticalScaling))) ||
comment|//     (position.getY()> (currentY + (position.getFontSize() * 0.9f * verticalScaling)))))
comment|//{
comment|/* XXX BC: In theory, this check should really check if the next char is in full range                      * seen in this line. This is what I tried to do with minYTopForLine, but this caused a lot                      * of regression test failures.  So, I'm leaving it be for now. */
if|if
condition|(
operator|(
operator|!
name|overlap
argument_list|(
name|positionY
argument_list|,
name|positionHeight
argument_list|,
name|maxYForLine
argument_list|,
name|maxHeightForLine
argument_list|)
operator|)
condition|)
comment|//maxYForLine - minYTopForLine)))
block|{
name|processLineSeparator
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|endOfLastTextX
operator|=
operator|-
literal|1
expr_stmt|;
name|expectedStartOfNextWordX
operator|=
operator|-
literal|1
expr_stmt|;
name|maxYForLine
operator|=
operator|-
literal|1
expr_stmt|;
name|maxHeightForLine
operator|=
operator|-
literal|1
expr_stmt|;
comment|//lastBaselineFontSize = -1;
name|minYTopForLine
operator|=
name|Float
operator|.
name|MAX_VALUE
expr_stmt|;
comment|//lastHeightForLine = -1;
block|}
if|if
condition|(
name|expectedStartOfNextWordX
operator|!=
operator|-
literal|1
operator|&&
name|expectedStartOfNextWordX
operator|<
name|positionX
operator|&&
comment|//only bother adding a space if the last character was not a space
name|lastPosition
operator|.
name|getCharacter
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|lastPosition
operator|.
name|getCharacter
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|" "
argument_list|)
condition|)
block|{
name|processWordSeparator
argument_list|(
name|lastPosition
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//System.out.println( "Not a word separator " + position.getCharacter() +  " start=" + startOfNextWordX + " x=" + position.getX() );
block|}
block|}
if|if
condition|(
name|positionY
operator|>=
name|maxYForLine
condition|)
block|{
name|maxYForLine
operator|=
name|positionY
expr_stmt|;
comment|//lastBaselineFontSize = position.getFontSize();
block|}
comment|// RDD - endX is what PDF considers to be the x coordinate of the
comment|// end position of the text.  We use it in computing our metrics below.
name|endOfLastTextX
operator|=
name|positionX
operator|+
name|positionWidth
expr_stmt|;
comment|//endOfLastTextY = positionY;
if|if
condition|(
name|characterValue
operator|!=
literal|null
condition|)
block|{
name|writeCharacters
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Position.getString() is null so not writing anything
block|}
name|maxHeightForLine
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxHeightForLine
argument_list|,
name|positionHeight
argument_list|)
expr_stmt|;
name|minYTopForLine
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minYTopForLine
argument_list|,
name|positionY
operator|-
name|positionHeight
argument_list|)
expr_stmt|;
name|lastPosition
operator|=
name|position
expr_stmt|;
comment|//lastHeightForLine = position.getHeight();
name|lastWordSpacing
operator|=
name|wordSpacing
expr_stmt|;
block|}
name|endParagraph
argument_list|()
expr_stmt|;
block|}
comment|// RDD - newline at end of flush - required for end of page (so that the top
comment|// of the next page starts on its own line.
comment|//
name|output
operator|.
name|write
argument_list|(
name|getPageSeparator
argument_list|()
argument_list|)
expr_stmt|;
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
specifier|private
name|boolean
name|overlap
parameter_list|(
name|float
name|y1
parameter_list|,
name|float
name|height1
parameter_list|,
name|float
name|y2
parameter_list|,
name|float
name|height2
parameter_list|)
block|{
return|return
name|within
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|,
literal|.1f
argument_list|)
operator|||
operator|(
name|y2
operator|<=
name|y1
operator|&&
name|y2
operator|>=
name|y1
operator|-
name|height1
operator|)
operator|||
operator|(
name|y1
operator|<=
name|y2
operator|&&
name|y1
operator|>=
name|y2
operator|-
name|height2
operator|)
return|;
block|}
specifier|protected
name|void
name|processLineSeparator
parameter_list|(
name|TextPosition
name|currentText
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getLineSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|processWordSeparator
parameter_list|(
name|TextPosition
name|lastText
parameter_list|,
name|TextPosition
name|currentText
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|getWordSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the string to the output stream.      *      * @param text The text to write to the stream.      * @throws IOException If there is an error when writing the text.      */
specifier|protected
name|void
name|writeCharacters
parameter_list|(
name|TextPosition
name|text
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|write
argument_list|(
name|text
operator|.
name|getCharacter
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will determine of two floating point numbers are within a specified variance.      *      * @param first The first number to compare to.      * @param second The second number to compare to.      * @param variance The allowed variance.      */
specifier|private
name|boolean
name|within
parameter_list|(
name|float
name|first
parameter_list|,
name|float
name|second
parameter_list|,
name|float
name|variance
parameter_list|)
block|{
return|return
name|second
operator|>
name|first
operator|-
name|variance
operator|&&
name|second
operator|<
name|first
operator|+
name|variance
return|;
block|}
comment|/**      * This will show add a character to the list of characters to be printed to      * the text file.      *      * @param text The description of the character to display.      */
specifier|protected
name|void
name|showCharacter
parameter_list|(
name|TextPosition
name|text
parameter_list|)
block|{
name|boolean
name|showCharacter
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|suppressDuplicateOverlappingText
condition|)
block|{
name|showCharacter
operator|=
literal|false
expr_stmt|;
name|String
name|textCharacter
init|=
name|text
operator|.
name|getCharacter
argument_list|()
decl_stmt|;
name|float
name|textX
init|=
name|text
operator|.
name|getX
argument_list|()
decl_stmt|;
name|float
name|textY
init|=
name|text
operator|.
name|getY
argument_list|()
decl_stmt|;
name|List
name|sameTextCharacters
init|=
operator|(
name|List
operator|)
name|characterListMapping
operator|.
name|get
argument_list|(
name|textCharacter
argument_list|)
decl_stmt|;
if|if
condition|(
name|sameTextCharacters
operator|==
literal|null
condition|)
block|{
name|sameTextCharacters
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
name|characterListMapping
operator|.
name|put
argument_list|(
name|textCharacter
argument_list|,
name|sameTextCharacters
argument_list|)
expr_stmt|;
block|}
comment|// RDD - Here we compute the value that represents the end of the rendered
comment|// text.  This value is used to determine whether subsequent text rendered
comment|// on the same line overwrites the current text.
comment|//
comment|// We subtract any positive padding to handle cases where extreme amounts
comment|// of padding are applied, then backed off (not sure why this is done, but there
comment|// are cases where the padding is on the order of 10x the character width, and
comment|// the TJ just backs up to compensate after each character).  Also, we subtract
comment|// an amount to allow for kerning (a percentage of the width of the last
comment|// character).
comment|//
name|boolean
name|suppressCharacter
init|=
literal|false
decl_stmt|;
name|float
name|tolerance
init|=
operator|(
name|text
operator|.
name|getWidth
argument_list|()
operator|/
name|textCharacter
operator|.
name|length
argument_list|()
operator|)
operator|/
literal|3.0f
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sameTextCharacters
operator|.
name|size
argument_list|()
operator|&&
name|textCharacter
operator|!=
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|TextPosition
name|character
init|=
operator|(
name|TextPosition
operator|)
name|sameTextCharacters
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|charCharacter
init|=
name|character
operator|.
name|getCharacter
argument_list|()
decl_stmt|;
name|float
name|charX
init|=
name|character
operator|.
name|getX
argument_list|()
decl_stmt|;
name|float
name|charY
init|=
name|character
operator|.
name|getY
argument_list|()
decl_stmt|;
comment|//only want to suppress
if|if
condition|(
name|charCharacter
operator|!=
literal|null
operator|&&
comment|//charCharacter.equals( textCharacter )&&
name|within
argument_list|(
name|charX
argument_list|,
name|textX
argument_list|,
name|tolerance
argument_list|)
operator|&&
name|within
argument_list|(
name|charY
argument_list|,
name|textY
argument_list|,
name|tolerance
argument_list|)
condition|)
block|{
name|suppressCharacter
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|suppressCharacter
condition|)
block|{
name|sameTextCharacters
operator|.
name|add
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|showCharacter
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|showCharacter
condition|)
block|{
comment|//if we are showing the character then we need to determine which
comment|//article it belongs to.
name|int
name|foundArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|notFoundButFirstLeftArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|notFoundButFirstAboveArticleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
name|float
name|x
init|=
name|text
operator|.
name|getX
argument_list|()
decl_stmt|;
name|float
name|y
init|=
name|text
operator|.
name|getY
argument_list|()
decl_stmt|;
if|if
condition|(
name|shouldSeparateByBeads
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pageArticles
operator|.
name|size
argument_list|()
operator|&&
name|foundArticleDivisionIndex
operator|==
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|PDThreadBead
name|bead
init|=
operator|(
name|PDThreadBead
operator|)
name|pageArticles
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bead
operator|!=
literal|null
condition|)
block|{
name|PDRectangle
name|rect
init|=
name|bead
operator|.
name|getRectangle
argument_list|()
decl_stmt|;
if|if
condition|(
name|rect
operator|.
name|contains
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|foundArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|x
operator|<
name|rect
operator|.
name|getLowerLeftX
argument_list|()
operator|||
name|y
operator|<
name|rect
operator|.
name|getUpperRightY
argument_list|()
operator|)
operator|&&
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
name|rect
operator|.
name|getLowerLeftX
argument_list|()
operator|&&
name|notFoundButFirstLeftArticleDivisionIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|notFoundButFirstLeftArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|<
name|rect
operator|.
name|getUpperRightY
argument_list|()
operator|&&
name|notFoundButFirstAboveArticleDivisionIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|notFoundButFirstAboveArticleDivisionIndex
operator|=
name|i
operator|*
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|foundArticleDivisionIndex
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|foundArticleDivisionIndex
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|articleDivisionIndex
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|foundArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|foundArticleDivisionIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|notFoundButFirstLeftAndAboveArticleDivisionIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notFoundButFirstLeftArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|notFoundButFirstLeftArticleDivisionIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|notFoundButFirstAboveArticleDivisionIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|articleDivisionIndex
operator|=
name|notFoundButFirstAboveArticleDivisionIndex
expr_stmt|;
block|}
else|else
block|{
name|articleDivisionIndex
operator|=
name|charactersByArticle
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
name|List
name|textList
init|=
operator|(
name|List
operator|)
name|charactersByArticle
operator|.
name|get
argument_list|(
name|articleDivisionIndex
argument_list|)
decl_stmt|;
name|textList
operator|.
name|add
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This is the page that the text extraction will start on.  The pages start      * at page 1.  For example in a 5 page PDF document, if the start page is 1      * then all pages will be extracted.  If the start page is 4 then pages 4 and 5      * will be extracted.  The default value is 1.      *      * @return Value of property startPage.      */
specifier|public
name|int
name|getStartPage
parameter_list|()
block|{
return|return
name|startPage
return|;
block|}
comment|/**      * This will set the first page to be extracted by this class.      *      * @param startPageValue New value of property startPage.      */
specifier|public
name|void
name|setStartPage
parameter_list|(
name|int
name|startPageValue
parameter_list|)
block|{
name|startPage
operator|=
name|startPageValue
expr_stmt|;
block|}
comment|/**      * This will get the last page that will be extracted.  This is inclusive,      * for example if a 5 page PDF an endPage value of 5 would extract the      * entire document, an end page of 2 would extract pages 1 and 2.  This defaults      * to Integer.MAX_VALUE such that all pages of the pdf will be extracted.      *      * @return Value of property endPage.      */
specifier|public
name|int
name|getEndPage
parameter_list|()
block|{
return|return
name|endPage
return|;
block|}
comment|/**      * This will set the last page to be extracted by this class.      *      * @param endPageValue New value of property endPage.      */
specifier|public
name|void
name|setEndPage
parameter_list|(
name|int
name|endPageValue
parameter_list|)
block|{
name|endPage
operator|=
name|endPageValue
expr_stmt|;
block|}
comment|/**      * Set the desired line separator for output text.  The line.separator      * system property is used if the line separator preference is not set      * explicitly using this method.      *      * @param separator The desired line separator string.      */
specifier|public
name|void
name|setLineSeparator
parameter_list|(
name|String
name|separator
parameter_list|)
block|{
name|lineSeparator
operator|=
name|separator
expr_stmt|;
block|}
comment|/**      * This will get the line separator.      *      * @return The desired line separator string.      */
specifier|public
name|String
name|getLineSeparator
parameter_list|()
block|{
return|return
name|lineSeparator
return|;
block|}
comment|/**      * Set the desired page separator for output text.  The line.separator      * system property is used if the page separator preference is not set      * explicitly using this method.      *      * @param separator The desired page separator string.      */
specifier|public
name|void
name|setPageSeparator
parameter_list|(
name|String
name|separator
parameter_list|)
block|{
name|pageSeparator
operator|=
name|separator
expr_stmt|;
block|}
comment|/**      * This will get the word separator.      *      * @return The desired word separator string.      */
specifier|public
name|String
name|getWordSeparator
parameter_list|()
block|{
return|return
name|wordSeparator
return|;
block|}
comment|/**      * Set the desired word separator for output text.  The PDFBox text extraction      * algorithm will output a space character if there is enough space between      * two words.  By default a space character is used.  If you need and accurate      * count of characters that are found in a PDF document then you might want to      * set the word separator to the empty string.      *      * @param separator The desired page separator string.      */
specifier|public
name|void
name|setWordSeparator
parameter_list|(
name|String
name|separator
parameter_list|)
block|{
name|wordSeparator
operator|=
name|separator
expr_stmt|;
block|}
comment|/**      * This will get the page separator.      *      * @return The page separator string.      */
specifier|public
name|String
name|getPageSeparator
parameter_list|()
block|{
return|return
name|pageSeparator
return|;
block|}
comment|/**      * @return Returns the suppressDuplicateOverlappingText.      */
specifier|public
name|boolean
name|shouldSuppressDuplicateOverlappingText
parameter_list|()
block|{
return|return
name|suppressDuplicateOverlappingText
return|;
block|}
comment|/**      * Get the current page number that is being processed.      *      * @return A 1 based number representing the current page.      */
specifier|protected
name|int
name|getCurrentPageNo
parameter_list|()
block|{
return|return
name|currentPageNo
return|;
block|}
comment|/**      * The output stream that is being written to.      *      * @return The stream that output is being written to.      */
specifier|protected
name|Writer
name|getOutput
parameter_list|()
block|{
return|return
name|output
return|;
block|}
comment|/**      * Character strings are grouped by articles.  It is quite common that there      * will only be a single article.  This returns a List that contains List objects,      * the inner lists will contain TextPosition objects.      *      * @return A double List of TextPositions for all text strings on the page.      */
specifier|protected
name|List
name|getCharactersByArticle
parameter_list|()
block|{
return|return
name|charactersByArticle
return|;
block|}
comment|/**      * By default the text stripper will attempt to remove text that overlapps each other.      * Word paints the same character several times in order to make it look bold.  By setting      * this to false all text will be extracted, which means that certain sections will be      * duplicated, but better performance will be noticed.      *      * @param suppressDuplicateOverlappingTextValue The suppressDuplicateOverlappingText to set.      */
specifier|public
name|void
name|setSuppressDuplicateOverlappingText
parameter_list|(
name|boolean
name|suppressDuplicateOverlappingTextValue
parameter_list|)
block|{
name|this
operator|.
name|suppressDuplicateOverlappingText
operator|=
name|suppressDuplicateOverlappingTextValue
expr_stmt|;
block|}
comment|/**      * This will tell if the text stripper should separate by beads.      *      * @return If the text will be grouped by beads.      */
specifier|public
name|boolean
name|shouldSeparateByBeads
parameter_list|()
block|{
return|return
name|shouldSeparateByBeads
return|;
block|}
comment|/**      * Set if the text stripper should group the text output by a list of beads.  The default value is true!      *      * @param aShouldSeparateByBeads The new grouping of beads.      */
specifier|public
name|void
name|setShouldSeparateByBeads
parameter_list|(
name|boolean
name|aShouldSeparateByBeads
parameter_list|)
block|{
name|this
operator|.
name|shouldSeparateByBeads
operator|=
name|aShouldSeparateByBeads
expr_stmt|;
block|}
comment|/**      * Get the bookmark where text extraction should end, inclusive.  Default is null.      *      * @return The ending bookmark.      */
specifier|public
name|PDOutlineItem
name|getEndBookmark
parameter_list|()
block|{
return|return
name|endBookmark
return|;
block|}
comment|/**      * Set the bookmark where the text extraction should stop.      *      * @param aEndBookmark The ending bookmark.      */
specifier|public
name|void
name|setEndBookmark
parameter_list|(
name|PDOutlineItem
name|aEndBookmark
parameter_list|)
block|{
name|endBookmark
operator|=
name|aEndBookmark
expr_stmt|;
block|}
comment|/**      * Get the bookmark where text extraction should start, inclusive.  Default is null.      *      * @return The starting bookmark.      */
specifier|public
name|PDOutlineItem
name|getStartBookmark
parameter_list|()
block|{
return|return
name|startBookmark
return|;
block|}
comment|/**      * Set the bookmark where text extraction should start, inclusive.      *      * @param aStartBookmark The starting bookmark.      */
specifier|public
name|void
name|setStartBookmark
parameter_list|(
name|PDOutlineItem
name|aStartBookmark
parameter_list|)
block|{
name|startBookmark
operator|=
name|aStartBookmark
expr_stmt|;
block|}
comment|/**      * This will tell if the text stripper should sort the text tokens      * before writing to the stream.      *      * @return true If the text tokens will be sorted before being written.      */
specifier|public
name|boolean
name|shouldSortByPosition
parameter_list|()
block|{
return|return
name|sortByPosition
return|;
block|}
comment|/**      * The order of the text tokens in a PDF file may not be in the same      * as they appear visually on the screen.  For example, a PDF writer may      * write out all text by font, so all bold or larger text, then make a second      * pass and write out the normal text.<br/>      * The default is to<b>not</b> sort by position.<br/>      *<br/>      * A PDF writer could choose to write each character in a different order.  By      * default PDFBox does<b>not</b> sort the text tokens before processing them due to      * performance reasons.      *      * @param newSortByPosition Tell PDFBox to sort the text positions.      */
specifier|public
name|void
name|setSortByPosition
parameter_list|(
name|boolean
name|newSortByPosition
parameter_list|)
block|{
name|sortByPosition
operator|=
name|newSortByPosition
expr_stmt|;
block|}
block|}
end_class

end_unit

