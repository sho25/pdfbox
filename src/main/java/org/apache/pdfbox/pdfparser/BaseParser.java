begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdfparser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|ByteArrayPushBackInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|PushBackInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|persistence
operator|.
name|util
operator|.
name|COSObjectKey
import|;
end_import

begin_comment
comment|/**  * This class is used to contain parsing logic that will be used by both the  * PDFParser and the COSStreamParser.  *  * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  * @version $Revision: 1.61 $  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|BaseParser
extends|extends
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|LoggingObject
block|{
comment|/**      * This is a byte array that will be used for comparisons.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ENDSTREAM
init|=
operator|new
name|byte
index|[]
block|{
literal|101
block|,
literal|110
block|,
literal|100
block|,
literal|115
block|,
literal|116
block|,
literal|114
block|,
literal|101
block|,
literal|97
block|,
literal|109
block|}
decl_stmt|;
comment|//"endstream".getBytes( "ISO-8859-1" );
comment|/**      * This is a byte array that will be used for comparisons.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ENDOBJ
init|=
operator|new
name|byte
index|[]
block|{
literal|101
block|,
literal|110
block|,
literal|100
block|,
literal|111
block|,
literal|98
block|,
literal|106
block|}
decl_stmt|;
comment|//"endobj".getBytes( "ISO-8859-1" );
comment|/**      * This is a byte array that will be used for comparisons.      */
specifier|public
specifier|static
specifier|final
name|String
name|DEF
init|=
literal|"def"
decl_stmt|;
comment|/**      * This is the stream that will be read from.      */
specifier|protected
name|PushBackInputStream
name|pdfSource
decl_stmt|;
comment|/**      * This is the document that will be parsed.      */
specifier|protected
name|COSDocument
name|document
decl_stmt|;
comment|/**      * Constructor.      *      * @param input The input stream to read the data from.      *      * @throws IOException If there is an error reading the input stream.      */
specifier|public
name|BaseParser
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|IOException
block|{
comment|//pdfSource = new PushBackByteArrayStream( input );
name|pdfSource
operator|=
operator|new
name|PushBackInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|input
argument_list|,
literal|16384
argument_list|)
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *      * @param input The array to read the data from.      *      * @throws IOException If there is an error reading the byte data.      */
specifier|protected
name|BaseParser
parameter_list|(
name|byte
index|[]
name|input
parameter_list|)
throws|throws
name|IOException
block|{
name|pdfSource
operator|=
operator|new
name|ByteArrayPushBackInputStream
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the document for this stream.      *      * @param doc The current document.      */
specifier|public
name|void
name|setDocument
parameter_list|(
name|COSDocument
name|doc
parameter_list|)
block|{
name|document
operator|=
name|doc
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|isHexDigit
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
operator|)
return|;
comment|// the line below can lead to problems with certain versions of the IBM JIT compiler
comment|// (and is slower anyway)
comment|//return (HEXDIGITS.indexOf(ch) != -1);
block|}
comment|/**      * This will parse a PDF dictionary value.      *      * @return The parsed Dictionary object.      *      * @throws IOException If there is an error parsing the dictionary object.      */
specifier|private
name|COSBase
name|parseCOSDictionaryValue
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBase
name|retval
init|=
literal|null
decl_stmt|;
name|COSBase
name|number
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|char
name|next
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|>=
literal|'0'
operator|&&
name|next
operator|<=
literal|'9'
condition|)
block|{
name|COSBase
name|generationNumber
init|=
name|parseDirObject
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|char
name|r
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|'R'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='R' actual='"
operator|+
name|r
operator|+
literal|"' "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
name|COSObjectKey
name|key
init|=
operator|new
name|COSObjectKey
argument_list|(
operator|(
operator|(
name|COSInteger
operator|)
name|number
operator|)
operator|.
name|intValue
argument_list|()
argument_list|,
operator|(
operator|(
name|COSInteger
operator|)
name|generationNumber
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|retval
operator|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|number
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will parse a PDF dictionary.      *      * @return The parsed dictionary.      *      * @throws IOException IF there is an error reading the stream.      */
specifier|protected
name|COSDictionary
name|parseCOSDictionary
parameter_list|()
throws|throws
name|IOException
block|{
name|char
name|c
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'<'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='<' actual='"
operator|+
name|c
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|c
operator|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'<'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='<' actual='"
operator|+
name|c
operator|+
literal|"' "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|COSDictionary
name|obj
init|=
operator|new
name|COSDictionary
argument_list|()
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'/'
condition|)
block|{
comment|//an invalid dictionary, we are expecting
comment|//the key, read until we can recover
name|logger
argument_list|()
operator|.
name|warning
argument_list|(
literal|"Invalid dictionary, found:"
operator|+
operator|(
name|char
operator|)
name|c
operator|+
literal|" but expected:\''"
argument_list|)
expr_stmt|;
name|int
name|read
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|read
operator|!=
operator|-
literal|1
operator|&&
name|read
operator|!=
literal|'/'
operator|&&
name|read
operator|!=
literal|'>'
condition|)
block|{
name|read
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|read
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|read
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|COSName
name|key
init|=
name|parseCOSName
argument_list|()
decl_stmt|;
name|COSBase
name|value
init|=
name|parseCOSDictionaryValue
argument_list|()
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
operator|)
operator|==
literal|'d'
condition|)
block|{
comment|//if the next string is 'def' then we are parsing a cmap stream
comment|//and want to ignore it, otherwise throw an exception.
name|String
name|potentialDEF
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|potentialDEF
operator|.
name|equals
argument_list|(
name|DEF
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|potentialDEF
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|logger
argument_list|()
operator|.
name|warning
argument_list|(
literal|"Bad Dictionary Declaration "
operator|+
name|pdfSource
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|.
name|setItem
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'>'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='>' actual='"
operator|+
name|ch
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|ch
operator|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'>'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='>' actual='"
operator|+
name|ch
operator|+
literal|"'"
argument_list|)
throw|;
block|}
return|return
name|obj
return|;
block|}
comment|/**      * This will read a COSStream from the input stream.      *      * @param file The file to write the stream to when reading.      * @param dic The dictionary that goes with this stream.      *      * @return The parsed pdf stream.      *      * @throws IOException If there is an error reading the stream.      */
specifier|protected
name|COSStream
name|parseCOSStream
parameter_list|(
name|COSDictionary
name|dic
parameter_list|,
name|RandomAccess
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|COSStream
name|stream
init|=
operator|new
name|COSStream
argument_list|(
name|dic
argument_list|,
name|file
argument_list|)
decl_stmt|;
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|streamString
init|=
name|readString
argument_list|()
decl_stmt|;
comment|//long streamLength;
if|if
condition|(
operator|!
name|streamString
operator|.
name|equals
argument_list|(
literal|"stream"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='stream' actual='"
operator|+
name|streamString
operator|+
literal|"'"
argument_list|)
throw|;
block|}
comment|//PDF Ref 3.2.7 A stream must be followed by either
comment|//a CRLF or LF but nothing else.
name|int
name|whitespace
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//see brother_scan_cover.pdf, it adds whitespaces
comment|//after the stream but before the start of the
comment|//data, so just read those first
while|while
condition|(
name|whitespace
operator|==
literal|0x20
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|whitespace
operator|==
literal|0x0D
condition|)
block|{
name|whitespace
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|whitespace
operator|!=
literal|0x0A
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
comment|//The spec says this is invalid but it happens in the real
comment|//world so we must support it.
block|}
block|}
elseif|else
if|if
condition|(
name|whitespace
operator|==
literal|0x0A
condition|)
block|{
comment|//that is fine
block|}
else|else
block|{
comment|//we are in an error.
comment|//but again we will do a lenient parsing and just assume that everything
comment|//is fine
name|pdfSource
operator|.
name|unread
argument_list|(
name|whitespace
argument_list|)
expr_stmt|;
block|}
comment|/*This needs to be dic.getItem because when we are parsing, the underlying object              * might still be null.              */
name|COSBase
name|streamLength
init|=
name|dic
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|LENGTH
argument_list|)
decl_stmt|;
comment|//Need to keep track of the
name|out
operator|=
name|stream
operator|.
name|createFilteredStream
argument_list|(
name|streamLength
argument_list|)
expr_stmt|;
name|String
name|endStream
init|=
literal|null
decl_stmt|;
name|readUntilEndStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|endStream
operator|=
name|readString
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|endStream
operator|.
name|equals
argument_list|(
literal|"endstream"
argument_list|)
condition|)
block|{
comment|/*                  * Sometimes stream objects don't have an endstream tag so readUntilEndStream(out)                  * also can stop on endobj tags. If that's the case we need to make sure to unread                  * the endobj so parseObject() can handle that case normally.                   */
if|if
condition|(
name|endStream
operator|.
name|startsWith
argument_list|(
literal|"endobj"
argument_list|)
condition|)
block|{
name|byte
index|[]
name|endobjarray
init|=
name|endStream
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
name|endobjarray
argument_list|)
expr_stmt|;
block|}
comment|/*                  * Some PDF files don't contain a new line after endstream so we                   * need to make sure that the next object number is getting read separately                  * and not part of the endstream keyword. Ex. Some files would have "endstream8"                  * instead of "endstream"                  */
elseif|else
if|if
condition|(
name|endStream
operator|.
name|startsWith
argument_list|(
literal|"endstream"
argument_list|)
condition|)
block|{
name|String
name|extra
init|=
name|endStream
operator|.
name|substring
argument_list|(
literal|9
argument_list|,
name|endStream
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|endStream
operator|=
name|endStream
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|byte
index|[]
name|array
init|=
name|extra
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|pdfSource
operator|.
name|unread
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*                      * If for some reason we get something else here, Read until we find the next                      * "endstream"                      */
name|readUntilEndStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|endStream
operator|=
name|readString
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|endStream
operator|.
name|equals
argument_list|(
literal|"endstream"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='endstream' actual='"
operator|+
name|endStream
operator|+
literal|"' "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|stream
return|;
block|}
comment|/**      * This method will read through the current stream object until      * we find the keyword "endstream" meaning we're at the end of this      * object. Some pdf files, however, forget to write some endstream tags      * and just close off objects with an "endobj" tag so we have to handle      * this case as well.      * @param out The stream we write out to.       * @throws IOException      */
specifier|private
name|void
name|readUntilEndStream
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|byteRead
init|=
literal|0
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|ENDSTREAM
operator|.
name|length
index|]
decl_stmt|;
name|int
name|nextIdx
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|%
name|buffer
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|nextIdx
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
while|while
condition|(
name|byteRead
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|cmpCircularBuffer
argument_list|(
name|buffer
argument_list|,
operator|(
name|nextIdx
operator|-
name|ENDSTREAM
operator|.
name|length
operator|+
name|buffer
operator|.
name|length
operator|)
operator|%
name|buffer
operator|.
name|length
argument_list|,
name|ENDSTREAM
argument_list|)
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|ENDSTREAM
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*              * occasionally steam objects do not write the endstream tag and just terminate              * the object with an endobj tag so we want to stop there as well.               */
name|int
name|endObjStart
init|=
operator|(
name|nextIdx
operator|-
name|ENDOBJ
operator|.
name|length
operator|+
name|buffer
operator|.
name|length
operator|)
operator|%
name|buffer
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|cmpCircularBuffer
argument_list|(
name|buffer
argument_list|,
name|endObjStart
argument_list|,
name|ENDOBJ
argument_list|)
condition|)
block|{
comment|// data is written to out only when it is going to be overwritten.
comment|// write out the rest of the data in the buffer since ENDOBJ is smaller then the buffer
for|for
control|(
name|int
name|i
init|=
name|nextIdx
init|;
name|i
operator|<
name|buffer
operator|.
name|length
operator|&&
name|i
operator|<
name|endObjStart
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|pdfSource
operator|.
name|unread
argument_list|(
name|ENDOBJ
argument_list|)
expr_stmt|;
return|return;
block|}
name|out
operator|.
name|write
argument_list|(
name|buffer
index|[
name|nextIdx
index|]
argument_list|)
expr_stmt|;
name|byteRead
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|buffer
index|[
name|nextIdx
index|]
operator|=
operator|(
name|byte
operator|)
name|byteRead
expr_stmt|;
if|if
condition|(
operator|++
name|nextIdx
operator|==
name|buffer
operator|.
name|length
condition|)
block|{
name|nextIdx
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/**      * This basically checks to see if the next compareTo.length bytes of the      * buffer match the compareTo byte array.      * @param buffer Circular buffer to look for string in      * @param currentIndex Index in buffer to start comparison from      * @param compareTo String to find in circular buffer at index      */
specifier|private
name|boolean
name|cmpCircularBuffer
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|currentIndex
parameter_list|,
name|byte
index|[]
name|compareTo
parameter_list|)
block|{
name|int
name|cmpLen
init|=
name|compareTo
operator|.
name|length
decl_stmt|;
name|int
name|buflen
init|=
name|buffer
operator|.
name|length
decl_stmt|;
name|boolean
name|match
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|match
operator|&&
name|i
operator|<
name|cmpLen
condition|;
operator|++
name|i
control|)
block|{
name|match
operator|=
name|buffer
index|[
operator|(
name|currentIndex
operator|+
name|i
operator|)
operator|%
name|buflen
index|]
operator|==
name|compareTo
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|match
return|;
block|}
comment|/**      * This will parse a PDF string.      *      * @return The parsed PDF string.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|COSString
name|parseCOSString
parameter_list|()
throws|throws
name|IOException
block|{
name|char
name|nextChar
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
name|COSString
name|retval
init|=
operator|new
name|COSString
argument_list|()
decl_stmt|;
name|char
name|openBrace
decl_stmt|;
name|char
name|closeBrace
decl_stmt|;
if|if
condition|(
name|nextChar
operator|==
literal|'('
condition|)
block|{
name|openBrace
operator|=
literal|'('
expr_stmt|;
name|closeBrace
operator|=
literal|')'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextChar
operator|==
literal|'<'
condition|)
block|{
name|openBrace
operator|=
literal|'<'
expr_stmt|;
name|closeBrace
operator|=
literal|'>'
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"parseCOSString string should start with '(' or '<' and not '"
operator|+
name|nextChar
operator|+
literal|"' "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
comment|//This is the number of braces read
comment|//
name|int
name|braces
init|=
literal|1
decl_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|braces
operator|>
literal|0
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
name|int
name|nextc
init|=
operator|-
literal|2
decl_stmt|;
comment|// not yet read
comment|//if( log.isDebugEnabled() )
comment|//{
comment|//    log.debug( "Parsing COSString character '" + c + "' code=" + (int)c );
comment|//}
if|if
condition|(
name|ch
operator|==
name|closeBrace
condition|)
block|{
name|braces
operator|--
expr_stmt|;
name|byte
index|[]
name|nextThreeBytes
init|=
operator|new
name|byte
index|[
literal|3
index|]
decl_stmt|;
name|int
name|amountRead
init|=
name|pdfSource
operator|.
name|read
argument_list|(
name|nextThreeBytes
argument_list|)
decl_stmt|;
comment|//lets handle the special case seen in Bull  River Rules and Regulations.pdf
comment|//The dictionary looks like this
comment|//    2 0 obj
comment|//<<
comment|//        /Type /Info
comment|//        /Creator (PaperPort http://www.scansoft.com)
comment|//        /Producer (sspdflib 1.0 http://www.scansoft.com)
comment|//        /Title ( (5)
comment|//        /Author ()
comment|//        /Subject ()
comment|//
comment|// Notice the /Title, the braces are not even but they should
comment|// be.  So lets assume that if we encounter an this scenario
comment|//<end_brace><new_line><opening_slash> then that
comment|// means that there is an error in the pdf and assume that
comment|// was the end of the document.
if|if
condition|(
name|amountRead
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|nextThreeBytes
index|[
literal|0
index|]
operator|==
literal|0x0d
operator|&&
name|nextThreeBytes
index|[
literal|1
index|]
operator|==
literal|0x0a
operator|&&
name|nextThreeBytes
index|[
literal|2
index|]
operator|==
literal|0x2f
condition|)
block|{
name|braces
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|amountRead
operator|>
literal|0
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|nextThreeBytes
argument_list|,
literal|0
argument_list|,
name|amountRead
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|braces
operator|!=
literal|0
condition|)
block|{
name|retval
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|openBrace
condition|)
block|{
name|braces
operator|++
expr_stmt|;
name|retval
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|//patched by ram
name|char
name|next
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|next
condition|)
block|{
case|case
literal|'n'
case|:
name|retval
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|retval
operator|.
name|append
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|retval
operator|.
name|append
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|retval
operator|.
name|append
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|retval
operator|.
name|append
argument_list|(
literal|'\f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'\\'
case|:
name|retval
operator|.
name|append
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
case|case
literal|13
case|:
comment|//this is a break in the line so ignore it and the newline and continue
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
while|while
condition|(
name|isEOL
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|nextc
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
name|StringBuffer
name|octal
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|octal
operator|.
name|append
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|char
name|digit
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|'0'
operator|&&
name|digit
operator|<=
literal|'7'
condition|)
block|{
name|octal
operator|.
name|append
argument_list|(
name|digit
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|digit
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|'0'
operator|&&
name|digit
operator|<=
literal|'7'
condition|)
block|{
name|octal
operator|.
name|append
argument_list|(
name|digit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextc
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
name|nextc
operator|=
name|c
expr_stmt|;
block|}
name|int
name|character
init|=
literal|0
decl_stmt|;
try|try
block|{
name|character
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|octal
operator|.
name|toString
argument_list|()
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected octal character, actual='"
operator|+
name|octal
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|retval
operator|.
name|append
argument_list|(
name|character
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|retval
operator|.
name|append
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|retval
operator|.
name|append
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|//another ficken problem with PDF's, sometimes the \ doesn't really
comment|//mean escape like the PDF spec says it does, sometimes is should be literal
comment|//which is what we will assume here.
comment|//throw new IOException( "Unexpected break sequence '" + next + "' " + pdfSource );
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|openBrace
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|isHexDigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|retval
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|retval
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nextc
operator|!=
operator|-
literal|2
condition|)
block|{
name|c
operator|=
name|nextc
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|openBrace
operator|==
literal|'<'
condition|)
block|{
name|retval
operator|=
name|COSString
operator|.
name|createFromHexString
argument_list|(
name|retval
operator|.
name|getString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will parse a PDF array object.      *      * @return The parsed PDF array.      *      * @throws IOException If there is an error parsing the stream.      */
specifier|protected
name|COSArray
name|parseCOSArray
parameter_list|()
throws|throws
name|IOException
block|{
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'['
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='[' actual='"
operator|+
name|ch
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|COSArray
name|po
init|=
operator|new
name|COSArray
argument_list|()
decl_stmt|;
name|COSBase
name|pbo
init|=
literal|null
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|i
operator|=
name|pdfSource
operator|.
name|peek
argument_list|()
operator|)
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|char
operator|)
name|i
operator|!=
literal|']'
operator|)
condition|)
block|{
name|pbo
operator|=
name|parseDirObject
argument_list|()
expr_stmt|;
if|if
condition|(
name|pbo
operator|instanceof
name|COSObject
condition|)
block|{
comment|// We have to check if the expected values are there or not PDFBOX-385
if|if
condition|(
name|po
operator|.
name|get
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|instanceof
name|COSInteger
condition|)
block|{
name|COSInteger
name|genNumber
init|=
operator|(
name|COSInteger
operator|)
name|po
operator|.
name|remove
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|po
operator|.
name|get
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|instanceof
name|COSInteger
condition|)
block|{
name|COSInteger
name|number
init|=
operator|(
name|COSInteger
operator|)
name|po
operator|.
name|remove
argument_list|(
name|po
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|COSObjectKey
name|key
init|=
operator|new
name|COSObjectKey
argument_list|(
name|number
operator|.
name|intValue
argument_list|()
argument_list|,
name|genNumber
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|pbo
operator|=
name|document
operator|.
name|getObjectFromPool
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the object reference is somehow wrong
name|pbo
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|pbo
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pbo
operator|!=
literal|null
condition|)
block|{
name|po
operator|.
name|add
argument_list|(
name|pbo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
argument_list|()
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"Corrupt object reference"
argument_list|)
expr_stmt|;
comment|//it could be a bad object in the array which is just skipped
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
comment|//read ']'
name|skipSpaces
argument_list|()
expr_stmt|;
return|return
name|po
return|;
block|}
comment|/**      * Determine if a character terminates a PDF name.      *      * @param ch The character      * @return<code>true</code> if the character terminates a PDF name, otherwise<code>false</code>.      */
specifier|protected
name|boolean
name|isEndOfName
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|13
operator|||
name|ch
operator|==
literal|10
operator|||
name|ch
operator|==
literal|9
operator|||
name|ch
operator|==
literal|'>'
operator|||
name|ch
operator|==
literal|'<'
operator|||
name|ch
operator|==
literal|'['
operator|||
name|ch
operator|==
literal|'/'
operator|||
name|ch
operator|==
literal|']'
operator|||
name|ch
operator|==
literal|')'
operator|||
name|ch
operator|==
literal|'('
operator|||
name|ch
operator|==
operator|-
literal|1
comment|//EOF
operator|)
return|;
block|}
comment|/**      * This will parse a PDF name from the stream.      *      * @return The parsed PDF name.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|COSName
name|parseCOSName
parameter_list|()
throws|throws
name|IOException
block|{
name|COSName
name|retval
init|=
literal|null
decl_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|char
operator|)
name|c
operator|!=
literal|'/'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected='/' actual='"
operator|+
operator|(
name|char
operator|)
name|c
operator|+
literal|"'-"
operator|+
name|c
operator|+
literal|" "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
comment|// costruisce il nome
name|StringBuffer
name|buffer
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|ch
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|char
name|ch1
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
name|char
name|ch2
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// Prior to PDF v1.2, the # was not a special character.  Also,
comment|// it has been observed that various PDF tools do not follow the
comment|// spec with respect to the # escape, even though they report
comment|// PDF versions of 1.2 or later.  The solution here is that we
comment|// interpret the # as an escape only when it is followed by two
comment|// valid hex digits.
comment|//
if|if
condition|(
name|isHexDigit
argument_list|(
name|ch1
argument_list|)
operator|&&
name|isHexDigit
argument_list|(
name|ch2
argument_list|)
condition|)
block|{
name|String
name|hex
init|=
literal|""
operator|+
name|ch1
operator|+
name|ch2
decl_stmt|;
try|try
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|hex
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: expected hex number, actual='"
operator|+
name|hex
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
name|c
operator|=
name|ch1
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isEndOfName
argument_list|(
name|ch
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|buffer
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|COSName
operator|.
name|getPDFName
argument_list|(
name|buffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/**      * This will parse a boolean object from the stream.      *      * @return The parsed boolean object.      *      * @throws IOException If an IO error occurs during parsing.      */
specifier|protected
name|COSBoolean
name|parseBoolean
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBoolean
name|retval
init|=
literal|null
decl_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
block|{
name|String
name|trueString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|trueString
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean: expected='true' actual='"
operator|+
name|trueString
operator|+
literal|"'"
argument_list|)
throw|;
block|}
else|else
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
block|{
name|String
name|falseString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|5
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|falseString
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean: expected='true' actual='"
operator|+
name|falseString
operator|+
literal|"'"
argument_list|)
throw|;
block|}
else|else
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing boolean expected='t or f' actual='"
operator|+
name|c
operator|+
literal|"'"
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will parse a directory object from the stream.      *      * @return The parsed object.      *      * @throws IOException If there is an error during parsing.      */
specifier|protected
name|COSBase
name|parseDirObject
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBase
name|retval
init|=
literal|null
decl_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|nextByte
init|=
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
name|char
name|c
init|=
operator|(
name|char
operator|)
name|nextByte
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
block|{
name|int
name|leftBracket
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//pull off first left bracket
name|c
operator|=
operator|(
name|char
operator|)
name|pdfSource
operator|.
name|peek
argument_list|()
expr_stmt|;
comment|//check for second left bracket
name|pdfSource
operator|.
name|unread
argument_list|(
name|leftBracket
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|retval
operator|=
name|parseCOSDictionary
argument_list|()
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|parseCOSString
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'['
case|:
comment|// array
block|{
name|retval
operator|=
name|parseCOSArray
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
literal|'('
case|:
name|retval
operator|=
name|parseCOSString
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|// name
name|retval
operator|=
name|parseCOSName
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|// null
block|{
name|String
name|nullString
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nullString
operator|.
name|equals
argument_list|(
literal|"null"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected='null' actual='"
operator|+
name|nullString
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|retval
operator|=
name|COSNull
operator|.
name|NULL
expr_stmt|;
break|break;
block|}
case|case
literal|'t'
case|:
block|{
name|String
name|trueString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|4
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|trueString
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|TRUE
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected true actual='"
operator|+
name|trueString
operator|+
literal|"' "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
break|break;
block|}
case|case
literal|'f'
case|:
block|{
name|String
name|falseString
init|=
operator|new
name|String
argument_list|(
name|pdfSource
operator|.
name|readFully
argument_list|(
literal|5
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|falseString
operator|.
name|equals
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|retval
operator|=
name|COSBoolean
operator|.
name|FALSE
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"expected false actual='"
operator|+
name|falseString
operator|+
literal|"' "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
break|break;
block|}
case|case
literal|'R'
case|:
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|retval
operator|=
operator|new
name|COSObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|char
operator|)
operator|-
literal|1
case|:
return|return
literal|null
return|;
default|default:
block|{
if|if
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'.'
condition|)
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|ic
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|ic
expr_stmt|;
while|while
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'e'
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ic
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|ic
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|COSNumber
operator|.
name|get
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//This is not suppose to happen, but we will allow for it
comment|//so we are more compatible with POS writers that don't
comment|//follow the spec
name|String
name|badString
init|=
name|readString
argument_list|()
decl_stmt|;
comment|//throw new IOException( "Unknown dir object c='" + c +
comment|//"' peek='" + (char)pdfSource.peek() + "' " + pdfSource );
if|if
condition|(
name|badString
operator|==
literal|null
operator|||
name|badString
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|int
name|peek
init|=
name|pdfSource
operator|.
name|peek
argument_list|()
decl_stmt|;
comment|// we can end up in an infinite loop otherwise
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown dir object c='"
operator|+
name|c
operator|+
literal|"' cInt="
operator|+
operator|(
name|int
operator|)
name|c
operator|+
literal|" peek='"
operator|+
operator|(
name|char
operator|)
name|peek
operator|+
literal|"' peekInt="
operator|+
name|peek
operator|+
literal|" "
operator|+
name|pdfSource
argument_list|)
throw|;
block|}
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will read the next string from the stream.      *      * @return The string that was read from the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readString
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|StringBuffer
name|buffer
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|isEndOfName
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
operator|&&
operator|!
name|isClosing
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will read bytes until the end of line marker occurs.      *      * @param theString The next expected string in the stream.      *      * @return The characters between the current position and the end of the line.      *      * @throws IOException If there is an error reading from the stream or theString does not match what was read.      */
specifier|protected
name|String
name|readExpectedString
parameter_list|(
name|String
name|theString
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
name|StringBuffer
name|buffer
init|=
operator|new
name|StringBuffer
argument_list|(
name|theString
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|charsRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|isEOL
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
operator|&&
name|charsRead
operator|<
name|theString
operator|.
name|length
argument_list|()
condition|)
block|{
name|char
name|next
init|=
operator|(
name|char
operator|)
name|c
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|theString
operator|.
name|charAt
argument_list|(
name|charsRead
argument_list|)
operator|==
name|next
condition|)
block|{
name|charsRead
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|buffer
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected to read '"
operator|+
name|theString
operator|+
literal|"' instead started reading '"
operator|+
name|buffer
operator|.
name|toString
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|isEOL
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will read the next string from the stream up to a certain length.      *      * @param length The length to stop reading at.      *      * @return The string that was read from the stream of length 0 to length.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readString
parameter_list|(
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|//average string size is around 2 and the normal string buffer size is
comment|//about 16 so lets save some space.
name|StringBuffer
name|buffer
init|=
operator|new
name|StringBuffer
argument_list|(
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|isClosing
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
operator|&&
name|buffer
operator|.
name|length
argument_list|()
operator|<
name|length
operator|&&
name|c
operator|!=
literal|'['
operator|&&
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|'('
operator|&&
name|c
operator|!=
literal|'/'
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will tell if the next character is a closing brace( close of PDF array ).      *      * @return true if the next byte is ']', false otherwise.      *      * @throws IOException If an IO error occurs.      */
specifier|protected
name|boolean
name|isClosing
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isClosing
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the next character is a closing brace( close of PDF array ).      *      * @param c The character to check against end of line      * @return true if the next byte is ']', false otherwise.      */
specifier|protected
name|boolean
name|isClosing
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|']'
return|;
block|}
comment|/**      * This will read bytes until the first end of line marker occurs.      * Note: if you later unread the results of this function, you'll      * need to add a newline character to the end of the string.      *      * @return The characters between the current position and the end of the line.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|String
name|readLine
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuffer
name|buffer
init|=
operator|new
name|StringBuffer
argument_list|(
literal|11
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|isEOL
argument_list|(
name|c
argument_list|)
condition|)
block|{
break|break;
block|}
name|buffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will tell if the next byte to be read is an end of line byte.      *      * @return true if the next byte is 0x0A or 0x0D.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isEOL
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isEOL
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the next byte to be read is an end of line byte.      *      * @param c The character to check against end of line      * @return true if the next byte is 0x0A or 0x0D.      */
specifier|protected
name|boolean
name|isEOL
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|10
operator|||
name|c
operator|==
literal|13
return|;
block|}
comment|/**      * This will tell if the next byte is whitespace or not.      *      * @return true if the next byte in the stream is a whitespace character.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|boolean
name|isWhitespace
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|isWhitespace
argument_list|(
name|pdfSource
operator|.
name|peek
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * This will tell if the next byte is whitespace or not.      *      * @param c The character to check against whitespace      *      * @return true if the next byte in the stream is a whitespace character.      */
specifier|protected
name|boolean
name|isWhitespace
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|9
operator|||
name|c
operator|==
literal|12
operator|||
name|c
operator|==
literal|10
operator|||
name|c
operator|==
literal|13
operator|||
name|c
operator|==
literal|32
return|;
block|}
comment|/**      * This will skip all spaces and comments that are present.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|void
name|skipSpaces
parameter_list|()
throws|throws
name|IOException
block|{
comment|//log( "skipSpaces() " + pdfSource );
name|int
name|c
init|=
name|pdfSource
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// identical to, but faster as: isWhiteSpace(c) || c == 37
while|while
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|9
operator|||
name|c
operator|==
literal|12
operator|||
name|c
operator|==
literal|10
operator|||
name|c
operator|==
literal|13
operator|||
name|c
operator|==
literal|32
operator|||
name|c
operator|==
literal|37
condition|)
comment|//37 is the % character, a comment
block|{
if|if
condition|(
name|c
operator|==
literal|37
condition|)
block|{
comment|// skip past the comment section
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|isEOL
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|//log( "skipSpaces() done peek='" + (char)pdfSource.peek() + "'" );
block|}
comment|/**      * This will read an integer from the stream.      *      * @return The integer that was read from the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|protected
name|int
name|readInt
parameter_list|()
throws|throws
name|IOException
block|{
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|lastByte
init|=
literal|0
decl_stmt|;
name|StringBuffer
name|intBuffer
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|lastByte
operator|=
name|pdfSource
operator|.
name|read
argument_list|()
operator|)
operator|!=
literal|32
operator|&&
name|lastByte
operator|!=
literal|10
operator|&&
name|lastByte
operator|!=
literal|13
operator|&&
name|lastByte
operator|!=
literal|60
operator|&&
comment|//see sourceforge bug 1714707
name|lastByte
operator|!=
literal|0
operator|&&
comment|//See sourceforge bug 853328
name|lastByte
operator|!=
operator|-
literal|1
condition|)
block|{
name|intBuffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|lastByte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastByte
operator|!=
operator|-
literal|1
condition|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|lastByte
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|retval
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|intBuffer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|pdfSource
operator|.
name|unread
argument_list|(
name|intBuffer
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected an integer type, actual='"
operator|+
name|intBuffer
operator|+
literal|"'"
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
block|}
end_class

end_unit

