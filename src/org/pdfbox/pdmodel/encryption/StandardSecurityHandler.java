begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *   *      http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|encryption
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|encryption
operator|.
name|ARCFour
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|exceptions
operator|.
name|CryptographyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_comment
comment|/**  *   * The class implements the standard security handler as decribed  * in the PDF specifications. This security handler protects document  * with password.  *   * @see StandardProtectionPolicy to see how to protect document with this security handler.  *   * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  * @author Benoit Guillon (benoit.guillon@snv.jussieu.fr)  *  * @version $Revision: 1.5 $  */
end_comment

begin_class
specifier|public
class|class
name|StandardSecurityHandler
extends|extends
name|SecurityHandler
block|{
comment|/**      * Type of security handler.      */
specifier|public
specifier|static
specifier|final
name|String
name|FILTER
init|=
literal|"Standard"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_VERSION
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_REVISION
init|=
literal|3
decl_stmt|;
specifier|private
name|int
name|revision
init|=
name|DEFAULT_REVISION
decl_stmt|;
specifier|private
name|StandardProtectionPolicy
name|policy
decl_stmt|;
specifier|private
name|ARCFour
name|rc4
init|=
operator|new
name|ARCFour
argument_list|()
decl_stmt|;
comment|/**      * Protection policy class for this handler.      */
specifier|public
specifier|static
specifier|final
name|Class
name|PROTECTION_POLICY_CLASS
init|=
name|StandardProtectionPolicy
operator|.
name|class
decl_stmt|;
comment|/**      * Standard padding for encryption.      */
specifier|public
specifier|static
specifier|final
name|byte
index|[]
name|ENCRYPT_PADDING
init|=
block|{
operator|(
name|byte
operator|)
literal|0x28
block|,
operator|(
name|byte
operator|)
literal|0xBF
block|,
operator|(
name|byte
operator|)
literal|0x4E
block|,
operator|(
name|byte
operator|)
literal|0x5E
block|,
operator|(
name|byte
operator|)
literal|0x4E
block|,
operator|(
name|byte
operator|)
literal|0x75
block|,
operator|(
name|byte
operator|)
literal|0x8A
block|,
operator|(
name|byte
operator|)
literal|0x41
block|,
operator|(
name|byte
operator|)
literal|0x64
block|,
operator|(
name|byte
operator|)
literal|0x00
block|,
operator|(
name|byte
operator|)
literal|0x4E
block|,
operator|(
name|byte
operator|)
literal|0x56
block|,
operator|(
name|byte
operator|)
literal|0xFF
block|,
operator|(
name|byte
operator|)
literal|0xFA
block|,
operator|(
name|byte
operator|)
literal|0x01
block|,
operator|(
name|byte
operator|)
literal|0x08
block|,
operator|(
name|byte
operator|)
literal|0x2E
block|,
operator|(
name|byte
operator|)
literal|0x2E
block|,
operator|(
name|byte
operator|)
literal|0x00
block|,
operator|(
name|byte
operator|)
literal|0xB6
block|,
operator|(
name|byte
operator|)
literal|0xD0
block|,
operator|(
name|byte
operator|)
literal|0x68
block|,
operator|(
name|byte
operator|)
literal|0x3E
block|,
operator|(
name|byte
operator|)
literal|0x80
block|,
operator|(
name|byte
operator|)
literal|0x2F
block|,
operator|(
name|byte
operator|)
literal|0x0C
block|,
operator|(
name|byte
operator|)
literal|0xA9
block|,
operator|(
name|byte
operator|)
literal|0xFE
block|,
operator|(
name|byte
operator|)
literal|0x64
block|,
operator|(
name|byte
operator|)
literal|0x53
block|,
operator|(
name|byte
operator|)
literal|0x69
block|,
operator|(
name|byte
operator|)
literal|0x7A
block|}
decl_stmt|;
comment|/**      * Constructor.      */
specifier|public
name|StandardSecurityHandler
parameter_list|()
block|{             }
comment|/**      * Constructor used for encryption.      *       * @param p The protection policy.      */
specifier|public
name|StandardSecurityHandler
parameter_list|(
name|StandardProtectionPolicy
name|p
parameter_list|)
block|{
name|policy
operator|=
name|p
expr_stmt|;
name|keyLength
operator|=
name|policy
operator|.
name|getEncryptionKeyLength
argument_list|()
expr_stmt|;
block|}
comment|/**      * Computes the version number of the StandardSecurityHandler       * regarding the encryption key length.      * See PDF Spec 1.6 p 93      *        * @return The computed cersion number.      */
specifier|private
name|int
name|computeVersionNumber
parameter_list|()
block|{
if|if
condition|(
name|keyLength
operator|==
literal|40
condition|)
block|{
return|return
name|DEFAULT_VERSION
return|;
block|}
return|return
literal|2
return|;
block|}
comment|/**      * Computes the revision version of the StandardSecurityHandler to      * use regarding the version number and the permissions bits set.      * See PDF Spec 1.6 p98      *       * @return The computed revision number.      */
specifier|private
name|int
name|computeRevisionNumber
parameter_list|()
block|{
if|if
condition|(
name|version
operator|==
literal|2
operator|&&
operator|!
name|policy
operator|.
name|getPermissions
argument_list|()
operator|.
name|canFillInForm
argument_list|()
operator|&&
operator|!
name|policy
operator|.
name|getPermissions
argument_list|()
operator|.
name|canExtractForAccessibility
argument_list|()
operator|&&
operator|!
name|policy
operator|.
name|getPermissions
argument_list|()
operator|.
name|canPrintDegraded
argument_list|()
condition|)
block|{
return|return
literal|2
return|;
block|}
return|return
literal|3
return|;
block|}
comment|/**      * Decrypt the document.      *       * @param doc The document to be decrypted.      * @param decryptionMaterial Information used to decrypt the document.      *       * @throws IOException If there is an error accessing data.      * @throws CryptographyException If there is an error with decryption.      */
specifier|public
name|void
name|decryptDocument
parameter_list|(
name|PDDocument
name|doc
parameter_list|,
name|DecryptionMaterial
name|decryptionMaterial
parameter_list|)
throws|throws
name|CryptographyException
throws|,
name|IOException
block|{
name|document
operator|=
name|doc
expr_stmt|;
name|PDEncryptionDictionary
name|dictionary
init|=
name|document
operator|.
name|getEncryptionDictionary
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|decryptionMaterial
operator|instanceof
name|StandardDecryptionMaterial
operator|)
condition|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
literal|"Provided decryption material is not compatible with the document"
argument_list|)
throw|;
block|}
name|StandardDecryptionMaterial
name|material
init|=
operator|(
name|StandardDecryptionMaterial
operator|)
name|decryptionMaterial
decl_stmt|;
name|String
name|password
init|=
name|material
operator|.
name|getPassword
argument_list|()
decl_stmt|;
if|if
condition|(
name|password
operator|==
literal|null
condition|)
block|{
name|password
operator|=
literal|""
expr_stmt|;
block|}
name|int
name|dicPermissions
init|=
name|dictionary
operator|.
name|getPermissions
argument_list|()
decl_stmt|;
name|int
name|dicRevision
init|=
name|dictionary
operator|.
name|getRevision
argument_list|()
decl_stmt|;
name|int
name|dicLength
init|=
name|dictionary
operator|.
name|getLength
argument_list|()
operator|/
literal|8
decl_stmt|;
comment|//some documents may have not document id, see
comment|//test\encryption\encrypted_doc_no_id.pdf
name|COSArray
name|documentIDArray
init|=
name|document
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocumentID
argument_list|()
decl_stmt|;
name|byte
index|[]
name|documentIDBytes
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|documentIDArray
operator|!=
literal|null
operator|&&
name|documentIDArray
operator|.
name|size
argument_list|()
operator|>=
literal|1
condition|)
block|{
name|COSString
name|id
init|=
operator|(
name|COSString
operator|)
name|documentIDArray
operator|.
name|getObject
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|documentIDBytes
operator|=
name|id
operator|.
name|getBytes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|documentIDBytes
operator|=
operator|new
name|byte
index|[
literal|0
index|]
expr_stmt|;
block|}
name|byte
index|[]
name|u
init|=
name|dictionary
operator|.
name|getUserKey
argument_list|()
decl_stmt|;
name|byte
index|[]
name|o
init|=
name|dictionary
operator|.
name|getOwnerKey
argument_list|()
decl_stmt|;
name|boolean
name|isUserPassword
init|=
name|isUserPassword
argument_list|(
name|password
operator|.
name|getBytes
argument_list|()
argument_list|,
name|u
argument_list|,
name|o
argument_list|,
name|dicPermissions
argument_list|,
name|documentIDBytes
argument_list|,
name|dicRevision
argument_list|,
name|dicLength
argument_list|)
decl_stmt|;
name|boolean
name|isOwnerPassword
init|=
name|isOwnerPassword
argument_list|(
name|password
operator|.
name|getBytes
argument_list|()
argument_list|,
name|u
argument_list|,
name|o
argument_list|,
name|dicPermissions
argument_list|,
name|documentIDBytes
argument_list|,
name|dicRevision
argument_list|,
name|dicLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|isUserPassword
condition|)
block|{
name|currentAccessPermission
operator|=
operator|new
name|AccessPermission
argument_list|(
name|dicPermissions
argument_list|)
expr_stmt|;
name|encryptionKey
operator|=
name|computeEncryptedKey
argument_list|(
name|password
operator|.
name|getBytes
argument_list|()
argument_list|,
name|o
argument_list|,
name|dicPermissions
argument_list|,
name|documentIDBytes
argument_list|,
name|dicRevision
argument_list|,
name|dicLength
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isOwnerPassword
condition|)
block|{
name|currentAccessPermission
operator|=
name|AccessPermission
operator|.
name|getOwnerAccessPermission
argument_list|()
expr_stmt|;
name|byte
index|[]
name|computedUserPassword
init|=
name|getUserPassword
argument_list|(
name|password
operator|.
name|getBytes
argument_list|()
argument_list|,
name|o
argument_list|,
name|dicRevision
argument_list|,
name|dicLength
argument_list|)
decl_stmt|;
name|encryptionKey
operator|=
name|computeEncryptedKey
argument_list|(
name|computedUserPassword
argument_list|,
name|o
argument_list|,
name|dicPermissions
argument_list|,
name|documentIDBytes
argument_list|,
name|dicRevision
argument_list|,
name|dicLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
literal|"Error: The supplied password does not match either the owner or user password in the document."
argument_list|)
throw|;
block|}
name|this
operator|.
name|proceedDecryption
argument_list|()
expr_stmt|;
block|}
comment|/**      * Prepare document for encryption.      *       * @param doc The documeent to encrypt.      *       * @throws IOException If there is an error accessing data.      * @throws CryptographyException If there is an error with decryption.      */
specifier|public
name|void
name|prepareDocumentForEncryption
parameter_list|(
name|PDDocument
name|doc
parameter_list|)
throws|throws
name|CryptographyException
throws|,
name|IOException
block|{
name|document
operator|=
name|doc
expr_stmt|;
name|PDEncryptionDictionary
name|encryptionDictionary
init|=
name|document
operator|.
name|getEncryptionDictionary
argument_list|()
decl_stmt|;
if|if
condition|(
name|encryptionDictionary
operator|==
literal|null
condition|)
block|{
name|encryptionDictionary
operator|=
operator|new
name|PDEncryptionDictionary
argument_list|()
expr_stmt|;
block|}
name|version
operator|=
name|computeVersionNumber
argument_list|()
expr_stmt|;
name|revision
operator|=
name|computeRevisionNumber
argument_list|()
expr_stmt|;
name|encryptionDictionary
operator|.
name|setFilter
argument_list|(
name|FILTER
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setRevision
argument_list|(
name|revision
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setLength
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
name|String
name|ownerPassword
init|=
name|policy
operator|.
name|getOwnerPassword
argument_list|()
decl_stmt|;
name|String
name|userPassword
init|=
name|policy
operator|.
name|getUserPassword
argument_list|()
decl_stmt|;
if|if
condition|(
name|ownerPassword
operator|==
literal|null
condition|)
block|{
name|ownerPassword
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|userPassword
operator|==
literal|null
condition|)
block|{
name|userPassword
operator|=
literal|""
expr_stmt|;
block|}
name|int
name|permissionInt
init|=
name|policy
operator|.
name|getPermissions
argument_list|()
operator|.
name|getPermissionBytes
argument_list|()
decl_stmt|;
name|encryptionDictionary
operator|.
name|setPermissions
argument_list|(
name|permissionInt
argument_list|)
expr_stmt|;
name|int
name|length
init|=
name|keyLength
operator|/
literal|8
decl_stmt|;
name|COSArray
name|idArray
init|=
name|document
operator|.
name|getDocument
argument_list|()
operator|.
name|getDocumentID
argument_list|()
decl_stmt|;
comment|//check if the document has an id yet.  If it does not then
comment|//generate one
if|if
condition|(
name|idArray
operator|==
literal|null
operator|||
name|idArray
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
name|idArray
operator|=
operator|new
name|COSArray
argument_list|()
expr_stmt|;
try|try
block|{
name|MessageDigest
name|md
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
decl_stmt|;
name|BigInteger
name|time
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
name|md
operator|.
name|update
argument_list|(
name|time
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|ownerPassword
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|userPassword
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|document
operator|.
name|getDocument
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|id
init|=
name|md
operator|.
name|digest
argument_list|(
name|this
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
name|COSString
name|idString
init|=
operator|new
name|COSString
argument_list|()
decl_stmt|;
name|idString
operator|.
name|append
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|idArray
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|idArray
operator|.
name|add
argument_list|(
name|idString
argument_list|)
expr_stmt|;
name|document
operator|.
name|getDocument
argument_list|()
operator|.
name|setDocumentID
argument_list|(
name|idArray
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|COSString
name|id
init|=
operator|(
name|COSString
operator|)
name|idArray
operator|.
name|getObject
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|byte
index|[]
name|o
init|=
name|computeOwnerPassword
argument_list|(
name|ownerPassword
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|,
name|userPassword
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|,
name|revision
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|byte
index|[]
name|u
init|=
name|computeUserPassword
argument_list|(
name|userPassword
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|,
name|o
argument_list|,
name|permissionInt
argument_list|,
name|id
operator|.
name|getBytes
argument_list|()
argument_list|,
name|revision
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|encryptionKey
operator|=
name|computeEncryptedKey
argument_list|(
name|userPassword
operator|.
name|getBytes
argument_list|(
literal|"ISO-8859-1"
argument_list|)
argument_list|,
name|o
argument_list|,
name|permissionInt
argument_list|,
name|id
operator|.
name|getBytes
argument_list|()
argument_list|,
name|revision
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setOwnerKey
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|encryptionDictionary
operator|.
name|setUserKey
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|document
operator|.
name|setEncryptionDictionary
argument_list|(
name|encryptionDictionary
argument_list|)
expr_stmt|;
name|document
operator|.
name|getDocument
argument_list|()
operator|.
name|setEncryptionDictionary
argument_list|(
name|encryptionDictionary
operator|.
name|getCOSDictionary
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check for owner password.      *       * @param ownerPassword The owner password.      * @param u The u entry of the encryption dictionary.      * @param o The o entry of the encryption dictionary.      * @param permissions The set of permissions on the document.      * @param id The document id.      * @param encRevision The encryption algorithm revision.      * @param length The encryption key length.      *       * @return True If the ownerPassword param is the owner password.      *       * @throws CryptographyException If there is an error during encryption.      * @throws IOException If there is an error accessing data.      */
specifier|public
specifier|final
name|boolean
name|isOwnerPassword
parameter_list|(
name|byte
index|[]
name|ownerPassword
parameter_list|,
name|byte
index|[]
name|u
parameter_list|,
name|byte
index|[]
name|o
parameter_list|,
name|int
name|permissions
parameter_list|,
name|byte
index|[]
name|id
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|CryptographyException
throws|,
name|IOException
block|{
name|byte
index|[]
name|userPassword
init|=
name|getUserPassword
argument_list|(
name|ownerPassword
argument_list|,
name|o
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|)
decl_stmt|;
return|return
name|isUserPassword
argument_list|(
name|userPassword
argument_list|,
name|u
argument_list|,
name|o
argument_list|,
name|permissions
argument_list|,
name|id
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/**      * Get the user password based on the owner password.      *       * @param ownerPassword The plaintext owner password.      * @param o The o entry of the encryption dictionary.      * @param encRevision The encryption revision number.      * @param length The key length.      *       * @return The u entry of the encryption dictionary.      *       * @throws CryptographyException If there is an error generating the user password.      * @throws IOException If there is an error accessing data while generating the user password.      */
specifier|public
specifier|final
name|byte
index|[]
name|getUserPassword
parameter_list|(
name|byte
index|[]
name|ownerPassword
parameter_list|,
name|byte
index|[]
name|o
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|CryptographyException
throws|,
name|IOException
block|{
try|try
block|{
name|ByteArrayOutputStream
name|result
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
comment|//3.3 STEP 1
name|byte
index|[]
name|ownerPadded
init|=
name|truncateOrPad
argument_list|(
name|ownerPassword
argument_list|)
decl_stmt|;
comment|//3.3 STEP 2
name|MessageDigest
name|md
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
decl_stmt|;
name|md
operator|.
name|update
argument_list|(
name|ownerPadded
argument_list|)
expr_stmt|;
name|byte
index|[]
name|digest
init|=
name|md
operator|.
name|digest
argument_list|()
decl_stmt|;
comment|//3.3 STEP 3
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|.
name|reset
argument_list|()
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|digest
argument_list|)
expr_stmt|;
name|digest
operator|=
name|md
operator|.
name|digest
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|encRevision
operator|==
literal|2
operator|&&
name|length
operator|!=
literal|5
condition|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
literal|"Error: Expected length=5 actual="
operator|+
name|length
argument_list|)
throw|;
block|}
comment|//3.3 STEP 4
name|byte
index|[]
name|rc4Key
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|digest
argument_list|,
literal|0
argument_list|,
name|rc4Key
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|)
expr_stmt|;
comment|//3.7 step 2
if|if
condition|(
name|encRevision
operator|==
literal|2
condition|)
block|{
name|rc4
operator|.
name|setKey
argument_list|(
name|rc4Key
argument_list|)
expr_stmt|;
name|rc4
operator|.
name|write
argument_list|(
name|o
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
comment|/**                 byte[] iterationKey = new byte[ rc4Key.length ];                 byte[] dataToEncrypt = o;                 for( int i=19; i>=0; i-- )                 {                     System.arraycopy( rc4Key, 0, iterationKey, 0, rc4Key.length );                     for( int j=0; j< iterationKey.length; j++ )                     {                         iterationKey[j] = (byte)(iterationKey[j] ^ (byte)i);                     }                     rc4.setKey( iterationKey );                     rc4.write( dataToEncrypt, result );                     dataToEncrypt = result.toByteArray();                     result.reset();                 }                 result.write( dataToEncrypt, 0, dataToEncrypt.length );                 */
name|byte
index|[]
name|iterationKey
init|=
operator|new
name|byte
index|[
name|rc4Key
operator|.
name|length
index|]
decl_stmt|;
name|byte
index|[]
name|otemp
init|=
operator|new
name|byte
index|[
name|o
operator|.
name|length
index|]
decl_stmt|;
comment|//sm
name|System
operator|.
name|arraycopy
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
name|otemp
argument_list|,
literal|0
argument_list|,
name|o
operator|.
name|length
argument_list|)
expr_stmt|;
comment|//sm
name|rc4
operator|.
name|write
argument_list|(
name|o
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|//sm
for|for
control|(
name|int
name|i
init|=
literal|19
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|rc4Key
argument_list|,
literal|0
argument_list|,
name|iterationKey
argument_list|,
literal|0
argument_list|,
name|rc4Key
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iterationKey
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|iterationKey
index|[
name|j
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|iterationKey
index|[
name|j
index|]
operator|^
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
name|rc4
operator|.
name|setKey
argument_list|(
name|iterationKey
argument_list|)
expr_stmt|;
name|result
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|//sm
name|rc4
operator|.
name|write
argument_list|(
name|otemp
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|//sm
name|otemp
operator|=
name|result
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
comment|//sm
block|}
block|}
return|return
name|result
operator|.
name|toByteArray
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Compute the encryption key.      *       * @param password The password to compute the encrypted key.      * @param o The o entry of the encryption dictionary.      * @param permissions The permissions for the document.      * @param id The document id.      * @param encRevision The revision of the encryption algorithm.      * @param length The length of the encryption key.      *       * @return The encrypted key bytes.      *       * @throws CryptographyException If there is an error with encryption.      */
specifier|public
specifier|final
name|byte
index|[]
name|computeEncryptedKey
parameter_list|(
name|byte
index|[]
name|password
parameter_list|,
name|byte
index|[]
name|o
parameter_list|,
name|int
name|permissions
parameter_list|,
name|byte
index|[]
name|id
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|CryptographyException
block|{
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
try|try
block|{
comment|//PDFReference 1.4 pg 78
comment|//step1
name|byte
index|[]
name|padded
init|=
name|truncateOrPad
argument_list|(
name|password
argument_list|)
decl_stmt|;
comment|//step 2
name|MessageDigest
name|md
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
decl_stmt|;
name|md
operator|.
name|update
argument_list|(
name|padded
argument_list|)
expr_stmt|;
comment|//step 3
name|md
operator|.
name|update
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|//step 4
name|byte
name|zero
init|=
call|(
name|byte
call|)
argument_list|(
name|permissions
operator|>>>
literal|0
argument_list|)
decl_stmt|;
name|byte
name|one
init|=
call|(
name|byte
call|)
argument_list|(
name|permissions
operator|>>>
literal|8
argument_list|)
decl_stmt|;
name|byte
name|two
init|=
call|(
name|byte
call|)
argument_list|(
name|permissions
operator|>>>
literal|16
argument_list|)
decl_stmt|;
name|byte
name|three
init|=
call|(
name|byte
call|)
argument_list|(
name|permissions
operator|>>>
literal|24
argument_list|)
decl_stmt|;
name|md
operator|.
name|update
argument_list|(
name|zero
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|one
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|two
argument_list|)
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|three
argument_list|)
expr_stmt|;
comment|//step 5
name|md
operator|.
name|update
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|byte
index|[]
name|digest
init|=
name|md
operator|.
name|digest
argument_list|()
decl_stmt|;
comment|//step 6
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|.
name|reset
argument_list|()
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|digest
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|digest
operator|=
name|md
operator|.
name|digest
argument_list|()
expr_stmt|;
block|}
block|}
comment|//step 7
if|if
condition|(
name|encRevision
operator|==
literal|2
operator|&&
name|length
operator|!=
literal|5
condition|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
literal|"Error: length should be 5 when revision is two actual="
operator|+
name|length
argument_list|)
throw|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|digest
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * This will compute the user password hash.      *      * @param password The plain text password.      * @param o The owner password hash.      * @param permissions The document permissions.      * @param id The document id.      * @param encRevision The revision of the encryption.      * @param length The length of the encryption key.      *      * @return The user password.      *      * @throws CryptographyException If there is an error computing the user password.      * @throws IOException If there is an IO error.      */
specifier|public
specifier|final
name|byte
index|[]
name|computeUserPassword
parameter_list|(
name|byte
index|[]
name|password
parameter_list|,
name|byte
index|[]
name|o
parameter_list|,
name|int
name|permissions
parameter_list|,
name|byte
index|[]
name|id
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|CryptographyException
throws|,
name|IOException
block|{
name|ByteArrayOutputStream
name|result
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
comment|//STEP 1
name|byte
index|[]
name|encryptionKey
init|=
name|computeEncryptedKey
argument_list|(
name|password
argument_list|,
name|o
argument_list|,
name|permissions
argument_list|,
name|id
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|encRevision
operator|==
literal|2
condition|)
block|{
comment|//STEP 2
name|rc4
operator|.
name|setKey
argument_list|(
name|encryptionKey
argument_list|)
expr_stmt|;
name|rc4
operator|.
name|write
argument_list|(
name|ENCRYPT_PADDING
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
try|try
block|{
comment|//STEP 2
name|MessageDigest
name|md
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
decl_stmt|;
comment|//md.update( truncateOrPad( password ) );
name|md
operator|.
name|update
argument_list|(
name|ENCRYPT_PADDING
argument_list|)
expr_stmt|;
comment|//STEP 3
name|md
operator|.
name|update
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|result
operator|.
name|write
argument_list|(
name|md
operator|.
name|digest
argument_list|()
argument_list|)
expr_stmt|;
comment|//STEP 4 and 5
name|byte
index|[]
name|iterationKey
init|=
operator|new
name|byte
index|[
name|encryptionKey
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|encryptionKey
argument_list|,
literal|0
argument_list|,
name|iterationKey
argument_list|,
literal|0
argument_list|,
name|iterationKey
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iterationKey
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|iterationKey
index|[
name|j
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|iterationKey
index|[
name|j
index|]
operator|^
name|i
argument_list|)
expr_stmt|;
block|}
name|rc4
operator|.
name|setKey
argument_list|(
name|iterationKey
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|input
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|result
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|.
name|reset
argument_list|()
expr_stmt|;
name|rc4
operator|.
name|write
argument_list|(
name|input
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|//step 6
name|byte
index|[]
name|finalResult
init|=
operator|new
name|byte
index|[
literal|32
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|result
operator|.
name|toByteArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|finalResult
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ENCRYPT_PADDING
argument_list|,
literal|0
argument_list|,
name|finalResult
argument_list|,
literal|16
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|result
operator|.
name|reset
argument_list|()
expr_stmt|;
name|result
operator|.
name|write
argument_list|(
name|finalResult
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|result
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**      * Compute the owner entry in the encryption dictionary.      *       * @param ownerPassword The plaintext owner password.      * @param userPassword The plaintext user password.      * @param encRevision The revision number of the encryption algorithm.      * @param length The length of the encryption key.      *       * @return The o entry of the encryption dictionary.      *       * @throws CryptographyException If there is an error with encryption.      * @throws IOException If there is an error accessing data.      */
specifier|public
specifier|final
name|byte
index|[]
name|computeOwnerPassword
parameter_list|(
name|byte
index|[]
name|ownerPassword
parameter_list|,
name|byte
index|[]
name|userPassword
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|CryptographyException
throws|,
name|IOException
block|{
try|try
block|{
comment|//STEP 1
name|byte
index|[]
name|ownerPadded
init|=
name|truncateOrPad
argument_list|(
name|ownerPassword
argument_list|)
decl_stmt|;
comment|//STEP 2
name|MessageDigest
name|md
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
decl_stmt|;
name|md
operator|.
name|update
argument_list|(
name|ownerPadded
argument_list|)
expr_stmt|;
name|byte
index|[]
name|digest
init|=
name|md
operator|.
name|digest
argument_list|()
decl_stmt|;
comment|//STEP 3
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|.
name|reset
argument_list|()
expr_stmt|;
name|md
operator|.
name|update
argument_list|(
name|digest
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|digest
operator|=
name|md
operator|.
name|digest
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|encRevision
operator|==
literal|2
operator|&&
name|length
operator|!=
literal|5
condition|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
literal|"Error: Expected length=5 actual="
operator|+
name|length
argument_list|)
throw|;
block|}
comment|//STEP 4
name|byte
index|[]
name|rc4Key
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|digest
argument_list|,
literal|0
argument_list|,
name|rc4Key
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|//STEP 5
name|byte
index|[]
name|paddedUser
init|=
name|truncateOrPad
argument_list|(
name|userPassword
argument_list|)
decl_stmt|;
comment|//STEP 6
name|rc4
operator|.
name|setKey
argument_list|(
name|rc4Key
argument_list|)
expr_stmt|;
name|ByteArrayOutputStream
name|crypted
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|rc4
operator|.
name|write
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|paddedUser
argument_list|)
argument_list|,
name|crypted
argument_list|)
expr_stmt|;
comment|//STEP 7
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
name|byte
index|[]
name|iterationKey
init|=
operator|new
name|byte
index|[
name|rc4Key
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|rc4Key
argument_list|,
literal|0
argument_list|,
name|iterationKey
argument_list|,
literal|0
argument_list|,
name|rc4Key
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iterationKey
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|iterationKey
index|[
name|j
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|iterationKey
index|[
name|j
index|]
operator|^
operator|(
name|byte
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
name|rc4
operator|.
name|setKey
argument_list|(
name|iterationKey
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|input
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|crypted
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|crypted
operator|.
name|reset
argument_list|()
expr_stmt|;
name|rc4
operator|.
name|write
argument_list|(
name|input
argument_list|,
name|crypted
argument_list|)
expr_stmt|;
block|}
block|}
comment|//STEP 8
return|return
name|crypted
operator|.
name|toByteArray
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CryptographyException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * This will take the password and truncate or pad it as necessary.      *      * @param password The password to pad or truncate.      *      * @return The padded or truncated password.      */
specifier|private
specifier|final
name|byte
index|[]
name|truncateOrPad
parameter_list|(
name|byte
index|[]
name|password
parameter_list|)
block|{
name|byte
index|[]
name|padded
init|=
operator|new
name|byte
index|[
name|ENCRYPT_PADDING
operator|.
name|length
index|]
decl_stmt|;
name|int
name|bytesBeforePad
init|=
name|Math
operator|.
name|min
argument_list|(
name|password
operator|.
name|length
argument_list|,
name|padded
operator|.
name|length
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|password
argument_list|,
literal|0
argument_list|,
name|padded
argument_list|,
literal|0
argument_list|,
name|bytesBeforePad
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ENCRYPT_PADDING
argument_list|,
literal|0
argument_list|,
name|padded
argument_list|,
name|bytesBeforePad
argument_list|,
name|ENCRYPT_PADDING
operator|.
name|length
operator|-
name|bytesBeforePad
argument_list|)
expr_stmt|;
return|return
name|padded
return|;
block|}
comment|/**      * Check if a plaintext password is the user password.      *       * @param password The plaintext password.      * @param u The u entry of the encryption dictionary.      * @param o The o entry of the encryption dictionary.      * @param permissions The permissions set in the the PDF.      * @param id The document id used for encryption.      * @param encRevision The revision of the encryption algorithm.      * @param length The length of the encryption key.      *       * @return true If the plaintext password is the user password.      *       * @throws CryptographyException If there is an error during encryption.      * @throws IOException If there is an error accessing data.      */
specifier|public
specifier|final
name|boolean
name|isUserPassword
parameter_list|(
name|byte
index|[]
name|password
parameter_list|,
name|byte
index|[]
name|u
parameter_list|,
name|byte
index|[]
name|o
parameter_list|,
name|int
name|permissions
parameter_list|,
name|byte
index|[]
name|id
parameter_list|,
name|int
name|encRevision
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|CryptographyException
throws|,
name|IOException
block|{
name|boolean
name|matches
init|=
literal|false
decl_stmt|;
comment|//STEP 1
name|byte
index|[]
name|computedValue
init|=
name|computeUserPassword
argument_list|(
name|password
argument_list|,
name|o
argument_list|,
name|permissions
argument_list|,
name|id
argument_list|,
name|encRevision
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|encRevision
operator|==
literal|2
condition|)
block|{
comment|//STEP 2
name|matches
operator|=
name|arraysEqual
argument_list|(
name|u
argument_list|,
name|computedValue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encRevision
operator|==
literal|3
operator|||
name|encRevision
operator|==
literal|4
condition|)
block|{
comment|//STEP 2
name|matches
operator|=
name|arraysEqual
argument_list|(
name|u
argument_list|,
name|computedValue
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown Encryption Revision "
operator|+
name|encRevision
argument_list|)
throw|;
block|}
return|return
name|matches
return|;
block|}
specifier|private
specifier|static
specifier|final
name|boolean
name|arraysEqual
parameter_list|(
name|byte
index|[]
name|first
parameter_list|,
name|byte
index|[]
name|second
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|boolean
name|equal
init|=
name|first
operator|.
name|length
operator|>=
name|count
operator|&&
name|second
operator|.
name|length
operator|>=
name|count
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
operator|&&
name|equal
condition|;
name|i
operator|++
control|)
block|{
name|equal
operator|=
name|first
index|[
name|i
index|]
operator|==
name|second
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|equal
return|;
block|}
comment|/**      * This will compare two byte[] for equality.      *      * @param first The first byte array.      * @param second The second byte array.      *      * @return true If the arrays contain the exact same data.      */
specifier|private
specifier|static
specifier|final
name|boolean
name|arraysEqual
parameter_list|(
name|byte
index|[]
name|first
parameter_list|,
name|byte
index|[]
name|second
parameter_list|)
block|{
name|boolean
name|equal
init|=
name|first
operator|.
name|length
operator|==
name|second
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|first
operator|.
name|length
operator|&&
name|equal
condition|;
name|i
operator|++
control|)
block|{
name|equal
operator|=
name|first
index|[
name|i
index|]
operator|==
name|second
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|equal
return|;
block|}
block|}
end_class

end_unit

