begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2003-2006, www.pdfbox.org  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  * 3. Neither the name of pdfbox; nor the names of its  *    contributors may be used to endorse or promote products derived from this  *    software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * http://www.pdfbox.org  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
package|;
end_package

begin_import
import|import
name|org
operator|.
name|fontbox
operator|.
name|afm
operator|.
name|AFMParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|fontbox
operator|.
name|afm
operator|.
name|FontMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|fontbox
operator|.
name|cmap
operator|.
name|CMapParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|fontbox
operator|.
name|cmap
operator|.
name|CMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|AFMEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|DictionaryEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|Encoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|EncodingManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|COSArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|COSObjectable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDMatrix
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRectangle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|ResourceLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Graphics
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_comment
comment|/**  * This is the base class for all PDF fonts.  *  * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  * @version $Revision: 1.46 $  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|PDFont
implements|implements
name|COSObjectable
block|{
comment|/**      * The cos dictionary for this font.      */
specifier|protected
name|COSDictionary
name|font
decl_stmt|;
comment|/**      * This is only used if this is a font object and it has an encoding.      */
specifier|private
name|Encoding
name|fontEncoding
init|=
literal|null
decl_stmt|;
comment|/**      * This is only used if this is a font object and it has an encoding and it is      * a type0 font with a cmap.      */
specifier|private
name|CMap
name|cmap
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
name|Map
name|afmResources
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
name|Map
name|cmapObjects
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
name|Map
name|afmObjects
init|=
literal|null
decl_stmt|;
static|static
block|{
comment|//these are read-only once they are created
name|afmResources
operator|=
operator|new
name|HashMap
argument_list|()
expr_stmt|;
comment|//these are read-write
name|cmapObjects
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|()
argument_list|)
expr_stmt|;
name|afmObjects
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|()
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Courier-Bold"
argument_list|)
argument_list|,
literal|"Resources/afm/Courier-Bold.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Courier-BoldOblique"
argument_list|)
argument_list|,
literal|"Resources/afm/Courier-BoldOblique.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Courier"
argument_list|)
argument_list|,
literal|"Resources/afm/Courier.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Courier-Oblique"
argument_list|)
argument_list|,
literal|"Resources/afm/Courier-Oblique.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Helvetica"
argument_list|)
argument_list|,
literal|"Resources/afm/Helvetica.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Helvetica-Bold"
argument_list|)
argument_list|,
literal|"Resources/afm/Helvetica-Bold.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Helvetica-BoldOblique"
argument_list|)
argument_list|,
literal|"Resources/afm/Helvetica-BoldOblique.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Helvetica-Oblique"
argument_list|)
argument_list|,
literal|"Resources/afm/Helvetica-Oblique.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Symbol"
argument_list|)
argument_list|,
literal|"Resources/afm/Symbol.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Times-Bold"
argument_list|)
argument_list|,
literal|"Resources/afm/Times-Bold.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Times-BoldItalic"
argument_list|)
argument_list|,
literal|"Resources/afm/Times-BoldItalic.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Times-Italic"
argument_list|)
argument_list|,
literal|"Resources/afm/Times-Italic.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"Times-Roman"
argument_list|)
argument_list|,
literal|"Resources/afm/Times-Roman.afm"
argument_list|)
expr_stmt|;
name|afmResources
operator|.
name|put
argument_list|(
name|COSName
operator|.
name|getPDFName
argument_list|(
literal|"ZapfDingbats"
argument_list|)
argument_list|,
literal|"Resources/afm/ZapfDingbats.afm"
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will clear AFM resources that are stored statically.      * This is usually not a problem unless you want to reclaim      * resources for a long running process.      *      * SPECIAL NOTE: The font calculations are currently in COSObject, which      * is where they will reside until PDFont is mature enough to take them over.      * PDFont is the appropriate place for them and not in COSObject but we need font      * calculations for text extractaion.  THIS METHOD WILL BE MOVED OR REMOVED      * TO ANOTHER LOCATION IN A FUTURE VERSION OF PDFBOX.      */
specifier|public
specifier|static
name|void
name|clearResources
parameter_list|()
block|{
name|afmObjects
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cmapObjects
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Constructor.      */
specifier|public
name|PDFont
parameter_list|()
block|{
name|font
operator|=
operator|new
name|COSDictionary
argument_list|()
expr_stmt|;
name|font
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|,
name|COSName
operator|.
name|FONT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *      * @param fontDictionary The font dictionary according to the PDF specification.      */
specifier|public
name|PDFont
parameter_list|(
name|COSDictionary
name|fontDictionary
parameter_list|)
block|{
name|font
operator|=
name|fontDictionary
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|COSBase
name|getCOSObject
parameter_list|()
block|{
return|return
name|font
return|;
block|}
comment|/**      * This will get the font width for a character.      *      * @param c The character code to get the width for.      * @param offset The offset into the array.      * @param length The length of the data.      *      * @return The width is in 1000 unit of text space, ie 333 or 777      *      * @throws IOException If an error occurs while parsing.      */
specifier|public
specifier|abstract
name|float
name|getFontWidth
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * This will get the font width for a character.      *      * @param c The character code to get the width for.      * @param offset The offset into the array.      * @param length The length of the data.      *      * @return The width is in 1000 unit of text space, ie 333 or 777      *      * @throws IOException If an error occurs while parsing.      */
specifier|public
specifier|abstract
name|float
name|getFontHeight
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * This will get the width of this string for this font.      *      * @param string The string to get the width of.      *      * @return The width of the string in 1000 units of text space, ie 333 567...      *      * @throws IOException If there is an error getting the width information.      */
specifier|public
name|float
name|getStringWidth
parameter_list|(
name|String
name|string
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|data
init|=
name|string
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|float
name|totalWidth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|totalWidth
operator|+=
name|getFontWidth
argument_list|(
name|data
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|totalWidth
return|;
block|}
comment|/**      * This will get the average font width for all characters.      *      * @return The width is in 1000 unit of text space, ie 333 or 777      *      * @throws IOException If an error occurs while parsing.      */
specifier|public
specifier|abstract
name|float
name|getAverageFontWidth
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**      * This will draw a string on a canvas using the font.      *      * @param string The string to draw.      * @param g The graphics to draw onto.      * @param fontSize The size of the font to draw.      * @param xScale The x scaling percent.      * @param yScale The y scaling percent.      * @param x The x coordinate to draw at.      * @param y The y coordinate to draw at.      *      * @throws IOException If there is an error drawing the specific string.      */
specifier|public
specifier|abstract
name|void
name|drawString
parameter_list|(
name|String
name|string
parameter_list|,
name|Graphics
name|g
parameter_list|,
name|float
name|fontSize
parameter_list|,
name|float
name|xScale
parameter_list|,
name|float
name|yScale
parameter_list|,
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Used for multibyte encodings.      *      * @param data The array of data.      * @param offset The offset into the array.      * @param length The number of bytes to use.      *      * @return The int value of data from the array.      */
specifier|protected
name|int
name|getCodeFromArray
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|code
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|code
operator|<<=
literal|8
expr_stmt|;
name|code
operator||=
operator|(
name|data
index|[
name|offset
operator|+
name|i
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
comment|/**      * This will attempt to get the font width from an AFM file.      *      * @param code The character code we are trying to get.      *      * @return The font width from the AFM file.      *      * @throws IOException if we cannot find the width.      */
specifier|protected
name|float
name|getFontWidthFromAFMFile
parameter_list|(
name|int
name|code
parameter_list|)
throws|throws
name|IOException
block|{
name|float
name|retval
init|=
literal|0
decl_stmt|;
name|FontMetric
name|metric
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|null
condition|)
block|{
name|Encoding
name|encoding
init|=
name|getEncoding
argument_list|()
decl_stmt|;
name|COSName
name|characterName
init|=
name|encoding
operator|.
name|getName
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|retval
operator|=
name|metric
operator|.
name|getCharacterWidth
argument_list|(
name|characterName
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will attempt to get the average font width from an AFM file.      *      * @return The average font width from the AFM file.      *      * @throws IOException if we cannot find the width.      */
specifier|protected
name|float
name|getAverageFontWidthFromAFMFile
parameter_list|()
throws|throws
name|IOException
block|{
name|float
name|retval
init|=
literal|0
decl_stmt|;
name|FontMetric
name|metric
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|metric
operator|.
name|getAverageCharacterWidth
argument_list|()
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * This will get an AFM object if one exists.      *      * @return The afm object from the name.      *      * @throws IOException If there is an error getting the AFM object.      */
specifier|protected
name|FontMetric
name|getAFM
parameter_list|()
throws|throws
name|IOException
block|{
name|COSBase
name|baseFont
init|=
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|BASE_FONT
argument_list|)
decl_stmt|;
name|COSName
name|name
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|baseFont
operator|instanceof
name|COSName
condition|)
block|{
name|name
operator|=
operator|(
name|COSName
operator|)
name|baseFont
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseFont
operator|instanceof
name|COSString
condition|)
block|{
name|COSString
name|string
init|=
operator|(
name|COSString
operator|)
name|baseFont
decl_stmt|;
name|name
operator|=
name|COSName
operator|.
name|getPDFName
argument_list|(
name|string
operator|.
name|getString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FontMetric
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
operator|(
name|FontMetric
operator|)
name|afmObjects
operator|.
name|get
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|String
name|resource
init|=
operator|(
name|String
operator|)
name|afmResources
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|resource
operator|==
literal|null
condition|)
block|{
comment|//ok for now
comment|//throw new IOException( "Unknown AFM font '" + name.getName() + "'" );
block|}
else|else
block|{
name|InputStream
name|afmStream
init|=
name|ResourceLoader
operator|.
name|loadResource
argument_list|(
name|resource
argument_list|)
decl_stmt|;
if|if
condition|(
name|afmStream
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't handle font width:"
operator|+
name|resource
argument_list|)
throw|;
block|}
name|AFMParser
name|parser
init|=
operator|new
name|AFMParser
argument_list|(
name|afmStream
argument_list|)
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|()
expr_stmt|;
name|result
operator|=
name|parser
operator|.
name|getResult
argument_list|()
expr_stmt|;
name|afmObjects
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * This will perform the encoding of a character if needed.      *      * @param c The character to encode.      * @param offset The offset into the array to get the data      * @param length The number of bytes to read.      *      * @return The value of the encoded character.      *      * @throws IOException If there is an error during the encoding.      */
specifier|public
name|String
name|encode
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|retval
init|=
literal|null
decl_stmt|;
name|COSName
name|fontSubtype
init|=
operator|(
name|COSName
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|SUBTYPE
argument_list|)
decl_stmt|;
name|String
name|fontSubtypeName
init|=
name|fontSubtype
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|fontSubtypeName
operator|.
name|equals
argument_list|(
literal|"Type0"
argument_list|)
operator|||
name|fontSubtypeName
operator|.
name|equals
argument_list|(
literal|"Type1"
argument_list|)
operator|||
name|fontSubtypeName
operator|.
name|equals
argument_list|(
literal|"TrueType"
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmap
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|TO_UNICODE
argument_list|)
operator|instanceof
name|COSStream
condition|)
block|{
name|COSStream
name|toUnicode
init|=
operator|(
name|COSStream
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|TO_UNICODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|toUnicode
operator|!=
literal|null
condition|)
block|{
name|parseCmap
argument_list|(
literal|null
argument_list|,
name|toUnicode
operator|.
name|getUnfilteredStream
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|COSBase
name|encoding
init|=
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
if|if
condition|(
name|encoding
operator|instanceof
name|COSStream
condition|)
block|{
name|COSStream
name|encodingStream
init|=
operator|(
name|COSStream
operator|)
name|encoding
decl_stmt|;
name|parseCmap
argument_list|(
literal|null
argument_list|,
name|encodingStream
operator|.
name|getUnfilteredStream
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fontSubtypeName
operator|.
name|equals
argument_list|(
literal|"Type0"
argument_list|)
operator|&&
name|encoding
operator|instanceof
name|COSName
condition|)
block|{
name|COSName
name|encodingName
init|=
operator|(
name|COSName
operator|)
name|encoding
decl_stmt|;
name|cmap
operator|=
operator|(
name|CMap
operator|)
name|cmapObjects
operator|.
name|get
argument_list|(
name|encodingName
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap
operator|!=
literal|null
condition|)
block|{
name|cmap
operator|=
operator|(
name|CMap
operator|)
name|cmapObjects
operator|.
name|get
argument_list|(
name|encodingName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|cmapName
init|=
name|encodingName
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|resourceRoot
init|=
literal|"Resources/cmap/"
decl_stmt|;
name|String
name|resourceName
init|=
name|resourceRoot
operator|+
name|cmapName
decl_stmt|;
name|parseCmap
argument_list|(
name|resourceRoot
argument_list|,
name|ResourceLoader
operator|.
name|loadResource
argument_list|(
name|resourceName
argument_list|)
argument_list|,
name|encodingName
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap
operator|==
literal|null
operator|&&
operator|!
name|encodingName
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|COSName
operator|.
name|IDENTITY_H
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Could not find predefined "
operator|+
literal|"CMAP file for '"
operator|+
name|encodingName
operator|.
name|getName
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|encoding
operator|instanceof
name|COSName
operator|||
name|encoding
operator|instanceof
name|COSDictionary
condition|)
block|{
name|Encoding
name|currentFontEncoding
init|=
name|getEncoding
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentFontEncoding
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|currentFontEncoding
operator|.
name|getCharacter
argument_list|(
name|getCodeFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|COSDictionary
name|fontDescriptor
init|=
operator|(
name|COSDictionary
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_DESC
argument_list|)
decl_stmt|;
if|if
condition|(
name|fontSubtypeName
operator|.
name|equals
argument_list|(
literal|"TrueType"
argument_list|)
operator|&&
name|fontDescriptor
operator|!=
literal|null
operator|&&
operator|(
name|fontDescriptor
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_FILE
argument_list|)
operator|!=
literal|null
operator|||
name|fontDescriptor
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_FILE2
argument_list|)
operator|!=
literal|null
operator|||
name|fontDescriptor
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_FILE3
argument_list|)
operator|!=
literal|null
operator|)
condition|)
block|{
comment|//If we are using an embedded font then there is not much we can do besides
comment|//return the same character codes.
comment|//retval = new String( c,offset, length );
name|retval
operator|=
name|getStringFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//this case will be handled below after checking the cmap
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|retval
operator|==
literal|null
operator|&&
name|cmap
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|cmap
operator|.
name|lookup
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|//if we havn't found a value yet and
comment|//we are still on the first byte and
comment|//there is no cmap or the cmap does not have 2 byte mappings then try to encode
comment|//using fallback methods.
if|if
condition|(
name|retval
operator|==
literal|null
operator|&&
name|length
operator|==
literal|1
operator|&&
operator|(
name|cmap
operator|==
literal|null
operator|||
operator|!
name|cmap
operator|.
name|hasTwoByteMappings
argument_list|()
operator|)
condition|)
block|{
name|Encoding
name|encoding
init|=
name|getEncoding
argument_list|()
decl_stmt|;
if|if
condition|(
name|encoding
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
name|encoding
operator|.
name|getCharacter
argument_list|(
name|getCodeFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
literal|null
condition|)
block|{
name|retval
operator|=
name|getStringFromArray
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|SINGLE_CHAR_STRING
init|=
operator|new
name|String
index|[
literal|256
index|]
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
index|[]
index|[]
name|DOUBLE_CHAR_STRING
init|=
operator|new
name|String
index|[
literal|256
index|]
index|[
literal|256
index|]
decl_stmt|;
static|static
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|SINGLE_CHAR_STRING
index|[
name|i
index|]
operator|=
operator|new
name|String
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
name|i
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|DOUBLE_CHAR_STRING
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|new
name|String
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
name|i
block|,
operator|(
name|byte
operator|)
name|j
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|String
name|getStringFromArray
parameter_list|(
name|byte
index|[]
name|c
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|retval
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|1
condition|)
block|{
name|retval
operator|=
name|SINGLE_CHAR_STRING
index|[
operator|(
name|c
index|[
name|offset
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|2
condition|)
block|{
name|retval
operator|=
name|DOUBLE_CHAR_STRING
index|[
operator|(
name|c
index|[
name|offset
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
index|[
operator|(
name|c
index|[
name|offset
operator|+
literal|1
index|]
operator|+
literal|256
operator|)
operator|%
literal|256
index|]
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error:Unknown character length:"
operator|+
name|length
argument_list|)
throw|;
block|}
return|return
name|retval
return|;
block|}
specifier|private
name|void
name|parseCmap
parameter_list|(
name|String
name|cmapRoot
parameter_list|,
name|InputStream
name|cmapStream
parameter_list|,
name|COSName
name|encodingName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cmapStream
operator|!=
literal|null
condition|)
block|{
name|CMapParser
name|parser
init|=
operator|new
name|CMapParser
argument_list|()
decl_stmt|;
name|cmap
operator|=
name|parser
operator|.
name|parse
argument_list|(
name|cmapRoot
argument_list|,
name|cmapStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|encodingName
operator|!=
literal|null
condition|)
block|{
name|cmapObjects
operator|.
name|put
argument_list|(
name|encodingName
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * The will set the encoding for this font.      *       * @param enc The font encoding.      */
specifier|public
name|void
name|setEncoding
parameter_list|(
name|Encoding
name|enc
parameter_list|)
block|{
name|font
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|ENCODING
argument_list|,
name|enc
argument_list|)
expr_stmt|;
name|fontEncoding
operator|=
name|enc
expr_stmt|;
block|}
comment|/**      * This will get or create the encoder.      *      * modified by Christophe Huault : DGBS Strasbourg huault@free.fr october 2004      *      * @return The encoding to use.      *      * @throws IOException If there is an error getting the encoding.      */
specifier|public
name|Encoding
name|getEncoding
parameter_list|()
throws|throws
name|IOException
block|{
name|EncodingManager
name|manager
init|=
operator|new
name|EncodingManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|fontEncoding
operator|==
literal|null
condition|)
block|{
name|COSBase
name|encoding
init|=
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|ENCODING
argument_list|)
decl_stmt|;
if|if
condition|(
name|encoding
operator|==
literal|null
condition|)
block|{
name|FontMetric
name|metric
init|=
name|getAFM
argument_list|()
decl_stmt|;
if|if
condition|(
name|metric
operator|!=
literal|null
condition|)
block|{
name|fontEncoding
operator|=
operator|new
name|AFMEncoding
argument_list|(
name|metric
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fontEncoding
operator|==
literal|null
condition|)
block|{
name|fontEncoding
operator|=
name|manager
operator|.
name|getStandardEncoding
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**              * Si la clé /Encoding existe dans le dictionnaire fonte il y a deux possibilités :              * 1er cas : elle est associé à une reference contenant un dictionnaire de type encoding.              * Ce dictionnaire PDF est représenté par un DictionaryEncoding.              * If the /Encoding Key does exist in the font dictionary, there are two cases :              * case one : The value associated with /Encoding is a reference to a dictionary.              * This dictionary is represented by an instance of DictionaryEncoding class              */
elseif|else
if|if
condition|(
name|encoding
operator|instanceof
name|COSDictionary
condition|)
block|{
name|COSDictionary
name|encodingDic
init|=
operator|(
name|COSDictionary
operator|)
name|encoding
decl_stmt|;
comment|//Let's see if the encoding dictionary has a base encoding
comment|//If it does not then we will attempt to get it from the font
comment|//file
name|COSName
name|baseEncodingName
init|=
operator|(
name|COSName
operator|)
name|encodingDic
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|BASE_ENCODING
argument_list|)
decl_stmt|;
comment|//on ajoute une entrée /BaseEncoding dans /Encoding uniquement si elle en est absente
comment|//if not find in Encoding dictinary target, we try to find it from else where
if|if
condition|(
name|baseEncodingName
operator|==
literal|null
condition|)
block|{
name|COSName
name|fontEncodingFromFile
init|=
name|getEncodingFromFont
argument_list|()
decl_stmt|;
name|encodingDic
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|BASE_ENCODING
argument_list|,
name|fontEncodingFromFile
argument_list|)
expr_stmt|;
block|}
name|fontEncoding
operator|=
operator|new
name|DictionaryEncoding
argument_list|(
name|encodingDic
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encoding
operator|instanceof
name|COSName
condition|)
block|{
if|if
condition|(
operator|!
name|encoding
operator|.
name|equals
argument_list|(
name|COSName
operator|.
name|IDENTITY_H
argument_list|)
condition|)
block|{
name|fontEncoding
operator|=
name|manager
operator|.
name|getEncoding
argument_list|(
operator|(
name|COSName
operator|)
name|encoding
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected encoding type:"
operator|+
name|encoding
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|fontEncoding
return|;
block|}
comment|/**      * This will always return "Font" for fonts.      *       * @return The type of object that this is.      */
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|font
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
return|;
block|}
comment|/**      * This will get the subtype of font, Type1, Type3, ...      *       * @return The type of font that this is.      */
specifier|public
name|String
name|getSubType
parameter_list|()
block|{
return|return
name|font
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|SUBTYPE
argument_list|)
return|;
block|}
comment|/**      * The PostScript name of the font.      *       * @return The postscript name of the font.      */
specifier|public
name|String
name|getBaseFont
parameter_list|()
block|{
return|return
name|font
operator|.
name|getNameAsString
argument_list|(
name|COSName
operator|.
name|BASE_FONT
argument_list|)
return|;
block|}
comment|/**      * Set the PostScript name of the font.      *       * @param baseFont The postscript name for the font.      */
specifier|public
name|void
name|setBaseFont
parameter_list|(
name|String
name|baseFont
parameter_list|)
block|{
name|font
operator|.
name|setName
argument_list|(
name|COSName
operator|.
name|BASE_FONT
argument_list|,
name|baseFont
argument_list|)
expr_stmt|;
block|}
comment|/**      * The code for the first char or -1 if there is none.      *       * @return The code for the first character.      */
specifier|public
name|int
name|getFirstChar
parameter_list|()
block|{
return|return
name|font
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|FIRST_CHAR
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * Set the first character this font supports.      *       * @param firstChar The first character.      */
specifier|public
name|void
name|setFirstChar
parameter_list|(
name|int
name|firstChar
parameter_list|)
block|{
name|font
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|FIRST_CHAR
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
block|}
comment|/**      * The code for the last char or -1 if there is none.      *       * @return The code for the last character.      */
specifier|public
name|int
name|getLastChar
parameter_list|()
block|{
return|return
name|font
operator|.
name|getInt
argument_list|(
name|COSName
operator|.
name|LAST_CHAR
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**      * Set the last character this font supports.      *       * @param lastChar The last character.      */
specifier|public
name|void
name|setLastChar
parameter_list|(
name|int
name|lastChar
parameter_list|)
block|{
name|font
operator|.
name|setInt
argument_list|(
name|COSName
operator|.
name|LAST_CHAR
argument_list|,
name|lastChar
argument_list|)
expr_stmt|;
block|}
comment|/**      * The widths of the characters.  This will be null for the standard 14 fonts.      *       * @return The widths of the characters.      */
specifier|public
name|List
name|getWidths
parameter_list|()
block|{
name|COSArray
name|array
init|=
operator|(
name|COSArray
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|WIDTHS
argument_list|)
decl_stmt|;
return|return
name|COSArrayList
operator|.
name|convertFloatCOSArrayToList
argument_list|(
name|array
argument_list|)
return|;
block|}
comment|/**      * Set the widths of the characters code.      *       * @param widths The widths of the character codes.      */
specifier|public
name|void
name|setWidths
parameter_list|(
name|List
name|widths
parameter_list|)
block|{
name|font
operator|.
name|setItem
argument_list|(
name|COSName
operator|.
name|WIDTHS
argument_list|,
name|COSArrayList
operator|.
name|converterToCOSArray
argument_list|(
name|widths
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will get the matrix that is used to transform glyph space to      * text space.  By default there are 1000 glyph units to 1 text space      * unit, but type3 fonts can use any value.        *       * Note:If this is a type3 font then it can be modified via the PDType3Font.setFontMatrix, otherwise this      * is a read-only property.      *       * @return The matrix to transform from glyph space to text space.      */
specifier|public
name|PDMatrix
name|getFontMatrix
parameter_list|()
block|{
name|PDMatrix
name|matrix
init|=
literal|null
decl_stmt|;
name|COSArray
name|array
init|=
operator|(
name|COSArray
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_MATRIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|==
literal|null
condition|)
block|{
name|array
operator|=
operator|new
name|COSArray
argument_list|()
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
operator|new
name|COSFloat
argument_list|(
literal|0.001f
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSNumber
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSNumber
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
operator|new
name|COSFloat
argument_list|(
literal|0.001f
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSNumber
operator|.
name|ZERO
argument_list|)
expr_stmt|;
name|array
operator|.
name|add
argument_list|(
name|COSNumber
operator|.
name|ZERO
argument_list|)
expr_stmt|;
block|}
name|matrix
operator|=
operator|new
name|PDMatrix
argument_list|(
name|array
argument_list|)
expr_stmt|;
return|return
name|matrix
return|;
block|}
comment|/**      * Try to get the encoding for the font and add it to the target      * the target must be an an Encoding Dictionary.      *      * added by Christophe Huault : DGBS Strasbourg huault@free.fr october 2004      *      * @return The encoding from the font.      *       * @throws IOException If there is an error reading the file.      */
specifier|private
name|COSName
name|getEncodingFromFont
parameter_list|()
throws|throws
name|IOException
block|{
comment|//This whole section of code needs to be replaced with an actual
comment|//type1 font parser!!
name|COSName
name|retvalue
init|=
literal|null
decl_stmt|;
comment|//recuperer le programme de fonte dans son stream qui doit se trouver
comment|//dans le flux référencé par à la clé FileFont lui même situé dans
comment|//le dictionnaire associé à /FontDescriptor du dictionnaire de type /Font courrant
comment|//get the font program in the stream which should be located in
comment|//the /FileFont Stream object himself in the /FontDescriptior of the current
comment|//font dictionary
name|COSDictionary
name|fontDescriptor
init|=
operator|(
name|COSDictionary
operator|)
name|font
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_DESC
argument_list|)
decl_stmt|;
if|if
condition|(
name|fontDescriptor
operator|!=
literal|null
condition|)
block|{
name|COSStream
name|fontFile
init|=
operator|(
name|COSStream
operator|)
name|fontDescriptor
operator|.
name|getDictionaryObject
argument_list|(
name|COSName
operator|.
name|FONT_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
name|fontFile
operator|!=
literal|null
condition|)
block|{
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|fontFile
operator|.
name|getUnfilteredStream
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|/**                  * this section parse the FileProgram stream searching for a /Encoding entry                  * the research stop if the entry "currentdict end" is reach or after 100 lignes                  */
name|StringTokenizer
name|st
init|=
literal|null
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|String
name|line
init|=
literal|""
decl_stmt|;
name|String
name|key
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
literal|null
operator|!=
operator|(
name|line
operator|=
name|in
operator|.
name|readLine
argument_list|()
operator|)
operator|&&
name|i
operator|<
literal|40
operator|&&
operator|!
name|line
operator|.
name|equals
argument_list|(
literal|"currentdict end"
argument_list|)
operator|&&
operator|!
name|found
condition|;
name|i
operator|++
control|)
block|{
name|st
operator|=
operator|new
name|StringTokenizer
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|key
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
literal|"/Encoding"
argument_list|)
operator|&&
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|COSName
name|value
init|=
name|COSName
operator|.
name|getPDFName
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
argument_list|)
decl_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|equals
argument_list|(
name|COSName
operator|.
name|MAC_ROMAN_ENCODING
argument_list|)
operator|||
name|value
operator|.
name|equals
argument_list|(
name|COSName
operator|.
name|PDF_DOC_ENCODING
argument_list|)
operator|||
name|value
operator|.
name|equals
argument_list|(
name|COSName
operator|.
name|STANDARD_ENCODING
argument_list|)
operator|||
name|value
operator|.
name|equals
argument_list|(
name|COSName
operator|.
name|WIN_ANSI_ENCODING
argument_list|)
condition|)
block|{
comment|//value is expected to be one of the encodings
comment|//ie. StandardEncoding,WinAnsiEncoding,MacRomanEncoding,PDFDocEncoding
name|retvalue
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|retvalue
return|;
block|}
comment|/**      * This will get the fonts bouding box.      *      * @return The fonts bouding box.      *       * @throws IOException If there is an error getting the bounding box.      */
specifier|public
specifier|abstract
name|PDRectangle
name|getFontBoundingBox
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**      * {@inheritDoc}      */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|other
operator|instanceof
name|PDFont
operator|&&
operator|(
operator|(
name|PDFont
operator|)
name|other
operator|)
operator|.
name|getCOSObject
argument_list|()
operator|==
name|this
operator|.
name|getCOSObject
argument_list|()
return|;
block|}
comment|/**      * {@inheritDoc}      */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|getCOSObject
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
end_class

end_unit

