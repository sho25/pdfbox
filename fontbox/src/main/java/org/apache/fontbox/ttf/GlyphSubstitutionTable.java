begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|gsub
operator|.
name|GlyphSubstitutionDataExtractor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|model
operator|.
name|GsubData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|CoverageTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|CoverageTableFormat1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|CoverageTableFormat2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|FeatureListTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|FeatureRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|FeatureTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|LangSysRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|LangSysTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|LookupListTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|LookupSubTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|LookupTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|RangeRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|ScriptRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|common
operator|.
name|ScriptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|gsub
operator|.
name|LigatureSetTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|gsub
operator|.
name|LigatureTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|gsub
operator|.
name|LookupTypeLigatureSubstitutionSubstFormat1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|gsub
operator|.
name|LookupTypeSingleSubstFormat1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|table
operator|.
name|gsub
operator|.
name|LookupTypeSingleSubstFormat2
import|;
end_import

begin_comment
comment|/**  * A glyph substitution 'GSUB' table in a TrueType or OpenType font.  *  * @author Aaron Madlon-Kay  */
end_comment

begin_class
specifier|public
class|class
name|GlyphSubstitutionTable
extends|extends
name|TTFTable
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|GlyphSubstitutionTable
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG
init|=
literal|"GSUB"
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ScriptTable
argument_list|>
name|scriptList
decl_stmt|;
comment|// featureList and lookupList are not maps because we need to index into them
specifier|private
name|FeatureListTable
name|featureListTable
decl_stmt|;
specifier|private
name|LookupListTable
name|lookupListTable
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|lookupCache
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|reverseLookup
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|String
name|lastUsedSupportedScript
decl_stmt|;
specifier|private
name|GsubData
name|gsubData
decl_stmt|;
name|GlyphSubstitutionTable
parameter_list|(
name|TrueTypeFont
name|font
parameter_list|)
block|{
name|super
argument_list|(
name|font
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"squid:S1854"
block|}
argument_list|)
name|void
name|read
parameter_list|(
name|TrueTypeFont
name|ttf
parameter_list|,
name|TTFDataStream
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|start
init|=
name|data
operator|.
name|getCurrentPosition
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unused"
block|}
argument_list|)
name|int
name|majorVersion
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|minorVersion
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|scriptListOffset
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|featureListOffset
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|lookupListOffset
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unused"
block|}
argument_list|)
name|long
name|featureVariationsOffset
init|=
operator|-
literal|1L
decl_stmt|;
if|if
condition|(
name|minorVersion
operator|==
literal|1L
condition|)
block|{
name|featureVariationsOffset
operator|=
name|data
operator|.
name|readUnsignedInt
argument_list|()
expr_stmt|;
block|}
name|scriptList
operator|=
name|readScriptList
argument_list|(
name|data
argument_list|,
name|start
operator|+
name|scriptListOffset
argument_list|)
expr_stmt|;
name|featureListTable
operator|=
name|readFeatureList
argument_list|(
name|data
argument_list|,
name|start
operator|+
name|featureListOffset
argument_list|)
expr_stmt|;
name|lookupListTable
operator|=
name|readLookupList
argument_list|(
name|data
argument_list|,
name|start
operator|+
name|lookupListOffset
argument_list|)
expr_stmt|;
name|GlyphSubstitutionDataExtractor
name|glyphSubstitutionDataExtractor
init|=
operator|new
name|GlyphSubstitutionDataExtractor
argument_list|()
decl_stmt|;
name|gsubData
operator|=
name|glyphSubstitutionDataExtractor
operator|.
name|getGsubData
argument_list|(
name|scriptList
argument_list|,
name|featureListTable
argument_list|,
name|lookupListTable
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ScriptTable
argument_list|>
name|readScriptList
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|scriptCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|ScriptTable
index|[]
name|scriptTables
init|=
operator|new
name|ScriptTable
index|[
name|scriptCount
index|]
decl_stmt|;
name|int
index|[]
name|scriptOffsets
init|=
operator|new
name|int
index|[
name|scriptCount
index|]
decl_stmt|;
name|String
index|[]
name|scriptTags
init|=
operator|new
name|String
index|[
name|scriptCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scriptCount
condition|;
name|i
operator|++
control|)
block|{
name|scriptTags
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|scriptOffsets
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scriptCount
condition|;
name|i
operator|++
control|)
block|{
name|scriptTables
index|[
name|i
index|]
operator|=
name|readScriptTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|scriptOffsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|ScriptTable
argument_list|>
name|resultScriptList
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|scriptCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scriptCount
condition|;
name|i
operator|++
control|)
block|{
name|ScriptRecord
name|scriptRecord
init|=
operator|new
name|ScriptRecord
argument_list|(
name|scriptTags
index|[
name|i
index|]
argument_list|,
name|scriptTables
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|resultScriptList
operator|.
name|put
argument_list|(
name|scriptRecord
operator|.
name|getScriptTag
argument_list|()
argument_list|,
name|scriptRecord
operator|.
name|getScriptTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|resultScriptList
argument_list|)
return|;
block|}
specifier|private
name|ScriptTable
name|readScriptTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|defaultLangSys
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|langSysCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|LangSysRecord
index|[]
name|langSysRecords
init|=
operator|new
name|LangSysRecord
index|[
name|langSysCount
index|]
decl_stmt|;
name|String
index|[]
name|langSysTags
init|=
operator|new
name|String
index|[
name|langSysCount
index|]
decl_stmt|;
name|int
index|[]
name|langSysOffsets
init|=
operator|new
name|int
index|[
name|langSysCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|langSysCount
condition|;
name|i
operator|++
control|)
block|{
name|langSysTags
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|langSysOffsets
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
name|LangSysTable
name|defaultLangSysTable
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|defaultLangSys
operator|!=
literal|0
condition|)
block|{
name|defaultLangSysTable
operator|=
name|readLangSysTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|defaultLangSys
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|langSysCount
condition|;
name|i
operator|++
control|)
block|{
name|LangSysTable
name|langSysTable
init|=
name|readLangSysTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|langSysOffsets
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|langSysRecords
index|[
name|i
index|]
operator|=
operator|new
name|LangSysRecord
argument_list|(
name|langSysTags
index|[
name|i
index|]
argument_list|,
name|langSysTable
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|LangSysTable
argument_list|>
name|langSysTables
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|langSysCount
argument_list|)
decl_stmt|;
for|for
control|(
name|LangSysRecord
name|langSysRecord
range|:
name|langSysRecords
control|)
block|{
name|langSysTables
operator|.
name|put
argument_list|(
name|langSysRecord
operator|.
name|getLangSysTag
argument_list|()
argument_list|,
name|langSysRecord
operator|.
name|getLangSysTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ScriptTable
argument_list|(
name|defaultLangSysTable
argument_list|,
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|langSysTables
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|LangSysTable
name|readLangSysTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|lookupOrder
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|requiredFeatureIndex
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|featureIndexCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
index|[]
name|featureIndices
init|=
operator|new
name|int
index|[
name|featureIndexCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|featureIndexCount
condition|;
name|i
operator|++
control|)
block|{
name|featureIndices
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|LangSysTable
argument_list|(
name|lookupOrder
argument_list|,
name|requiredFeatureIndex
argument_list|,
name|featureIndexCount
argument_list|,
name|featureIndices
argument_list|)
return|;
block|}
specifier|private
name|FeatureListTable
name|readFeatureList
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|featureCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|FeatureRecord
index|[]
name|featureRecords
init|=
operator|new
name|FeatureRecord
index|[
name|featureCount
index|]
decl_stmt|;
name|int
index|[]
name|featureOffsets
init|=
operator|new
name|int
index|[
name|featureCount
index|]
decl_stmt|;
name|String
index|[]
name|featureTags
init|=
operator|new
name|String
index|[
name|featureCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|featureCount
condition|;
name|i
operator|++
control|)
block|{
name|featureTags
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|featureOffsets
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|featureCount
condition|;
name|i
operator|++
control|)
block|{
name|FeatureTable
name|featureTable
init|=
name|readFeatureTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|featureOffsets
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|featureRecords
index|[
name|i
index|]
operator|=
operator|new
name|FeatureRecord
argument_list|(
name|featureTags
index|[
name|i
index|]
argument_list|,
name|featureTable
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FeatureListTable
argument_list|(
name|featureCount
argument_list|,
name|featureRecords
argument_list|)
return|;
block|}
specifier|private
name|FeatureTable
name|readFeatureTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|featureParams
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|lookupIndexCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
index|[]
name|lookupListIndices
init|=
operator|new
name|int
index|[
name|lookupIndexCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lookupIndexCount
condition|;
name|i
operator|++
control|)
block|{
name|lookupListIndices
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|FeatureTable
argument_list|(
name|featureParams
argument_list|,
name|lookupIndexCount
argument_list|,
name|lookupListIndices
argument_list|)
return|;
block|}
specifier|private
name|LookupListTable
name|readLookupList
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|lookupCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
index|[]
name|lookups
init|=
operator|new
name|int
index|[
name|lookupCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lookupCount
condition|;
name|i
operator|++
control|)
block|{
name|lookups
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
name|LookupTable
index|[]
name|lookupTables
init|=
operator|new
name|LookupTable
index|[
name|lookupCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lookupCount
condition|;
name|i
operator|++
control|)
block|{
name|lookupTables
index|[
name|i
index|]
operator|=
name|readLookupTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|lookups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|LookupListTable
argument_list|(
name|lookupCount
argument_list|,
name|lookupTables
argument_list|)
return|;
block|}
specifier|private
name|LookupTable
name|readLookupTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|lookupType
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|lookupFlag
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|subTableCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
index|[]
name|subTableOffets
init|=
operator|new
name|int
index|[
name|subTableCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subTableCount
condition|;
name|i
operator|++
control|)
block|{
name|subTableOffets
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
name|int
name|markFilteringSet
decl_stmt|;
if|if
condition|(
operator|(
name|lookupFlag
operator|&
literal|0x0010
operator|)
operator|!=
literal|0
condition|)
block|{
name|markFilteringSet
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|markFilteringSet
operator|=
literal|0
expr_stmt|;
block|}
name|LookupSubTable
index|[]
name|subTables
init|=
operator|new
name|LookupSubTable
index|[
name|subTableCount
index|]
decl_stmt|;
switch|switch
condition|(
name|lookupType
condition|)
block|{
case|case
literal|1
case|:
comment|// Single
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subTableCount
condition|;
name|i
operator|++
control|)
block|{
name|subTables
index|[
name|i
index|]
operator|=
name|readLookupSubTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|subTableOffets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
comment|// Ligature Substitution Subtable
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subTableCount
condition|;
name|i
operator|++
control|)
block|{
name|subTables
index|[
name|i
index|]
operator|=
name|readLigatureSubstitutionSubtable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|subTableOffets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// Other lookup types are not supported
name|LOG
operator|.
name|debug
argument_list|(
literal|"Type "
operator|+
name|lookupType
operator|+
literal|" GSUB lookup table is not supported and will be ignored"
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|LookupTable
argument_list|(
name|lookupType
argument_list|,
name|lookupFlag
argument_list|,
name|markFilteringSet
argument_list|,
name|subTables
argument_list|)
return|;
block|}
specifier|private
name|LookupSubTable
name|readLookupSubTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|substFormat
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|substFormat
condition|)
block|{
case|case
literal|1
case|:
block|{
name|int
name|coverageOffset
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|short
name|deltaGlyphID
init|=
name|data
operator|.
name|readSignedShort
argument_list|()
decl_stmt|;
name|CoverageTable
name|coverageTable
init|=
name|readCoverageTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|coverageOffset
argument_list|)
decl_stmt|;
return|return
operator|new
name|LookupTypeSingleSubstFormat1
argument_list|(
name|substFormat
argument_list|,
name|coverageTable
argument_list|,
name|deltaGlyphID
argument_list|)
return|;
block|}
case|case
literal|2
case|:
block|{
name|int
name|coverageOffset
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|glyphCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
index|[]
name|substituteGlyphIDs
init|=
operator|new
name|int
index|[
name|glyphCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|glyphCount
condition|;
name|i
operator|++
control|)
block|{
name|substituteGlyphIDs
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
name|CoverageTable
name|coverageTable
init|=
name|readCoverageTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|coverageOffset
argument_list|)
decl_stmt|;
return|return
operator|new
name|LookupTypeSingleSubstFormat2
argument_list|(
name|substFormat
argument_list|,
name|coverageTable
argument_list|,
name|substituteGlyphIDs
argument_list|)
return|;
block|}
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown substFormat: "
operator|+
name|substFormat
argument_list|)
throw|;
block|}
block|}
specifier|private
name|LookupSubTable
name|readLigatureSubstitutionSubtable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|substFormat
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
if|if
condition|(
name|substFormat
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The expected SubstFormat for LigatureSubstitutionTable is 1"
argument_list|)
throw|;
block|}
name|int
name|coverage
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|ligSetCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
index|[]
name|ligatureOffsets
init|=
operator|new
name|int
index|[
name|ligSetCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ligSetCount
condition|;
name|i
operator|++
control|)
block|{
name|ligatureOffsets
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
name|CoverageTable
name|coverageTable
init|=
name|readCoverageTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|coverage
argument_list|)
decl_stmt|;
if|if
condition|(
name|ligSetCount
operator|!=
name|coverageTable
operator|.
name|getSize
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"According to the OpenTypeFont specifications, the coverage count should be equal to the no. of LigatureSetTables"
argument_list|)
throw|;
block|}
name|LigatureSetTable
index|[]
name|ligatureSetTables
init|=
operator|new
name|LigatureSetTable
index|[
name|ligSetCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ligSetCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|coverageGlyphId
init|=
name|coverageTable
operator|.
name|getGlyphId
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ligatureSetTables
index|[
name|i
index|]
operator|=
name|readLigatureSetTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|ligatureOffsets
index|[
name|i
index|]
argument_list|,
name|coverageGlyphId
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|LookupTypeLigatureSubstitutionSubstFormat1
argument_list|(
name|substFormat
argument_list|,
name|coverageTable
argument_list|,
name|ligatureSetTables
argument_list|)
return|;
block|}
specifier|private
name|LigatureSetTable
name|readLigatureSetTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|ligatureSetTableLocation
parameter_list|,
name|int
name|coverageGlyphId
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|ligatureSetTableLocation
argument_list|)
expr_stmt|;
name|int
name|ligatureCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"ligatureCount="
operator|+
name|ligatureCount
argument_list|)
expr_stmt|;
name|int
index|[]
name|ligatureOffsets
init|=
operator|new
name|int
index|[
name|ligatureCount
index|]
decl_stmt|;
name|LigatureTable
index|[]
name|ligatureTables
init|=
operator|new
name|LigatureTable
index|[
name|ligatureCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ligatureOffsets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ligatureOffsets
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ligatureOffsets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ligatureOffset
init|=
name|ligatureOffsets
index|[
name|i
index|]
decl_stmt|;
name|ligatureTables
index|[
name|i
index|]
operator|=
name|readLigatureTable
argument_list|(
name|data
argument_list|,
name|ligatureSetTableLocation
operator|+
name|ligatureOffset
argument_list|,
name|coverageGlyphId
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|LigatureSetTable
argument_list|(
name|ligatureCount
argument_list|,
name|ligatureTables
argument_list|)
return|;
block|}
specifier|private
name|LigatureTable
name|readLigatureTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|ligatureTableLocation
parameter_list|,
name|int
name|coverageGlyphId
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|ligatureTableLocation
argument_list|)
expr_stmt|;
name|int
name|ligatureGlyph
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|componentCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
index|[]
name|componentGlyphIDs
init|=
operator|new
name|int
index|[
name|componentCount
index|]
decl_stmt|;
name|componentGlyphIDs
index|[
literal|0
index|]
operator|=
name|coverageGlyphId
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|componentCount
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|componentGlyphIDs
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|LigatureTable
argument_list|(
name|ligatureGlyph
argument_list|,
name|componentCount
argument_list|,
name|componentGlyphIDs
argument_list|)
return|;
block|}
specifier|private
name|CoverageTable
name|readCoverageTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|coverageFormat
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|coverageFormat
condition|)
block|{
case|case
literal|1
case|:
block|{
name|int
name|glyphCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
index|[]
name|glyphArray
init|=
operator|new
name|int
index|[
name|glyphCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|glyphCount
condition|;
name|i
operator|++
control|)
block|{
name|glyphArray
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|CoverageTableFormat1
argument_list|(
name|coverageFormat
argument_list|,
name|glyphArray
argument_list|)
return|;
block|}
case|case
literal|2
case|:
block|{
name|int
name|rangeCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|RangeRecord
index|[]
name|rangeRecords
init|=
operator|new
name|RangeRecord
index|[
name|rangeCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rangeCount
condition|;
name|i
operator|++
control|)
block|{
name|rangeRecords
index|[
name|i
index|]
operator|=
name|readRangeRecord
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|CoverageTableFormat2
argument_list|(
name|coverageFormat
argument_list|,
name|rangeRecords
argument_list|)
return|;
block|}
default|default:
comment|// Should not happen (the spec indicates only format 1 and format 2)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown coverage format: "
operator|+
name|coverageFormat
argument_list|)
throw|;
block|}
block|}
comment|/**      * Choose from one of the supplied OpenType script tags, depending on what the font supports and potentially on      * context.      *      * @param tags      * @return The best OpenType script tag      */
specifier|private
name|String
name|selectScriptTag
parameter_list|(
name|String
index|[]
name|tags
parameter_list|)
block|{
if|if
condition|(
name|tags
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|String
name|tag
init|=
name|tags
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|OpenTypeScript
operator|.
name|INHERITED
operator|.
name|equals
argument_list|(
name|tag
argument_list|)
operator|||
operator|(
name|OpenTypeScript
operator|.
name|TAG_DEFAULT
operator|.
name|equals
argument_list|(
name|tag
argument_list|)
operator|&&
operator|!
name|scriptList
operator|.
name|containsKey
argument_list|(
name|tag
argument_list|)
operator|)
condition|)
block|{
comment|// We don't know what script this should be.
if|if
condition|(
name|lastUsedSupportedScript
operator|==
literal|null
condition|)
block|{
comment|// We have no past context and (currently) no way to get future context so we guess.
name|lastUsedSupportedScript
operator|=
name|scriptList
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
comment|// else use past context
return|return
name|lastUsedSupportedScript
return|;
block|}
block|}
for|for
control|(
name|String
name|tag
range|:
name|tags
control|)
block|{
if|if
condition|(
name|scriptList
operator|.
name|containsKey
argument_list|(
name|tag
argument_list|)
condition|)
block|{
comment|// Use the first recognized tag. We assume a single font only recognizes one version ("ver. 2")
comment|// of a single script, or if it recognizes more than one that it prefers the latest one.
name|lastUsedSupportedScript
operator|=
name|tag
expr_stmt|;
return|return
name|lastUsedSupportedScript
return|;
block|}
block|}
return|return
name|tags
index|[
literal|0
index|]
return|;
block|}
specifier|private
name|Collection
argument_list|<
name|LangSysTable
argument_list|>
name|getLangSysTables
parameter_list|(
name|String
name|scriptTag
parameter_list|)
block|{
name|Collection
argument_list|<
name|LangSysTable
argument_list|>
name|result
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
name|ScriptTable
name|scriptTable
init|=
name|scriptList
operator|.
name|get
argument_list|(
name|scriptTag
argument_list|)
decl_stmt|;
if|if
condition|(
name|scriptTable
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|scriptTable
operator|.
name|getDefaultLangSysTable
argument_list|()
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|scriptTable
operator|.
name|getLangSysTables
argument_list|()
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|scriptTable
operator|.
name|getLangSysTables
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|scriptTable
operator|.
name|getDefaultLangSysTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Get a list of {@code FeatureRecord}s from a collection of {@code LangSysTable}s. Optionally      * filter the returned features by supplying a list of allowed feature tags in      * {@code enabledFeatures}.      *      * Note that features listed as required ({@code LangSysTable#requiredFeatureIndex}) will be      * included even if not explicitly enabled.      *      * @param langSysTables The {@code LangSysTable}s indicating {@code FeatureRecord}s to search      * for      * @param enabledFeatures An optional whitelist of feature tags ({@code null} to allow all)      * @return The indicated {@code FeatureRecord}s      */
specifier|private
name|List
argument_list|<
name|FeatureRecord
argument_list|>
name|getFeatureRecords
parameter_list|(
name|Collection
argument_list|<
name|LangSysTable
argument_list|>
name|langSysTables
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|enabledFeatures
parameter_list|)
block|{
if|if
condition|(
name|langSysTables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|List
argument_list|<
name|FeatureRecord
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|LangSysTable
name|langSysTable
range|:
name|langSysTables
control|)
block|{
name|int
name|required
init|=
name|langSysTable
operator|.
name|getRequiredFeatureIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|required
operator|!=
literal|0xffff
condition|)
comment|// if no required features = 0xFFFF
block|{
name|result
operator|.
name|add
argument_list|(
name|featureListTable
operator|.
name|getFeatureRecords
argument_list|()
index|[
name|required
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|featureIndex
range|:
name|langSysTable
operator|.
name|getFeatureIndices
argument_list|()
control|)
block|{
if|if
condition|(
name|enabledFeatures
operator|==
literal|null
operator|||
name|enabledFeatures
operator|.
name|contains
argument_list|(
name|featureListTable
operator|.
name|getFeatureRecords
argument_list|()
index|[
name|featureIndex
index|]
operator|.
name|getFeatureTag
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|featureListTable
operator|.
name|getFeatureRecords
argument_list|()
index|[
name|featureIndex
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// 'vrt2' supersedes 'vert' and they should not be used together
comment|// https://www.microsoft.com/typography/otspec/features_uz.htm
if|if
condition|(
name|containsFeature
argument_list|(
name|result
argument_list|,
literal|"vrt2"
argument_list|)
condition|)
block|{
name|removeFeature
argument_list|(
name|result
argument_list|,
literal|"vert"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enabledFeatures
operator|!=
literal|null
operator|&&
name|result
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|result
argument_list|,
operator|new
name|Comparator
argument_list|<
name|FeatureRecord
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|FeatureRecord
name|o1
parameter_list|,
name|FeatureRecord
name|o2
parameter_list|)
block|{
return|return
name|Integer
operator|.
name|compare
argument_list|(
name|enabledFeatures
operator|.
name|indexOf
argument_list|(
name|o1
operator|.
name|getFeatureTag
argument_list|()
argument_list|)
argument_list|,
name|enabledFeatures
operator|.
name|indexOf
argument_list|(
name|o2
operator|.
name|getFeatureTag
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|boolean
name|containsFeature
parameter_list|(
name|List
argument_list|<
name|FeatureRecord
argument_list|>
name|featureRecords
parameter_list|,
name|String
name|featureTag
parameter_list|)
block|{
for|for
control|(
name|FeatureRecord
name|featureRecord
range|:
name|featureRecords
control|)
block|{
if|if
condition|(
name|featureRecord
operator|.
name|getFeatureTag
argument_list|()
operator|.
name|equals
argument_list|(
name|featureTag
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|removeFeature
parameter_list|(
name|List
argument_list|<
name|FeatureRecord
argument_list|>
name|featureRecords
parameter_list|,
name|String
name|featureTag
parameter_list|)
block|{
name|Iterator
argument_list|<
name|FeatureRecord
argument_list|>
name|iter
init|=
name|featureRecords
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|getFeatureTag
argument_list|()
operator|.
name|equals
argument_list|(
name|featureTag
argument_list|)
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|int
name|applyFeature
parameter_list|(
name|FeatureRecord
name|featureRecord
parameter_list|,
name|int
name|gid
parameter_list|)
block|{
name|int
name|lookupResult
init|=
name|gid
decl_stmt|;
for|for
control|(
name|int
name|lookupListIndex
range|:
name|featureRecord
operator|.
name|getFeatureTable
argument_list|()
operator|.
name|getLookupListIndices
argument_list|()
control|)
block|{
name|LookupTable
name|lookupTable
init|=
name|lookupListTable
operator|.
name|getLookups
argument_list|()
index|[
name|lookupListIndex
index|]
decl_stmt|;
if|if
condition|(
name|lookupTable
operator|.
name|getLookupType
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping GSUB feature '"
operator|+
name|featureRecord
operator|.
name|getFeatureTag
argument_list|()
operator|+
literal|"' because it requires unsupported lookup table type "
operator|+
name|lookupTable
operator|.
name|getLookupType
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lookupResult
operator|=
name|doLookup
argument_list|(
name|lookupTable
argument_list|,
name|lookupResult
argument_list|)
expr_stmt|;
block|}
return|return
name|lookupResult
return|;
block|}
specifier|private
name|int
name|doLookup
parameter_list|(
name|LookupTable
name|lookupTable
parameter_list|,
name|int
name|gid
parameter_list|)
block|{
for|for
control|(
name|LookupSubTable
name|lookupSubtable
range|:
name|lookupTable
operator|.
name|getSubTables
argument_list|()
control|)
block|{
name|int
name|coverageIndex
init|=
name|lookupSubtable
operator|.
name|getCoverageTable
argument_list|()
operator|.
name|getCoverageIndex
argument_list|(
name|gid
argument_list|)
decl_stmt|;
if|if
condition|(
name|coverageIndex
operator|>=
literal|0
condition|)
block|{
return|return
name|lookupSubtable
operator|.
name|doSubstitution
argument_list|(
name|gid
argument_list|,
name|coverageIndex
argument_list|)
return|;
block|}
block|}
return|return
name|gid
return|;
block|}
comment|/**      * Apply glyph substitutions to the supplied gid. The applicable substitutions are determined by      * the {@code scriptTags} which indicate the language of the gid, and by the      * {@code enabledFeatures} which acts as a whitelist.      *      * To ensure that a single gid isn't mapped to multiple substitutions, subsequent invocations      * with the same gid will return the same result as the first, regardless of script or enabled      * features.      *      * @param gid GID      * @param scriptTags Script tags applicable to the gid (see {@link OpenTypeScript})      * @param enabledFeatures Whitelist of features to apply      */
specifier|public
name|int
name|getSubstitution
parameter_list|(
name|int
name|gid
parameter_list|,
name|String
index|[]
name|scriptTags
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|enabledFeatures
parameter_list|)
block|{
if|if
condition|(
name|gid
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|Integer
name|cached
init|=
name|lookupCache
operator|.
name|get
argument_list|(
name|gid
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
block|{
comment|// Because script detection for indeterminate scripts (COMMON, INHERIT, etc.) depends on context,
comment|// it is possible to return a different substitution for the same input. However we don't want that,
comment|// as we need a one-to-one mapping.
return|return
name|cached
return|;
block|}
name|String
name|scriptTag
init|=
name|selectScriptTag
argument_list|(
name|scriptTags
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|LangSysTable
argument_list|>
name|langSysTables
init|=
name|getLangSysTables
argument_list|(
name|scriptTag
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FeatureRecord
argument_list|>
name|featureRecords
init|=
name|getFeatureRecords
argument_list|(
name|langSysTables
argument_list|,
name|enabledFeatures
argument_list|)
decl_stmt|;
name|int
name|sgid
init|=
name|gid
decl_stmt|;
for|for
control|(
name|FeatureRecord
name|featureRecord
range|:
name|featureRecords
control|)
block|{
name|sgid
operator|=
name|applyFeature
argument_list|(
name|featureRecord
argument_list|,
name|sgid
argument_list|)
expr_stmt|;
block|}
name|lookupCache
operator|.
name|put
argument_list|(
name|gid
argument_list|,
name|sgid
argument_list|)
expr_stmt|;
name|reverseLookup
operator|.
name|put
argument_list|(
name|sgid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
return|return
name|sgid
return|;
block|}
comment|/**      * For a substitute-gid (obtained from {@link #getSubstitution(int, String[], List)}), retrieve      * the original gid.      *      * Only gids previously substituted by this instance can be un-substituted. If you are trying to      * unsubstitute before you substitute, something is wrong.      *      * @param sgid Substitute GID      */
specifier|public
name|int
name|getUnsubstitution
parameter_list|(
name|int
name|sgid
parameter_list|)
block|{
name|Integer
name|gid
init|=
name|reverseLookup
operator|.
name|get
argument_list|(
name|sgid
argument_list|)
decl_stmt|;
if|if
condition|(
name|gid
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Trying to un-substitute a never-before-seen gid: "
operator|+
name|sgid
argument_list|)
expr_stmt|;
return|return
name|sgid
return|;
block|}
return|return
name|gid
return|;
block|}
specifier|public
name|GsubData
name|getGsubData
parameter_list|()
block|{
return|return
name|gsubData
return|;
block|}
specifier|private
name|RangeRecord
name|readRangeRecord
parameter_list|(
name|TTFDataStream
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|startGlyphID
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|endGlyphID
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|startCoverageIndex
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
return|return
operator|new
name|RangeRecord
argument_list|(
name|startGlyphID
argument_list|,
name|endGlyphID
argument_list|,
name|startCoverageIndex
argument_list|)
return|;
block|}
block|}
end_class

end_unit

