begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_comment
comment|/**  * A glyph substitution 'GSUB' table in a TrueType or OpenType font.  *  * @author Aaron Madlon-Kay  */
end_comment

begin_class
specifier|public
class|class
name|GlyphSubstitutionTable
extends|extends
name|TTFTable
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|GlyphSubstitutionTable
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|TAG
init|=
literal|"GSUB"
decl_stmt|;
specifier|private
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ScriptTable
argument_list|>
name|scriptList
decl_stmt|;
comment|// featureList and lookupList are not maps because we need to index into them
specifier|private
name|FeatureRecord
index|[]
name|featureList
decl_stmt|;
specifier|private
name|LookupTable
index|[]
name|lookupList
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|lookupCache
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|reverseLookup
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|String
name|lastUsedSupportedScript
decl_stmt|;
name|GlyphSubstitutionTable
parameter_list|(
name|TrueTypeFont
name|font
parameter_list|)
block|{
name|super
argument_list|(
name|font
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"squid:S1854"
block|}
argument_list|)
name|void
name|read
parameter_list|(
name|TrueTypeFont
name|ttf
parameter_list|,
name|TTFDataStream
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|start
init|=
name|data
operator|.
name|getCurrentPosition
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unused"
block|}
argument_list|)
name|int
name|majorVersion
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|minorVersion
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|scriptListOffset
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|featureListOffset
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|lookupListOffset
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unused"
block|}
argument_list|)
name|long
name|featureVariationsOffset
init|=
operator|-
literal|1L
decl_stmt|;
if|if
condition|(
name|minorVersion
operator|==
literal|1L
condition|)
block|{
name|featureVariationsOffset
operator|=
name|data
operator|.
name|readUnsignedInt
argument_list|()
expr_stmt|;
block|}
name|scriptList
operator|=
name|readScriptList
argument_list|(
name|data
argument_list|,
name|start
operator|+
name|scriptListOffset
argument_list|)
expr_stmt|;
name|featureList
operator|=
name|readFeatureList
argument_list|(
name|data
argument_list|,
name|start
operator|+
name|featureListOffset
argument_list|)
expr_stmt|;
name|lookupList
operator|=
name|readLookupList
argument_list|(
name|data
argument_list|,
name|start
operator|+
name|lookupListOffset
argument_list|)
expr_stmt|;
block|}
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ScriptTable
argument_list|>
name|readScriptList
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|scriptCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|ScriptRecord
index|[]
name|scriptRecords
init|=
operator|new
name|ScriptRecord
index|[
name|scriptCount
index|]
decl_stmt|;
name|int
index|[]
name|scriptOffsets
init|=
operator|new
name|int
index|[
name|scriptCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scriptCount
condition|;
name|i
operator|++
control|)
block|{
name|ScriptRecord
name|scriptRecord
init|=
operator|new
name|ScriptRecord
argument_list|()
decl_stmt|;
name|scriptRecord
operator|.
name|scriptTag
operator|=
name|data
operator|.
name|readString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|scriptOffsets
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|scriptRecords
index|[
name|i
index|]
operator|=
name|scriptRecord
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scriptCount
condition|;
name|i
operator|++
control|)
block|{
name|scriptRecords
index|[
name|i
index|]
operator|.
name|scriptTable
operator|=
name|readScriptTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|scriptOffsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ScriptTable
argument_list|>
name|resultScriptList
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|scriptCount
argument_list|)
decl_stmt|;
for|for
control|(
name|ScriptRecord
name|scriptRecord
range|:
name|scriptRecords
control|)
block|{
name|resultScriptList
operator|.
name|put
argument_list|(
name|scriptRecord
operator|.
name|scriptTag
argument_list|,
name|scriptRecord
operator|.
name|scriptTable
argument_list|)
expr_stmt|;
block|}
return|return
name|resultScriptList
return|;
block|}
name|ScriptTable
name|readScriptTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|ScriptTable
name|scriptTable
init|=
operator|new
name|ScriptTable
argument_list|()
decl_stmt|;
name|int
name|defaultLangSys
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|langSysCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|LangSysRecord
index|[]
name|langSysRecords
init|=
operator|new
name|LangSysRecord
index|[
name|langSysCount
index|]
decl_stmt|;
name|int
index|[]
name|langSysOffsets
init|=
operator|new
name|int
index|[
name|langSysCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|langSysCount
condition|;
name|i
operator|++
control|)
block|{
name|LangSysRecord
name|langSysRecord
init|=
operator|new
name|LangSysRecord
argument_list|()
decl_stmt|;
name|langSysRecord
operator|.
name|langSysTag
operator|=
name|data
operator|.
name|readString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|langSysOffsets
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|langSysRecords
index|[
name|i
index|]
operator|=
name|langSysRecord
expr_stmt|;
block|}
if|if
condition|(
name|defaultLangSys
operator|!=
literal|0
condition|)
block|{
name|scriptTable
operator|.
name|defaultLangSysTable
operator|=
name|readLangSysTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|defaultLangSys
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|langSysCount
condition|;
name|i
operator|++
control|)
block|{
name|langSysRecords
index|[
name|i
index|]
operator|.
name|langSysTable
operator|=
name|readLangSysTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|langSysOffsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|scriptTable
operator|.
name|langSysTables
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|(
name|langSysCount
argument_list|)
expr_stmt|;
for|for
control|(
name|LangSysRecord
name|langSysRecord
range|:
name|langSysRecords
control|)
block|{
name|scriptTable
operator|.
name|langSysTables
operator|.
name|put
argument_list|(
name|langSysRecord
operator|.
name|langSysTag
argument_list|,
name|langSysRecord
operator|.
name|langSysTable
argument_list|)
expr_stmt|;
block|}
return|return
name|scriptTable
return|;
block|}
name|LangSysTable
name|readLangSysTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|LangSysTable
name|langSysTable
init|=
operator|new
name|LangSysTable
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unused"
block|,
literal|"squid:S1854"
block|}
argument_list|)
name|int
name|lookupOrder
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|langSysTable
operator|.
name|requiredFeatureIndex
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|int
name|featureIndexCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|langSysTable
operator|.
name|featureIndices
operator|=
operator|new
name|int
index|[
name|featureIndexCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|featureIndexCount
condition|;
name|i
operator|++
control|)
block|{
name|langSysTable
operator|.
name|featureIndices
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
return|return
name|langSysTable
return|;
block|}
name|FeatureRecord
index|[]
name|readFeatureList
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|featureCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|FeatureRecord
index|[]
name|featureRecords
init|=
operator|new
name|FeatureRecord
index|[
name|featureCount
index|]
decl_stmt|;
name|int
index|[]
name|featureOffsets
init|=
operator|new
name|int
index|[
name|featureCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|featureCount
condition|;
name|i
operator|++
control|)
block|{
name|FeatureRecord
name|featureRecord
init|=
operator|new
name|FeatureRecord
argument_list|()
decl_stmt|;
name|featureRecord
operator|.
name|featureTag
operator|=
name|data
operator|.
name|readString
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|featureOffsets
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|featureRecords
index|[
name|i
index|]
operator|=
name|featureRecord
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|featureCount
condition|;
name|i
operator|++
control|)
block|{
name|featureRecords
index|[
name|i
index|]
operator|.
name|featureTable
operator|=
name|readFeatureTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|featureOffsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|featureRecords
return|;
block|}
name|FeatureTable
name|readFeatureTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|FeatureTable
name|featureTable
init|=
operator|new
name|FeatureTable
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unused"
block|,
literal|"squid:S1854"
block|}
argument_list|)
name|int
name|featureParams
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|lookupIndexCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|featureTable
operator|.
name|lookupListIndices
operator|=
operator|new
name|int
index|[
name|lookupIndexCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lookupIndexCount
condition|;
name|i
operator|++
control|)
block|{
name|featureTable
operator|.
name|lookupListIndices
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
return|return
name|featureTable
return|;
block|}
name|LookupTable
index|[]
name|readLookupList
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|lookupCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
index|[]
name|lookups
init|=
operator|new
name|int
index|[
name|lookupCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lookupCount
condition|;
name|i
operator|++
control|)
block|{
name|lookups
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
name|LookupTable
index|[]
name|lookupTables
init|=
operator|new
name|LookupTable
index|[
name|lookupCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lookupCount
condition|;
name|i
operator|++
control|)
block|{
name|lookupTables
index|[
name|i
index|]
operator|=
name|readLookupTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|lookups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|lookupTables
return|;
block|}
name|LookupTable
name|readLookupTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|LookupTable
name|lookupTable
init|=
operator|new
name|LookupTable
argument_list|()
decl_stmt|;
name|lookupTable
operator|.
name|lookupType
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|lookupTable
operator|.
name|lookupFlag
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|int
name|subTableCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
index|[]
name|subTableOffets
init|=
operator|new
name|int
index|[
name|subTableCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subTableCount
condition|;
name|i
operator|++
control|)
block|{
name|subTableOffets
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lookupTable
operator|.
name|lookupFlag
operator|&
literal|0x0010
operator|)
operator|!=
literal|0
condition|)
block|{
name|lookupTable
operator|.
name|markFilteringSet
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
name|lookupTable
operator|.
name|subTables
operator|=
operator|new
name|LookupSubTable
index|[
name|subTableCount
index|]
expr_stmt|;
switch|switch
condition|(
name|lookupTable
operator|.
name|lookupType
condition|)
block|{
case|case
literal|1
case|:
comment|// Single
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subTableCount
condition|;
name|i
operator|++
control|)
block|{
name|lookupTable
operator|.
name|subTables
index|[
name|i
index|]
operator|=
name|readLookupSubTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|subTableOffets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// Other lookup types are not supported
name|LOG
operator|.
name|debug
argument_list|(
literal|"Type "
operator|+
name|lookupTable
operator|.
name|lookupType
operator|+
literal|" GSUB lookup table is not supported and will be ignored"
argument_list|)
expr_stmt|;
block|}
return|return
name|lookupTable
return|;
block|}
name|LookupSubTable
name|readLookupSubTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|substFormat
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|substFormat
condition|)
block|{
case|case
literal|1
case|:
block|{
name|LookupTypeSingleSubstFormat1
name|lookupSubTable
init|=
operator|new
name|LookupTypeSingleSubstFormat1
argument_list|()
decl_stmt|;
name|lookupSubTable
operator|.
name|substFormat
operator|=
name|substFormat
expr_stmt|;
name|int
name|coverageOffset
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|lookupSubTable
operator|.
name|deltaGlyphID
operator|=
name|data
operator|.
name|readSignedShort
argument_list|()
expr_stmt|;
name|lookupSubTable
operator|.
name|coverageTable
operator|=
name|readCoverageTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|coverageOffset
argument_list|)
expr_stmt|;
return|return
name|lookupSubTable
return|;
block|}
case|case
literal|2
case|:
block|{
name|LookupTypeSingleSubstFormat2
name|lookupSubTable
init|=
operator|new
name|LookupTypeSingleSubstFormat2
argument_list|()
decl_stmt|;
name|lookupSubTable
operator|.
name|substFormat
operator|=
name|substFormat
expr_stmt|;
name|int
name|coverageOffset
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|int
name|glyphCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|lookupSubTable
operator|.
name|substituteGlyphIDs
operator|=
operator|new
name|int
index|[
name|glyphCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|glyphCount
condition|;
name|i
operator|++
control|)
block|{
name|lookupSubTable
operator|.
name|substituteGlyphIDs
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
name|lookupSubTable
operator|.
name|coverageTable
operator|=
name|readCoverageTable
argument_list|(
name|data
argument_list|,
name|offset
operator|+
name|coverageOffset
argument_list|)
expr_stmt|;
return|return
name|lookupSubTable
return|;
block|}
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown substFormat: "
operator|+
name|substFormat
argument_list|)
throw|;
block|}
block|}
name|CoverageTable
name|readCoverageTable
parameter_list|(
name|TTFDataStream
name|data
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|data
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|int
name|coverageFormat
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|coverageFormat
condition|)
block|{
case|case
literal|1
case|:
block|{
name|CoverageTableFormat1
name|coverageTable
init|=
operator|new
name|CoverageTableFormat1
argument_list|()
decl_stmt|;
name|coverageTable
operator|.
name|coverageFormat
operator|=
name|coverageFormat
expr_stmt|;
name|int
name|glyphCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|coverageTable
operator|.
name|glyphArray
operator|=
operator|new
name|int
index|[
name|glyphCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|glyphCount
condition|;
name|i
operator|++
control|)
block|{
name|coverageTable
operator|.
name|glyphArray
index|[
name|i
index|]
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
block|}
return|return
name|coverageTable
return|;
block|}
case|case
literal|2
case|:
block|{
name|CoverageTableFormat2
name|coverageTable
init|=
operator|new
name|CoverageTableFormat2
argument_list|()
decl_stmt|;
name|coverageTable
operator|.
name|coverageFormat
operator|=
name|coverageFormat
expr_stmt|;
name|int
name|rangeCount
init|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|coverageTable
operator|.
name|rangeRecords
operator|=
operator|new
name|RangeRecord
index|[
name|rangeCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rangeCount
condition|;
name|i
operator|++
control|)
block|{
name|coverageTable
operator|.
name|rangeRecords
index|[
name|i
index|]
operator|=
name|readRangeRecord
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|coverageTable
return|;
block|}
default|default:
comment|// Should not happen (the spec indicates only format 1 and format 2)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown coverage format: "
operator|+
name|coverageFormat
argument_list|)
throw|;
block|}
block|}
comment|/**      * Choose from one of the supplied OpenType script tags, depending on what the font supports and      * potentially on context.      *      * @param tags      * @return The best OpenType script tag      */
specifier|private
name|String
name|selectScriptTag
parameter_list|(
name|String
index|[]
name|tags
parameter_list|)
block|{
if|if
condition|(
name|tags
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|String
name|tag
init|=
name|tags
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|OpenTypeScript
operator|.
name|INHERITED
operator|.
name|equals
argument_list|(
name|tag
argument_list|)
operator|||
operator|(
name|OpenTypeScript
operator|.
name|TAG_DEFAULT
operator|.
name|equals
argument_list|(
name|tag
argument_list|)
operator|&&
operator|!
name|scriptList
operator|.
name|containsKey
argument_list|(
name|tag
argument_list|)
operator|)
condition|)
block|{
comment|// We don't know what script this should be.
if|if
condition|(
name|lastUsedSupportedScript
operator|==
literal|null
condition|)
block|{
comment|// We have no past context and (currently) no way to get future context so we guess.
name|lastUsedSupportedScript
operator|=
name|scriptList
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
comment|// else use past context
return|return
name|lastUsedSupportedScript
return|;
block|}
block|}
for|for
control|(
name|String
name|tag
range|:
name|tags
control|)
block|{
if|if
condition|(
name|scriptList
operator|.
name|containsKey
argument_list|(
name|tag
argument_list|)
condition|)
block|{
comment|// Use the first recognized tag. We assume a single font only recognizes one version ("ver. 2")
comment|// of a single script, or if it recognizes more than one that it prefers the latest one.
name|lastUsedSupportedScript
operator|=
name|tag
expr_stmt|;
return|return
name|lastUsedSupportedScript
return|;
block|}
block|}
return|return
name|tags
index|[
literal|0
index|]
return|;
block|}
specifier|private
name|Collection
argument_list|<
name|LangSysTable
argument_list|>
name|getLangSysTables
parameter_list|(
name|String
name|scriptTag
parameter_list|)
block|{
name|Collection
argument_list|<
name|LangSysTable
argument_list|>
name|result
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
name|ScriptTable
name|scriptTable
init|=
name|scriptList
operator|.
name|get
argument_list|(
name|scriptTag
argument_list|)
decl_stmt|;
if|if
condition|(
name|scriptTable
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|scriptTable
operator|.
name|defaultLangSysTable
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|scriptTable
operator|.
name|langSysTables
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|scriptTable
operator|.
name|langSysTables
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|scriptTable
operator|.
name|defaultLangSysTable
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Get a list of {@code FeatureRecord}s from a collection of {@code LangSysTable}s. Optionally      * filter the returned features by supplying a list of allowed feature tags in      * {@code enabledFeatures}.      *      * Note that features listed as required ({@code LangSysTable#requiredFeatureIndex}) will be      * included even if not explicitly enabled.      *      * @param langSysTables The {@code LangSysTable}s indicating {@code FeatureRecord}s to search      * for      * @param enabledFeatures An optional whitelist of feature tags ({@code null} to allow all)      * @return The indicated {@code FeatureRecord}s      */
specifier|private
name|List
argument_list|<
name|FeatureRecord
argument_list|>
name|getFeatureRecords
parameter_list|(
name|Collection
argument_list|<
name|LangSysTable
argument_list|>
name|langSysTables
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|enabledFeatures
parameter_list|)
block|{
if|if
condition|(
name|langSysTables
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|List
argument_list|<
name|FeatureRecord
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|LangSysTable
name|langSysTable
range|:
name|langSysTables
control|)
block|{
name|int
name|required
init|=
name|langSysTable
operator|.
name|requiredFeatureIndex
decl_stmt|;
if|if
condition|(
name|required
operator|!=
literal|0xffff
condition|)
comment|// if no required features = 0xFFFF
block|{
name|result
operator|.
name|add
argument_list|(
name|featureList
index|[
name|required
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|featureIndex
range|:
name|langSysTable
operator|.
name|featureIndices
control|)
block|{
if|if
condition|(
name|enabledFeatures
operator|==
literal|null
operator|||
name|enabledFeatures
operator|.
name|contains
argument_list|(
name|featureList
index|[
name|featureIndex
index|]
operator|.
name|featureTag
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|featureList
index|[
name|featureIndex
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// 'vrt2' supersedes 'vert' and they should not be used together
comment|// https://www.microsoft.com/typography/otspec/features_uz.htm
if|if
condition|(
name|containsFeature
argument_list|(
name|result
argument_list|,
literal|"vrt2"
argument_list|)
condition|)
block|{
name|removeFeature
argument_list|(
name|result
argument_list|,
literal|"vert"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enabledFeatures
operator|!=
literal|null
operator|&&
name|result
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|result
argument_list|,
operator|new
name|Comparator
argument_list|<
name|FeatureRecord
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|FeatureRecord
name|o1
parameter_list|,
name|FeatureRecord
name|o2
parameter_list|)
block|{
return|return
name|Integer
operator|.
name|compare
argument_list|(
name|enabledFeatures
operator|.
name|indexOf
argument_list|(
name|o1
operator|.
name|featureTag
argument_list|)
argument_list|,
name|enabledFeatures
operator|.
name|indexOf
argument_list|(
name|o2
operator|.
name|featureTag
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|boolean
name|containsFeature
parameter_list|(
name|List
argument_list|<
name|FeatureRecord
argument_list|>
name|featureRecords
parameter_list|,
name|String
name|featureTag
parameter_list|)
block|{
for|for
control|(
name|FeatureRecord
name|featureRecord
range|:
name|featureRecords
control|)
block|{
if|if
condition|(
name|featureRecord
operator|.
name|featureTag
operator|.
name|equals
argument_list|(
name|featureTag
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|removeFeature
parameter_list|(
name|List
argument_list|<
name|FeatureRecord
argument_list|>
name|featureRecords
parameter_list|,
name|String
name|featureTag
parameter_list|)
block|{
name|Iterator
argument_list|<
name|FeatureRecord
argument_list|>
name|iter
init|=
name|featureRecords
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|featureTag
operator|.
name|equals
argument_list|(
name|featureTag
argument_list|)
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|int
name|applyFeature
parameter_list|(
name|FeatureRecord
name|featureRecord
parameter_list|,
name|int
name|gid
parameter_list|)
block|{
name|int
name|lookupResult
init|=
name|gid
decl_stmt|;
for|for
control|(
name|int
name|lookupListIndex
range|:
name|featureRecord
operator|.
name|featureTable
operator|.
name|lookupListIndices
control|)
block|{
name|LookupTable
name|lookupTable
init|=
name|lookupList
index|[
name|lookupListIndex
index|]
decl_stmt|;
if|if
condition|(
name|lookupTable
operator|.
name|lookupType
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping GSUB feature '"
operator|+
name|featureRecord
operator|.
name|featureTag
operator|+
literal|"' because it requires unsupported lookup table type "
operator|+
name|lookupTable
operator|.
name|lookupType
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lookupResult
operator|=
name|doLookup
argument_list|(
name|lookupTable
argument_list|,
name|gid
argument_list|)
expr_stmt|;
block|}
return|return
name|lookupResult
return|;
block|}
specifier|private
name|int
name|doLookup
parameter_list|(
name|LookupTable
name|lookupTable
parameter_list|,
name|int
name|gid
parameter_list|)
block|{
for|for
control|(
name|LookupSubTable
name|lookupSubtable
range|:
name|lookupTable
operator|.
name|subTables
control|)
block|{
name|int
name|coverageIndex
init|=
name|lookupSubtable
operator|.
name|coverageTable
operator|.
name|getCoverageIndex
argument_list|(
name|gid
argument_list|)
decl_stmt|;
if|if
condition|(
name|coverageIndex
operator|>=
literal|0
condition|)
block|{
return|return
name|lookupSubtable
operator|.
name|doSubstitution
argument_list|(
name|gid
argument_list|,
name|coverageIndex
argument_list|)
return|;
block|}
block|}
return|return
name|gid
return|;
block|}
comment|/**      * Apply glyph substitutions to the supplied gid. The applicable substitutions are determined by      * the {@code scriptTags} which indicate the language of the gid, and by the      * {@code enabledFeatures} which acts as a whitelist.      *      * To ensure that a single gid isn't mapped to multiple substitutions, subsequent invocations      * with the same gid will return the same result as the first, regardless of script or enabled      * features.      *      * @param gid GID      * @param scriptTags Script tags applicable to the gid (see {@link OpenTypeScript})      * @param enabledFeatures Whitelist of features to apply      */
specifier|public
name|int
name|getSubstitution
parameter_list|(
name|int
name|gid
parameter_list|,
name|String
index|[]
name|scriptTags
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|enabledFeatures
parameter_list|)
block|{
if|if
condition|(
name|gid
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|Integer
name|cached
init|=
name|lookupCache
operator|.
name|get
argument_list|(
name|gid
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|!=
literal|null
condition|)
block|{
comment|// Because script detection for indeterminate scripts (COMMON, INHERIT, etc.) depends on context,
comment|// it is possible to return a different substitution for the same input. However we don't want that,
comment|// as we need a one-to-one mapping.
return|return
name|cached
return|;
block|}
name|String
name|scriptTag
init|=
name|selectScriptTag
argument_list|(
name|scriptTags
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|LangSysTable
argument_list|>
name|langSysTables
init|=
name|getLangSysTables
argument_list|(
name|scriptTag
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FeatureRecord
argument_list|>
name|featureRecords
init|=
name|getFeatureRecords
argument_list|(
name|langSysTables
argument_list|,
name|enabledFeatures
argument_list|)
decl_stmt|;
name|int
name|sgid
init|=
name|gid
decl_stmt|;
for|for
control|(
name|FeatureRecord
name|featureRecord
range|:
name|featureRecords
control|)
block|{
name|sgid
operator|=
name|applyFeature
argument_list|(
name|featureRecord
argument_list|,
name|sgid
argument_list|)
expr_stmt|;
block|}
name|lookupCache
operator|.
name|put
argument_list|(
name|gid
argument_list|,
name|sgid
argument_list|)
expr_stmt|;
name|reverseLookup
operator|.
name|put
argument_list|(
name|sgid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
return|return
name|sgid
return|;
block|}
comment|/**      * For a substitute-gid (obtained from {@link #getSubstitution(int, String[], List)}), retrieve      * the original gid.      *      * Only gids previously substituted by this instance can be un-substituted. If you are trying to      * unsubstitute before you substitute, something is wrong.      *      * @param sgid Substitute GID      */
specifier|public
name|int
name|getUnsubstitution
parameter_list|(
name|int
name|sgid
parameter_list|)
block|{
name|Integer
name|gid
init|=
name|reverseLookup
operator|.
name|get
argument_list|(
name|sgid
argument_list|)
decl_stmt|;
if|if
condition|(
name|gid
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Trying to un-substitute a never-before-seen gid: "
operator|+
name|sgid
argument_list|)
expr_stmt|;
return|return
name|sgid
return|;
block|}
return|return
name|gid
return|;
block|}
name|RangeRecord
name|readRangeRecord
parameter_list|(
name|TTFDataStream
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|RangeRecord
name|rangeRecord
init|=
operator|new
name|RangeRecord
argument_list|()
decl_stmt|;
name|rangeRecord
operator|.
name|startGlyphID
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|rangeRecord
operator|.
name|endGlyphID
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|rangeRecord
operator|.
name|startCoverageIndex
operator|=
name|data
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
return|return
name|rangeRecord
return|;
block|}
specifier|static
class|class
name|ScriptRecord
block|{
comment|// https://www.microsoft.com/typography/otspec/scripttags.htm
name|String
name|scriptTag
decl_stmt|;
name|ScriptTable
name|scriptTable
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"ScriptRecord[scriptTag=%s]"
argument_list|,
name|scriptTag
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|ScriptTable
block|{
name|LangSysTable
name|defaultLangSysTable
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|LangSysTable
argument_list|>
name|langSysTables
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"ScriptTable[hasDefault=%s,langSysRecordsCount=%d]"
argument_list|,
name|defaultLangSysTable
operator|!=
literal|null
argument_list|,
name|langSysTables
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|LangSysRecord
block|{
comment|// https://www.microsoft.com/typography/otspec/languagetags.htm
name|String
name|langSysTag
decl_stmt|;
name|LangSysTable
name|langSysTable
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"LangSysRecord[langSysTag=%s]"
argument_list|,
name|langSysTag
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|LangSysTable
block|{
name|int
name|requiredFeatureIndex
decl_stmt|;
name|int
index|[]
name|featureIndices
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"LangSysTable[requiredFeatureIndex=%d]"
argument_list|,
name|requiredFeatureIndex
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|FeatureRecord
block|{
name|String
name|featureTag
decl_stmt|;
name|FeatureTable
name|featureTable
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"FeatureRecord[featureTag=%s]"
argument_list|,
name|featureTag
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|FeatureTable
block|{
name|int
index|[]
name|lookupListIndices
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"FeatureTable[lookupListIndiciesCount=%d]"
argument_list|,
name|lookupListIndices
operator|.
name|length
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|LookupTable
block|{
name|int
name|lookupType
decl_stmt|;
name|int
name|lookupFlag
decl_stmt|;
name|int
name|markFilteringSet
decl_stmt|;
name|LookupSubTable
index|[]
name|subTables
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"LookupTable[lookupType=%d,lookupFlag=%d,markFilteringSet=%d]"
argument_list|,
name|lookupType
argument_list|,
name|lookupFlag
argument_list|,
name|markFilteringSet
argument_list|)
return|;
block|}
block|}
specifier|static
specifier|abstract
class|class
name|LookupSubTable
block|{
name|int
name|substFormat
decl_stmt|;
name|CoverageTable
name|coverageTable
decl_stmt|;
specifier|abstract
name|int
name|doSubstitution
parameter_list|(
name|int
name|gid
parameter_list|,
name|int
name|coverageIndex
parameter_list|)
function_decl|;
block|}
specifier|static
class|class
name|LookupTypeSingleSubstFormat1
extends|extends
name|LookupSubTable
block|{
name|short
name|deltaGlyphID
decl_stmt|;
annotation|@
name|Override
name|int
name|doSubstitution
parameter_list|(
name|int
name|gid
parameter_list|,
name|int
name|coverageIndex
parameter_list|)
block|{
return|return
name|coverageIndex
operator|<
literal|0
condition|?
name|gid
else|:
name|gid
operator|+
name|deltaGlyphID
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"LookupTypeSingleSubstFormat1[substFormat=%d,deltaGlyphID=%d]"
argument_list|,
name|substFormat
argument_list|,
name|deltaGlyphID
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|LookupTypeSingleSubstFormat2
extends|extends
name|LookupSubTable
block|{
name|int
index|[]
name|substituteGlyphIDs
decl_stmt|;
annotation|@
name|Override
name|int
name|doSubstitution
parameter_list|(
name|int
name|gid
parameter_list|,
name|int
name|coverageIndex
parameter_list|)
block|{
return|return
name|coverageIndex
operator|<
literal|0
condition|?
name|gid
else|:
name|substituteGlyphIDs
index|[
name|coverageIndex
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"LookupTypeSingleSubstFormat2[substFormat=%d,substituteGlyphIDs=%s]"
argument_list|,
name|substFormat
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|substituteGlyphIDs
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|static
specifier|abstract
class|class
name|CoverageTable
block|{
name|int
name|coverageFormat
decl_stmt|;
specifier|abstract
name|int
name|getCoverageIndex
parameter_list|(
name|int
name|gid
parameter_list|)
function_decl|;
block|}
specifier|static
class|class
name|CoverageTableFormat1
extends|extends
name|CoverageTable
block|{
name|int
index|[]
name|glyphArray
decl_stmt|;
annotation|@
name|Override
name|int
name|getCoverageIndex
parameter_list|(
name|int
name|gid
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|glyphArray
argument_list|,
name|gid
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"CoverageTableFormat1[coverageFormat=%d,glyphArray=%s]"
argument_list|,
name|coverageFormat
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|glyphArray
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|CoverageTableFormat2
extends|extends
name|CoverageTable
block|{
name|RangeRecord
index|[]
name|rangeRecords
decl_stmt|;
annotation|@
name|Override
name|int
name|getCoverageIndex
parameter_list|(
name|int
name|gid
parameter_list|)
block|{
for|for
control|(
name|RangeRecord
name|rangeRecord
range|:
name|rangeRecords
control|)
block|{
if|if
condition|(
name|rangeRecord
operator|.
name|startGlyphID
operator|<=
name|gid
operator|&&
name|gid
operator|<=
name|rangeRecord
operator|.
name|endGlyphID
condition|)
block|{
return|return
name|rangeRecord
operator|.
name|startCoverageIndex
operator|+
name|gid
operator|-
name|rangeRecord
operator|.
name|startGlyphID
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"CoverageTableFormat2[coverageFormat=%d]"
argument_list|,
name|coverageFormat
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|RangeRecord
block|{
name|int
name|startGlyphID
decl_stmt|;
name|int
name|endGlyphID
decl_stmt|;
name|int
name|startCoverageIndex
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"RangeRecord[startGlyphID=%d,endGlyphID=%d,startCoverageIndex=%d]"
argument_list|,
name|startGlyphID
argument_list|,
name|endGlyphID
argument_list|,
name|startCoverageIndex
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

