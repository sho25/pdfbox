begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*     Licensed to the Apache Software Foundation (ASF) under one or more    contributor license agreements.  See the NOTICE file distributed with    this work for additional information regarding copyright ownership.    The ASF licenses this file to You under the Apache License, Version 2.0    (the "License"); you may not use this file except in compliance with    the License.  You may obtain a copy of the License at         http://www.apache.org/licenses/LICENSE-2.0     Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an "AS IS" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.   */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|GeneralPath
import|;
end_import

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|geom
operator|.
name|Point2D
import|;
end_import

begin_comment
comment|/**  * This class provides a glyph to GeneralPath conversion.  *   * This class is based on code from Apache Batik a subproject of Apache XMLGraphics.  * see http://xmlgraphics.apache.org/batik/ for further details.  */
end_comment

begin_class
specifier|public
class|class
name|Glyph2D
block|{
specifier|private
name|short
name|leftSideBearing
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|advanceWidth
init|=
literal|0
decl_stmt|;
specifier|private
name|Point
index|[]
name|points
decl_stmt|;
specifier|private
name|GeneralPath
name|glyphPath
decl_stmt|;
comment|/**      * Constructor.      *       * @param gd the glyph description      * @param lsb leftSideBearing      * @param advance advanceWidth      */
specifier|public
name|Glyph2D
parameter_list|(
name|GlyphDescription
name|gd
parameter_list|,
name|short
name|lsb
parameter_list|,
name|int
name|advance
parameter_list|)
block|{
name|leftSideBearing
operator|=
name|lsb
expr_stmt|;
name|advanceWidth
operator|=
name|advance
expr_stmt|;
name|describe
argument_list|(
name|gd
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the advanceWidth value.      *       * @return the advanceWidth      */
specifier|public
name|int
name|getAdvanceWidth
parameter_list|()
block|{
return|return
name|advanceWidth
return|;
block|}
comment|/**      * Returns the leftSideBearing value.      *       * @return the leftSideBearing      */
specifier|public
name|short
name|getLeftSideBearing
parameter_list|()
block|{
return|return
name|leftSideBearing
return|;
block|}
comment|/**      * Set the points of a glyph from the GlyphDescription.      */
specifier|private
name|void
name|describe
parameter_list|(
name|GlyphDescription
name|gd
parameter_list|)
block|{
name|int
name|endPtIndex
init|=
literal|0
decl_stmt|;
name|points
operator|=
operator|new
name|Point
index|[
name|gd
operator|.
name|getPointCount
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gd
operator|.
name|getPointCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|endPt
init|=
name|gd
operator|.
name|getEndPtOfContours
argument_list|(
name|endPtIndex
argument_list|)
operator|==
name|i
decl_stmt|;
if|if
condition|(
name|endPt
condition|)
block|{
name|endPtIndex
operator|++
expr_stmt|;
block|}
name|points
index|[
name|i
index|]
operator|=
operator|new
name|Point
argument_list|(
name|gd
operator|.
name|getXCoordinate
argument_list|(
name|i
argument_list|)
argument_list|,
name|gd
operator|.
name|getYCoordinate
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|gd
operator|.
name|getFlags
argument_list|(
name|i
argument_list|)
operator|&
name|GlyfDescript
operator|.
name|ON_CURVE
operator|)
operator|!=
literal|0
argument_list|,
name|endPt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the path describing the glyph.      *       * @return the GeneralPath of the glyph      */
specifier|public
name|GeneralPath
name|getPath
parameter_list|()
block|{
if|if
condition|(
name|glyphPath
operator|==
literal|null
condition|)
block|{
name|glyphPath
operator|=
name|calculatePath
argument_list|()
expr_stmt|;
block|}
return|return
name|glyphPath
return|;
block|}
specifier|private
name|GeneralPath
name|calculatePath
parameter_list|()
block|{
name|GeneralPath
name|path
init|=
operator|new
name|GeneralPath
argument_list|()
decl_stmt|;
name|int
name|numberOfPoints
init|=
name|points
operator|.
name|length
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|boolean
name|endOfContour
init|=
literal|true
decl_stmt|;
name|Point
name|startingPoint
init|=
literal|null
decl_stmt|;
name|Point
name|lastCtrlPoint
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|numberOfPoints
condition|)
block|{
name|Point
name|point
init|=
name|points
index|[
name|i
operator|%
name|numberOfPoints
index|]
decl_stmt|;
name|Point
name|nextPoint1
init|=
name|points
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|numberOfPoints
index|]
decl_stmt|;
name|Point
name|nextPoint2
init|=
name|points
index|[
operator|(
name|i
operator|+
literal|2
operator|)
operator|%
name|numberOfPoints
index|]
decl_stmt|;
comment|// new contour
if|if
condition|(
name|endOfContour
condition|)
block|{
comment|// skip endOfContour points
if|if
condition|(
name|point
operator|.
name|endOfContour
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|// move to the starting point
name|path
operator|.
name|moveTo
argument_list|(
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|)
expr_stmt|;
name|endOfContour
operator|=
literal|false
expr_stmt|;
name|startingPoint
operator|=
name|point
expr_stmt|;
block|}
comment|// lineTo
if|if
condition|(
name|point
operator|.
name|onCurve
operator|&&
name|nextPoint1
operator|.
name|onCurve
condition|)
block|{
name|path
operator|.
name|lineTo
argument_list|(
name|nextPoint1
operator|.
name|x
argument_list|,
name|nextPoint1
operator|.
name|y
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|point
operator|.
name|endOfContour
operator|||
name|nextPoint1
operator|.
name|endOfContour
condition|)
block|{
name|endOfContour
operator|=
literal|true
expr_stmt|;
name|path
operator|.
name|closePath
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
comment|// quadratic bezier
if|if
condition|(
name|point
operator|.
name|onCurve
operator|&&
operator|!
name|nextPoint1
operator|.
name|onCurve
operator|&&
name|nextPoint2
operator|.
name|onCurve
condition|)
block|{
if|if
condition|(
name|nextPoint1
operator|.
name|endOfContour
condition|)
block|{
comment|// use the starting point as end point
name|path
operator|.
name|quadTo
argument_list|(
name|nextPoint1
operator|.
name|x
argument_list|,
name|nextPoint1
operator|.
name|y
argument_list|,
name|startingPoint
operator|.
name|x
argument_list|,
name|startingPoint
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path
operator|.
name|quadTo
argument_list|(
name|nextPoint1
operator|.
name|x
argument_list|,
name|nextPoint1
operator|.
name|y
argument_list|,
name|nextPoint2
operator|.
name|x
argument_list|,
name|nextPoint2
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextPoint1
operator|.
name|endOfContour
operator|||
name|nextPoint2
operator|.
name|endOfContour
condition|)
block|{
name|endOfContour
operator|=
literal|true
expr_stmt|;
name|path
operator|.
name|closePath
argument_list|()
expr_stmt|;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
name|lastCtrlPoint
operator|=
name|nextPoint1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|point
operator|.
name|onCurve
operator|&&
operator|!
name|nextPoint1
operator|.
name|onCurve
operator|&&
operator|!
name|nextPoint2
operator|.
name|onCurve
condition|)
block|{
comment|// interpolate endPoint
name|int
name|endPointX
init|=
name|midValue
argument_list|(
name|nextPoint1
operator|.
name|x
argument_list|,
name|nextPoint2
operator|.
name|x
argument_list|)
decl_stmt|;
name|int
name|endPointY
init|=
name|midValue
argument_list|(
name|nextPoint1
operator|.
name|y
argument_list|,
name|nextPoint2
operator|.
name|y
argument_list|)
decl_stmt|;
name|path
operator|.
name|quadTo
argument_list|(
name|nextPoint1
operator|.
name|x
argument_list|,
name|nextPoint1
operator|.
name|y
argument_list|,
name|endPointX
argument_list|,
name|endPointY
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|.
name|endOfContour
operator|||
name|nextPoint1
operator|.
name|endOfContour
operator|||
name|nextPoint2
operator|.
name|endOfContour
condition|)
block|{
name|path
operator|.
name|quadTo
argument_list|(
name|nextPoint2
operator|.
name|x
argument_list|,
name|nextPoint2
operator|.
name|y
argument_list|,
name|startingPoint
operator|.
name|x
argument_list|,
name|startingPoint
operator|.
name|y
argument_list|)
expr_stmt|;
name|endOfContour
operator|=
literal|true
expr_stmt|;
name|path
operator|.
name|closePath
argument_list|()
expr_stmt|;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
name|lastCtrlPoint
operator|=
name|nextPoint1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|point
operator|.
name|onCurve
operator|&&
operator|!
name|nextPoint1
operator|.
name|onCurve
condition|)
block|{
name|Point2D
name|lastEndPoint
init|=
name|path
operator|.
name|getCurrentPoint
argument_list|()
decl_stmt|;
comment|// calculate new control point using the previous control point
name|lastCtrlPoint
operator|=
operator|new
name|Point
argument_list|(
name|midValue
argument_list|(
name|lastCtrlPoint
operator|.
name|x
argument_list|,
operator|(
name|int
operator|)
name|lastEndPoint
operator|.
name|getX
argument_list|()
argument_list|)
argument_list|,
name|midValue
argument_list|(
name|lastCtrlPoint
operator|.
name|y
argument_list|,
operator|(
name|int
operator|)
name|lastEndPoint
operator|.
name|getY
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// interpolate endPoint
name|int
name|endPointX
init|=
name|midValue
argument_list|(
operator|(
name|int
operator|)
name|lastEndPoint
operator|.
name|getX
argument_list|()
argument_list|,
name|nextPoint1
operator|.
name|x
argument_list|)
decl_stmt|;
name|int
name|endPointY
init|=
name|midValue
argument_list|(
operator|(
name|int
operator|)
name|lastEndPoint
operator|.
name|getY
argument_list|()
argument_list|,
name|nextPoint1
operator|.
name|y
argument_list|)
decl_stmt|;
name|path
operator|.
name|quadTo
argument_list|(
name|lastCtrlPoint
operator|.
name|x
argument_list|,
name|lastCtrlPoint
operator|.
name|y
argument_list|,
name|endPointX
argument_list|,
name|endPointY
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|.
name|endOfContour
operator|||
name|nextPoint1
operator|.
name|endOfContour
condition|)
block|{
name|endOfContour
operator|=
literal|true
expr_stmt|;
name|path
operator|.
name|closePath
argument_list|()
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|point
operator|.
name|onCurve
operator|&&
name|nextPoint1
operator|.
name|onCurve
condition|)
block|{
name|path
operator|.
name|quadTo
argument_list|(
name|point
operator|.
name|x
argument_list|,
name|point
operator|.
name|y
argument_list|,
name|nextPoint1
operator|.
name|x
argument_list|,
name|nextPoint1
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|.
name|endOfContour
operator|||
name|nextPoint1
operator|.
name|endOfContour
condition|)
block|{
name|endOfContour
operator|=
literal|true
expr_stmt|;
name|path
operator|.
name|closePath
argument_list|()
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|lastCtrlPoint
operator|=
name|point
expr_stmt|;
continue|continue;
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Unknown glyph command!!"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|path
return|;
block|}
specifier|private
name|int
name|midValue
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|+
operator|(
name|b
operator|-
name|a
operator|)
operator|/
literal|2
return|;
block|}
comment|/**      * This class represents one point of a glyph.        *      */
specifier|private
class|class
name|Point
block|{
specifier|public
name|int
name|x
init|=
literal|0
decl_stmt|;
specifier|public
name|int
name|y
init|=
literal|0
decl_stmt|;
specifier|public
name|boolean
name|onCurve
init|=
literal|true
decl_stmt|;
specifier|public
name|boolean
name|endOfContour
init|=
literal|false
decl_stmt|;
specifier|public
name|Point
parameter_list|(
name|int
name|xValue
parameter_list|,
name|int
name|yValue
parameter_list|,
name|boolean
name|onCurveValue
parameter_list|,
name|boolean
name|endOfContourValue
parameter_list|)
block|{
name|x
operator|=
name|xValue
expr_stmt|;
name|y
operator|=
name|yValue
expr_stmt|;
name|onCurve
operator|=
name|onCurveValue
expr_stmt|;
name|endOfContour
operator|=
name|endOfContourValue
expr_stmt|;
block|}
specifier|public
name|Point
parameter_list|(
name|int
name|xValue
parameter_list|,
name|int
name|yValue
parameter_list|)
block|{
name|this
argument_list|(
name|xValue
argument_list|,
name|yValue
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

