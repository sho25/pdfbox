begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|afm
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|util
operator|.
name|BoundingBox
import|;
end_import

begin_comment
comment|/**  * This class is used to parse AFM(Adobe Font Metrics) documents.  *  * @see<A href="http://partners.adobe.com/asn/developer/type/">AFM Documentation</A>  *  * @author Ben Litchfield  *   */
end_comment

begin_class
specifier|public
class|class
name|AFMParser
block|{
comment|/**      * This is a comment in a AFM file.      */
specifier|public
specifier|static
specifier|final
name|String
name|COMMENT
init|=
literal|"Comment"
decl_stmt|;
comment|/**      * This is the constant used in the AFM file to start a font metrics item.      */
specifier|public
specifier|static
specifier|final
name|String
name|START_FONT_METRICS
init|=
literal|"StartFontMetrics"
decl_stmt|;
comment|/**      * This is the constant used in the AFM file to end a font metrics item.      */
specifier|public
specifier|static
specifier|final
name|String
name|END_FONT_METRICS
init|=
literal|"EndFontMetrics"
decl_stmt|;
comment|/**      * This is the font name.      */
specifier|public
specifier|static
specifier|final
name|String
name|FONT_NAME
init|=
literal|"FontName"
decl_stmt|;
comment|/**      * This is the full name.      */
specifier|public
specifier|static
specifier|final
name|String
name|FULL_NAME
init|=
literal|"FullName"
decl_stmt|;
comment|/**      * This is the Family name.      */
specifier|public
specifier|static
specifier|final
name|String
name|FAMILY_NAME
init|=
literal|"FamilyName"
decl_stmt|;
comment|/**      * This is the weight.      */
specifier|public
specifier|static
specifier|final
name|String
name|WEIGHT
init|=
literal|"Weight"
decl_stmt|;
comment|/**      * This is the font bounding box.      */
specifier|public
specifier|static
specifier|final
name|String
name|FONT_BBOX
init|=
literal|"FontBBox"
decl_stmt|;
comment|/**      * This is the version of the font.      */
specifier|public
specifier|static
specifier|final
name|String
name|VERSION
init|=
literal|"Version"
decl_stmt|;
comment|/**      * This is the notice.      */
specifier|public
specifier|static
specifier|final
name|String
name|NOTICE
init|=
literal|"Notice"
decl_stmt|;
comment|/**      * This is the encoding scheme.      */
specifier|public
specifier|static
specifier|final
name|String
name|ENCODING_SCHEME
init|=
literal|"EncodingScheme"
decl_stmt|;
comment|/**      * This is the mapping scheme.      */
specifier|public
specifier|static
specifier|final
name|String
name|MAPPING_SCHEME
init|=
literal|"MappingScheme"
decl_stmt|;
comment|/**      * This is the escape character.      */
specifier|public
specifier|static
specifier|final
name|String
name|ESC_CHAR
init|=
literal|"EscChar"
decl_stmt|;
comment|/**      * This is the character set.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARACTER_SET
init|=
literal|"CharacterSet"
decl_stmt|;
comment|/**      * This is the characters attribute.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARACTERS
init|=
literal|"Characters"
decl_stmt|;
comment|/**      * This will determine if this is a base font.      */
specifier|public
specifier|static
specifier|final
name|String
name|IS_BASE_FONT
init|=
literal|"IsBaseFont"
decl_stmt|;
comment|/**      * This is the V Vector attribute.      */
specifier|public
specifier|static
specifier|final
name|String
name|V_VECTOR
init|=
literal|"VVector"
decl_stmt|;
comment|/**      * This will tell if the V is fixed.      */
specifier|public
specifier|static
specifier|final
name|String
name|IS_FIXED_V
init|=
literal|"IsFixedV"
decl_stmt|;
comment|/**      * This is the cap height attribute.      */
specifier|public
specifier|static
specifier|final
name|String
name|CAP_HEIGHT
init|=
literal|"CapHeight"
decl_stmt|;
comment|/**      * This is the X height.      */
specifier|public
specifier|static
specifier|final
name|String
name|X_HEIGHT
init|=
literal|"XHeight"
decl_stmt|;
comment|/**      * This is ascender attribute.      */
specifier|public
specifier|static
specifier|final
name|String
name|ASCENDER
init|=
literal|"Ascender"
decl_stmt|;
comment|/**      * This is the descender attribute.      */
specifier|public
specifier|static
specifier|final
name|String
name|DESCENDER
init|=
literal|"Descender"
decl_stmt|;
comment|/**      * The underline position.      */
specifier|public
specifier|static
specifier|final
name|String
name|UNDERLINE_POSITION
init|=
literal|"UnderlinePosition"
decl_stmt|;
comment|/**      * This is the Underline thickness.      */
specifier|public
specifier|static
specifier|final
name|String
name|UNDERLINE_THICKNESS
init|=
literal|"UnderlineThickness"
decl_stmt|;
comment|/**      * This is the italic angle.      */
specifier|public
specifier|static
specifier|final
name|String
name|ITALIC_ANGLE
init|=
literal|"ItalicAngle"
decl_stmt|;
comment|/**      * This is the char width.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHAR_WIDTH
init|=
literal|"CharWidth"
decl_stmt|;
comment|/**      * This will determine if this is fixed pitch.      */
specifier|public
specifier|static
specifier|final
name|String
name|IS_FIXED_PITCH
init|=
literal|"IsFixedPitch"
decl_stmt|;
comment|/**      * This is the start of character metrics.      */
specifier|public
specifier|static
specifier|final
name|String
name|START_CHAR_METRICS
init|=
literal|"StartCharMetrics"
decl_stmt|;
comment|/**      * This is the end of character metrics.      */
specifier|public
specifier|static
specifier|final
name|String
name|END_CHAR_METRICS
init|=
literal|"EndCharMetrics"
decl_stmt|;
comment|/**      * The character metrics c value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_C
init|=
literal|"C"
decl_stmt|;
comment|/**      * The character metrics c value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_CH
init|=
literal|"CH"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_WX
init|=
literal|"WX"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_W0X
init|=
literal|"W0X"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_W1X
init|=
literal|"W1X"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_WY
init|=
literal|"WY"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_W0Y
init|=
literal|"W0Y"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_W1Y
init|=
literal|"W1Y"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_W
init|=
literal|"W"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_W0
init|=
literal|"W0"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_W1
init|=
literal|"W1"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_VV
init|=
literal|"VV"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_N
init|=
literal|"N"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_B
init|=
literal|"B"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|CHARMETRICS_L
init|=
literal|"L"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|STD_HW
init|=
literal|"StdHW"
decl_stmt|;
comment|/**      * The character metrics value.      */
specifier|public
specifier|static
specifier|final
name|String
name|STD_VW
init|=
literal|"StdVW"
decl_stmt|;
comment|/**      * This is the start of track kern data.      */
specifier|public
specifier|static
specifier|final
name|String
name|START_TRACK_KERN
init|=
literal|"StartTrackKern"
decl_stmt|;
comment|/**      * This is the end of track kern data.      */
specifier|public
specifier|static
specifier|final
name|String
name|END_TRACK_KERN
init|=
literal|"EndTrackKern"
decl_stmt|;
comment|/**      * This is the start of kern data.      */
specifier|public
specifier|static
specifier|final
name|String
name|START_KERN_DATA
init|=
literal|"StartKernData"
decl_stmt|;
comment|/**      * This is the end of kern data.      */
specifier|public
specifier|static
specifier|final
name|String
name|END_KERN_DATA
init|=
literal|"EndKernData"
decl_stmt|;
comment|/**      * This is the start of kern pairs data.      */
specifier|public
specifier|static
specifier|final
name|String
name|START_KERN_PAIRS
init|=
literal|"StartKernPairs"
decl_stmt|;
comment|/**      * This is the end of kern pairs data.      */
specifier|public
specifier|static
specifier|final
name|String
name|END_KERN_PAIRS
init|=
literal|"EndKernPairs"
decl_stmt|;
comment|/**      * This is the start of kern pairs data.      */
specifier|public
specifier|static
specifier|final
name|String
name|START_KERN_PAIRS0
init|=
literal|"StartKernPairs0"
decl_stmt|;
comment|/**      * This is the start of kern pairs data.      */
specifier|public
specifier|static
specifier|final
name|String
name|START_KERN_PAIRS1
init|=
literal|"StartKernPairs1"
decl_stmt|;
comment|/**      * This is the start compisites data section.      */
specifier|public
specifier|static
specifier|final
name|String
name|START_COMPOSITES
init|=
literal|"StartComposites"
decl_stmt|;
comment|/**      * This is the end compisites data section.      */
specifier|public
specifier|static
specifier|final
name|String
name|END_COMPOSITES
init|=
literal|"EndComposites"
decl_stmt|;
comment|/**      * This is a composite character.      */
specifier|public
specifier|static
specifier|final
name|String
name|CC
init|=
literal|"CC"
decl_stmt|;
comment|/**      * This is a composite character part.      */
specifier|public
specifier|static
specifier|final
name|String
name|PCC
init|=
literal|"PCC"
decl_stmt|;
comment|/**      * This is a kern pair.      */
specifier|public
specifier|static
specifier|final
name|String
name|KERN_PAIR_KP
init|=
literal|"KP"
decl_stmt|;
comment|/**      * This is a kern pair.      */
specifier|public
specifier|static
specifier|final
name|String
name|KERN_PAIR_KPH
init|=
literal|"KPH"
decl_stmt|;
comment|/**      * This is a kern pair.      */
specifier|public
specifier|static
specifier|final
name|String
name|KERN_PAIR_KPX
init|=
literal|"KPX"
decl_stmt|;
comment|/**      * This is a kern pair.      */
specifier|public
specifier|static
specifier|final
name|String
name|KERN_PAIR_KPY
init|=
literal|"KPY"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|BITS_IN_HEX
init|=
literal|16
decl_stmt|;
specifier|private
specifier|final
name|InputStream
name|input
decl_stmt|;
comment|/**      * Constructor.      *      * @param in The input stream to read the AFM document from.      */
specifier|public
name|AFMParser
parameter_list|(
name|InputStream
name|in
parameter_list|)
block|{
name|input
operator|=
name|in
expr_stmt|;
block|}
comment|/**      * This will parse the AFM document. The input stream is closed      * when the parsing is finished.      *      * @return the parsed FontMetric      *       * @throws IOException If there is an IO error reading the document.      */
specifier|public
name|FontMetrics
name|parse
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|parseFontMetric
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**      * This will parse the AFM document. The input stream is closed      * when the parsing is finished.      *      * @param reducedDataset parse a reduced subset of data if set to true      * @return the parsed FontMetric      *       * @throws IOException If there is an IO error reading the document.      */
specifier|public
name|FontMetrics
name|parse
parameter_list|(
name|boolean
name|reducedDataset
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|parseFontMetric
argument_list|(
name|reducedDataset
argument_list|)
return|;
block|}
comment|/**      * This will parse a font metrics item.      *      * @return The parse font metrics item.      *      * @throws IOException If there is an error reading the AFM file.      */
specifier|private
name|FontMetrics
name|parseFontMetric
parameter_list|(
name|boolean
name|reducedDataset
parameter_list|)
throws|throws
name|IOException
block|{
name|FontMetrics
name|fontMetrics
init|=
operator|new
name|FontMetrics
argument_list|()
decl_stmt|;
name|String
name|startFontMetrics
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|START_FONT_METRICS
operator|.
name|equals
argument_list|(
name|startFontMetrics
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: The AFM file should start with "
operator|+
name|START_FONT_METRICS
operator|+
literal|" and not '"
operator|+
name|startFontMetrics
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|fontMetrics
operator|.
name|setAFMVersion
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|nextCommand
decl_stmt|;
name|boolean
name|charMetricsRead
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|END_FONT_METRICS
operator|.
name|equals
argument_list|(
name|nextCommand
operator|=
name|readString
argument_list|()
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|nextCommand
condition|)
block|{
case|case
name|FONT_NAME
case|:
name|fontMetrics
operator|.
name|setFontName
argument_list|(
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|FULL_NAME
case|:
name|fontMetrics
operator|.
name|setFullName
argument_list|(
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAMILY_NAME
case|:
name|fontMetrics
operator|.
name|setFamilyName
argument_list|(
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|WEIGHT
case|:
name|fontMetrics
operator|.
name|setWeight
argument_list|(
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|FONT_BBOX
case|:
name|BoundingBox
name|bBox
init|=
operator|new
name|BoundingBox
argument_list|()
decl_stmt|;
name|bBox
operator|.
name|setLowerLeftX
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|bBox
operator|.
name|setLowerLeftY
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|bBox
operator|.
name|setUpperRightX
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|bBox
operator|.
name|setUpperRightY
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|fontMetrics
operator|.
name|setFontBBox
argument_list|(
name|bBox
argument_list|)
expr_stmt|;
break|break;
case|case
name|VERSION
case|:
name|fontMetrics
operator|.
name|setFontVersion
argument_list|(
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTICE
case|:
name|fontMetrics
operator|.
name|setNotice
argument_list|(
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODING_SCHEME
case|:
name|fontMetrics
operator|.
name|setEncodingScheme
argument_list|(
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAPPING_SCHEME
case|:
name|fontMetrics
operator|.
name|setMappingScheme
argument_list|(
name|readInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESC_CHAR
case|:
name|fontMetrics
operator|.
name|setEscChar
argument_list|(
name|readInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARACTER_SET
case|:
name|fontMetrics
operator|.
name|setCharacterSet
argument_list|(
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARACTERS
case|:
name|fontMetrics
operator|.
name|setCharacters
argument_list|(
name|readInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|IS_BASE_FONT
case|:
name|fontMetrics
operator|.
name|setIsBaseFont
argument_list|(
name|readBoolean
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_VECTOR
case|:
name|float
index|[]
name|vector
init|=
operator|new
name|float
index|[
literal|2
index|]
decl_stmt|;
name|vector
index|[
literal|0
index|]
operator|=
name|readFloat
argument_list|()
expr_stmt|;
name|vector
index|[
literal|1
index|]
operator|=
name|readFloat
argument_list|()
expr_stmt|;
name|fontMetrics
operator|.
name|setVVector
argument_list|(
name|vector
argument_list|)
expr_stmt|;
break|break;
case|case
name|IS_FIXED_V
case|:
name|fontMetrics
operator|.
name|setIsFixedV
argument_list|(
name|readBoolean
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAP_HEIGHT
case|:
name|fontMetrics
operator|.
name|setCapHeight
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|X_HEIGHT
case|:
name|fontMetrics
operator|.
name|setXHeight
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASCENDER
case|:
name|fontMetrics
operator|.
name|setAscender
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DESCENDER
case|:
name|fontMetrics
operator|.
name|setDescender
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|STD_HW
case|:
name|fontMetrics
operator|.
name|setStandardHorizontalWidth
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|STD_VW
case|:
name|fontMetrics
operator|.
name|setStandardVerticalWidth
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMENT
case|:
name|fontMetrics
operator|.
name|addComment
argument_list|(
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNDERLINE_POSITION
case|:
name|fontMetrics
operator|.
name|setUnderlinePosition
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNDERLINE_THICKNESS
case|:
name|fontMetrics
operator|.
name|setUnderlineThickness
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITALIC_ANGLE
case|:
name|fontMetrics
operator|.
name|setItalicAngle
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR_WIDTH
case|:
name|float
index|[]
name|widths
init|=
operator|new
name|float
index|[
literal|2
index|]
decl_stmt|;
name|widths
index|[
literal|0
index|]
operator|=
name|readFloat
argument_list|()
expr_stmt|;
name|widths
index|[
literal|1
index|]
operator|=
name|readFloat
argument_list|()
expr_stmt|;
name|fontMetrics
operator|.
name|setCharWidth
argument_list|(
name|widths
argument_list|)
expr_stmt|;
break|break;
case|case
name|IS_FIXED_PITCH
case|:
name|fontMetrics
operator|.
name|setFixedPitch
argument_list|(
name|readBoolean
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|START_CHAR_METRICS
case|:
name|int
name|countMetrics
init|=
name|readInt
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|CharMetric
argument_list|>
name|charMetrics
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|countMetrics
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|countMetrics
condition|;
name|i
operator|++
control|)
block|{
name|CharMetric
name|charMetric
init|=
name|parseCharMetric
argument_list|()
decl_stmt|;
name|charMetrics
operator|.
name|add
argument_list|(
name|charMetric
argument_list|)
expr_stmt|;
block|}
name|String
name|endCharMetrics
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|endCharMetrics
operator|.
name|equals
argument_list|(
name|END_CHAR_METRICS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected '"
operator|+
name|END_CHAR_METRICS
operator|+
literal|"' actual '"
operator|+
name|endCharMetrics
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|charMetricsRead
operator|=
literal|true
expr_stmt|;
name|fontMetrics
operator|.
name|setCharMetrics
argument_list|(
name|charMetrics
argument_list|)
expr_stmt|;
break|break;
case|case
name|START_COMPOSITES
case|:
if|if
condition|(
operator|!
name|reducedDataset
condition|)
block|{
name|int
name|countComposites
init|=
name|readInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|countComposites
condition|;
name|i
operator|++
control|)
block|{
name|Composite
name|part
init|=
name|parseComposite
argument_list|()
decl_stmt|;
name|fontMetrics
operator|.
name|addComposite
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
name|String
name|endComposites
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|endComposites
operator|.
name|equals
argument_list|(
name|END_COMPOSITES
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected '"
operator|+
name|END_COMPOSITES
operator|+
literal|"' actual '"
operator|+
name|endComposites
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
break|break;
case|case
name|START_KERN_DATA
case|:
if|if
condition|(
operator|!
name|reducedDataset
condition|)
block|{
name|parseKernData
argument_list|(
name|fontMetrics
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|reducedDataset
operator|&&
name|charMetricsRead
condition|)
block|{
break|break;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown AFM key '"
operator|+
name|nextCommand
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
return|return
name|fontMetrics
return|;
block|}
comment|/**      * This will parse the kern data.      *      * @param fontMetrics The metrics class to put the parsed data into.      *      * @throws IOException If there is an error parsing the data.      */
specifier|private
name|void
name|parseKernData
parameter_list|(
name|FontMetrics
name|fontMetrics
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nextCommand
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|nextCommand
operator|=
name|readString
argument_list|()
operator|)
operator|.
name|equals
argument_list|(
name|END_KERN_DATA
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|nextCommand
condition|)
block|{
case|case
name|START_TRACK_KERN
case|:
name|int
name|countTrackKern
init|=
name|readInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|countTrackKern
condition|;
name|i
operator|++
control|)
block|{
name|TrackKern
name|kern
init|=
operator|new
name|TrackKern
argument_list|()
decl_stmt|;
name|kern
operator|.
name|setDegree
argument_list|(
name|readInt
argument_list|()
argument_list|)
expr_stmt|;
name|kern
operator|.
name|setMinPointSize
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|kern
operator|.
name|setMinKern
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|kern
operator|.
name|setMaxPointSize
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|kern
operator|.
name|setMaxKern
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|fontMetrics
operator|.
name|addTrackKern
argument_list|(
name|kern
argument_list|)
expr_stmt|;
block|}
name|String
name|endTrackKern
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|endTrackKern
operator|.
name|equals
argument_list|(
name|END_TRACK_KERN
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected '"
operator|+
name|END_TRACK_KERN
operator|+
literal|"' actual '"
operator|+
name|endTrackKern
operator|+
literal|"'"
argument_list|)
throw|;
block|}
break|break;
case|case
name|START_KERN_PAIRS
case|:
name|int
name|countKernPairs
init|=
name|readInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|countKernPairs
condition|;
name|i
operator|++
control|)
block|{
name|KernPair
name|pair
init|=
name|parseKernPair
argument_list|()
decl_stmt|;
name|fontMetrics
operator|.
name|addKernPair
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
name|String
name|endKernPairs
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|endKernPairs
operator|.
name|equals
argument_list|(
name|END_KERN_PAIRS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected '"
operator|+
name|END_KERN_PAIRS
operator|+
literal|"' actual '"
operator|+
name|endKernPairs
operator|+
literal|"'"
argument_list|)
throw|;
block|}
break|break;
case|case
name|START_KERN_PAIRS0
case|:
name|int
name|countKernPairs0
init|=
name|readInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|countKernPairs0
condition|;
name|i
operator|++
control|)
block|{
name|KernPair
name|pair
init|=
name|parseKernPair
argument_list|()
decl_stmt|;
name|fontMetrics
operator|.
name|addKernPair0
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
name|String
name|endKernPairs0
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|endKernPairs0
operator|.
name|equals
argument_list|(
name|END_KERN_PAIRS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected '"
operator|+
name|END_KERN_PAIRS
operator|+
literal|"' actual '"
operator|+
name|endKernPairs0
operator|+
literal|"'"
argument_list|)
throw|;
block|}
break|break;
case|case
name|START_KERN_PAIRS1
case|:
name|int
name|countKernPairs1
init|=
name|readInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|countKernPairs1
condition|;
name|i
operator|++
control|)
block|{
name|KernPair
name|pair
init|=
name|parseKernPair
argument_list|()
decl_stmt|;
name|fontMetrics
operator|.
name|addKernPair1
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
name|String
name|endKernPairs1
init|=
name|readString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|endKernPairs1
operator|.
name|equals
argument_list|(
name|END_KERN_PAIRS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected '"
operator|+
name|END_KERN_PAIRS
operator|+
literal|"' actual '"
operator|+
name|endKernPairs1
operator|+
literal|"'"
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown kerning data type '"
operator|+
name|nextCommand
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * This will parse a kern pair from the data stream.      *      * @return The kern pair that was parsed from the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|private
name|KernPair
name|parseKernPair
parameter_list|()
throws|throws
name|IOException
block|{
name|KernPair
name|kernPair
init|=
operator|new
name|KernPair
argument_list|()
decl_stmt|;
name|String
name|cmd
init|=
name|readString
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|KERN_PAIR_KP
case|:
name|kernPair
operator|.
name|setFirstKernCharacter
argument_list|(
name|readString
argument_list|()
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setSecondKernCharacter
argument_list|(
name|readString
argument_list|()
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setX
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setY
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|KERN_PAIR_KPH
case|:
name|kernPair
operator|.
name|setFirstKernCharacter
argument_list|(
name|hexToString
argument_list|(
name|readString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setSecondKernCharacter
argument_list|(
name|hexToString
argument_list|(
name|readString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setX
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setY
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|KERN_PAIR_KPX
case|:
name|kernPair
operator|.
name|setFirstKernCharacter
argument_list|(
name|readString
argument_list|()
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setSecondKernCharacter
argument_list|(
name|readString
argument_list|()
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setX
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setY
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KERN_PAIR_KPY
case|:
name|kernPair
operator|.
name|setFirstKernCharacter
argument_list|(
name|readString
argument_list|()
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setSecondKernCharacter
argument_list|(
name|readString
argument_list|()
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setX
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|kernPair
operator|.
name|setY
argument_list|(
name|readFloat
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error expected kern pair command actual='"
operator|+
name|cmd
operator|+
literal|"'"
argument_list|)
throw|;
block|}
return|return
name|kernPair
return|;
block|}
comment|/**      * This will convert and angle bracket hex string to a string.      *      * @param hexString An angle bracket string.      *      * @return The bytes of the hex string.      *      * @throws IOException If the string is in an invalid format.      */
specifier|private
name|String
name|hexToString
parameter_list|(
name|String
name|hexString
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|hexString
operator|.
name|length
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected hex string of length>= 2 not='"
operator|+
name|hexString
argument_list|)
throw|;
block|}
if|if
condition|(
name|hexString
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'<'
operator|||
name|hexString
operator|.
name|charAt
argument_list|(
name|hexString
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|!=
literal|'>'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"String should be enclosed by angle brackets '"
operator|+
name|hexString
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|hexString
operator|=
name|hexString
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|hexString
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|hexString
operator|.
name|length
argument_list|()
operator|/
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hexString
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|String
name|hex
init|=
name|Character
operator|.
name|toString
argument_list|(
name|hexString
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|+
name|hexString
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
try|try
block|{
name|data
index|[
name|i
operator|/
literal|2
index|]
operator|=
operator|(
name|byte
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|hex
argument_list|,
name|BITS_IN_HEX
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing AFM file:"
operator|+
name|e
argument_list|)
throw|;
block|}
block|}
return|return
operator|new
name|String
argument_list|(
name|data
argument_list|,
name|StandardCharsets
operator|.
name|ISO_8859_1
argument_list|)
return|;
block|}
comment|/**      * This will parse a composite part from the stream.      *      * @return The composite.      *      * @throws IOException If there is an error parsing the composite.      */
specifier|private
name|Composite
name|parseComposite
parameter_list|()
throws|throws
name|IOException
block|{
name|Composite
name|composite
init|=
operator|new
name|Composite
argument_list|()
decl_stmt|;
name|String
name|partData
init|=
name|readLine
argument_list|()
decl_stmt|;
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|partData
argument_list|,
literal|" ;"
argument_list|)
decl_stmt|;
name|String
name|cc
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cc
operator|.
name|equals
argument_list|(
name|CC
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected '"
operator|+
name|CC
operator|+
literal|"' actual='"
operator|+
name|cc
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|String
name|name
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|composite
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|int
name|partCount
decl_stmt|;
try|try
block|{
name|partCount
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|tokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing AFM document:"
operator|+
name|e
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partCount
condition|;
name|i
operator|++
control|)
block|{
name|CompositePart
name|part
init|=
operator|new
name|CompositePart
argument_list|()
decl_stmt|;
name|String
name|pcc
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|pcc
operator|.
name|equals
argument_list|(
name|PCC
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected '"
operator|+
name|PCC
operator|+
literal|"' actual='"
operator|+
name|pcc
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|String
name|partName
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|x
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|tokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|y
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|tokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
decl_stmt|;
name|part
operator|.
name|setName
argument_list|(
name|partName
argument_list|)
expr_stmt|;
name|part
operator|.
name|setXDisplacement
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|part
operator|.
name|setYDisplacement
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|composite
operator|.
name|addPart
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing AFM document:"
operator|+
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|composite
return|;
block|}
comment|/**      * This will parse a single CharMetric object from the stream.      *      * @return The next char metric in the stream.      *      * @throws IOException If there is an error reading from the stream.      */
specifier|private
name|CharMetric
name|parseCharMetric
parameter_list|()
throws|throws
name|IOException
block|{
name|CharMetric
name|charMetric
init|=
operator|new
name|CharMetric
argument_list|()
decl_stmt|;
name|String
name|metrics
init|=
name|readLine
argument_list|()
decl_stmt|;
name|StringTokenizer
name|metricsTokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|metrics
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
name|metricsTokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|nextCommand
init|=
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|nextCommand
condition|)
block|{
case|case
name|CHARMETRICS_C
case|:
name|String
name|charCodeC
init|=
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|charMetric
operator|.
name|setCharacterCode
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|charCodeC
argument_list|)
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_CH
case|:
comment|//Is the hex string<FF> or FF, the spec is a little
comment|//unclear, wait and see if it breaks anything.
name|String
name|charCodeCH
init|=
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|charMetric
operator|.
name|setCharacterCode
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|charCodeCH
argument_list|,
name|BITS_IN_HEX
argument_list|)
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_WX
case|:
name|charMetric
operator|.
name|setWx
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_W0X
case|:
name|charMetric
operator|.
name|setW0x
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_W1X
case|:
name|charMetric
operator|.
name|setW1x
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_WY
case|:
name|charMetric
operator|.
name|setWy
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_W0Y
case|:
name|charMetric
operator|.
name|setW0y
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_W1Y
case|:
name|charMetric
operator|.
name|setW1y
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_W
case|:
name|float
index|[]
name|w
init|=
operator|new
name|float
index|[
literal|2
index|]
decl_stmt|;
name|w
index|[
literal|0
index|]
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|w
index|[
literal|1
index|]
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|charMetric
operator|.
name|setW
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_W0
case|:
name|float
index|[]
name|w0
init|=
operator|new
name|float
index|[
literal|2
index|]
decl_stmt|;
name|w0
index|[
literal|0
index|]
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|w0
index|[
literal|1
index|]
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|charMetric
operator|.
name|setW0
argument_list|(
name|w0
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_W1
case|:
name|float
index|[]
name|w1
init|=
operator|new
name|float
index|[
literal|2
index|]
decl_stmt|;
name|w1
index|[
literal|0
index|]
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|w1
index|[
literal|1
index|]
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|charMetric
operator|.
name|setW1
argument_list|(
name|w1
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_VV
case|:
name|float
index|[]
name|vv
init|=
operator|new
name|float
index|[
literal|2
index|]
decl_stmt|;
name|vv
index|[
literal|0
index|]
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|vv
index|[
literal|1
index|]
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|charMetric
operator|.
name|setVv
argument_list|(
name|vv
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_N
case|:
name|charMetric
operator|.
name|setName
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_B
case|:
name|BoundingBox
name|box
init|=
operator|new
name|BoundingBox
argument_list|()
decl_stmt|;
name|box
operator|.
name|setLowerLeftX
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|box
operator|.
name|setLowerLeftY
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|box
operator|.
name|setUpperRightX
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|box
operator|.
name|setUpperRightY
argument_list|(
name|Float
operator|.
name|parseFloat
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|charMetric
operator|.
name|setBoundingBox
argument_list|(
name|box
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARMETRICS_L
case|:
name|Ligature
name|lig
init|=
operator|new
name|Ligature
argument_list|()
decl_stmt|;
name|lig
operator|.
name|setSuccessor
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|lig
operator|.
name|setLigature
argument_list|(
name|metricsTokenizer
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|charMetric
operator|.
name|addLigature
argument_list|(
name|lig
argument_list|)
expr_stmt|;
name|verifySemicolon
argument_list|(
name|metricsTokenizer
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown CharMetrics command '"
operator|+
name|nextCommand
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Corrupt AFM document:"
operator|+
name|e
argument_list|)
throw|;
block|}
return|return
name|charMetric
return|;
block|}
comment|/**      * This is used to verify that a semicolon is the next token in the stream.      *      * @param tokenizer The tokenizer to read from.      *      * @throws IOException If the semicolon is missing.      */
specifier|private
name|void
name|verifySemicolon
parameter_list|(
name|StringTokenizer
name|tokenizer
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|semicolon
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
literal|";"
operator|.
name|equals
argument_list|(
name|semicolon
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error: Expected semicolon in stream actual='"
operator|+
name|semicolon
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"CharMetrics is missing a semicolon after a command"
argument_list|)
throw|;
block|}
block|}
comment|/**      * This will read a boolean from the stream.      *      * @return The boolean in the stream.      */
specifier|private
name|boolean
name|readBoolean
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|theBoolean
init|=
name|readString
argument_list|()
decl_stmt|;
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|theBoolean
argument_list|)
return|;
block|}
comment|/**      * This will read an integer from the stream.      *      * @return The integer in the stream.      */
specifier|private
name|int
name|readInt
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|theInt
init|=
name|readString
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|theInt
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error parsing AFM document:"
operator|+
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * This will read a float from the stream.      *      * @return The float in the stream.      */
specifier|private
name|float
name|readFloat
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|theFloat
init|=
name|readString
argument_list|()
decl_stmt|;
return|return
name|Float
operator|.
name|parseFloat
argument_list|(
name|theFloat
argument_list|)
return|;
block|}
comment|/**      * This will read until the end of a line.      *      * @return The string that is read.      */
specifier|private
name|String
name|readLine
parameter_list|()
throws|throws
name|IOException
block|{
comment|//First skip the whitespace
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|60
argument_list|)
decl_stmt|;
name|int
name|nextByte
init|=
name|input
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|isWhitespace
argument_list|(
name|nextByte
argument_list|)
condition|)
block|{
name|nextByte
operator|=
name|input
operator|.
name|read
argument_list|()
expr_stmt|;
comment|//do nothing just skip the whitespace.
block|}
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|nextByte
argument_list|)
expr_stmt|;
comment|//now read the data
name|nextByte
operator|=
name|input
operator|.
name|read
argument_list|()
expr_stmt|;
while|while
condition|(
name|nextByte
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|isEOL
argument_list|(
name|nextByte
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|nextByte
argument_list|)
expr_stmt|;
name|nextByte
operator|=
name|input
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will read a string from the input stream and stop at any whitespace.      *      * @return The string read from the stream.      *      * @throws IOException If an IO error occurs when reading from the stream.      */
specifier|private
name|String
name|readString
parameter_list|()
throws|throws
name|IOException
block|{
comment|//First skip the whitespace
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|24
argument_list|)
decl_stmt|;
name|int
name|nextByte
init|=
name|input
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|isWhitespace
argument_list|(
name|nextByte
argument_list|)
condition|)
block|{
name|nextByte
operator|=
name|input
operator|.
name|read
argument_list|()
expr_stmt|;
comment|//do nothing just skip the whitespace.
block|}
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|nextByte
argument_list|)
expr_stmt|;
comment|//now read the data
name|nextByte
operator|=
name|input
operator|.
name|read
argument_list|()
expr_stmt|;
while|while
condition|(
name|nextByte
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|isWhitespace
argument_list|(
name|nextByte
argument_list|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|nextByte
argument_list|)
expr_stmt|;
name|nextByte
operator|=
name|input
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * This will determine if the byte is a whitespace character or not.      *      * @param character The character to test for whitespace.      *      * @return true If the character is whitespace as defined by the AFM spec.      */
specifier|private
name|boolean
name|isEOL
parameter_list|(
name|int
name|character
parameter_list|)
block|{
return|return
name|character
operator|==
literal|0x0D
operator|||
name|character
operator|==
literal|0x0A
return|;
block|}
comment|/**      * This will determine if the byte is a whitespace character or not.      *      * @param character The character to test for whitespace.      *      * @return true If the character is whitespace as defined by the AFM spec.      */
specifier|private
name|boolean
name|isWhitespace
parameter_list|(
name|int
name|character
parameter_list|)
block|{
return|return
name|character
operator|==
literal|' '
operator|||
name|character
operator|==
literal|'\t'
operator|||
name|character
operator|==
literal|0x0D
operator|||
name|character
operator|==
literal|0x0A
return|;
block|}
block|}
end_class

end_unit

