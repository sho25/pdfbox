begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|examples
operator|.
name|signature
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|cos
operator|.
name|COSName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|interactive
operator|.
name|digitalsignature
operator|.
name|PDSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|util
operator|.
name|Hex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|cms
operator|.
name|CMSException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|bouncycastle
operator|.
name|cms
operator|.
name|CMSSignedData
import|;
end_import

begin_comment
comment|/**  * An example for timestamp-signing a PDF for PADeS-Specification. The document will only be changed  * in its existing signature by a signed timestamp (A timestamp and the Hash-Value of the document  * are signed by a Time Stamp Authority (TSA)).  *  * This method only changes the unsigned parameters of a signature, so that it is kept valid.  *  * Use case: sign offline to avoid zero-day attacks against the signing machine. Once the signature  * is there and the pdf is transferred to a network connected machine, one is likely to want to add  * a timestamp. (Ralf Hauser)  *  * @author Alexis Suter  */
end_comment

begin_class
specifier|public
class|class
name|CreateEmbeddedTimeStamp
block|{
specifier|private
specifier|final
name|String
name|tsaUrl
decl_stmt|;
specifier|private
name|PDDocument
name|document
decl_stmt|;
specifier|private
name|PDSignature
name|signature
decl_stmt|;
specifier|private
name|byte
index|[]
name|changedEncodedSignature
decl_stmt|;
specifier|public
name|CreateEmbeddedTimeStamp
parameter_list|(
name|String
name|tsaUrl
parameter_list|)
block|{
name|this
operator|.
name|tsaUrl
operator|=
name|tsaUrl
expr_stmt|;
block|}
comment|/**      * Embeds the given PDF file with signed timestamp(s). Alters the original file on disk.      *       * @param file the PDF file to sign and to overwrite      * @throws IOException      */
specifier|public
name|void
name|embedTimeStamp
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|embedTimeStamp
argument_list|(
name|file
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/**      * Embeds signed timestamp(s) into existing signatures of the given document      *       * @param inFile The pdf file possibly containing signatures      * @param outFile Where the changed document will be saved      * @throws IOException      */
specifier|public
name|void
name|embedTimeStamp
parameter_list|(
name|File
name|inFile
parameter_list|,
name|File
name|outFile
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|inFile
operator|==
literal|null
operator|||
operator|!
name|inFile
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Document for signing does not exist"
argument_list|)
throw|;
block|}
comment|// sign
try|try
init|(
name|PDDocument
name|doc
init|=
name|PDDocument
operator|.
name|load
argument_list|(
name|inFile
argument_list|)
init|)
block|{
name|document
operator|=
name|doc
expr_stmt|;
name|processTimeStamping
argument_list|(
name|outFile
argument_list|,
name|inFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Processes the time-stamping of the Signature.      *       * @param outFile Where the new file will be written to      * @param fileName of the existing file containing the pdf      * @throws IOException      */
specifier|private
name|void
name|processTimeStamping
parameter_list|(
name|File
name|outFile
parameter_list|,
name|String
name|fileName
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|accessPermissions
init|=
name|SigUtils
operator|.
name|getMDPPermission
argument_list|(
name|document
argument_list|)
decl_stmt|;
if|if
condition|(
name|accessPermissions
operator|==
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No changes to the document are permitted due to DocMDP transform parameters dictionary"
argument_list|)
throw|;
block|}
try|try
block|{
name|byte
index|[]
name|documentBytes
decl_stmt|;
try|try
init|(
name|FileInputStream
name|fis
init|=
operator|new
name|FileInputStream
argument_list|(
name|fileName
argument_list|)
init|)
block|{
name|documentBytes
operator|=
name|IOUtils
operator|.
name|toByteArray
argument_list|(
name|fis
argument_list|)
expr_stmt|;
block|}
name|processRelevantSignatures
argument_list|(
name|documentBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|changedEncodedSignature
operator|!=
literal|null
condition|)
block|{
try|try
init|(
name|FileOutputStream
name|output
init|=
operator|new
name|FileOutputStream
argument_list|(
name|outFile
argument_list|)
init|)
block|{
name|embedNewSignatureIntoDocument
argument_list|(
name|documentBytes
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|NoSuchAlgorithmException
decl||
name|CMSException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Create changed Signature with embedded TimeStamp from TSA      *       * @param documentBytes byte[] of the input file      * @throws IOException      * @throws CMSException      * @throws NoSuchAlgorithmException      */
specifier|private
name|void
name|processRelevantSignatures
parameter_list|(
name|byte
index|[]
name|documentBytes
parameter_list|)
throws|throws
name|IOException
throws|,
name|CMSException
throws|,
name|NoSuchAlgorithmException
block|{
name|getRelevantSignature
argument_list|(
name|document
argument_list|)
expr_stmt|;
if|if
condition|(
name|signature
operator|!=
literal|null
condition|)
block|{
name|byte
index|[]
name|sigBlock
init|=
name|signature
operator|.
name|getContents
argument_list|(
name|documentBytes
argument_list|)
decl_stmt|;
name|CMSSignedData
name|signedData
init|=
operator|new
name|CMSSignedData
argument_list|(
name|sigBlock
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"INFO: Byte Range: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|signature
operator|.
name|getByteRange
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsaUrl
operator|!=
literal|null
operator|&&
name|tsaUrl
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ValidationTimeStamp
name|validation
init|=
operator|new
name|ValidationTimeStamp
argument_list|(
name|tsaUrl
argument_list|)
decl_stmt|;
name|signedData
operator|=
name|validation
operator|.
name|addSignedTimeStamp
argument_list|(
name|signedData
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|newEncoded
init|=
name|Hex
operator|.
name|getBytes
argument_list|(
name|signedData
operator|.
name|getEncoded
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|maxSize
init|=
name|signature
operator|.
name|getByteRange
argument_list|()
index|[
literal|2
index|]
operator|-
name|signature
operator|.
name|getByteRange
argument_list|()
index|[
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"INFO: New Signature has Size: "
operator|+
name|newEncoded
operator|.
name|length
operator|+
literal|" maxSize: "
operator|+
name|maxSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newEncoded
operator|.
name|length
operator|>
name|maxSize
operator|-
literal|2
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"New Signature is too big for existing Signature-Placeholder. Max Place: "
operator|+
name|maxSize
argument_list|)
throw|;
block|}
else|else
block|{
name|changedEncodedSignature
operator|=
name|newEncoded
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Extracts last Document-Signature from the document. The signature will be set on the signature-field.      *      * @param document to get the Signature from      * @throws IOException      */
specifier|private
name|void
name|getRelevantSignature
parameter_list|(
name|PDDocument
name|document
parameter_list|)
throws|throws
name|IOException
block|{
comment|// we can't use getLastSignatureDictionary() because this will fail (see PDFBOX-3978)
comment|// if a signature is assigned to a pre-defined empty signature field that isn't the last.
comment|// we get the last in time by looking at the offset in the PDF file.
name|SortedMap
argument_list|<
name|Integer
argument_list|,
name|PDSignature
argument_list|>
name|sortedMap
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|PDSignature
name|sig
range|:
name|document
operator|.
name|getSignatureDictionaries
argument_list|()
control|)
block|{
name|int
name|sigOffset
init|=
name|sig
operator|.
name|getByteRange
argument_list|()
index|[
literal|1
index|]
decl_stmt|;
name|sortedMap
operator|.
name|put
argument_list|(
name|sigOffset
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sortedMap
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|PDSignature
name|lastSignature
init|=
name|sortedMap
operator|.
name|get
argument_list|(
name|sortedMap
operator|.
name|lastKey
argument_list|()
argument_list|)
decl_stmt|;
name|COSBase
name|type
init|=
name|lastSignature
operator|.
name|getCOSObject
argument_list|()
operator|.
name|getItem
argument_list|(
name|COSName
operator|.
name|TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|COSName
operator|.
name|SIG
argument_list|)
condition|)
block|{
name|signature
operator|=
name|lastSignature
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Embeds the new signature into the document, by copying the rest of the document      *       * @param docBytes byte array of the document      * @param output target, where the file will be written      * @throws IOException      */
specifier|private
name|void
name|embedNewSignatureIntoDocument
parameter_list|(
name|byte
index|[]
name|docBytes
parameter_list|,
name|OutputStream
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|int
index|[]
name|byteRange
init|=
name|signature
operator|.
name|getByteRange
argument_list|()
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
name|docBytes
argument_list|,
name|byteRange
index|[
literal|0
index|]
argument_list|,
name|byteRange
index|[
literal|1
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
name|changedEncodedSignature
argument_list|)
expr_stmt|;
name|int
name|addingLength
init|=
name|byteRange
index|[
literal|2
index|]
operator|-
name|byteRange
index|[
literal|1
index|]
operator|-
literal|2
operator|-
name|changedEncodedSignature
operator|.
name|length
decl_stmt|;
name|byte
index|[]
name|zeroes
init|=
name|Hex
operator|.
name|getBytes
argument_list|(
operator|new
name|byte
index|[
operator|(
name|addingLength
operator|+
literal|1
operator|)
operator|/
literal|2
index|]
argument_list|)
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
name|zeroes
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
name|docBytes
argument_list|,
name|byteRange
index|[
literal|2
index|]
operator|-
literal|1
argument_list|,
name|byteRange
index|[
literal|3
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|3
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|String
name|tsaUrl
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|"-tsa"
operator|.
name|equals
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|args
operator|.
name|length
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tsaUrl
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|File
name|inFile
init|=
operator|new
name|File
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Input File: "
operator|+
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|inFile
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|substring
init|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
name|File
name|outFile
init|=
operator|new
name|File
argument_list|(
name|inFile
operator|.
name|getParent
argument_list|()
argument_list|,
name|substring
operator|+
literal|"_eTs.pdf"
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Output File: "
operator|+
name|outFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// Embed TimeStamp
name|CreateEmbeddedTimeStamp
name|signing
init|=
operator|new
name|CreateEmbeddedTimeStamp
argument_list|(
name|tsaUrl
argument_list|)
decl_stmt|;
name|signing
operator|.
name|embedTimeStamp
argument_list|(
name|inFile
argument_list|,
name|outFile
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"usage: java "
operator|+
name|CreateEmbeddedTimeStamp
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|" "
operator|+
literal|"<pdf_to_sign>\n"
operator|+
literal|"mandatory option:\n"
operator|+
literal|"  -tsa<url>    sign timestamp using the given TSA server\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

