begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|examples
operator|.
name|pdmodel
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|ttf
operator|.
name|TrueTypeCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDPage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|PDPageContentStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|common
operator|.
name|PDRectangle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDFont
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDType0Font
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|PDType1Font
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|encoding
operator|.
name|GlyphList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|pdmodel
operator|.
name|font
operator|.
name|encoding
operator|.
name|WinAnsiEncoding
import|;
end_import

begin_comment
comment|/**  * Output a text without knowing which font is the right one. One use case is a worldwide address  * list. Only LTR languages are supported, RTL (e.g. Hebrew, Arabic) are not supported so they would  * appear in the wrong direction. Complex scripts (Thai, Arabic, some Indian languages) are also not  * supported, any output will look weird. There is an (unfinished) effort here:  * https://issues.apache.org/jira/browse/PDFBOX-4189  *  * @author Tilman Hausherr  */
end_comment

begin_class
specifier|public
class|class
name|EmbeddedMultipleFonts
block|{
specifier|private
name|EmbeddedMultipleFonts
parameter_list|()
block|{     }
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|PDDocument
name|document
init|=
operator|new
name|PDDocument
argument_list|()
init|)
block|{
name|PDPage
name|page
init|=
operator|new
name|PDPage
argument_list|(
name|PDRectangle
operator|.
name|A4
argument_list|)
decl_stmt|;
name|document
operator|.
name|addPage
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|PDFont
name|font1
init|=
name|PDType1Font
operator|.
name|HELVETICA
decl_stmt|;
comment|// always have a simple font as first one
name|TrueTypeCollection
name|ttc2
init|=
operator|new
name|TrueTypeCollection
argument_list|(
operator|new
name|File
argument_list|(
literal|"c:/windows/fonts/batang.ttc"
argument_list|)
argument_list|)
decl_stmt|;
name|PDType0Font
name|font2
init|=
name|PDType0Font
operator|.
name|load
argument_list|(
name|document
argument_list|,
name|ttc2
operator|.
name|getFontByName
argument_list|(
literal|"Batang"
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Korean
name|TrueTypeCollection
name|ttc3
init|=
operator|new
name|TrueTypeCollection
argument_list|(
operator|new
name|File
argument_list|(
literal|"c:/windows/fonts/mingliu.ttc"
argument_list|)
argument_list|)
decl_stmt|;
name|PDType0Font
name|font3
init|=
name|PDType0Font
operator|.
name|load
argument_list|(
name|document
argument_list|,
name|ttc3
operator|.
name|getFontByName
argument_list|(
literal|"MingLiU"
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Chinese
name|PDType0Font
name|font4
init|=
name|PDType0Font
operator|.
name|load
argument_list|(
name|document
argument_list|,
operator|new
name|File
argument_list|(
literal|"c:/windows/fonts/mangal.ttf"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Indian
name|PDType0Font
name|font5
init|=
name|PDType0Font
operator|.
name|load
argument_list|(
name|document
argument_list|,
operator|new
name|File
argument_list|(
literal|"c:/windows/fonts/ArialUni.ttf"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Fallback
try|try
init|(
name|PDPageContentStream
name|cs
init|=
operator|new
name|PDPageContentStream
argument_list|(
name|document
argument_list|,
name|page
argument_list|)
init|)
block|{
name|cs
operator|.
name|beginText
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|PDFont
argument_list|>
name|fonts
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|fonts
operator|.
name|add
argument_list|(
name|font1
argument_list|)
expr_stmt|;
name|fonts
operator|.
name|add
argument_list|(
name|font2
argument_list|)
expr_stmt|;
name|fonts
operator|.
name|add
argument_list|(
name|font3
argument_list|)
expr_stmt|;
name|fonts
operator|.
name|add
argument_list|(
name|font4
argument_list|)
expr_stmt|;
name|fonts
operator|.
name|add
argument_list|(
name|font5
argument_list|)
expr_stmt|;
name|cs
operator|.
name|newLineAtOffset
argument_list|(
literal|20
argument_list|,
literal|700
argument_list|)
expr_stmt|;
name|showTextMultiple
argument_list|(
name|cs
argument_list|,
literal|"abc 한국 中国 भारत 日本 abc"
argument_list|,
name|fonts
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|cs
operator|.
name|endText
argument_list|()
expr_stmt|;
block|}
name|document
operator|.
name|save
argument_list|(
literal|"example.pdf"
argument_list|)
expr_stmt|;
name|ttc2
operator|.
name|close
argument_list|()
expr_stmt|;
name|ttc3
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|showTextMultiple
parameter_list|(
name|PDPageContentStream
name|cs
parameter_list|,
name|String
name|text
parameter_list|,
name|List
argument_list|<
name|PDFont
argument_list|>
name|fonts
parameter_list|,
name|float
name|size
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// first try all at once
name|fonts
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|encode
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setFont
argument_list|(
name|fonts
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cs
operator|.
name|showText
argument_list|(
name|text
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
comment|// do nothing
block|}
comment|// now try separately
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|PDFont
name|font
range|:
name|fonts
control|)
block|{
try|try
block|{
name|String
name|s
init|=
name|text
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|font
operator|.
name|encode
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|// it works! Try more with this font
name|int
name|j
init|=
name|i
operator|+
literal|1
decl_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|text
operator|.
name|length
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|String
name|s2
init|=
name|text
operator|.
name|substring
argument_list|(
name|j
argument_list|,
name|j
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|isWinAnsiEncoding
argument_list|(
name|s2
operator|.
name|codePointAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|font
operator|!=
name|fonts
operator|.
name|get
argument_list|(
literal|0
argument_list|)
condition|)
block|{
comment|// Without this segment, the example would have a flaw:
comment|// This code tries to keep the current font, so
comment|// the second "abc" would appear in a different font
comment|// than the first one, which would be weird.
comment|// This segment assumes that the first font has WinAnsiEncoding.
comment|// (all static PDType1Font Times / Helvetica / Courier fonts)
break|break;
block|}
try|try
block|{
name|font
operator|.
name|encode
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
comment|// it's over
break|break;
block|}
block|}
name|s
operator|=
name|text
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setFont
argument_list|(
name|font
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cs
operator|.
name|showText
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
comment|// didn't work, will try next font
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Could not show '"
operator|+
name|text
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|+
literal|"' with the fonts provided"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|static
name|boolean
name|isWinAnsiEncoding
parameter_list|(
name|int
name|unicode
parameter_list|)
block|{
name|String
name|name
init|=
name|GlyphList
operator|.
name|getAdobeGlyphList
argument_list|()
operator|.
name|codePointToName
argument_list|(
name|unicode
argument_list|)
decl_stmt|;
if|if
condition|(
literal|".notdef"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|WinAnsiEncoding
operator|.
name|INSTANCE
operator|.
name|contains
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
end_class

end_unit

