begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************  *   * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  *   ****************************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|schema
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|XMLConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|XMPMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|XmpConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|AbstractField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|AbstractSimpleProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|AbstractStructuredType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|ArrayProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|Attribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|BadFieldValueException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|BooleanType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|Cardinality
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|ComplexPropertyContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|DateType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|IntegerType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|TextType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|TypeMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|Types
import|;
end_import

begin_comment
comment|/**  * This class represents a metadata schema that can be stored in an XMP document. It handles all generic properties that  * are available. See subclasses for access to specific properties. MODIFIED TO INCLUDE OBJECT REPRESENTATION  *   */
end_comment

begin_class
specifier|public
class|class
name|XMPSchema
extends|extends
name|AbstractStructuredType
block|{
comment|/**      * Create a new blank schema that can be populated.      *      * @param metadata The parent XMP metadata that this schema will be part of.      * @param namespaceURI The URI of the namespace, e.g. "http://ns.adobe.com/pdf/1.3/"      * @param prefix The field prefix of the namespace.      * @param name The property name.      */
specifier|public
name|XMPSchema
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|String
name|namespaceURI
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|metadata
argument_list|,
name|namespaceURI
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|addNamespace
argument_list|(
name|getNamespace
argument_list|()
argument_list|,
name|getPrefix
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new blank schema that can be populated.      *      * @param metadata The parent XMP metadata that this schema will be part of.      */
specifier|public
name|XMPSchema
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|)
block|{
name|this
argument_list|(
name|metadata
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new blank schema that can be populated.      *      * @param metadata The parent XMP metadata that this schema will be part of.      * @param prefix The field prefix of the namespace.      */
specifier|public
name|XMPSchema
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
name|this
argument_list|(
name|metadata
argument_list|,
literal|null
argument_list|,
name|prefix
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new blank schema that can be populated.      *      * @param metadata The parent XMP metadata that this schema will be part of.      * @param namespaceURI The URI of the namespace, e.g. "http://ns.adobe.com/pdf/1.3/"      * @param prefix The field prefix of the namespace.      */
specifier|public
name|XMPSchema
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|String
name|namespaceURI
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
name|this
argument_list|(
name|metadata
argument_list|,
name|namespaceURI
argument_list|,
name|prefix
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Retrieve a generic simple type property      *       * @param qualifiedName      *            Full qualified name of property wanted      * @return The generic simple type property according to its qualified name      */
specifier|public
name|AbstractField
name|getAbstractProperty
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
for|for
control|(
name|AbstractField
name|child
range|:
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|getPropertyName
argument_list|()
operator|.
name|equals
argument_list|(
name|qualifiedName
argument_list|)
condition|)
block|{
return|return
name|child
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Get the RDF about attribute      *       * @return The RDF 'about' attribute.      */
specifier|public
name|Attribute
name|getAboutAttribute
parameter_list|()
block|{
return|return
name|getAttribute
argument_list|(
name|XmpConstants
operator|.
name|ABOUT_NAME
argument_list|)
return|;
block|}
comment|/**      * Get the RDF about value.      *       * @return The RDF 'about' value. If there is no rdf:about attribute, an empty string is returned.      */
specifier|public
name|String
name|getAboutValue
parameter_list|()
block|{
name|Attribute
name|prop
init|=
name|getAttribute
argument_list|(
name|XmpConstants
operator|.
name|ABOUT_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
return|return
name|prop
operator|.
name|getValue
argument_list|()
return|;
block|}
comment|// PDFBOX-1685 : if missing, rdf:about should be considered as empty string
return|return
literal|""
return|;
block|}
comment|/**      * Set the RDF 'about' attribute      *       * @param about      *            the well-formed attribute      * @throws BadFieldValueException      *             Bad Attribute name (not corresponding to about attribute)      */
specifier|public
name|void
name|setAbout
parameter_list|(
name|Attribute
name|about
parameter_list|)
throws|throws
name|BadFieldValueException
block|{
if|if
condition|(
name|XmpConstants
operator|.
name|RDF_NAMESPACE
operator|.
name|equals
argument_list|(
name|about
operator|.
name|getNamespace
argument_list|()
argument_list|)
operator|&&
name|XmpConstants
operator|.
name|ABOUT_NAME
operator|.
name|equals
argument_list|(
name|about
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|setAttribute
argument_list|(
name|about
argument_list|)
expr_stmt|;
return|return;
block|}
throw|throw
operator|new
name|BadFieldValueException
argument_list|(
literal|"Attribute 'about' must be named 'rdf:about' or 'about'"
argument_list|)
throw|;
block|}
comment|/**      * Set the RDF 'about' attribute. Passing in null will clear this attribute.      *       * @param about      *            The new RFD about value.      */
specifier|public
name|void
name|setAboutAsSimple
parameter_list|(
name|String
name|about
parameter_list|)
block|{
if|if
condition|(
name|about
operator|==
literal|null
condition|)
block|{
name|removeAttribute
argument_list|(
name|XmpConstants
operator|.
name|ABOUT_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setAttribute
argument_list|(
operator|new
name|Attribute
argument_list|(
name|XmpConstants
operator|.
name|RDF_NAMESPACE
argument_list|,
name|XmpConstants
operator|.
name|ABOUT_NAME
argument_list|,
name|about
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setSpecifiedSimpleTypeProperty
parameter_list|(
name|Types
name|type
parameter_list|,
name|String
name|qualifiedName
parameter_list|,
name|Object
name|propertyValue
parameter_list|)
block|{
if|if
condition|(
name|propertyValue
operator|==
literal|null
condition|)
block|{
comment|// Search in properties to erase
for|for
control|(
name|AbstractField
name|child
range|:
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|getPropertyName
argument_list|()
operator|.
name|equals
argument_list|(
name|qualifiedName
argument_list|)
condition|)
block|{
name|getContainer
argument_list|()
operator|.
name|removeProperty
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
name|AbstractSimpleProperty
name|specifiedTypeProperty
decl_stmt|;
try|try
block|{
name|TypeMapping
name|tm
init|=
name|getMetadata
argument_list|()
operator|.
name|getTypeMapping
argument_list|()
decl_stmt|;
name|specifiedTypeProperty
operator|=
name|tm
operator|.
name|instanciateSimpleProperty
argument_list|(
literal|null
argument_list|,
name|getPrefix
argument_list|()
argument_list|,
name|qualifiedName
argument_list|,
name|propertyValue
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Failed to create property with the specified type given in parameters"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// attribute placement for simple property has been removed
comment|// Search in properties to erase
for|for
control|(
name|AbstractField
name|child
range|:
name|getAllProperties
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|getPropertyName
argument_list|()
operator|.
name|equals
argument_list|(
name|qualifiedName
argument_list|)
condition|)
block|{
name|removeProperty
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|addProperty
argument_list|(
name|specifiedTypeProperty
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|addProperty
argument_list|(
name|specifiedTypeProperty
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Add a SimpleProperty to this schema      *       * @param prop      *            The Property to add      */
specifier|private
name|void
name|setSpecifiedSimpleTypeProperty
parameter_list|(
name|AbstractSimpleProperty
name|prop
parameter_list|)
block|{
comment|// attribute placement for simple property has been removed
comment|// Search in properties to erase
for|for
control|(
name|AbstractField
name|child
range|:
name|getAllProperties
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|getPropertyName
argument_list|()
operator|.
name|equals
argument_list|(
name|prop
operator|.
name|getPropertyName
argument_list|()
argument_list|)
condition|)
block|{
name|removeProperty
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|addProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|addProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set TextType property      *       * @param prop      *            The text property to add      */
specifier|public
name|void
name|setTextProperty
parameter_list|(
name|TextType
name|prop
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set a simple text property on the schema.      *       * @param qualifiedName      *            The name of the property, it must contain the namespace prefix, ie "pdf:Keywords"      * @param propertyValue      *            The value for the property, can be any string. Passing null will remove the property.      */
specifier|public
name|void
name|setTextPropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|String
name|propertyValue
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|Types
operator|.
name|Text
argument_list|,
name|qualifiedName
argument_list|,
name|propertyValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set a simple text property on the schema, using the current prefix.      *       * @param simpleName      *            the name of the property without prefix      * @param propertyValue      *            The value for the property, can be any string. Passing null will remove the property.      */
specifier|public
name|void
name|setTextPropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|String
name|propertyValue
parameter_list|)
block|{
name|this
operator|.
name|setTextPropertyValue
argument_list|(
name|simpleName
argument_list|,
name|propertyValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get a TextProperty Type from its name      *       * @param name The property name.      * @return The Text Type property wanted      */
specifier|public
name|TextType
name|getUnqualifiedTextProperty
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|TextType
condition|)
block|{
return|return
operator|(
name|TextType
operator|)
name|prop
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not a Text Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Get the value of a simple text property.      *       * @param name The property name.      * @return The value of the text property or null if there is no value.      *       */
specifier|public
name|String
name|getUnqualifiedTextPropertyValue
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|TextType
name|tt
init|=
name|getUnqualifiedTextProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|tt
operator|==
literal|null
condition|?
literal|null
else|:
name|tt
operator|.
name|getStringValue
argument_list|()
return|;
block|}
comment|/**      * Get the Date property with its name      *       * @param qualifiedName      *            The name of the property to get, it must include the namespace prefix, e.g. "pdf:Keywords".      * @return Date Type property      *       */
specifier|public
name|DateType
name|getDateProperty
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|DateType
condition|)
block|{
return|return
operator|(
name|DateType
operator|)
name|prop
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not a Date Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Get a simple date property value on the schema, using the current prefix.      *       * @param simpleName      *            the local name of the property to get      * @return The value of the property as a calendar.      *       */
specifier|public
name|Calendar
name|getDatePropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|this
operator|.
name|getDatePropertyValue
argument_list|(
name|simpleName
argument_list|)
return|;
block|}
comment|/**      * Get the value of the property as a date.      *       * @param qualifiedName      *            The fully qualified property name for the date.      *       * @return The value of the property as a date.      *       */
specifier|public
name|Calendar
name|getDatePropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|DateType
condition|)
block|{
return|return
operator|(
operator|(
name|DateType
operator|)
name|prop
operator|)
operator|.
name|getValue
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not a Date Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Set a new DateProperty      *       * @param date      *            The DateType Property      */
specifier|public
name|void
name|setDateProperty
parameter_list|(
name|DateType
name|date
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|date
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set a simple Date property on the schema, using the current prefix.      *       * @param simpleName      *            the name of the property without prefix      * @param date      *            The calendar value for the property, can be any string. Passing null will remove the property.      */
specifier|public
name|void
name|setDatePropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|this
operator|.
name|setDatePropertyValue
argument_list|(
name|simpleName
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the value of the property as a date.      *       * @param qualifiedName      *            The fully qualified property name for the date.      * @param date      *            The date to set, or null to clear.      */
specifier|public
name|void
name|setDatePropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|Types
operator|.
name|Date
argument_list|,
name|qualifiedName
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get a BooleanType property with its name      *       * @param qualifiedName      *            the full qualified name of property wanted      * @return boolean Type property      */
specifier|public
name|BooleanType
name|getBooleanProperty
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|BooleanType
condition|)
block|{
return|return
operator|(
name|BooleanType
operator|)
name|prop
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not a Boolean Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Get a simple boolean property value on the schema, using the current prefix.      *       * @param simpleName      *            the local name of property wanted      * @return The value of the property as a boolean or null if the property does not exist.      */
specifier|public
name|Boolean
name|getBooleanPropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|this
operator|.
name|getBooleanPropertyValue
argument_list|(
name|simpleName
argument_list|)
return|;
block|}
comment|/**      * Get the value of the property as a Boolean. If you want to use this value      * like a condition, you<i>must</i> do a null check before.      *      * @param qualifiedName The fully qualified property name for the Boolean.      *      * @return The value of the property as a Boolean, or null if the property      * does not exist.      */
specifier|public
name|Boolean
name|getBooleanPropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|BooleanType
condition|)
block|{
return|return
operator|(
operator|(
name|BooleanType
operator|)
name|prop
operator|)
operator|.
name|getValue
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not a Boolean Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Set a BooleanType property      *       * @param bool      *            the booleanType property      */
specifier|public
name|void
name|setBooleanProperty
parameter_list|(
name|BooleanType
name|bool
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|bool
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set a simple Boolean property on the schema, using the current prefix.      *       * @param simpleName      *            the name of the property without prefix      * @param bool      *            The value for the property, can be any string. Passing null will remove the property.      */
specifier|public
name|void
name|setBooleanPropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|Boolean
name|bool
parameter_list|)
block|{
name|this
operator|.
name|setBooleanPropertyValue
argument_list|(
name|simpleName
argument_list|,
name|bool
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the value of the property as a boolean.      *       * @param qualifiedName      *            The fully qualified property name for the boolean.      * @param bool      *            The boolean to set, or null to clear.      */
specifier|public
name|void
name|setBooleanPropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|Boolean
name|bool
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|Types
operator|.
name|Boolean
argument_list|,
name|qualifiedName
argument_list|,
name|bool
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the Integer property with its name      *       * @param qualifiedName      *            the full qualified name of property wanted      * @return Integer Type property      */
specifier|public
name|IntegerType
name|getIntegerProperty
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|IntegerType
condition|)
block|{
return|return
operator|(
operator|(
name|IntegerType
operator|)
name|prop
operator|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not an Integer Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Get a simple integer property value on the schema, using the current prefix.      *       * @param simpleName      *            the local name of property wanted      * @return The value of the property as an integer.      */
specifier|public
name|Integer
name|getIntegerPropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|this
operator|.
name|getIntegerPropertyValue
argument_list|(
name|simpleName
argument_list|)
return|;
block|}
comment|/**      * Get the value of the property as an integer.      *       * @param qualifiedName      *            The fully qualified property name for the integer.      *       * @return The value of the property as an integer.      */
specifier|public
name|Integer
name|getIntegerPropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|IntegerType
condition|)
block|{
return|return
operator|(
operator|(
name|IntegerType
operator|)
name|prop
operator|)
operator|.
name|getValue
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not an Integer Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Add an integerProperty      *       * @param prop      *            The Integer Type property      */
specifier|public
name|void
name|setIntegerProperty
parameter_list|(
name|IntegerType
name|prop
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set a simple Integer property on the schema, using the current prefix.      *       * @param simpleName      *            the name of the property without prefix      * @param intValue      *            The value for the property, can be any string. Passing null will remove the property.      */
specifier|public
name|void
name|setIntegerPropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|Integer
name|intValue
parameter_list|)
block|{
name|this
operator|.
name|setIntegerPropertyValue
argument_list|(
name|simpleName
argument_list|,
name|intValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set the value of the property as an integer.      *       * @param qualifiedName      *            The fully qualified property name for the integer.      * @param intValue      *            The int to set, or null to clear.      */
specifier|public
name|void
name|setIntegerPropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|Integer
name|intValue
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|Types
operator|.
name|Integer
argument_list|,
name|qualifiedName
argument_list|,
name|intValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Generic array property removing      *       * @param fieldValue      *            the field value      */
specifier|private
name|void
name|removeUnqualifiedArrayValue
parameter_list|(
name|String
name|arrayName
parameter_list|,
name|String
name|fieldValue
parameter_list|)
block|{
name|ArrayProperty
name|array
init|=
operator|(
name|ArrayProperty
operator|)
name|getAbstractProperty
argument_list|(
name|arrayName
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
name|toDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|array
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|AbstractSimpleProperty
name|tmp
init|=
operator|(
name|AbstractSimpleProperty
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|getStringValue
argument_list|()
operator|.
name|equals
argument_list|(
name|fieldValue
argument_list|)
condition|)
block|{
name|toDelete
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|eraseProperties
init|=
name|toDelete
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|eraseProperties
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|array
operator|.
name|getContainer
argument_list|()
operator|.
name|removeProperty
argument_list|(
name|eraseProperties
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Remove all matching entries with the given value from the bag.      *       * @param bagName The bag name.      * @param bagValue      *            The value to remove from the bagList.      */
specifier|public
name|void
name|removeUnqualifiedBagValue
parameter_list|(
name|String
name|bagName
parameter_list|,
name|String
name|bagValue
parameter_list|)
block|{
name|removeUnqualifiedArrayValue
argument_list|(
name|bagName
argument_list|,
name|bagValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * add a bag value property on the schema, using the current prefix.      *       * @param simpleName      *            the local name of property      * @param bagValue      *            the string value to add      */
specifier|public
name|void
name|addBagValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|String
name|bagValue
parameter_list|)
block|{
name|this
operator|.
name|internalAddBagValue
argument_list|(
name|simpleName
argument_list|,
name|bagValue
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|internalAddBagValue
parameter_list|(
name|String
name|qualifiedBagName
parameter_list|,
name|String
name|bagValue
parameter_list|)
block|{
name|ArrayProperty
name|bag
init|=
operator|(
name|ArrayProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedBagName
argument_list|)
decl_stmt|;
name|TextType
name|li
init|=
name|createTextType
argument_list|(
name|XmpConstants
operator|.
name|LIST_NAME
argument_list|,
name|bagValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|bag
operator|!=
literal|null
condition|)
block|{
name|bag
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ArrayProperty
name|newBag
init|=
name|createArrayProperty
argument_list|(
name|qualifiedBagName
argument_list|,
name|Cardinality
operator|.
name|Bag
argument_list|)
decl_stmt|;
name|newBag
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|li
argument_list|)
expr_stmt|;
name|addProperty
argument_list|(
name|newBag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Add an entry to a bag property.      *       * @param simpleName      *            The name of the bag without the namespace prefix      * @param bagValue      *            The value to add to the bagList.      */
specifier|public
name|void
name|addQualifiedBagValue
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|String
name|bagValue
parameter_list|)
block|{
name|internalAddBagValue
argument_list|(
name|simpleName
argument_list|,
name|bagValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get all the values of the bag property. This will return a list of java.lang.String objects, this is a read-only      * list.      *       * @param bagName The bag name.      * @return All values of the bag property in a list.      */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getUnqualifiedBagValueList
parameter_list|(
name|String
name|bagName
parameter_list|)
block|{
name|ArrayProperty
name|array
init|=
operator|(
name|ArrayProperty
operator|)
name|getAbstractProperty
argument_list|(
name|bagName
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
return|return
name|array
operator|.
name|getElementsAsString
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Remove all matching values from a sequence property.      *       * @param qualifiedSeqName      *            The name of the sequence property. It must include the namespace prefix, e.g. "pdf:Keywords".      * @param seqValue      *            The value to remove from the list.      */
specifier|public
name|void
name|removeUnqualifiedSequenceValue
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|,
name|String
name|seqValue
parameter_list|)
block|{
name|removeUnqualifiedArrayValue
argument_list|(
name|qualifiedSeqName
argument_list|,
name|seqValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Generic method to remove a field from an array with an Elementable Object      *       * @param arrayName      *            the name of the property concerned      * @param fieldValue      *            the elementable field value      */
specifier|public
name|void
name|removeUnqualifiedArrayValue
parameter_list|(
name|String
name|arrayName
parameter_list|,
name|AbstractField
name|fieldValue
parameter_list|)
block|{
name|String
name|qualifiedArrayName
init|=
name|arrayName
decl_stmt|;
name|ArrayProperty
name|array
init|=
operator|(
name|ArrayProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedArrayName
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
name|toDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|array
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|AbstractSimpleProperty
name|tmp
init|=
operator|(
name|AbstractSimpleProperty
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|equals
argument_list|(
name|fieldValue
argument_list|)
condition|)
block|{
name|toDelete
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|eraseProperties
init|=
name|toDelete
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|eraseProperties
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|array
operator|.
name|getContainer
argument_list|()
operator|.
name|removeProperty
argument_list|(
name|eraseProperties
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Remove a value from a sequence property. This will remove all entries from the list.      *       * @param qualifiedSeqName      *            The name of the sequence property. It must include the namespace prefix, e.g. "pdf:Keywords".      * @param seqValue      *            The value to remove from the list.      */
specifier|public
name|void
name|removeUnqualifiedSequenceValue
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|,
name|AbstractField
name|seqValue
parameter_list|)
block|{
name|removeUnqualifiedArrayValue
argument_list|(
name|qualifiedSeqName
argument_list|,
name|seqValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a new value to a sequence property.      *       * @param simpleSeqName      *            The name of the sequence property without the namespace prefix      * @param seqValue      *            The value to add to the sequence.      */
specifier|public
name|void
name|addUnqualifiedSequenceValue
parameter_list|(
name|String
name|simpleSeqName
parameter_list|,
name|String
name|seqValue
parameter_list|)
block|{
name|String
name|qualifiedSeqName
init|=
name|simpleSeqName
decl_stmt|;
name|ArrayProperty
name|seq
init|=
operator|(
name|ArrayProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedSeqName
argument_list|)
decl_stmt|;
name|TextType
name|li
init|=
name|createTextType
argument_list|(
name|XmpConstants
operator|.
name|LIST_NAME
argument_list|,
name|seqValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
literal|null
condition|)
block|{
name|seq
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ArrayProperty
name|newSeq
init|=
name|createArrayProperty
argument_list|(
name|simpleSeqName
argument_list|,
name|Cardinality
operator|.
name|Seq
argument_list|)
decl_stmt|;
name|newSeq
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|li
argument_list|)
expr_stmt|;
name|addProperty
argument_list|(
name|newSeq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Add a new value to a bag property.      *       * @param qualifiedSeqName      *            The name of the sequence property, it must include the namespace prefix, e.g. "pdf:Keywords"      * @param seqValue      *            The value to add to the bag.      */
specifier|public
name|void
name|addBagValue
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|,
name|AbstractField
name|seqValue
parameter_list|)
block|{
name|ArrayProperty
name|bag
init|=
operator|(
name|ArrayProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedSeqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|bag
operator|!=
literal|null
condition|)
block|{
name|bag
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|seqValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ArrayProperty
name|newBag
init|=
name|createArrayProperty
argument_list|(
name|qualifiedSeqName
argument_list|,
name|Cardinality
operator|.
name|Bag
argument_list|)
decl_stmt|;
name|newBag
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|seqValue
argument_list|)
expr_stmt|;
name|addProperty
argument_list|(
name|newBag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Add a new value to a sequence property.      *       * @param seqName      *            The name of the sequence property, it must include the namespace prefix, e.g. "pdf:Keywords"      * @param seqValue      *            The value to add to the sequence.      */
specifier|public
name|void
name|addUnqualifiedSequenceValue
parameter_list|(
name|String
name|seqName
parameter_list|,
name|AbstractField
name|seqValue
parameter_list|)
block|{
name|String
name|qualifiedSeqName
init|=
name|seqName
decl_stmt|;
name|ArrayProperty
name|seq
init|=
operator|(
name|ArrayProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedSeqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
literal|null
condition|)
block|{
name|seq
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|seqValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ArrayProperty
name|newSeq
init|=
name|createArrayProperty
argument_list|(
name|seqName
argument_list|,
name|Cardinality
operator|.
name|Seq
argument_list|)
decl_stmt|;
name|newSeq
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|seqValue
argument_list|)
expr_stmt|;
name|addProperty
argument_list|(
name|newSeq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get all the values in a sequence property.      *       * @param seqName      *            The name of the sequence property without namespace prefix.      *       * @return A read-only list of java.lang.String objects or null if the property does not exist.      */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getUnqualifiedSequenceValueList
parameter_list|(
name|String
name|seqName
parameter_list|)
block|{
name|ArrayProperty
name|array
init|=
operator|(
name|ArrayProperty
operator|)
name|getAbstractProperty
argument_list|(
name|seqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
return|return
name|array
operator|.
name|getElementsAsString
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Remove a date sequence value from the list.      *       * @param seqName      *            The name of the sequence property, it must include the namespace prefix, e.g. "pdf:Keywords"      * @param date      *            The date to remove from the sequence property.      */
specifier|public
name|void
name|removeUnqualifiedSequenceDateValue
parameter_list|(
name|String
name|seqName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|String
name|qualifiedSeqName
init|=
name|seqName
decl_stmt|;
name|ArrayProperty
name|seq
init|=
operator|(
name|ArrayProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedSeqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
name|toDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|seq
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|AbstractField
name|tmp
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmp
operator|instanceof
name|DateType
operator|&&
operator|(
operator|(
name|DateType
operator|)
name|tmp
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|date
argument_list|)
condition|)
block|{
name|toDelete
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|eraseProperties
init|=
name|toDelete
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|eraseProperties
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|seq
operator|.
name|getContainer
argument_list|()
operator|.
name|removeProperty
argument_list|(
name|eraseProperties
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Add a date sequence value to the list using the current prefix      *       * @param simpleName      *            the local name of the property      * @param date      *            the value to add      */
specifier|public
name|void
name|addSequenceDateValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|addUnqualifiedSequenceDateValue
argument_list|(
name|simpleName
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a date sequence value to the list.      *       * @param seqName      *            The name of the sequence property, it must include the namespace prefix, e.g. "pdf:Keywords"      * @param date      *            The date to add to the sequence property.      */
specifier|public
name|void
name|addUnqualifiedSequenceDateValue
parameter_list|(
name|String
name|seqName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|addUnqualifiedSequenceValue
argument_list|(
name|seqName
argument_list|,
name|getMetadata
argument_list|()
operator|.
name|getTypeMapping
argument_list|()
operator|.
name|createDate
argument_list|(
literal|null
argument_list|,
name|XmpConstants
operator|.
name|DEFAULT_RDF_LOCAL_NAME
argument_list|,
name|XmpConstants
operator|.
name|LIST_NAME
argument_list|,
name|date
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get all the date values in a sequence property.      *       * @param seqName      *            The name of the sequence property, it must include the namespace prefix, e.g. "pdf:Keywords".      *       * @return A read-only list of java.util.Calendar objects or null if the property does not exist.      *       */
specifier|public
name|List
argument_list|<
name|Calendar
argument_list|>
name|getUnqualifiedSequenceDateValueList
parameter_list|(
name|String
name|seqName
parameter_list|)
block|{
name|String
name|qualifiedSeqName
init|=
name|seqName
decl_stmt|;
name|List
argument_list|<
name|Calendar
argument_list|>
name|retval
init|=
literal|null
decl_stmt|;
name|ArrayProperty
name|seq
init|=
operator|(
name|ArrayProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedSeqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
operator|new
name|ArrayList
argument_list|<
name|Calendar
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|AbstractField
name|child
range|:
name|seq
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|instanceof
name|DateType
condition|)
block|{
name|retval
operator|.
name|add
argument_list|(
operator|(
operator|(
name|DateType
operator|)
name|child
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Method used to place the 'x-default' value in first in Language alternatives as said in xmp spec      *       * @param alt      *            The property to reorganize      */
specifier|public
name|void
name|reorganizeAltOrder
parameter_list|(
name|ComplexPropertyContainer
name|alt
parameter_list|)
block|{
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|alt
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|xdefault
init|=
literal|null
decl_stmt|;
name|boolean
name|xdefaultFound
init|=
literal|false
decl_stmt|;
comment|// If alternatives contains x-default in first value
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
operator|&&
name|it
operator|.
name|next
argument_list|()
operator|.
name|getAttribute
argument_list|(
name|XmpConstants
operator|.
name|LANG_NAME
argument_list|)
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|XmpConstants
operator|.
name|X_DEFAULT
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Find the xdefault definition
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|xdefaultFound
condition|)
block|{
name|xdefault
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|xdefault
operator|.
name|getAttribute
argument_list|(
name|XmpConstants
operator|.
name|LANG_NAME
argument_list|)
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|XmpConstants
operator|.
name|X_DEFAULT
argument_list|)
condition|)
block|{
name|alt
operator|.
name|removeProperty
argument_list|(
name|xdefault
argument_list|)
expr_stmt|;
name|xdefaultFound
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xdefaultFound
condition|)
block|{
name|it
operator|=
name|alt
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
name|reordered
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
name|toDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|()
decl_stmt|;
name|reordered
operator|.
name|add
argument_list|(
name|xdefault
argument_list|)
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|AbstractField
name|tmp
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|reordered
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|toDelete
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|eraseProperties
init|=
name|toDelete
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|eraseProperties
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|alt
operator|.
name|removeProperty
argument_list|(
name|eraseProperties
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|it
operator|=
name|reordered
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|alt
operator|.
name|addProperty
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Set the value of a multi-lingual property.      *       * @param name      *            The name of the property, it must include the namespace prefix, e.g. "pdf:Keywords"      * @param language      *            The language code of the value. If null then "x-default" is assumed.      * @param value      *            The value of the property in the specified language.      */
specifier|public
name|void
name|setUnqualifiedLanguagePropertyValue
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|language
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|String
name|qualifiedName
init|=
name|name
decl_stmt|;
name|AbstractField
name|property
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
name|ArrayProperty
name|arrayProp
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
block|{
comment|// Analyzing content of property
if|if
condition|(
name|property
operator|instanceof
name|ArrayProperty
condition|)
block|{
name|arrayProp
operator|=
operator|(
name|ArrayProperty
operator|)
name|property
expr_stmt|;
comment|// Try to find a definition
for|for
control|(
name|AbstractField
name|child
range|:
name|arrayProp
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
control|)
block|{
comment|// try to find the same lang definition
if|if
condition|(
name|child
operator|.
name|getAttribute
argument_list|(
name|XmpConstants
operator|.
name|LANG_NAME
argument_list|)
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|language
argument_list|)
condition|)
block|{
comment|// the same language has been found
name|arrayProp
operator|.
name|getContainer
argument_list|()
operator|.
name|removeProperty
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|TextType
name|langValue
init|=
name|createTextType
argument_list|(
name|XmpConstants
operator|.
name|LIST_NAME
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|langValue
operator|.
name|setAttribute
argument_list|(
operator|new
name|Attribute
argument_list|(
name|XMLConstants
operator|.
name|XML_NS_URI
argument_list|,
name|XmpConstants
operator|.
name|LANG_NAME
argument_list|,
name|language
argument_list|)
argument_list|)
expr_stmt|;
name|arrayProp
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|langValue
argument_list|)
expr_stmt|;
block|}
name|reorganizeAltOrder
argument_list|(
name|arrayProp
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// if no definition found, we add a new one
name|TextType
name|langValue
init|=
name|createTextType
argument_list|(
name|XmpConstants
operator|.
name|LIST_NAME
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|langValue
operator|.
name|setAttribute
argument_list|(
operator|new
name|Attribute
argument_list|(
name|XMLConstants
operator|.
name|XML_NS_URI
argument_list|,
name|XmpConstants
operator|.
name|LANG_NAME
argument_list|,
name|language
argument_list|)
argument_list|)
expr_stmt|;
name|arrayProp
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|langValue
argument_list|)
expr_stmt|;
name|reorganizeAltOrder
argument_list|(
name|arrayProp
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|arrayProp
operator|=
name|createArrayProperty
argument_list|(
name|name
argument_list|,
name|Cardinality
operator|.
name|Alt
argument_list|)
expr_stmt|;
name|TextType
name|langValue
init|=
name|createTextType
argument_list|(
name|XmpConstants
operator|.
name|LIST_NAME
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|langValue
operator|.
name|setAttribute
argument_list|(
operator|new
name|Attribute
argument_list|(
name|XMLConstants
operator|.
name|XML_NS_URI
argument_list|,
name|XmpConstants
operator|.
name|LANG_NAME
argument_list|,
name|language
argument_list|)
argument_list|)
expr_stmt|;
name|arrayProp
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|langValue
argument_list|)
expr_stmt|;
name|addProperty
argument_list|(
name|arrayProp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get the value of a multi-lingual property.      *       * @param name      *            The name of the property, without the namespace prefix.      * @param expectedLanguage      *            The language code of the value. If null then "x-default" is assumed.      *       * @return The value of the language property.      */
specifier|public
name|String
name|getUnqualifiedLanguagePropertyValue
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|expectedLanguage
parameter_list|)
block|{
name|String
name|language
init|=
operator|(
name|expectedLanguage
operator|!=
literal|null
operator|)
condition|?
name|expectedLanguage
else|:
name|XmpConstants
operator|.
name|X_DEFAULT
decl_stmt|;
name|AbstractField
name|property
init|=
name|getAbstractProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|property
operator|instanceof
name|ArrayProperty
condition|)
block|{
name|ArrayProperty
name|arrayProp
init|=
operator|(
name|ArrayProperty
operator|)
name|property
decl_stmt|;
for|for
control|(
name|AbstractField
name|child
range|:
name|arrayProp
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
control|)
block|{
name|Attribute
name|text
init|=
name|child
operator|.
name|getAttribute
argument_list|(
name|XmpConstants
operator|.
name|LANG_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
operator|!=
literal|null
operator|&&
name|text
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|language
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|TextType
operator|)
name|child
operator|)
operator|.
name|getStringValue
argument_list|()
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The property '"
operator|+
name|name
operator|+
literal|"' is not of Lang Alt type"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Get a list of all languages that are currently defined for a specific      * property.      *      * @param name The name of the property, it must include the namespace      * prefix, e.g. "pdf:Keywords".      *      * @return A list of all languages, this will return an non-null empty list      * if none have been defined, and null if the property doesn't exist.      */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getUnqualifiedLanguagePropertyLanguagesValue
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|AbstractField
name|property
init|=
name|getAbstractProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|property
operator|instanceof
name|ArrayProperty
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|retval
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayProperty
name|arrayProp
init|=
operator|(
name|ArrayProperty
operator|)
name|property
decl_stmt|;
for|for
control|(
name|AbstractField
name|child
range|:
name|arrayProp
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
control|)
block|{
name|Attribute
name|text
init|=
name|child
operator|.
name|getAttribute
argument_list|(
name|XmpConstants
operator|.
name|LANG_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
operator|!=
literal|null
condition|)
block|{
name|retval
operator|.
name|add
argument_list|(
name|text
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|.
name|add
argument_list|(
name|XmpConstants
operator|.
name|X_DEFAULT
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The property '"
operator|+
name|name
operator|+
literal|"' is not of Lang Alt type"
argument_list|)
throw|;
block|}
block|}
comment|// no property with that name
return|return
literal|null
return|;
block|}
comment|/**      * A basic schema merge, it merges bags and sequences and replace everything else.      *       * @param xmpSchema      *            The schema to merge.      * @throws IOException      *             If there is an error during the merge.      */
specifier|public
name|void
name|merge
parameter_list|(
name|XMPSchema
name|xmpSchema
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|xmpSchema
operator|.
name|getClass
argument_list|()
operator|.
name|equals
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can only merge schemas of the same type."
argument_list|)
throw|;
block|}
for|for
control|(
name|Attribute
name|att
range|:
name|xmpSchema
operator|.
name|getAllAttributes
argument_list|()
control|)
block|{
if|if
condition|(
name|att
operator|.
name|getNamespace
argument_list|()
operator|.
name|equals
argument_list|(
name|getNamespace
argument_list|()
argument_list|)
condition|)
block|{
name|setAttribute
argument_list|(
name|att
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|analyzedPropQualifiedName
decl_stmt|;
for|for
control|(
name|AbstractField
name|child
range|:
name|xmpSchema
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|getPrefix
argument_list|()
operator|.
name|equals
argument_list|(
name|getPrefix
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|child
operator|instanceof
name|ArrayProperty
condition|)
block|{
name|analyzedPropQualifiedName
operator|=
name|child
operator|.
name|getPropertyName
argument_list|()
expr_stmt|;
for|for
control|(
name|AbstractField
name|tmpEmbeddedProperty
range|:
name|getAllProperties
argument_list|()
control|)
block|{
if|if
condition|(
name|tmpEmbeddedProperty
operator|instanceof
name|ArrayProperty
operator|&&
name|tmpEmbeddedProperty
operator|.
name|getPropertyName
argument_list|()
operator|.
name|equals
argument_list|(
name|analyzedPropQualifiedName
argument_list|)
condition|)
block|{
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|itNewValues
init|=
operator|(
operator|(
name|ArrayProperty
operator|)
name|child
operator|)
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|mergeComplexProperty
argument_list|(
name|itNewValues
argument_list|,
operator|(
name|ArrayProperty
operator|)
name|tmpEmbeddedProperty
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
else|else
block|{
name|addProperty
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|boolean
name|mergeComplexProperty
parameter_list|(
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|itNewValues
parameter_list|,
name|ArrayProperty
name|arrayProperty
parameter_list|)
block|{
while|while
condition|(
name|itNewValues
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|TextType
name|tmpNewValue
init|=
operator|(
name|TextType
operator|)
name|itNewValues
operator|.
name|next
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|itOldValues
init|=
name|arrayProperty
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itOldValues
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|TextType
name|tmpOldValue
init|=
operator|(
name|TextType
operator|)
name|itOldValues
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmpOldValue
operator|.
name|getStringValue
argument_list|()
operator|.
name|equals
argument_list|(
name|tmpNewValue
operator|.
name|getStringValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
name|arrayProperty
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|tmpNewValue
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Get an AbstractField list corresponding to the content of an array      * property.      *      * @param name The property name whitout namespace.      * @return List of properties contained in the array property.      * @throws BadFieldValueException If the property with the requested name isn't an array.      */
specifier|public
name|List
argument_list|<
name|AbstractField
argument_list|>
name|getUnqualifiedArrayList
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|BadFieldValueException
block|{
name|ArrayProperty
name|array
init|=
literal|null
decl_stmt|;
for|for
control|(
name|AbstractField
name|child
range|:
name|getAllProperties
argument_list|()
control|)
block|{
if|if
condition|(
name|child
operator|.
name|getPropertyName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|child
operator|instanceof
name|ArrayProperty
condition|)
block|{
name|array
operator|=
operator|(
name|ArrayProperty
operator|)
name|child
expr_stmt|;
break|break;
block|}
throw|throw
operator|new
name|BadFieldValueException
argument_list|(
literal|"Property asked is not an array"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|(
name|array
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|protected
name|AbstractSimpleProperty
name|instanciateSimple
parameter_list|(
name|String
name|param
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|TypeMapping
name|tm
init|=
name|getMetadata
argument_list|()
operator|.
name|getTypeMapping
argument_list|()
decl_stmt|;
return|return
name|tm
operator|.
name|instanciateSimpleField
argument_list|(
name|getClass
argument_list|()
argument_list|,
literal|null
argument_list|,
name|getPrefix
argument_list|()
argument_list|,
name|param
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
end_class

end_unit

