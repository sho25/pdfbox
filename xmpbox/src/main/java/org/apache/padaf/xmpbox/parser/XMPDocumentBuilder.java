begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************  *   * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  *   ****************************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|parser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLInputFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|CreateXMPMetadataException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|XMPMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|schema
operator|.
name|PDFAExtensionSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|schema
operator|.
name|PDFAFieldDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|schema
operator|.
name|SchemaDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|schema
operator|.
name|XMPSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|AbstractSimpleProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|Attribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|BadFieldValueException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|BooleanType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|ComplexProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|ComplexPropertyContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|DateType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|IntegerType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|RealType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|TextType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|ThumbnailType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_comment
comment|/**  * Parse serialized XMP (in XML/RDF Format) to the XmpBox representation.  *   * @author a183132  *   */
end_comment

begin_class
specifier|public
class|class
name|XMPDocumentBuilder
block|{
specifier|protected
name|NSMapping
name|nsMap
decl_stmt|;
specifier|protected
name|ThreadLocal
argument_list|<
name|XMLStreamReader
argument_list|>
name|reader
init|=
operator|new
name|ThreadLocal
argument_list|<
name|XMLStreamReader
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
name|List
argument_list|<
name|XMPDocumentPreprocessor
argument_list|>
name|preprocessors
init|=
operator|new
name|ArrayList
argument_list|<
name|XMPDocumentPreprocessor
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|BAG_NAME
init|=
literal|"Bag"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|SEQ_NAME
init|=
literal|"Seq"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ALT_NAME
init|=
literal|"Alt"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|VALUE_TYPE_NAME
init|=
literal|"valueType"
decl_stmt|;
comment|/** 	 * Constructor of a XMPDocumentBuilder 	 *  	 * @throws XmpSchemaException 	 *             When instancing schema object failed or in PDF/A Extension 	 *             case, if its namespace miss 	 */
specifier|public
name|XMPDocumentBuilder
parameter_list|()
throws|throws
name|XmpSchemaException
block|{
name|nsMap
operator|=
operator|new
name|NSMapping
argument_list|()
expr_stmt|;
block|}
comment|/** 	 * Parsing method. Return a XMPMetadata object with all elements read 	 *  	 * @param xmp 	 *            serialized XMP 	 * @return Metadata with all information read 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XmpSchemaException 	 *             When instancing schema object failed or in PDF/A Extension 	 *             case, if its namespace miss 	 * @throws XmpUnknownValueTypeException 	 *             When ValueType found not correspond to basic type and not has 	 *             been declared in current schema 	 * @throws XmpExpectedRdfAboutAttribute 	 *             When rdf:Description not contains rdf:about attribute 	 * @throws XmpXpacketEndException 	 *             When xpacket end Processing Instruction is missing or is 	 *             incorrect 	 * @throws BadFieldValueException 	 *             When treat a Schema associed to a schema Description in PDF/A 	 *             Extension schema 	 */
specifier|public
name|XMPMetadata
name|parse
parameter_list|(
name|byte
index|[]
name|xmp
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XmpSchemaException
throws|,
name|XmpUnknownValueTypeException
throws|,
name|XmpExpectedRdfAboutAttribute
throws|,
name|XmpXpacketEndException
throws|,
name|BadFieldValueException
block|{
if|if
condition|(
operator|!
operator|(
name|this
operator|instanceof
name|XMPDocumentPreprocessor
operator|)
condition|)
block|{
for|for
control|(
name|XMPDocumentPreprocessor
name|processor
range|:
name|preprocessors
control|)
block|{
name|NSMapping
name|additionalNSMapping
init|=
name|processor
operator|.
name|process
argument_list|(
name|xmp
argument_list|)
decl_stmt|;
name|this
operator|.
name|nsMap
operator|.
name|importNSMapping
argument_list|(
name|additionalNSMapping
argument_list|)
expr_stmt|;
block|}
block|}
name|ByteArrayInputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|xmp
argument_list|)
decl_stmt|;
try|try
block|{
name|XMLInputFactory
name|factory
init|=
name|XMLInputFactory
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|reader
operator|.
name|set
argument_list|(
name|factory
operator|.
name|createXMLStreamReader
argument_list|(
name|is
argument_list|)
argument_list|)
expr_stmt|;
comment|// expect xpacket processing instruction
name|expectNext
argument_list|(
name|XMLStreamReader
operator|.
name|PROCESSING_INSTRUCTION
argument_list|,
literal|"Did not find initial xpacket processing instruction"
argument_list|)
expr_stmt|;
name|XMPMetadata
name|metadata
init|=
name|parseInitialXpacket
argument_list|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getPIData
argument_list|()
argument_list|)
decl_stmt|;
comment|// expect x:xmpmeta
name|expectNextTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
literal|"Did not find initial x:xmpmeta"
argument_list|)
expr_stmt|;
name|expectName
argument_list|(
literal|"adobe:ns:meta/"
argument_list|,
literal|"xmpmeta"
argument_list|)
expr_stmt|;
comment|// expect rdf:RDF
name|expectNextTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
literal|"Did not find initial rdf:RDF"
argument_list|)
expr_stmt|;
name|expectName
argument_list|(
literal|"http://www.w3.org/1999/02/22-rdf-syntax-ns#"
argument_list|,
literal|"RDF"
argument_list|)
expr_stmt|;
name|nsMap
operator|.
name|resetComplexBasicTypesDeclarationInEntireXMPLevel
argument_list|()
expr_stmt|;
comment|// add all namespaces which could declare nsURI of a basicValueType
comment|// all others declarations are ignored
name|int
name|nsCount
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nsCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nsMap
operator|.
name|isComplexBasicTypes
argument_list|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|nsMap
operator|.
name|setComplexBasicTypesDeclarationForLevelXMP
argument_list|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|(
name|i
argument_list|)
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespacePrefix
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now work on each rdf:Description
name|int
name|type
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
while|while
condition|(
name|type
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
condition|)
block|{
name|parseDescription
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|type
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
comment|// all description are finished
comment|// expect end of rdf:RDF
name|expectType
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
literal|"Expected end of descriptions"
argument_list|)
expr_stmt|;
name|expectName
argument_list|(
literal|"http://www.w3.org/1999/02/22-rdf-syntax-ns#"
argument_list|,
literal|"RDF"
argument_list|)
expr_stmt|;
comment|// expect ending xmpmeta
name|expectNextTag
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
literal|"Did not find initial x:xmpmeta"
argument_list|)
expr_stmt|;
name|expectName
argument_list|(
literal|"adobe:ns:meta/"
argument_list|,
literal|"xmpmeta"
argument_list|)
expr_stmt|;
comment|// expect final processing instruction
name|expectNext
argument_list|(
name|XMLStreamReader
operator|.
name|PROCESSING_INSTRUCTION
argument_list|,
literal|"Did not find final xpacket processing instruction"
argument_list|)
expr_stmt|;
comment|// treats xpacket end
if|if
condition|(
operator|!
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getPITarget
argument_list|()
operator|.
name|equals
argument_list|(
literal|"xpacket"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|XmpXpacketEndException
argument_list|(
literal|"Excepted PI xpacket"
argument_list|)
throw|;
block|}
name|String
name|xpackData
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getPIData
argument_list|()
decl_stmt|;
comment|// end attribute must be present and placed in first
comment|// xmp spec says Other unrecognized attributes can follow, but
comment|// should be ignored
if|if
condition|(
name|xpackData
operator|.
name|startsWith
argument_list|(
literal|"end="
argument_list|)
condition|)
block|{
comment|// check value (5 for end='X')
if|if
condition|(
name|xpackData
operator|.
name|charAt
argument_list|(
literal|5
argument_list|)
operator|!=
literal|'r'
operator|&&
name|xpackData
operator|.
name|charAt
argument_list|(
literal|5
argument_list|)
operator|!=
literal|'w'
condition|)
block|{
throw|throw
operator|new
name|XmpXpacketEndException
argument_list|(
literal|"Excepted xpacket 'end' attribute with value 'r' or 'w' "
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// should find end='r/w'
throw|throw
operator|new
name|XmpXpacketEndException
argument_list|(
literal|"Excepted xpacket 'end' attribute (must be present and placed in first)"
argument_list|)
throw|;
block|}
name|metadata
operator|.
name|setEndXPacket
argument_list|(
name|xpackData
argument_list|)
expr_stmt|;
comment|// return constructed object
return|return
name|metadata
return|;
block|}
catch|catch
parameter_list|(
name|XMLStreamException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"An error has occured when processing the underlying XMP source"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|reader
operator|.
name|remove
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Parsing method using serialized xmp read from a stream 	 *  	 * @param is 	 *            The stream to read 	 * @return Metadata with all information read 	 * @throws XmpParsingException 	 *             When element expected not found When element expected not 	 *             found 	 * @throws XmpSchemaException 	 *             When instancing schema object failed or in PDF/A Extension 	 *             case, if its namespace miss 	 * @throws XmpUnknownValueTypeException 	 *             When ValueType found not correspond to basic type and not has 	 *             been declared in current schema 	 * @throws XmpExpectedRdfAboutAttribute 	 *             When rdf:Description not contains rdf:about attribute 	 * @throws XmpXpacketEndException 	 *             When xpacket end Processing Instruction is missing or is 	 *             incorrect 	 * @throws BadFieldValueException 	 *             When treat a Schema associed to a schema Description in PDF/A 	 *             Extension schema 	 */
specifier|public
name|XMPMetadata
name|parse
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XmpSchemaException
throws|,
name|XmpUnknownValueTypeException
throws|,
name|XmpExpectedRdfAboutAttribute
throws|,
name|XmpXpacketEndException
throws|,
name|BadFieldValueException
block|{
name|byte
index|[]
name|bos
init|=
name|getStreamAsByteArray
argument_list|(
name|input
argument_list|)
decl_stmt|;
return|return
name|parse
argument_list|(
name|bos
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|getStreamAsByteArray
parameter_list|(
name|InputStream
name|input
parameter_list|)
throws|throws
name|XmpParsingException
block|{
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
try|try
block|{
name|IOUtils
operator|.
name|copy
argument_list|(
name|input
argument_list|,
name|bos
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"An error has occured when processing the underlying XMP source"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|bos
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
return|return
name|bos
operator|.
name|toByteArray
argument_list|()
return|;
block|}
specifier|public
name|void
name|addPreprocessor
parameter_list|(
name|XMPDocumentPreprocessor
name|processor
parameter_list|)
block|{
name|this
operator|.
name|preprocessors
operator|.
name|add
argument_list|(
name|processor
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Check InitialXPacket and build metadata object with these information 	 *  	 * @param data 	 *            data corresponding to Initial XPacket Processing Instruction 	 *            Processing Information corresponding to Inital XPacket data 	 * @return Metadata with specified information 	 * @throws XmpInitialXPacketParsingException 	 *             When Initial XPacket missing or is incorrect 	 * @throws CreateXMPMetadataException 	 *             If DOM Document associated could not be created 	 */
specifier|protected
name|XMPMetadata
name|parseInitialXpacket
parameter_list|(
name|String
name|data
parameter_list|)
throws|throws
name|XmpInitialXPacketParsingException
throws|,
name|CreateXMPMetadataException
block|{
name|StringTokenizer
name|tokens
init|=
operator|new
name|StringTokenizer
argument_list|(
name|data
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
name|String
name|id
init|=
literal|null
decl_stmt|;
name|String
name|begin
init|=
literal|null
decl_stmt|;
name|String
name|bytes
init|=
literal|null
decl_stmt|;
name|String
name|encoding
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|tokens
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|token
init|=
name|tokens
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|token
operator|.
name|endsWith
argument_list|(
literal|"\""
argument_list|)
operator|&&
operator|!
name|token
operator|.
name|endsWith
argument_list|(
literal|"\'"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|XmpInitialXPacketParsingException
argument_list|(
literal|"Cannot understand PI data part : '"
operator|+
name|token
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|String
name|quote
init|=
name|token
operator|.
name|substring
argument_list|(
name|token
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|token
operator|.
name|indexOf
argument_list|(
literal|"="
operator|+
name|quote
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|XmpInitialXPacketParsingException
argument_list|(
literal|"Cannot understand PI data part : '"
operator|+
name|token
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|String
name|name
init|=
name|token
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|token
operator|.
name|substring
argument_list|(
name|pos
operator|+
literal|2
argument_list|,
name|token
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"id"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|id
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"begin"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|begin
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"bytes"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|bytes
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"encoding"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|encoding
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpInitialXPacketParsingException
argument_list|(
literal|"Unknown attribute in xpacket PI : '"
operator|+
name|token
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
return|return
operator|new
name|XMPMetadata
argument_list|(
name|begin
argument_list|,
name|id
argument_list|,
name|bytes
argument_list|,
name|encoding
argument_list|)
return|;
block|}
comment|/** 	 * Check the next element type. all comments are ignored. 	 *  	 * @param expectType 	 *            Type of xml element expected 	 * @param message 	 *            Error message if problems occur 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XmpUnexpectedTypeException 	 *             When DOM Element type found unexpected When DOM Element type 	 *             found unexpected 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream When error 	 *             during reading the rest of xmp stream 	 */
specifier|private
name|void
name|expectNext
parameter_list|(
name|int
name|expectType
parameter_list|,
name|String
name|message
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XmpUnexpectedTypeException
throws|,
name|XMLStreamException
block|{
try|try
block|{
name|int
name|type
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|type
operator|==
name|XMLStreamReader
operator|.
name|COMMENT
operator|||
name|type
operator|==
name|XMLStreamReader
operator|.
name|SPACE
condition|)
block|{
name|type
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|expectType
condition|)
block|{
throw|throw
operator|new
name|XmpUnexpectedTypeException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
comment|// unexpected end of stream
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"XMP Stream did not end in a good way, invalid content"
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Check the next element type. White spaces , Comments and Processing 	 * Instructions are ignored. 	 *  	 * @param type 	 *            Type of xml element expected 	 * @param message 	 *            Error message if problems occur 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XmpUnexpectedTypeException 	 *             When DOM Element type found unexpected 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 */
specifier|private
name|void
name|expectNextTag
parameter_list|(
name|int
name|type
parameter_list|,
name|String
name|message
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XmpUnexpectedTypeException
throws|,
name|XMLStreamException
block|{
try|try
block|{
if|if
condition|(
operator|!
operator|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
operator|==
name|type
operator|)
condition|)
block|{
throw|throw
operator|new
name|XmpUnexpectedTypeException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|e
parameter_list|)
block|{
comment|// unexpected end of stream
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"XMP Stream did not end in a good way, invalid content"
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * check if qualified name of current element is what is expected 	 *  	 * @param namespace 	 *            namespace URI 	 * @param name 	 *            current element name 	 * @throws XmpUnexpectedElementQualifiedNameException 	 *             When a qualifiedName found and is not that expected 	 *  	 */
specifier|private
name|void
name|expectName
parameter_list|(
name|String
name|namespace
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|XmpUnexpectedElementQualifiedNameException
block|{
if|if
condition|(
operator|!
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|()
operator|.
name|equals
argument_list|(
name|namespace
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|XmpUnexpectedElementQualifiedNameException
argument_list|(
literal|"Expected '"
operator|+
name|namespace
operator|+
literal|"' and found '"
operator|+
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|XmpUnexpectedElementQualifiedNameException
argument_list|(
literal|"Expected '"
operator|+
name|name
operator|+
literal|"' and found '"
operator|+
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Check the current element type. 	 *  	 * @param type 	 *            XML element type expected 	 * @param message 	 *            Error Message if problems occur 	 * @throws XmpUnexpectedTypeException 	 *             When DOM Element type found unexpected 	 */
specifier|private
name|void
name|expectType
parameter_list|(
name|int
name|type
parameter_list|,
name|String
name|message
parameter_list|)
throws|throws
name|XmpUnexpectedTypeException
block|{
if|if
condition|(
operator|!
operator|(
name|type
operator|==
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getEventType
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|XmpUnexpectedTypeException
argument_list|(
literal|"Expected type "
operator|+
name|type
operator|+
literal|" and found "
operator|+
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getEventType
argument_list|()
operator|+
literal|" : "
operator|+
name|message
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Check if rdf:about attribute is declared for rdf description and add all 	 * attributes to the schema 	 *  	 * @param metadata 	 *            Metadata to attach new elements 	 * @param schema 	 *            Schema corresponding to the rdf:Description use 	 * @throws XmpExpectedRdfAboutAttribute 	 *             When rdf:Description not contains rdf:about attribute 	 * @throws XmpUnexpectedTypeException if the attribute is known  	 * as an expected property but the property type isn't a Simple type. 	 */
specifier|protected
specifier|final
name|void
name|treatDescriptionAttributes
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|XMPSchema
name|schema
parameter_list|)
throws|throws
name|XmpExpectedRdfAboutAttribute
throws|,
name|XmpUnexpectedTypeException
block|{
name|int
name|cptAtt
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributeCount
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|boolean
name|rdfAboutFound
init|=
literal|false
decl_stmt|;
name|String
name|prefix
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|cptAtt
condition|)
block|{
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributeLocalName
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
literal|"about"
argument_list|)
condition|)
block|{
name|prefix
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributePrefix
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|prefix
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|&&
operator|!
name|prefix
operator|.
name|equals
argument_list|(
literal|"rdf"
argument_list|)
condition|)
block|{
comment|// System.out.println("prefix de l'attribut "+reader.get().getAttributeLocalName(i)+": "+prefix);
throw|throw
operator|new
name|XmpExpectedRdfAboutAttribute
argument_list|(
literal|"An about attribute is present but have an invalid prefix (it must be 'rdf')"
argument_list|)
throw|;
block|}
block|}
name|rdfAboutFound
operator|=
literal|true
expr_stmt|;
block|}
name|Attribute
name|attr
init|=
operator|new
name|Attribute
argument_list|(
literal|null
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributePrefix
argument_list|(
name|i
argument_list|)
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributeLocalName
argument_list|(
name|i
argument_list|)
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|addAttributeAsProperty
argument_list|(
name|metadata
argument_list|,
name|schema
argument_list|,
name|attr
argument_list|)
condition|)
block|{
comment|// attribute isn't a property, so add the attribute
name|schema
operator|.
name|setAttribute
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rdfAboutFound
condition|)
block|{
comment|// create rdf:about if not found
name|Attribute
name|attr
init|=
operator|new
name|Attribute
argument_list|(
literal|null
argument_list|,
literal|"rdf"
argument_list|,
literal|"about"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|schema
operator|.
name|setAttribute
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * If the attribute has same the name as an expected property of the Schema, then the property is created using the attributes fields. 	 *  	 * @param metadata Metadata to attach new elements 	 * @param schema Schema corresponding to the rdf:Description use 	 * @param attr the attribute used to create the property 	 * @return true if the attribute has been converted into Property 	 */
specifier|private
name|boolean
name|addAttributeAsProperty
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|XMPSchema
name|schema
parameter_list|,
name|Attribute
name|attr
parameter_list|)
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
name|String
name|schemaNamespace
init|=
name|schema
operator|.
name|getNamespaceValue
argument_list|()
decl_stmt|;
name|String
name|prefix
init|=
name|attr
operator|.
name|getPrefix
argument_list|()
operator|!=
literal|null
condition|?
name|attr
operator|.
name|getPrefix
argument_list|()
else|:
name|schema
operator|.
name|getPrefix
argument_list|()
decl_stmt|;
name|String
name|type
init|=
name|this
operator|.
name|nsMap
operator|.
name|getSpecifiedPropertyType
argument_list|(
name|schemaNamespace
argument_list|,
operator|new
name|QName
argument_list|(
name|schemaNamespace
argument_list|,
name|attr
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|prefix
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Text"
argument_list|)
condition|)
block|{
name|schema
operator|.
name|getContent
argument_list|()
operator|.
name|addProperty
argument_list|(
operator|new
name|TextType
argument_list|(
name|metadata
argument_list|,
name|prefix
argument_list|,
name|attr
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Integer"
argument_list|)
condition|)
block|{
name|schema
operator|.
name|getContent
argument_list|()
operator|.
name|addProperty
argument_list|(
operator|new
name|IntegerType
argument_list|(
name|metadata
argument_list|,
name|prefix
argument_list|,
name|attr
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Boolean"
argument_list|)
condition|)
block|{
name|schema
operator|.
name|getContent
argument_list|()
operator|.
name|addProperty
argument_list|(
operator|new
name|BooleanType
argument_list|(
name|metadata
argument_list|,
name|prefix
argument_list|,
name|attr
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Real"
argument_list|)
condition|)
block|{
name|schema
operator|.
name|getContent
argument_list|()
operator|.
name|addProperty
argument_list|(
operator|new
name|RealType
argument_list|(
name|metadata
argument_list|,
name|prefix
argument_list|,
name|attr
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Date"
argument_list|)
condition|)
block|{
name|schema
operator|.
name|getContent
argument_list|()
operator|.
name|addProperty
argument_list|(
operator|new
name|DateType
argument_list|(
name|metadata
argument_list|,
name|prefix
argument_list|,
name|attr
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"URI"
argument_list|)
condition|)
block|{
name|schema
operator|.
name|getContent
argument_list|()
operator|.
name|addProperty
argument_list|(
operator|new
name|TextType
argument_list|(
name|metadata
argument_list|,
name|prefix
argument_list|,
name|attr
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"URL"
argument_list|)
condition|)
block|{
name|schema
operator|.
name|getContent
argument_list|()
operator|.
name|addProperty
argument_list|(
operator|new
name|TextType
argument_list|(
name|metadata
argument_list|,
name|prefix
argument_list|,
name|attr
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|attr
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|added
return|;
block|}
comment|/** 	 * Treat each rdf:Description (which must represent a schema), instanciate 	 * class representation of this schema and add it to metadata 	 *  	 * @param metadata 	 *            Metadata to attach new elements 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws XmpSchemaException 	 *             When instancing schema object failed or in PDF/A Extension 	 *             case, if its namespace miss 	 * @throws XmpUnknownValueTypeException 	 *             When ValueType found not correspond to basic type and not has 	 *             been declared in current schema 	 * @throws XmpExpectedRdfAboutAttribute 	 *             When rdf:Description not contains rdf:about attribute 	 * @throws BadFieldValueException 	 *             When a bad value found in Schema description content 	 */
specifier|protected
name|void
name|parseDescription
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|XmpSchemaException
throws|,
name|XmpUnknownValueTypeException
throws|,
name|XmpExpectedRdfAboutAttribute
throws|,
name|BadFieldValueException
block|{
name|nsMap
operator|.
name|resetComplexBasicTypesDeclarationInSchemaLevel
argument_list|()
expr_stmt|;
name|int
name|cptNS
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceCount
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|namespaces
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cptNS
condition|;
name|i
operator|++
control|)
block|{
name|namespaces
operator|.
name|put
argument_list|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespacePrefix
argument_list|(
name|i
argument_list|)
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsMap
operator|.
name|isComplexBasicTypes
argument_list|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
comment|// System.out.println("in parseDesc method: prefix:"+reader.get().getNamespacePrefix(i)+", nsURI:"+reader.get().getNamespaceURI(i));
name|nsMap
operator|.
name|setComplexBasicTypesDeclarationForLevelSchema
argument_list|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|(
name|i
argument_list|)
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespacePrefix
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Different treatment for PDF/A Extension schema
comment|// System.out.println(PDFAExtensionSchema.PDFAEXTENSION+";"+PDFAExtensionSchema.PDFAPROPERTY+";"+PDFAExtensionSchema.PDFASCHEMA);
if|if
condition|(
name|namespaces
operator|.
name|containsKey
argument_list|(
name|PDFAExtensionSchema
operator|.
name|PDFAEXTENSION
argument_list|)
condition|)
block|{
if|if
condition|(
name|namespaces
operator|.
name|containsKey
argument_list|(
name|PDFAExtensionSchema
operator|.
name|PDFAPROPERTY
argument_list|)
operator|&&
name|namespaces
operator|.
name|containsKey
argument_list|(
name|PDFAExtensionSchema
operator|.
name|PDFASCHEMA
argument_list|)
condition|)
block|{
if|if
condition|(
name|namespaces
operator|.
name|containsValue
argument_list|(
name|PDFAExtensionSchema
operator|.
name|PDFAEXTENSIONURI
argument_list|)
operator|&&
name|namespaces
operator|.
name|containsValue
argument_list|(
name|PDFAExtensionSchema
operator|.
name|PDFAPROPERTYURI
argument_list|)
operator|&&
name|namespaces
operator|.
name|containsValue
argument_list|(
name|PDFAExtensionSchema
operator|.
name|PDFASCHEMAURI
argument_list|)
condition|)
block|{
name|PDFAExtensionSchema
name|schema
init|=
name|metadata
operator|.
name|createAndAddPDFAExtensionSchemaWithNS
argument_list|(
name|namespaces
argument_list|)
decl_stmt|;
name|treatDescriptionAttributes
argument_list|(
name|metadata
argument_list|,
name|schema
argument_list|)
expr_stmt|;
name|parseExtensionSchema
argument_list|(
name|schema
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpUnexpectedNamespaceURIException
argument_list|(
literal|"Unexpected namespaceURI in PDFA Extension Schema encountered"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|XmpUnexpectedNamespacePrefixException
argument_list|(
literal|"Unexpected namespace Prefix in PDFA Extension Schema"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|int
name|c
init|=
literal|0
decl_stmt|;
name|String
name|namespaceUri
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|String
name|namespacePrefix
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespacePrefix
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|c
operator|++
expr_stmt|;
name|XMPSchema
name|schema
init|=
name|nsMap
operator|.
name|getAssociatedSchemaObject
argument_list|(
name|metadata
argument_list|,
name|namespaceUri
argument_list|,
name|namespacePrefix
argument_list|)
decl_stmt|;
while|while
condition|(
name|c
operator|<
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceCount
argument_list|()
operator|&&
name|schema
operator|==
literal|null
condition|)
block|{
comment|// try next
name|namespaceUri
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|namespacePrefix
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespacePrefix
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|schema
operator|=
name|nsMap
operator|.
name|getAssociatedSchemaObject
argument_list|(
name|metadata
argument_list|,
name|namespaceUri
argument_list|,
name|namespacePrefix
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|schema
operator|!=
literal|null
condition|)
block|{
name|namespaces
operator|.
name|remove
argument_list|(
name|namespacePrefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|schema
operator|=
name|metadata
operator|.
name|createAndAddDefaultSchema
argument_list|(
name|namespacePrefix
argument_list|,
name|namespaceUri
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|cptNS
condition|;
name|i
operator|++
control|)
block|{
name|schema
operator|.
name|setAttribute
argument_list|(
operator|new
name|Attribute
argument_list|(
name|XMPSchema
operator|.
name|NS_NAMESPACE
argument_list|,
literal|"xmlns"
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespacePrefix
argument_list|(
name|i
argument_list|)
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|treatDescriptionAttributes
argument_list|(
name|metadata
argument_list|,
name|schema
argument_list|)
expr_stmt|;
while|while
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
condition|)
block|{
name|parseProperty
argument_list|(
name|schema
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * Check the next element type and its expected value 	 *  	 * @param type 	 *            expected type of xml element 	 * @param localNameExpected 	 *            The property name (local) expected 	 * @param message 	 *            Error message if problems occur 	 * @throws XmpUnexpectedTypeException 	 *             When DOM Element type found unexpected 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 */
specifier|private
name|void
name|expectNextSpecificTag
parameter_list|(
name|int
name|type
parameter_list|,
name|String
name|localNameExpected
parameter_list|,
name|String
name|message
parameter_list|)
throws|throws
name|XmpUnexpectedTypeException
throws|,
name|XmpParsingException
throws|,
name|XMLStreamException
block|{
name|expectNextTag
argument_list|(
name|type
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|expectCurrentLocalName
argument_list|(
name|localNameExpected
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * check that the current local name is that expected 	 *  	 * @param localNameExpected 	 *            The name expected 	 * @throws XmpUnexpectedElementException 	 *             When Element is not that expected 	 */
specifier|protected
name|void
name|expectCurrentLocalName
parameter_list|(
name|String
name|localNameExpected
parameter_list|)
throws|throws
name|XmpUnexpectedElementException
block|{
if|if
condition|(
operator|!
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
name|localNameExpected
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|XmpUnexpectedElementException
argument_list|(
literal|"'"
operator|+
name|localNameExpected
operator|+
literal|"' expected and '"
operator|+
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|+
literal|"' found at "
operator|+
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocation
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Treat a PDFAExtension schema 	 *  	 * @param schema 	 *            PDFA/Extension schema where save information found 	 * @param metadata 	 *            Metadata to attach new elements 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws XmpUnknownValueTypeException 	 *             When ValueType found not correspond to basic type and not has 	 *             been declared in current schema 	 * @throws BadFieldValueException 	 *             When one of a field property include to describe a property 	 *             in Schema Description contain an incorrect value 	 */
specifier|protected
specifier|final
name|void
name|parseExtensionSchema
parameter_list|(
name|PDFAExtensionSchema
name|schema
parameter_list|,
name|XMPMetadata
name|metadata
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|XmpUnknownValueTypeException
throws|,
name|BadFieldValueException
block|{
comment|//<pdfaExtension:schemas>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
literal|"schemas"
argument_list|,
literal|"Cannot find container declaration of schemas descriptions "
argument_list|)
expr_stmt|;
comment|//<rdf:Bag>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
name|BAG_NAME
argument_list|,
literal|"Cannot find bag declaration for container of schemas descriptions"
argument_list|)
expr_stmt|;
comment|// now work on each rdf:li corresponding to each schema description
name|int
name|type
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
while|while
condition|(
name|type
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
condition|)
block|{
name|parseSchemaDescription
argument_list|(
name|schema
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
name|type
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
literal|"schemas"
argument_list|,
literal|"Cannot find end of container declaration in schemas descriptions "
argument_list|)
expr_stmt|;
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
literal|"Description"
argument_list|,
literal|"Cannot find end of PDF/A Extension definition "
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Treat one Schema description defined in the extension Schema found 	 *  	 * @param schema 	 *            PDFA/Extension schema where save information found 	 * @param metadata 	 *            Metadata to attach new elements 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XmpUnknownValueTypeException 	 *             When ValueType found not correspond to basic type and not has 	 *             been declared in current schema 	 * @throws BadFieldValueException 	 *             When one of a field property contain an incorrect value 	 */
specifier|private
name|void
name|parseSchemaDescription
parameter_list|(
name|PDFAExtensionSchema
name|schema
parameter_list|,
name|XMPMetadata
name|metadata
parameter_list|)
throws|throws
name|XMLStreamException
throws|,
name|XmpParsingException
throws|,
name|XmpUnknownValueTypeException
throws|,
name|BadFieldValueException
block|{
name|expectCurrentLocalName
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
name|SchemaDescription
name|desc
init|=
name|schema
operator|.
name|createSchemaDescription
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"Resource"
operator|.
name|equals
argument_list|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributeValue
argument_list|(
literal|"http://www.w3.org/1999/02/22-rdf-syntax-ns#"
argument_list|,
literal|"parseType"
argument_list|)
argument_list|)
condition|)
block|{
name|fillSchemaDescription
argument_list|(
name|desc
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|type
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
operator|&&
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"Description"
argument_list|)
condition|)
block|{
name|fillSchemaDescription
argument_list|(
name|desc
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
comment|// read the end tag
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// ?? TODO
block|}
block|}
name|schema
operator|.
name|addSchemaDescription
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|nsMap
operator|.
name|setNamespaceDefinition
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|fillSchemaDescription
parameter_list|(
name|SchemaDescription
name|desc
parameter_list|,
name|XMPMetadata
name|metadata
parameter_list|)
throws|throws
name|XMLStreamException
throws|,
name|XmpParsingException
throws|,
name|XmpUnknownValueTypeException
throws|,
name|BadFieldValueException
block|{
name|int
name|type
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
while|while
condition|(
name|type
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
condition|)
block|{
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"schema"
argument_list|)
operator|||
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"namespaceURI"
argument_list|)
operator|||
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"prefix"
argument_list|)
condition|)
block|{
try|try
block|{
comment|// System.out.println(reader.get().getPrefix()+";"+reader.get().getLocalName()+";"+reader.get().getElementText());
name|desc
operator|.
name|addProperty
argument_list|(
operator|new
name|TextType
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpPropertyFormatException
argument_list|(
literal|"Unexpected value for '"
operator|+
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|+
literal|"' property"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"property"
argument_list|)
condition|)
block|{
name|parsePropertyDefinition
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
name|VALUE_TYPE_NAME
argument_list|)
condition|)
block|{
name|parseValueTypeDefinition
argument_list|(
name|desc
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpUnexpectedElementException
argument_list|(
literal|"Unexpected property definition in one of PDF/A Extension schemas description"
argument_list|)
throw|;
block|}
name|type
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** 	 * Treat value type definition for a specific Schema Description 	 *  	 * @param desc 	 *            the current Schema Description analyzed 	 * @param metadata 	 *            Metadata to attach new elements 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 */
specifier|private
name|void
name|parseValueTypeDefinition
parameter_list|(
name|SchemaDescription
name|desc
parameter_list|,
name|XMPMetadata
name|metadata
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XMLStreamException
block|{
comment|//<rdf:Seq>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
name|SEQ_NAME
argument_list|,
literal|"Expected Seq Declaration"
argument_list|)
expr_stmt|;
name|int
name|elmtType
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
name|String
name|type
decl_stmt|,
name|namespaceURI
decl_stmt|,
name|prefix
decl_stmt|,
name|description
decl_stmt|;
name|List
argument_list|<
name|PDFAFieldDescription
argument_list|>
name|fields
decl_stmt|;
while|while
condition|(
name|elmtType
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
condition|)
block|{
name|type
operator|=
literal|null
expr_stmt|;
name|namespaceURI
operator|=
literal|null
expr_stmt|;
name|prefix
operator|=
literal|null
expr_stmt|;
name|description
operator|=
literal|null
expr_stmt|;
name|fields
operator|=
literal|null
expr_stmt|;
name|expectCurrentLocalName
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
while|while
condition|(
name|elmtType
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
condition|)
block|{
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"type"
argument_list|)
condition|)
block|{
name|type
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"namespaceURI"
argument_list|)
condition|)
block|{
name|namespaceURI
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"prefix"
argument_list|)
condition|)
block|{
name|prefix
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"description"
argument_list|)
condition|)
block|{
name|description
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"field"
argument_list|)
condition|)
block|{
name|fields
operator|=
name|parseFieldDescription
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpUnexpectedElementException
argument_list|(
literal|"Unexpected property definition in one of ValueType Descriptions of PDF/A Extension schemas description"
argument_list|)
throw|;
block|}
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|namespaceURI
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|prefix
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|description
operator|!=
literal|null
operator|)
condition|)
block|{
name|desc
operator|.
name|addValueType
argument_list|(
name|type
argument_list|,
name|namespaceURI
argument_list|,
name|prefix
argument_list|,
name|description
argument_list|,
name|fields
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpRequiredPropertyException
argument_list|(
literal|"one property declaration in PDF/A Extension is not complete"
argument_list|)
throw|;
block|}
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
name|VALUE_TYPE_NAME
argument_list|,
literal|"Expected End of ValueType Declaration"
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Treat field description on the current analyzed value type description 	 *  	 * @param metadata 	 *            Metadata to attach new elements 	 * @return A list of parsed fields 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws XmpParsingException 	 *             When element expected not found 	 */
specifier|private
name|List
argument_list|<
name|PDFAFieldDescription
argument_list|>
name|parseFieldDescription
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XMLStreamException
block|{
name|List
argument_list|<
name|PDFAFieldDescription
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<
name|PDFAFieldDescription
argument_list|>
argument_list|()
decl_stmt|;
comment|//<rdf:Seq>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
name|SEQ_NAME
argument_list|,
literal|"Expected Seq Declaration"
argument_list|)
expr_stmt|;
name|int
name|elmtType
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
name|String
name|name
decl_stmt|,
name|type
decl_stmt|,
name|description
decl_stmt|;
while|while
condition|(
name|elmtType
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
condition|)
block|{
name|expectCurrentLocalName
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
name|name
operator|=
literal|null
expr_stmt|;
name|type
operator|=
literal|null
expr_stmt|;
name|description
operator|=
literal|null
expr_stmt|;
while|while
condition|(
name|elmtType
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
condition|)
block|{
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"name"
argument_list|)
condition|)
block|{
name|name
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
name|VALUE_TYPE_NAME
argument_list|)
condition|)
block|{
name|type
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"description"
argument_list|)
condition|)
block|{
name|description
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpUnexpectedElementException
argument_list|(
literal|"Unexpected property definition in one of ValueType Field Descriptions of PDF/A Extension schemas description"
argument_list|)
throw|;
block|}
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|name
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|type
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|description
operator|!=
literal|null
operator|)
condition|)
block|{
name|PDFAFieldDescription
name|tmp
init|=
operator|new
name|PDFAFieldDescription
argument_list|(
name|metadata
argument_list|)
decl_stmt|;
name|tmp
operator|.
name|setNameValue
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setValueTypeValue
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|setDescriptionValue
argument_list|(
name|description
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpRequiredPropertyException
argument_list|(
literal|"One valuetype field declaration in PDF/A Extension is not complete"
argument_list|)
throw|;
block|}
comment|// expectNextTag(XMLStreamReader.END_ELEMENT,"Expected element end");
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
literal|"field"
argument_list|,
literal|"Expected End of Properties Declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|fields
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Treat a property definition for a specific Schema Description 	 *  	 * @param desc 	 *            the current Schema Description analyzed 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws BadFieldValueException 	 *             When one of a field property contain an incorrect value 	 */
specifier|private
name|void
name|parsePropertyDefinition
parameter_list|(
name|SchemaDescription
name|desc
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|BadFieldValueException
block|{
comment|//<rdf:Seq>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
name|SEQ_NAME
argument_list|,
literal|"Expected Seq Declaration"
argument_list|)
expr_stmt|;
comment|// Each property definition
name|int
name|elmtType
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
while|while
condition|(
name|elmtType
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
condition|)
block|{
name|expectCurrentLocalName
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"Resource"
operator|.
name|equals
argument_list|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributeValue
argument_list|(
literal|"http://www.w3.org/1999/02/22-rdf-syntax-ns#"
argument_list|,
literal|"parseType"
argument_list|)
argument_list|)
condition|)
block|{
name|fillDescription
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
if|if
condition|(
name|elmtType
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
operator|&&
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"Description"
argument_list|)
condition|)
block|{
name|fillDescription
argument_list|(
name|desc
argument_list|)
expr_stmt|;
comment|// read the end tag
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// ?? TODO
block|}
block|}
comment|// expectNextTag(XMLStreamReader.END_ELEMENT,"Expected element end");
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
literal|"property"
argument_list|,
literal|"Expected End of Properties Declaration"
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|fillDescription
parameter_list|(
name|SchemaDescription
name|desc
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|BadFieldValueException
block|{
name|int
name|elmtType
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
name|String
name|name
init|=
literal|null
decl_stmt|;
name|String
name|type
init|=
literal|null
decl_stmt|;
name|String
name|category
init|=
literal|null
decl_stmt|;
name|String
name|description
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|elmtType
operator|==
name|XMLStreamReader
operator|.
name|START_ELEMENT
condition|)
block|{
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"name"
argument_list|)
condition|)
block|{
name|name
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
name|VALUE_TYPE_NAME
argument_list|)
condition|)
block|{
name|type
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"category"
argument_list|)
condition|)
block|{
name|category
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getLocalName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"description"
argument_list|)
condition|)
block|{
name|description
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpUnexpectedElementException
argument_list|(
literal|"Unexpected property definition in one of Properties Descriptions of PDF/A Extension schemas description"
argument_list|)
throw|;
block|}
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|name
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|type
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|category
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|description
operator|!=
literal|null
operator|)
condition|)
block|{
name|desc
operator|.
name|addProperty
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|category
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpRequiredPropertyException
argument_list|(
literal|"one property declaration in PDF/A Extension is not complete"
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Check for all namespaces declared for the specified schema if the 	 * property searched exists and return its type or null 	 *  	 * @param schema 	 *            The Schema to analyze 	 * @param prop 	 *            The property Qualified Name 	 * @return The property value type or null if not found in schema 	 * @throws XmpParsingException 	 *             When element expected not found 	 */
specifier|private
name|String
name|getPropertyDeclarationInNamespaces
parameter_list|(
name|XMPSchema
name|schema
parameter_list|,
name|QName
name|prop
parameter_list|)
throws|throws
name|XmpParsingException
block|{
name|Iterator
argument_list|<
name|Attribute
argument_list|>
name|it
init|=
name|schema
operator|.
name|getAllAttributes
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Attribute
name|tmp
decl_stmt|;
name|ArrayList
argument_list|<
name|Attribute
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|Attribute
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|getPrefix
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|tmp
operator|.
name|getPrefix
argument_list|()
operator|.
name|equals
argument_list|(
literal|"xmlns"
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|it
operator|=
name|list
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|String
name|type
decl_stmt|;
name|StringBuffer
name|unknownNS
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|namespace
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nsMap
operator|.
name|isContainedNamespace
argument_list|(
name|namespace
argument_list|)
condition|)
block|{
name|unknownNS
operator|.
name|append
argument_list|(
literal|" '"
argument_list|)
operator|.
name|append
argument_list|(
name|namespace
argument_list|)
operator|.
name|append
argument_list|(
literal|"' "
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|type
operator|=
name|nsMap
operator|.
name|getSpecifiedPropertyType
argument_list|(
name|namespace
argument_list|,
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
return|return
name|type
return|;
block|}
block|}
name|String
name|uns
init|=
name|unknownNS
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|uns
operator|==
literal|null
operator|)
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|uns
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|XmpUnknownPropertyException
argument_list|(
literal|"Cannot find a description for '"
operator|+
name|prop
operator|.
name|getLocalPart
argument_list|()
operator|+
literal|"' property"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpUnknownSchemaException
argument_list|(
literal|"Cannot find a definition for the namespace "
operator|+
name|uns
operator|+
literal|" "
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Build a property with the specific type defined in schema or complex 	 * property and add it to the object representation 	 *  	 * @param metadata 	 *            Metadata to attach new elements 	 * @param propertyName 	 *            The fully qualified name of the property 	 * @param stype 	 *            Type of the property 	 * @param container 	 *            the entity where place the property representation 	 * @throws XmpUnknownPropertyTypeException 	 *             Value Type property is incorrect or the basic value type 	 *             can't be treat at the moment 	 * @throws XmpPropertyFormatException 	 *             Unexpected type found (IllegalArgumentException) 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 */
specifier|protected
name|void
name|parseXmpSimpleProperty
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|QName
name|propertyName
parameter_list|,
name|XmpPropertyType
name|stype
parameter_list|,
name|ComplexPropertyContainer
name|container
parameter_list|)
throws|throws
name|XmpUnknownPropertyTypeException
throws|,
name|XmpPropertyFormatException
throws|,
name|XMLStreamException
block|{
try|try
block|{
name|AbstractSimpleProperty
name|prop
init|=
literal|null
decl_stmt|;
name|ArrayList
argument_list|<
name|Attribute
argument_list|>
name|attributes
init|=
operator|new
name|ArrayList
argument_list|<
name|Attribute
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|cpt
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributeCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cpt
condition|;
name|i
operator|++
control|)
block|{
name|attributes
operator|.
name|add
argument_list|(
operator|new
name|Attribute
argument_list|(
literal|null
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributePrefix
argument_list|(
name|i
argument_list|)
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributeLocalName
argument_list|(
name|i
argument_list|)
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stype
operator|==
name|XmpPropertyType
operator|.
name|Text
condition|)
block|{
name|prop
operator|=
operator|new
name|TextType
argument_list|(
name|metadata
argument_list|,
name|propertyName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|propertyName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stype
operator|==
name|XmpPropertyType
operator|.
name|Integer
condition|)
block|{
name|prop
operator|=
operator|new
name|IntegerType
argument_list|(
name|metadata
argument_list|,
name|propertyName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|propertyName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stype
operator|==
name|XmpPropertyType
operator|.
name|Date
condition|)
block|{
name|prop
operator|=
operator|new
name|DateType
argument_list|(
name|metadata
argument_list|,
name|propertyName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|propertyName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stype
operator|==
name|XmpPropertyType
operator|.
name|Boolean
condition|)
block|{
name|prop
operator|=
operator|new
name|BooleanType
argument_list|(
name|metadata
argument_list|,
name|propertyName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|propertyName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stype
operator|==
name|XmpPropertyType
operator|.
name|Real
condition|)
block|{
name|prop
operator|=
operator|new
name|RealType
argument_list|(
name|metadata
argument_list|,
name|propertyName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|propertyName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
name|container
operator|.
name|addProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
comment|// ADD ATTRIBUTES
for|for
control|(
name|Attribute
name|att
range|:
name|attributes
control|)
block|{
name|prop
operator|.
name|setAttribute
argument_list|(
name|att
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|XmpUnknownPropertyTypeException
argument_list|(
literal|"Unknown simple type found"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpPropertyFormatException
argument_list|(
literal|"Unexpected type found for the property '"
operator|+
name|propertyName
operator|.
name|getLocalPart
argument_list|()
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Parse a bag property (unordered array) with the specific type defined in 	 * schema or complex property and add it to the object representation 	 *  	 * @param metadata 	 *            Metadata to attach new elements 	 * @param bagName 	 *            name of bag property 	 * @param stype 	 *            type of values contained in this bag 	 * @param container 	 *            the entity where place the property representation 	 * @throws XmpUnexpectedTypeException 	 *             When DOM Element type found unexpected 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws XmpUnknownPropertyTypeException 	 *             Value Type property is incorrect or the basic value type 	 *             can't be treat at the moment 	 * @throws XmpPropertyFormatException 	 *             Unexpected type found (IllegalArgumentException) 	 */
specifier|protected
name|void
name|parseBagProperty
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|QName
name|bagName
parameter_list|,
name|XmpPropertyType
name|stype
parameter_list|,
name|ComplexPropertyContainer
name|container
parameter_list|)
throws|throws
name|XmpUnexpectedTypeException
throws|,
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|XmpUnknownPropertyTypeException
throws|,
name|XmpPropertyFormatException
block|{
name|ComplexProperty
name|bag
init|=
operator|new
name|ComplexProperty
argument_list|(
name|metadata
argument_list|,
name|bagName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|bagName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|ComplexProperty
operator|.
name|UNORDERED_ARRAY
argument_list|)
decl_stmt|;
name|container
operator|.
name|addProperty
argument_list|(
name|bag
argument_list|)
expr_stmt|;
comment|//<rdf:Bag>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
name|BAG_NAME
argument_list|,
literal|"Expected Bag Declaration"
argument_list|)
expr_stmt|;
comment|// Each property definition
name|int
name|elmtType
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|elmtType
operator|!=
name|XMLStreamReader
operator|.
name|END_ELEMENT
operator|)
operator|&&
operator|!
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
name|BAG_NAME
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|stype
argument_list|,
name|bag
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
name|bagName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
literal|"Expected end of Bag property"
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|parseComplexBagProperty
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|QName
name|bagName
parameter_list|,
name|StructuredPropertyParser
name|complexParser
parameter_list|,
name|ComplexPropertyContainer
name|container
parameter_list|)
throws|throws
name|XmpUnexpectedTypeException
throws|,
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|XmpUnknownPropertyTypeException
throws|,
name|XmpPropertyFormatException
block|{
name|ComplexProperty
name|bag
init|=
operator|new
name|ComplexProperty
argument_list|(
name|metadata
argument_list|,
name|bagName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|bagName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|ComplexProperty
operator|.
name|UNORDERED_ARRAY
argument_list|)
decl_stmt|;
name|container
operator|.
name|addProperty
argument_list|(
name|bag
argument_list|)
expr_stmt|;
comment|//<rdf:Bag>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
name|BAG_NAME
argument_list|,
literal|"Expected Bag Declaration"
argument_list|)
expr_stmt|;
comment|// Each property definition
name|int
name|elmtType
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|elmtType
operator|!=
name|XMLStreamReader
operator|.
name|END_ELEMENT
operator|)
operator|&&
operator|!
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
name|BAG_NAME
argument_list|)
condition|)
block|{
name|complexParser
operator|.
name|parse
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|bag
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
name|bagName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
literal|"Expected end of Bag property"
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Parse a seq property (ordered array) with the specific type defined in 	 * schema or complex property and add it to the object representation 	 *  	 * @param metadata 	 *            Metadata to attach new elements 	 * @param seqName 	 *            name of the seq 	 * @param stype 	 *            type of values contained in this bag 	 * @param container 	 *            the entity where place the property representation 	 * @throws XmpUnexpectedTypeException 	 *             When DOM Element type found unexpected 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws XmpUnknownPropertyTypeException 	 *             Value Type property is incorrect or the basic value type 	 *             can't be treat at the moment 	 * @throws XmpPropertyFormatException 	 *             Unexpected type found (IllegalArgumentException) 	 */
specifier|protected
name|void
name|parseSeqProperty
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|QName
name|seqName
parameter_list|,
name|XmpPropertyType
name|stype
parameter_list|,
name|ComplexPropertyContainer
name|container
parameter_list|)
throws|throws
name|XmpUnexpectedTypeException
throws|,
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|XmpUnknownPropertyTypeException
throws|,
name|XmpPropertyFormatException
block|{
name|ComplexProperty
name|seq
init|=
operator|new
name|ComplexProperty
argument_list|(
name|metadata
argument_list|,
name|seqName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|seqName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|ComplexProperty
operator|.
name|ORDERED_ARRAY
argument_list|)
decl_stmt|;
name|container
operator|.
name|addProperty
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|//<rdf:Bag>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
name|SEQ_NAME
argument_list|,
literal|"Expected Seq Declaration"
argument_list|)
expr_stmt|;
comment|// Each property definition
name|int
name|elmtType
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|elmtType
operator|!=
name|XMLStreamReader
operator|.
name|END_ELEMENT
operator|)
operator|&&
operator|!
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
name|SEQ_NAME
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|stype
argument_list|,
name|seq
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
name|seqName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
literal|"Expected end of Seq property"
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Parse Alt property (Alternative language property) with the specific type 	 * defined in schema or complex property and add it to the object 	 * representation 	 *  	 * @param metadata 	 *            Metadata to attach new elements 	 * @param altName 	 *            name of Alt property 	 * @param stype 	 *            type of values contained in this bag 	 * @param container 	 *            the entity where place the property representation 	 * @throws XmpUnexpectedTypeException 	 *             When DOM Element type found unexpected 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws XmpUnknownPropertyTypeException 	 *             Value Type property is incorrect or the basic value type 	 *             can't be treat at the moment 	 * @throws XmpPropertyFormatException 	 *             Unexpected type found (IllegalArgumentException) 	 */
specifier|protected
name|void
name|parseAltProperty
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|QName
name|altName
parameter_list|,
name|XmpPropertyType
name|stype
parameter_list|,
name|ComplexPropertyContainer
name|container
parameter_list|)
throws|throws
name|XmpUnexpectedTypeException
throws|,
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|XmpUnknownPropertyTypeException
throws|,
name|XmpPropertyFormatException
block|{
name|ComplexProperty
name|alt
init|=
operator|new
name|ComplexProperty
argument_list|(
name|metadata
argument_list|,
name|altName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|altName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|ComplexProperty
operator|.
name|ALTERNATIVE_ARRAY
argument_list|)
decl_stmt|;
name|container
operator|.
name|addProperty
argument_list|(
name|alt
argument_list|)
expr_stmt|;
comment|//<rdf:Alt>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
name|ALT_NAME
argument_list|,
literal|"Expected Alt Declaration"
argument_list|)
expr_stmt|;
name|int
name|elmtType
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|elmtType
operator|==
name|XMLStreamReader
operator|.
name|END_ELEMENT
operator|)
operator|&&
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
name|ALT_NAME
argument_list|)
operator|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|stype
argument_list|,
name|alt
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
comment|//<dc:description><rdf:Alt><rdf:li>sujet</rdf:li></rdf:Alt></dc:description>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
name|altName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
literal|"Expected end of alt property"
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Create a property in a specified container (complexproperty or schema) 	 *  	 * @param metadata 	 *            Metadata to attach new elements 	 * @param type 	 *            type of value contained in the property 	 * @param container 	 *            the entity where place the property representation 	 * @return True if property has been treated (according to its type) 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XmpUnexpectedTypeException 	 *             When DOM Element type found unexpected 	 * @throws XmpUnknownPropertyTypeException 	 *             Value Type property is incorrect or the basic value type 	 *             can't be treat at the moment 	 * @throws XmpPropertyFormatException 	 *             Unexpected type found (IllegalArgumentException) 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 */
specifier|private
name|boolean
name|createAndAddPropertyToContainer
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|String
name|type
parameter_list|,
name|ComplexPropertyContainer
name|container
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XmpUnexpectedTypeException
throws|,
name|XmpUnknownPropertyTypeException
throws|,
name|XmpPropertyFormatException
throws|,
name|XMLStreamException
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Text"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Integer"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Integer
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Boolean"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Boolean
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Real"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Real
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Date"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Date
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"URI"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"URL"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"bag Text"
argument_list|)
condition|)
block|{
name|parseBagProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"bag ProperName"
argument_list|)
condition|)
block|{
name|parseBagProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"bag Job"
argument_list|)
condition|)
block|{
name|parseComplexBagProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|JobParser
argument_list|(
name|this
argument_list|)
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"bag Xpath"
argument_list|)
condition|)
block|{
name|parseBagProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"seq Text"
argument_list|)
condition|)
block|{
name|parseSeqProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"seq Field"
argument_list|)
condition|)
block|{
name|parseSeqProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"seq Date"
argument_list|)
condition|)
block|{
name|parseSeqProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Date
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Lang Alt"
argument_list|)
condition|)
block|{
name|parseAltProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/** 	 * Parse a specific field 	 *  	 * @param metadata 	 *            Metadata to attach new elements 	 * @param propertyName 	 *            the full qualified name of this property 	 * @param schema 	 *            The schema where save this property 	 * @throws XmpUnexpectedTypeException 	 *             When DOM Element type found unexpected 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws XmpUnknownPropertyTypeException 	 *             Value Type property is incorrect or the basic value type 	 *             can't be treat at the moment 	 * @throws XmpPropertyFormatException 	 *             Unexpected type found (IllegalArgumentException) 	 */
specifier|protected
name|void
name|parseFieldProperty
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|QName
name|propertyName
parameter_list|,
name|XMPSchema
name|schema
parameter_list|)
throws|throws
name|XmpUnexpectedTypeException
throws|,
name|XmpPropertyFormatException
throws|,
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|XmpUnknownPropertyTypeException
block|{
name|ComplexPropertyContainer
name|field
init|=
operator|new
name|ComplexPropertyContainer
argument_list|(
name|metadata
argument_list|,
name|propertyName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|propertyName
operator|.
name|getLocalPart
argument_list|()
argument_list|)
decl_stmt|;
name|schema
operator|.
name|addProperty
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|field
operator|.
name|setAttribute
argument_list|(
operator|new
name|Attribute
argument_list|(
literal|null
argument_list|,
literal|"rdf"
argument_list|,
literal|"parseType"
argument_list|,
literal|"Resource"
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|type
decl_stmt|;
name|int
name|elmtType
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|elmtType
operator|!=
name|XMLStreamReader
operator|.
name|END_ELEMENT
operator|)
operator|&&
operator|!
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
name|SEQ_NAME
argument_list|)
condition|)
block|{
name|type
operator|=
name|getPropertyDeclarationInNamespaces
argument_list|(
name|schema
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|createAndAddPropertyToContainer
argument_list|(
name|metadata
argument_list|,
name|type
argument_list|,
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Field"
argument_list|)
condition|)
block|{
name|String
name|stype
init|=
name|getPropertyDeclarationInNamespaces
argument_list|(
name|schema
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|createAndAddPropertyToContainer
argument_list|(
name|metadata
argument_list|,
name|stype
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpUnknownPropertyTypeException
argument_list|(
literal|"Unknown type : "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
name|expectCurrentLocalName
argument_list|(
name|propertyName
operator|.
name|getLocalPart
argument_list|()
argument_list|)
expr_stmt|;
comment|// expectNextSpecificTag(XMLStreamReader.END_ELEMENT,
comment|// propertyName.getLocalPart(), "Expected end of field declaration");
block|}
comment|/** 	 * analyze one property in the stream, retrieve its type according to the 	 * schema information and call its object representation building 	 *  	 * @param schema 	 *            The schema where find information 	 * @param metadata 	 *            Metadata to attach new elements 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMPUnexpectedTypeException 	 *             When DOM Element type found unexpected 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws XmpUnknownPropertyTypeException 	 *             Value Type property is incorrect or the basic value type 	 *             can't be treat at the moment 	 * @throws XmpPropertyFormatException 	 *             Unexpected type found (IllegalArgumentException) 	 */
specifier|protected
name|void
name|parseProperty
parameter_list|(
name|XMPSchema
name|schema
parameter_list|,
name|XMPMetadata
name|metadata
parameter_list|)
throws|throws
name|XmpParsingException
throws|,
name|XmpPropertyFormatException
throws|,
name|XmpUnexpectedTypeException
throws|,
name|XMLStreamException
throws|,
name|XmpUnknownPropertyTypeException
block|{
name|QName
name|propertyName
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|nsMap
operator|.
name|resetComplexBasicTypesDeclarationInPropertyLevel
argument_list|()
expr_stmt|;
name|int
name|cptNs
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cptNs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nsMap
operator|.
name|isComplexBasicTypes
argument_list|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|nsMap
operator|.
name|setComplexBasicTypesDeclarationForLevelSchema
argument_list|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespaceURI
argument_list|(
name|i
argument_list|)
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getNamespacePrefix
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|type
init|=
name|getPropertyDeclarationInNamespaces
argument_list|(
name|schema
argument_list|,
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Unmanaged"
argument_list|)
condition|)
block|{
comment|// do not parse the property, no validation, no reserialization
name|boolean
name|cont
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|cont
condition|)
block|{
name|int
name|t
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|XMLStreamReader
operator|.
name|END_ELEMENT
condition|)
block|{
if|if
condition|(
name|propertyName
operator|.
name|equals
argument_list|(
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|cont
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Text"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Integer"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Integer
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Boolean"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Boolean
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Real"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Real
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Date"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Date
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"URI"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"URL"
argument_list|)
condition|)
block|{
name|parseXmpSimpleProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"bag Text"
argument_list|)
condition|)
block|{
name|parseBagProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"bag ProperName"
argument_list|)
condition|)
block|{
name|parseBagProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"bag Job"
argument_list|)
condition|)
block|{
name|parseComplexBagProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
operator|new
name|JobParser
argument_list|(
name|this
argument_list|)
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"bag Xpath"
argument_list|)
condition|)
block|{
name|parseBagProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"seq Text"
argument_list|)
condition|)
block|{
name|parseSeqProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"seq Date"
argument_list|)
condition|)
block|{
name|parseSeqProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Date
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Lang Alt"
argument_list|)
condition|)
block|{
name|parseAltProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|XmpPropertyType
operator|.
name|Text
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Field"
argument_list|)
condition|)
block|{
name|parseFieldProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|schema
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Thumbnail"
argument_list|)
condition|)
block|{
name|parseThumbnailProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"Alt Thumbnail"
argument_list|)
condition|)
block|{
name|parseAltThumbnailProperty
argument_list|(
name|metadata
argument_list|,
name|propertyName
argument_list|,
name|schema
operator|.
name|getContent
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpUnknownPropertyTypeException
argument_list|(
literal|"Unknown type : "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Treat Alternative Thumbnails property 	 *  	 * @param metadata 	 *            Metadata to attach new elements 	 * @param altName 	 *            name of thumbnails alternative property 	 * @param container 	 *            the container where record this representation 	 * @throws XmpUnexpectedTypeException 	 *             When DOM Element type found unexpected 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws XmpUnknownPropertyTypeException 	 *             Value Type property is incorrect or the basic value type 	 *             can't be treat at the moment 	 * @throws XmpPropertyFormatException 	 *             Unexpected type found (IllegalArgumentException) 	 */
specifier|private
name|void
name|parseAltThumbnailProperty
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|QName
name|altName
parameter_list|,
name|ComplexPropertyContainer
name|container
parameter_list|)
throws|throws
name|XmpUnexpectedTypeException
throws|,
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|XmpUnknownPropertyTypeException
throws|,
name|XmpPropertyFormatException
block|{
name|ComplexProperty
name|alt
init|=
operator|new
name|ComplexProperty
argument_list|(
name|metadata
argument_list|,
name|altName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|altName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|ComplexProperty
operator|.
name|ALTERNATIVE_ARRAY
argument_list|)
decl_stmt|;
name|container
operator|.
name|addProperty
argument_list|(
name|alt
argument_list|)
expr_stmt|;
comment|//<rdf:Alt>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|START_ELEMENT
argument_list|,
name|ALT_NAME
argument_list|,
literal|"Expected Alt Declaration"
argument_list|)
expr_stmt|;
name|int
name|elmtType
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|elmtType
operator|==
name|XMLStreamReader
operator|.
name|END_ELEMENT
operator|)
operator|&&
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
name|ALT_NAME
argument_list|)
operator|)
condition|)
block|{
name|parseThumbnailProperty
argument_list|(
name|metadata
argument_list|,
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|alt
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
comment|//<dc:description><rdf:Alt><rdf:li>sujet</rdf:li></rdf:Alt></dc:description>
name|expectNextSpecificTag
argument_list|(
name|XMLStreamReader
operator|.
name|END_ELEMENT
argument_list|,
name|altName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
literal|"Expected end of alt property"
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * * Treat a thumbnail property 	 *  	 * @param metadata 	 *            Metadata to attach new elements 	 * @param altName 	 *            name of thumbnail property 	 * @param container 	 *            The container where save property representation 	 * @throws XmpUnexpectedTypeException 	 *             When DOM Element type found unexpected 	 * @throws XmpParsingException 	 *             When element expected not found 	 * @throws XMLStreamException 	 *             When error during reading the rest of xmp stream 	 * @throws XmpUnknownPropertyTypeException 	 *             Value Type property is incorrect or the basic value type 	 *             can't be treat at the moment 	 * @throws XmpPropertyFormatException 	 *             Unexpected type found (IllegalArgumentException) 	 */
specifier|private
name|void
name|parseThumbnailProperty
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|QName
name|altName
parameter_list|,
name|ComplexPropertyContainer
name|container
parameter_list|)
throws|throws
name|XmpUnexpectedTypeException
throws|,
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|XmpUnknownPropertyTypeException
throws|,
name|XmpPropertyFormatException
block|{
name|expectCurrentLocalName
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
name|ThumbnailType
name|thumbnail
init|=
operator|new
name|ThumbnailType
argument_list|(
name|metadata
argument_list|,
name|altName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|altName
operator|.
name|getLocalPart
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|elmtType
init|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
decl_stmt|;
name|QName
name|eltName
decl_stmt|;
name|String
name|eltContent
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|elmtType
operator|==
name|XMLStreamReader
operator|.
name|END_ELEMENT
operator|)
operator|&&
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
literal|"li"
argument_list|)
operator|)
condition|)
block|{
name|eltName
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|eltContent
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|getElementText
argument_list|()
expr_stmt|;
if|if
condition|(
name|eltName
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
literal|"height"
argument_list|)
condition|)
block|{
name|thumbnail
operator|.
name|setHeight
argument_list|(
name|eltName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|eltName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|eltContent
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eltName
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
literal|"width"
argument_list|)
condition|)
block|{
name|thumbnail
operator|.
name|setWidth
argument_list|(
name|eltName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|eltName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|eltContent
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eltName
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
literal|"image"
argument_list|)
condition|)
block|{
name|thumbnail
operator|.
name|setImg
argument_list|(
name|eltName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|eltName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|eltContent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eltName
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
literal|"format"
argument_list|)
condition|)
block|{
name|thumbnail
operator|.
name|setFormat
argument_list|(
name|eltName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|eltName
operator|.
name|getLocalPart
argument_list|()
argument_list|,
name|eltContent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"Unknown property name for a thumbnail element : "
operator|+
name|eltName
operator|.
name|getLocalPart
argument_list|()
argument_list|)
throw|;
block|}
name|elmtType
operator|=
name|reader
operator|.
name|get
argument_list|()
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
name|container
operator|.
name|addProperty
argument_list|(
name|thumbnail
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

