begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************  *   * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  *   ****************************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|parser
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|namespace
operator|.
name|QName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|stream
operator|.
name|XMLStreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|XMPMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|AbstractField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|AbstractSimpleProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|AbstractStructuredType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|ComplexPropertyContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|PropertyType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|TypeDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|TypeMapping
import|;
end_import

begin_class
specifier|public
class|class
name|StructuredPropertyParser
block|{
specifier|private
name|XMPDocumentBuilder
name|builder
init|=
literal|null
decl_stmt|;
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|AbstractStructuredType
argument_list|>
name|typeClass
init|=
literal|null
decl_stmt|;
specifier|private
name|Constructor
argument_list|<
name|?
extends|extends
name|AbstractStructuredType
argument_list|>
name|typeConstructor
init|=
literal|null
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|PropertyDescription
argument_list|>
name|propDesc
init|=
literal|null
decl_stmt|;
comment|//	private static Class<?> [] propertyConstructorParams = new Class [] {XMPMetadata.class,String.class};
specifier|private
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|propertyConstructorParams
init|=
operator|new
name|Class
index|[]
block|{
name|XMPMetadata
operator|.
name|class
block|}
decl_stmt|;
specifier|public
name|StructuredPropertyParser
parameter_list|(
name|XMPDocumentBuilder
name|builder
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|AbstractStructuredType
argument_list|>
name|propertyTypeClass
parameter_list|)
throws|throws
name|XmpPropertyFormatException
block|{
name|this
operator|.
name|builder
operator|=
name|builder
expr_stmt|;
name|this
operator|.
name|typeClass
operator|=
name|propertyTypeClass
expr_stmt|;
name|this
operator|.
name|propDesc
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|PropertyDescription
argument_list|>
argument_list|()
expr_stmt|;
comment|// retrieve xmp properties
name|Field
index|[]
name|fields
init|=
name|typeClass
operator|.
name|getFields
argument_list|()
decl_stmt|;
for|for
control|(
name|Field
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|.
name|getAnnotation
argument_list|(
name|PropertyType
operator|.
name|class
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|PropertyDescription
name|pd
init|=
operator|new
name|PropertyDescription
argument_list|()
decl_stmt|;
name|pd
operator|.
name|propertyType
operator|=
name|field
operator|.
name|getAnnotation
argument_list|(
name|PropertyType
operator|.
name|class
argument_list|)
expr_stmt|;
comment|//				pd.fieldName = field.getName();
try|try
block|{
name|pd
operator|.
name|propertyName
operator|=
name|field
operator|.
name|get
argument_list|(
literal|null
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e1
parameter_list|)
block|{
throw|throw
operator|new
name|XmpPropertyFormatException
argument_list|(
literal|"Failed to parse structured type : "
operator|+
name|typeClass
operator|.
name|getName
argument_list|()
argument_list|,
name|e1
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e1
parameter_list|)
block|{
throw|throw
operator|new
name|XmpPropertyFormatException
argument_list|(
literal|"Failed to parse structured type : "
operator|+
name|typeClass
operator|.
name|getName
argument_list|()
argument_list|,
name|e1
argument_list|)
throw|;
block|}
name|propDesc
operator|.
name|put
argument_list|(
name|pd
operator|.
name|propertyName
argument_list|,
name|pd
argument_list|)
expr_stmt|;
block|}
block|}
comment|// retrieve constructor
try|try
block|{
name|typeConstructor
operator|=
name|typeClass
operator|.
name|getConstructor
argument_list|(
name|propertyConstructorParams
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpPropertyFormatException
argument_list|(
literal|"Failed to initialize structured type parser : "
operator|+
name|typeClass
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpPropertyFormatException
argument_list|(
literal|"Failed to initialize structured type parser : "
operator|+
name|typeClass
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|AbstractStructuredType
name|instanciateProperty
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|)
throws|throws
name|XmpParsingException
block|{
try|try
block|{
comment|//			return typeConstructor.newInstance(metadata,prefix);
return|return
name|typeConstructor
operator|.
name|newInstance
argument_list|(
name|metadata
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"Failed to instanciate structured type : "
operator|+
name|typeClass
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"Failed to instanciate structured type : "
operator|+
name|typeClass
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"Failed to instanciate structured type : "
operator|+
name|typeClass
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"Failed to instanciate structured type : "
operator|+
name|typeClass
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|boolean
name|isParseTypeResource
parameter_list|()
block|{
name|XMLStreamReader
name|reader
init|=
name|builder
operator|.
name|getReader
argument_list|()
decl_stmt|;
name|int
name|count
init|=
name|reader
operator|.
name|getAttributeCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|"parseType"
operator|.
name|equals
argument_list|(
name|reader
operator|.
name|getAttributeLocalName
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
literal|"Resource"
operator|.
name|equals
argument_list|(
name|reader
operator|.
name|getAttributeValue
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|parse
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|QName
name|altName
parameter_list|,
name|ComplexPropertyContainer
name|container
parameter_list|)
throws|throws
name|XmpUnexpectedTypeException
throws|,
name|XmpParsingException
throws|,
name|XMLStreamException
throws|,
name|XmpUnknownPropertyTypeException
throws|,
name|XmpPropertyFormatException
block|{
name|builder
operator|.
name|expectCurrentLocalName
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
name|XMLStreamReader
name|reader
init|=
name|builder
operator|.
name|getReader
argument_list|()
decl_stmt|;
comment|// check if parseType is defined
name|boolean
name|skipDescription
init|=
name|isParseTypeResource
argument_list|()
decl_stmt|;
name|int
name|elmtType
init|=
name|reader
operator|.
name|nextTag
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|skipDescription
condition|)
block|{
comment|// rdf:Description
name|builder
operator|.
name|expectCurrentLocalName
argument_list|(
literal|"Description"
argument_list|)
expr_stmt|;
name|elmtType
operator|=
name|reader
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
name|AbstractStructuredType
name|property
init|=
name|instanciateProperty
argument_list|(
name|metadata
argument_list|)
decl_stmt|;
name|QName
name|eltName
decl_stmt|;
name|String
name|structuredEndName
init|=
name|skipDescription
condition|?
literal|"li"
else|:
literal|"Description"
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|elmtType
operator|==
name|XMLStreamReader
operator|.
name|END_ELEMENT
operator|)
operator|&&
name|reader
operator|.
name|getName
argument_list|()
operator|.
name|getLocalPart
argument_list|()
operator|.
name|equals
argument_list|(
name|structuredEndName
argument_list|)
operator|)
condition|)
block|{
comment|// read element name, then text content
name|eltName
operator|=
name|reader
operator|.
name|getName
argument_list|()
expr_stmt|;
name|String
name|eltContent
init|=
name|reader
operator|.
name|getElementText
argument_list|()
decl_stmt|;
comment|// check if property is expected
name|String
name|localPart
init|=
name|eltName
operator|.
name|getLocalPart
argument_list|()
decl_stmt|;
if|if
condition|(
name|propDesc
operator|.
name|containsKey
argument_list|(
name|localPart
argument_list|)
condition|)
block|{
name|PropertyDescription
name|description
init|=
name|propDesc
operator|.
name|get
argument_list|(
name|localPart
argument_list|)
decl_stmt|;
name|AbstractField
name|a
init|=
name|instanciateSimple
argument_list|(
name|description
operator|.
name|propertyType
operator|.
name|propertyType
argument_list|()
argument_list|,
name|metadata
argument_list|,
name|eltName
operator|.
name|getPrefix
argument_list|()
argument_list|,
name|localPart
argument_list|,
name|eltContent
argument_list|)
decl_stmt|;
name|property
operator|.
name|addProperty
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// expect only defined properties are accepted
comment|// XXX : really the good choice ?
comment|// XXX : should we create text properties for unknown types ?
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"Unknown property name for a job element : "
operator|+
name|eltName
operator|.
name|getLocalPart
argument_list|()
argument_list|)
throw|;
block|}
name|elmtType
operator|=
name|reader
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skipDescription
condition|)
block|{
comment|// closing rdf:Description element
name|reader
operator|.
name|nextTag
argument_list|()
expr_stmt|;
block|}
name|container
operator|.
name|addProperty
argument_list|(
name|property
argument_list|)
expr_stmt|;
block|}
specifier|private
name|AbstractSimpleProperty
name|instanciateSimple
parameter_list|(
name|String
name|type
parameter_list|,
name|XMPMetadata
name|metadata
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|propertyName
parameter_list|,
name|String
name|valueAsString
parameter_list|)
throws|throws
name|XmpParsingException
block|{
name|TypeDescription
name|description
init|=
name|TypeMapping
operator|.
name|getTypeDescription
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|Object
name|value
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|description
operator|.
name|getBasic
argument_list|()
condition|)
block|{
case|case
name|Boolean
case|:
name|value
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|valueAsString
argument_list|)
expr_stmt|;
break|break;
case|case
name|Date
case|:
try|try
block|{
name|value
operator|=
name|DateConverter
operator|.
name|toCalendar
argument_list|(
name|valueAsString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"Failed to parse date property"
argument_list|,
name|e
argument_list|)
throw|;
block|}
break|break;
case|case
name|Integer
case|:
try|try
block|{
name|value
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|valueAsString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"Failed to parse integer property"
argument_list|,
name|e
argument_list|)
throw|;
block|}
break|break;
case|case
name|Real
case|:
try|try
block|{
name|value
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|valueAsString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|XmpParsingException
argument_list|(
literal|"Failed to parse real type property"
argument_list|,
name|e
argument_list|)
throw|;
block|}
break|break;
case|case
name|Text
case|:
name|value
operator|=
name|valueAsString
expr_stmt|;
block|}
return|return
name|TypeMapping
operator|.
name|instanciateSimpleProperty
argument_list|(
name|metadata
argument_list|,
literal|null
argument_list|,
name|prefix
argument_list|,
name|propertyName
argument_list|,
name|value
argument_list|,
name|type
argument_list|)
return|;
block|}
specifier|protected
class|class
name|PropertyDescription
block|{
comment|//		private String fieldName;
comment|//
specifier|private
name|String
name|propertyName
decl_stmt|;
specifier|private
name|PropertyType
name|propertyType
decl_stmt|;
block|}
block|}
end_class

end_unit

