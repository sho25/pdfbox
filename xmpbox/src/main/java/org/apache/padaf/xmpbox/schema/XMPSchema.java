begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************  *   * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  *   ****************************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|schema
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|XMPMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|AbstractField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|AbstractSimpleProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|Attribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|BadFieldValueException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|BooleanType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|ComplexProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|ComplexPropertyContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|DateType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|Elementable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|IntegerType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|padaf
operator|.
name|xmpbox
operator|.
name|type
operator|.
name|TextType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import

begin_comment
comment|/**  * This class represents a metadata schema that can be stored in an XMP  * document. It handles all generic properties that are available. See  * subclasses for access to specific properties. MODIFIED TO INCLUDE OBJECT  * REPRESENTATION  *   */
end_comment

begin_class
specifier|public
class|class
name|XMPSchema
implements|implements
name|Elementable
block|{
comment|/** 	 * The standard xmlns namespace. 	 */
specifier|public
specifier|static
specifier|final
name|String
name|NS_NAMESPACE
init|=
literal|"http://www.w3.org/2000/xmlns/"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|RDFABOUT
init|=
literal|"rdf:about"
decl_stmt|;
specifier|protected
name|String
name|localPrefix
decl_stmt|,
name|localNSUri
decl_stmt|;
specifier|protected
name|String
name|localPrefixSep
decl_stmt|;
specifier|protected
name|XMPMetadata
name|metadata
decl_stmt|;
specifier|protected
name|ComplexPropertyContainer
name|content
decl_stmt|;
comment|/** 	 * Create a new blank schema that can be populated. 	 *  	 * @param metadata 	 *            The parent XMP metadata that this schema will be part of. 	 * @param namespaceName 	 *            The name of the namespace, ie pdf,dc,... 	 * @param namespaceURI 	 *            The URI of the namespace, ie "http://ns.adobe.com/pdf/1.3/" 	 *  	 */
specifier|public
name|XMPSchema
parameter_list|(
name|XMPMetadata
name|metadata
parameter_list|,
name|String
name|namespaceName
parameter_list|,
name|String
name|namespaceURI
parameter_list|)
block|{
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
name|content
operator|=
operator|new
name|ComplexPropertyContainer
argument_list|(
name|metadata
argument_list|,
literal|"http://www.w3.org/1999/02/22-rdf-syntax-ns#"
argument_list|,
literal|"rdf"
argument_list|,
literal|"Description"
argument_list|)
expr_stmt|;
name|localPrefix
operator|=
name|namespaceName
expr_stmt|;
name|localPrefixSep
operator|=
name|localPrefix
operator|+
literal|":"
expr_stmt|;
name|localNSUri
operator|=
name|namespaceURI
expr_stmt|;
name|content
operator|.
name|setAttribute
argument_list|(
operator|new
name|Attribute
argument_list|(
name|NS_NAMESPACE
argument_list|,
literal|"xmlns"
argument_list|,
name|namespaceName
argument_list|,
name|namespaceURI
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Get the schema prefix 	 *  	 * @return Prefix fixed for the schema 	 */
specifier|public
name|String
name|getPrefix
parameter_list|()
block|{
return|return
name|localPrefix
return|;
block|}
comment|/** 	 * Get the namespace URI of this schema 	 *  	 * @return the namespace URI of this schema 	 */
specifier|public
name|String
name|getNamespaceValue
parameter_list|()
block|{
return|return
name|localNSUri
return|;
block|}
comment|/** 	 * Retrieve a generic simple type property 	 *  	 * @param qualifiedName 	 *            Full qualified name of proeprty wanted 	 * @return The generic simple type property according to its qualified Name 	 */
specifier|public
name|AbstractField
name|getAbstractProperty
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|content
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|tmp
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|qualifiedName
argument_list|)
condition|)
block|{
return|return
name|tmp
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Get the RDF about attribute 	 *  	 * @return The RDF 'about' attribute. 	 */
specifier|public
name|Attribute
name|getAboutAttribute
parameter_list|()
block|{
return|return
name|content
operator|.
name|getAttribute
argument_list|(
name|RDFABOUT
argument_list|)
return|;
block|}
comment|/** 	 * Get the RDF about value. 	 *  	 * @return The RDF 'about' value. 	 */
specifier|public
name|String
name|getAboutValue
parameter_list|()
block|{
name|Attribute
name|prop
init|=
name|content
operator|.
name|getAttribute
argument_list|(
name|RDFABOUT
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
return|return
name|prop
operator|.
name|getValue
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Set the RDF 'about' attribute 	 *  	 * @param about 	 *            the well-formed attribute 	 * @throws BadFieldValueException 	 *             Bad Attribute name (not corresponding to about attribute) 	 */
specifier|public
name|void
name|setAbout
parameter_list|(
name|Attribute
name|about
parameter_list|)
throws|throws
name|BadFieldValueException
block|{
if|if
condition|(
name|about
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|RDFABOUT
argument_list|)
operator|||
name|about
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"about"
argument_list|)
condition|)
block|{
name|content
operator|.
name|setAttribute
argument_list|(
name|about
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|BadFieldValueException
argument_list|(
literal|"Attribute 'about' must be named 'rdf:about' or 'about'"
argument_list|)
throw|;
block|}
block|}
comment|/** 	 * Set the RDF 'about' attribute. Passing in null will clear this attribute. 	 *  	 * @param about 	 *            The new RFD about value. 	 */
specifier|public
name|void
name|setAboutAsSimple
parameter_list|(
name|String
name|about
parameter_list|)
block|{
if|if
condition|(
name|about
operator|==
literal|null
condition|)
block|{
name|content
operator|.
name|removeAttribute
argument_list|(
name|RDFABOUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|content
operator|.
name|setAttribute
argument_list|(
operator|new
name|Attribute
argument_list|(
literal|null
argument_list|,
literal|"rdf"
argument_list|,
literal|"about"
argument_list|,
name|about
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Set a simple specified type property on the schema. 	 *  	 * @param type 	 *            the property type 	 * @param qualifiedName 	 *            the qualified name to specify for the new property 	 * @param propertyValue 	 *            The value (must be an object understandable by specified type) 	 */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|void
name|setSpecifiedSimpleTypeProperty
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|AbstractSimpleProperty
argument_list|>
name|type
parameter_list|,
name|String
name|qualifiedName
parameter_list|,
name|Object
name|propertyValue
parameter_list|)
block|{
name|String
index|[]
name|splittedQualifiedName
init|=
name|qualifiedName
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|Class
index|[]
name|propertyArgsClass
init|=
operator|new
name|Class
index|[]
block|{
name|XMPMetadata
operator|.
name|class
block|,
name|String
operator|.
name|class
block|,
name|String
operator|.
name|class
block|,
name|Object
operator|.
name|class
block|}
decl_stmt|;
name|Object
index|[]
name|propertyArgs
init|=
operator|new
name|Object
index|[]
block|{
name|metadata
block|,
name|splittedQualifiedName
index|[
literal|0
index|]
block|,
name|splittedQualifiedName
index|[
literal|1
index|]
block|,
name|propertyValue
block|}
decl_stmt|;
name|Constructor
argument_list|<
name|?
extends|extends
name|AbstractSimpleProperty
argument_list|>
name|propertyConstructor
decl_stmt|;
name|AbstractSimpleProperty
name|specifiedTypeProperty
decl_stmt|;
if|if
condition|(
name|propertyValue
operator|==
literal|null
condition|)
block|{
comment|// Search in properties to erase
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|content
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|tmp
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|qualifiedName
argument_list|)
condition|)
block|{
name|content
operator|.
name|removeProperty
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
try|try
block|{
name|propertyConstructor
operator|=
name|type
operator|.
name|getConstructor
argument_list|(
name|propertyArgsClass
argument_list|)
expr_stmt|;
name|specifiedTypeProperty
operator|=
operator|(
name|AbstractSimpleProperty
operator|)
name|propertyConstructor
operator|.
name|newInstance
argument_list|(
name|propertyArgs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Failed to create property with the specified type given in parameters"
argument_list|)
throw|;
block|}
comment|// attribute placement for simple property has been removed
comment|// Search in properties to erase
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|content
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|tmp
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|qualifiedName
argument_list|)
condition|)
block|{
name|content
operator|.
name|removeProperty
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|content
operator|.
name|addProperty
argument_list|(
name|specifiedTypeProperty
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|content
operator|.
name|addProperty
argument_list|(
name|specifiedTypeProperty
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Add a SimpleProperty to this schema 	 *  	 * @param prop 	 *            The Property to add 	 */
specifier|private
name|void
name|setSpecifiedSimpleTypeProperty
parameter_list|(
name|AbstractSimpleProperty
name|prop
parameter_list|)
block|{
comment|// attribute placement for simple property has been removed
comment|// Search in properties to erase
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|content
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|tmp
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|prop
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
condition|)
block|{
name|content
operator|.
name|removeProperty
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|content
operator|.
name|addProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|content
operator|.
name|addProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Set TextType property 	 *  	 * @param prop 	 *            The text property to add 	 */
specifier|public
name|void
name|setTextProperty
parameter_list|(
name|TextType
name|prop
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Set a simple text property on the schema. 	 *  	 * @param qualifiedName 	 *            The name of the property, it must contain the namespace 	 *            prefix, ie "pdf:Keywords" 	 * @param propertyValue 	 *            The value for the property, can be any string. Passing null 	 *            will remove the property. 	 */
specifier|public
name|void
name|setTextPropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|String
name|propertyValue
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|TextType
operator|.
name|class
argument_list|,
name|qualifiedName
argument_list|,
name|propertyValue
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Set a simple text property on the schema, using the current prefix. 	 *  	 * @param simpleName 	 *            the name of the property without prefix 	 * @param propertyValue 	 *            The value for the property, can be any string. Passing null 	 *            will remove the property. 	 */
specifier|public
name|void
name|setTextPropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|String
name|propertyValue
parameter_list|)
block|{
name|this
operator|.
name|setTextPropertyValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|,
name|propertyValue
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Get a TextProperty Type from its name 	 *  	 * @param qualifiedName 	 *            The full qualified name of the property wanted 	 * @return The Text Type property wanted 	 */
specifier|public
name|TextType
name|getTextProperty
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|TextType
condition|)
block|{
return|return
operator|(
name|TextType
operator|)
name|prop
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not a Text Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Get a simple text property value on the schema, using the current prefix. 	 *  	 * @param simpleName 	 *            The local name of the property wanted 	 * @return The value of the text property or the null if there is no value. 	 *  	 */
specifier|public
name|String
name|getTextPropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|this
operator|.
name|getTextPropertyValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|)
return|;
block|}
comment|/** 	 * Get the value of a simple text property. 	 *  	 * @param qualifiedName 	 *            The name of the property to get, it must include the namespace 	 *            prefix. ie "pdf:Keywords". 	 *  	 * @return The value of the text property or the null if there is no value. 	 *  	 */
specifier|public
name|String
name|getTextPropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|TextType
condition|)
block|{
return|return
operator|(
operator|(
name|TextType
operator|)
name|prop
operator|)
operator|.
name|getStringValue
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not a Text Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Get the Date property with its name 	 *  	 * @param qualifiedName 	 *            The name of the property to get, it must include the namespace 	 *            prefix. ie "pdf:Keywords". 	 * @return Date Type property 	 *  	 */
specifier|public
name|DateType
name|getDateProperty
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|DateType
condition|)
block|{
return|return
operator|(
name|DateType
operator|)
name|prop
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not a Date Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Get a simple date property value on the schema, using the current prefix. 	 *  	 * @param simpleName 	 *            the local name of the property to get 	 * @return The value of the property as a calendar. 	 *  	 */
specifier|public
name|Calendar
name|getDatePropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|this
operator|.
name|getDatePropertyValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|)
return|;
block|}
comment|/** 	 * Get the value of the property as a date. 	 *  	 * @param qualifiedName 	 *            The fully qualified property name for the date. 	 *  	 * @return The value of the property as a date. 	 *  	 */
specifier|public
name|Calendar
name|getDatePropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|DateType
condition|)
block|{
return|return
operator|(
operator|(
name|DateType
operator|)
name|prop
operator|)
operator|.
name|getValue
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not a Date Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Set a new DateProperty 	 *  	 * @param date 	 *            The DateType Property 	 */
specifier|public
name|void
name|setDateProperty
parameter_list|(
name|DateType
name|date
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|date
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Set a simple Date property on the schema, using the current prefix. 	 *  	 * @param simpleName 	 *            the name of the property without prefix 	 * @param date 	 *            The calendar value for the property, can be any string. 	 *            Passing null will remove the property. 	 */
specifier|public
name|void
name|setDatePropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|this
operator|.
name|setDatePropertyValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Set the value of the property as a date. 	 *  	 * @param qualifiedName 	 *            The fully qualified property name for the date. 	 * @param date 	 *            The date to set, or null to clear. 	 */
specifier|public
name|void
name|setDatePropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|DateType
operator|.
name|class
argument_list|,
name|qualifiedName
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Get a BooleanType property with its name 	 *  	 * @param qualifiedName 	 *            the full qualified name of property wanted 	 * @return boolean Type property 	 */
specifier|public
name|BooleanType
name|getBooleanProperty
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|BooleanType
condition|)
block|{
return|return
operator|(
name|BooleanType
operator|)
name|prop
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not a Boolean Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Get a simple boolean property value on the schema, using the current 	 * prefix. 	 *  	 * @param simpleName 	 *            the local name of property wanted 	 * @return The value of the property as a boolean. 	 */
specifier|public
name|Boolean
name|getBooleanPropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|this
operator|.
name|getBooleanPropertyValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|)
return|;
block|}
comment|/** 	 * Get the value of the property as a boolean. 	 *  	 * @param qualifiedName 	 *            The fully qualified property name for the boolean. 	 *  	 * @return The value of the property as a boolean. Return null if property 	 *         not exist 	 */
specifier|public
name|Boolean
name|getBooleanPropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|BooleanType
condition|)
block|{
return|return
operator|(
operator|(
name|BooleanType
operator|)
name|prop
operator|)
operator|.
name|getValue
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not a Boolean Property"
argument_list|)
throw|;
block|}
block|}
comment|// Return null if property not exist. This method give the property
comment|// value so treat this return in this way.
comment|// If you want to use this value like a condition, you must check this
comment|// return before
return|return
literal|null
return|;
block|}
comment|/** 	 * Set a BooleanType property 	 *  	 * @param bool 	 *            the booleanType property 	 */
specifier|public
name|void
name|setBooleanProperty
parameter_list|(
name|BooleanType
name|bool
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|bool
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Set a simple Boolean property on the schema, using the current prefix. 	 *  	 * @param simpleName 	 *            the name of the property without prefix 	 * @param bool 	 *            The value for the property, can be any string. Passing null 	 *            will remove the property. 	 */
specifier|public
name|void
name|setBooleanPropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|Boolean
name|bool
parameter_list|)
block|{
name|this
operator|.
name|setBooleanPropertyValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|,
name|bool
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Set the value of the property as a boolean. 	 *  	 * @param qualifiedName 	 *            The fully qualified property name for the boolean. 	 * @param bool 	 *            The boolean to set, or null to clear. 	 */
specifier|public
name|void
name|setBooleanPropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|Boolean
name|bool
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|BooleanType
operator|.
name|class
argument_list|,
name|qualifiedName
argument_list|,
name|bool
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Get the Integer property with its name 	 *  	 * @param qualifiedName 	 *            the full qualified name of property wanted 	 * @return Integer Type property 	 */
specifier|public
name|IntegerType
name|getIntegerProperty
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|IntegerType
condition|)
block|{
return|return
operator|(
operator|(
name|IntegerType
operator|)
name|prop
operator|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not an Integer Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Get a simple integer property value on the schema, using the current 	 * prefix. 	 *  	 * @param simpleName 	 *            the local name of property wanted 	 * @return The value of the property as an integer. 	 */
specifier|public
name|Integer
name|getIntegerPropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|this
operator|.
name|getIntegerPropertyValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|)
return|;
block|}
comment|/** 	 * Get the value of the property as an integer. 	 *  	 * @param qualifiedName 	 *            The fully qualified property name for the integer. 	 *  	 * @return The value of the property as an integer. 	 */
specifier|public
name|Integer
name|getIntegerPropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|AbstractField
name|prop
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|IntegerType
condition|)
block|{
return|return
operator|(
operator|(
name|IntegerType
operator|)
name|prop
operator|)
operator|.
name|getValue
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Property asked is not an Integer Property"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Add an integerProperty 	 *  	 * @param prop 	 *            The Integer Type property 	 */
specifier|public
name|void
name|setIntegerProperty
parameter_list|(
name|IntegerType
name|prop
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Set a simple Integer property on the schema, using the current prefix. 	 *  	 * @param simpleName 	 *            the name of the property without prefix 	 * @param intValue 	 *            The value for the property, can be any string. Passing null 	 *            will remove the property. 	 */
specifier|public
name|void
name|setIntegerPropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|Integer
name|intValue
parameter_list|)
block|{
name|this
operator|.
name|setIntegerPropertyValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|,
name|intValue
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Set the value of the property as an integer. 	 *  	 * @param qualifiedName 	 *            The fully qualified property name for the integer. 	 * @param intValue 	 *            The int to set, or null to clear. 	 */
specifier|public
name|void
name|setIntegerPropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|Integer
name|intValue
parameter_list|)
block|{
name|setSpecifiedSimpleTypeProperty
argument_list|(
name|IntegerType
operator|.
name|class
argument_list|,
name|qualifiedName
argument_list|,
name|intValue
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Generic array property removing 	 *  	 * @param qualifiedArrayName 	 *            the full qualified name of property wanted 	 * @param fieldValue 	 *            the field value 	 */
specifier|private
name|void
name|removeArrayValue
parameter_list|(
name|String
name|qualifiedArrayName
parameter_list|,
name|String
name|fieldValue
parameter_list|)
block|{
name|ComplexProperty
name|array
init|=
operator|(
name|ComplexProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedArrayName
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
name|toDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|array
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractSimpleProperty
name|tmp
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
operator|(
name|AbstractSimpleProperty
operator|)
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|getStringValue
argument_list|()
operator|.
name|equals
argument_list|(
name|fieldValue
argument_list|)
condition|)
block|{
name|toDelete
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|eraseProperties
init|=
name|toDelete
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|eraseProperties
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|array
operator|.
name|getContainer
argument_list|()
operator|.
name|removeProperty
argument_list|(
name|eraseProperties
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * Remove all matching entries with the given value from the bag. 	 *  	 * @param qualifiedBagName 	 *            The name of the bag, it must include the namespace prefix. ie 	 *            "pdf:Keywords". 	 * @param bagValue 	 *            The value to remove from the bagList. 	 */
specifier|public
name|void
name|removeBagValue
parameter_list|(
name|String
name|qualifiedBagName
parameter_list|,
name|String
name|bagValue
parameter_list|)
block|{
name|removeArrayValue
argument_list|(
name|qualifiedBagName
argument_list|,
name|bagValue
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * add a bag value property on the schema, using the current prefix. 	 *  	 * @param simpleName 	 *            the local name of property 	 * @param bagValue 	 *            the string value to add 	 */
specifier|public
name|void
name|addBagValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|String
name|bagValue
parameter_list|)
block|{
name|this
operator|.
name|addBagValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|,
name|bagValue
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Add an entry to a bag property. 	 *  	 * @param qualifiedBagName 	 *            The name of the bag, it must include the namespace prefix. ie 	 *            "pdf:Keywords". 	 * @param bagValue 	 *            The value to add to the bagList. 	 */
specifier|public
name|void
name|addBagValue
parameter_list|(
name|String
name|qualifiedBagName
parameter_list|,
name|String
name|bagValue
parameter_list|)
block|{
name|String
index|[]
name|splittedQualifiedName
init|=
name|qualifiedBagName
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|ComplexProperty
name|bag
init|=
operator|(
name|ComplexProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedBagName
argument_list|)
decl_stmt|;
name|TextType
name|li
init|=
operator|new
name|TextType
argument_list|(
name|metadata
argument_list|,
literal|"rdf"
argument_list|,
literal|"li"
argument_list|,
name|bagValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|bag
operator|!=
literal|null
condition|)
block|{
name|bag
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ComplexProperty
name|newBag
init|=
operator|new
name|ComplexProperty
argument_list|(
name|metadata
argument_list|,
name|splittedQualifiedName
index|[
literal|0
index|]
argument_list|,
name|splittedQualifiedName
index|[
literal|1
index|]
argument_list|,
name|ComplexProperty
operator|.
name|UNORDERED_ARRAY
argument_list|)
decl_stmt|;
name|newBag
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|li
argument_list|)
expr_stmt|;
name|content
operator|.
name|addProperty
argument_list|(
name|newBag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Generic String List Builder for arrays contents 	 *  	 * @param qualifiedArrayName 	 *            the full qualified name of property concerned 	 * @return String list which represents content of array property 	 */
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getArrayListToString
parameter_list|(
name|String
name|qualifiedArrayName
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|retval
init|=
literal|null
decl_stmt|;
name|ComplexProperty
name|array
init|=
operator|(
name|ComplexProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedArrayName
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|array
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractSimpleProperty
name|tmp
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
operator|(
name|AbstractSimpleProperty
operator|)
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|retval
operator|.
name|add
argument_list|(
name|tmp
operator|.
name|getStringValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/** 	 * Get all the values of the bag property, using the current prefix. This 	 * will return a list of java.lang.String objects, this is a read-only list. 	 *  	 * @param simpleName 	 *            the local name of property concerned 	 *  	 *  	 * @return All values of the bag property in a list. 	 */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getBagValueListAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|getBagValueList
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|)
return|;
block|}
comment|/** 	 * Get all the values of the bag property. This will return a list of 	 * java.lang.String objects, this is a read-only list. 	 *  	 * @param qualifiedBagName 	 *            The name of the bag property to get, it must include the 	 *            namespace prefix. ie "pdf:Keywords" 	 *  	 * @return All values of the bag property in a list. 	 */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getBagValueList
parameter_list|(
name|String
name|qualifiedBagName
parameter_list|)
block|{
return|return
name|getArrayListToString
argument_list|(
name|qualifiedBagName
argument_list|)
return|;
block|}
comment|/** 	 * Remove all matching values from a sequence property. 	 *  	 * @param qualifiedSeqName 	 *            The name of the sequence property. It must include the 	 *            namespace prefix. ie "pdf:Keywords". 	 * @param seqValue 	 *            The value to remove from the list. 	 */
specifier|public
name|void
name|removeSequenceValue
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|,
name|String
name|seqValue
parameter_list|)
block|{
name|removeArrayValue
argument_list|(
name|qualifiedSeqName
argument_list|,
name|seqValue
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Generic method to remove a field from an array with an Elementable Object 	 *  	 * @param qualifiedArrayName 	 *            the full qualified name of the property concerned 	 * @param fieldValue 	 *            the elementable field value 	 */
specifier|public
name|void
name|removeArrayValue
parameter_list|(
name|String
name|qualifiedArrayName
parameter_list|,
name|Elementable
name|fieldValue
parameter_list|)
block|{
name|ComplexProperty
name|array
init|=
operator|(
name|ComplexProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedArrayName
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
name|toDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|array
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractSimpleProperty
name|tmp
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
operator|(
name|AbstractSimpleProperty
operator|)
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|equals
argument_list|(
name|fieldValue
argument_list|)
condition|)
block|{
name|toDelete
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|eraseProperties
init|=
name|toDelete
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|eraseProperties
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|array
operator|.
name|getContainer
argument_list|()
operator|.
name|removeProperty
argument_list|(
name|eraseProperties
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * Remove a value from a sequence property. This will remove all entries 	 * from the list. 	 *  	 * @param qualifiedSeqName 	 *            The name of the sequence property. It must include the 	 *            namespace prefix. ie "pdf:Keywords". 	 * @param seqValue 	 *            The value to remove from the list. 	 */
specifier|public
name|void
name|removeSequenceValue
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|,
name|Elementable
name|seqValue
parameter_list|)
block|{
name|removeArrayValue
argument_list|(
name|qualifiedSeqName
argument_list|,
name|seqValue
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Add a new value to a sequence property. 	 *  	 * @param qualifiedSeqName 	 *            The name of the sequence property, it must include the 	 *            namespace prefix. ie "pdf:Keywords" 	 * @param seqValue 	 *            The value to add to the sequence. 	 */
specifier|public
name|void
name|addSequenceValue
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|,
name|String
name|seqValue
parameter_list|)
block|{
name|String
index|[]
name|splittedQualifiedName
init|=
name|qualifiedSeqName
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|ComplexProperty
name|seq
init|=
operator|(
name|ComplexProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedSeqName
argument_list|)
decl_stmt|;
name|TextType
name|li
init|=
operator|new
name|TextType
argument_list|(
name|metadata
argument_list|,
literal|"rdf"
argument_list|,
literal|"li"
argument_list|,
name|seqValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
literal|null
condition|)
block|{
name|seq
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ComplexProperty
name|newSeq
init|=
operator|new
name|ComplexProperty
argument_list|(
name|metadata
argument_list|,
name|splittedQualifiedName
index|[
literal|0
index|]
argument_list|,
name|splittedQualifiedName
index|[
literal|1
index|]
argument_list|,
name|ComplexProperty
operator|.
name|ORDERED_ARRAY
argument_list|)
decl_stmt|;
name|newSeq
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|li
argument_list|)
expr_stmt|;
name|content
operator|.
name|addProperty
argument_list|(
name|newSeq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Add a new value to a bag property. 	 *  	 * @param qualifiedSeqName 	 *            The name of the sequence property, it must include the 	 *            namespace prefix. ie "pdf:Keywords" 	 * @param seqValue 	 *            The value to add to the bag. 	 */
specifier|public
name|void
name|addBagValue
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|,
name|AbstractField
name|seqValue
parameter_list|)
block|{
name|String
index|[]
name|splittedQualifiedName
init|=
name|qualifiedSeqName
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|ComplexProperty
name|bag
init|=
operator|(
name|ComplexProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedSeqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|bag
operator|!=
literal|null
condition|)
block|{
name|bag
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|seqValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ComplexProperty
name|newBag
init|=
operator|new
name|ComplexProperty
argument_list|(
name|metadata
argument_list|,
name|splittedQualifiedName
index|[
literal|0
index|]
argument_list|,
name|splittedQualifiedName
index|[
literal|1
index|]
argument_list|,
name|ComplexProperty
operator|.
name|UNORDERED_ARRAY
argument_list|)
decl_stmt|;
name|newBag
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|seqValue
argument_list|)
expr_stmt|;
name|content
operator|.
name|addProperty
argument_list|(
name|newBag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * add a new value to a sequence property using the current prefix. 	 *  	 * @param simpleName 	 *            the local name of the property 	 * @param seqValue 	 *            the string value to add 	 */
specifier|public
name|void
name|addSequenceValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|String
name|seqValue
parameter_list|)
block|{
name|this
operator|.
name|addSequenceValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|,
name|seqValue
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Add a new value to a sequence property. 	 *  	 * @param qualifiedSeqName 	 *            The name of the sequence property, it must include the 	 *            namespace prefix. ie "pdf:Keywords" 	 * @param seqValue 	 *            The value to add to the sequence. 	 */
specifier|public
name|void
name|addSequenceValue
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|,
name|AbstractField
name|seqValue
parameter_list|)
block|{
name|String
index|[]
name|splittedQualifiedName
init|=
name|qualifiedSeqName
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|ComplexProperty
name|seq
init|=
operator|(
name|ComplexProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedSeqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
literal|null
condition|)
block|{
name|seq
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|seqValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ComplexProperty
name|newSeq
init|=
operator|new
name|ComplexProperty
argument_list|(
name|metadata
argument_list|,
name|splittedQualifiedName
index|[
literal|0
index|]
argument_list|,
name|splittedQualifiedName
index|[
literal|1
index|]
argument_list|,
name|ComplexProperty
operator|.
name|ORDERED_ARRAY
argument_list|)
decl_stmt|;
name|newSeq
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|seqValue
argument_list|)
expr_stmt|;
name|content
operator|.
name|addProperty
argument_list|(
name|newSeq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Get all the values in a sequence property, using the current prefix. 	 *  	 * @param simpleName 	 *            the local name of the property 	 * @return A read-only list of java.lang.String objects or null if the 	 *         property does not exist. 	 */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getSequenceValueListAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|this
operator|.
name|getSequenceValueList
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|)
return|;
block|}
comment|/** 	 * Get all the values in a sequence property. 	 *  	 * @param qualifiedSeqName 	 *            The name of the sequence property, it must include the 	 *            namespace prefix. ie "pdf:Keywords". 	 *  	 * @return A read-only list of java.lang.String objects or null if the 	 *         property does not exist. 	 */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getSequenceValueList
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|)
block|{
return|return
name|getArrayListToString
argument_list|(
name|qualifiedSeqName
argument_list|)
return|;
block|}
comment|/** 	 * Remove a date sequence value from the list. 	 *  	 * @param qualifiedSeqName 	 *            The name of the sequence property, it must include the 	 *            namespace prefix. ie "pdf:Keywords" 	 * @param date 	 *            The date to remove from the sequence property. 	 */
specifier|public
name|void
name|removeSequenceDateValue
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|ComplexProperty
name|seq
init|=
operator|(
name|ComplexProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedSeqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
name|toDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|seq
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|tmp
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|instanceof
name|DateType
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|DateType
operator|)
name|tmp
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|date
argument_list|)
condition|)
block|{
name|toDelete
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|eraseProperties
init|=
name|toDelete
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|eraseProperties
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|seq
operator|.
name|getContainer
argument_list|()
operator|.
name|removeProperty
argument_list|(
name|eraseProperties
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * Add a date sequence value to the list using the current prefix 	 *  	 * @param simpleName 	 *            the local name of the property 	 * @param date 	 *            the value to add 	 */
specifier|public
name|void
name|addSequenceDateValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|addSequenceDateValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Add a date sequence value to the list. 	 *  	 * @param qualifiedSeqName 	 *            The name of the sequence property, it must include the 	 *            namespace prefix. ie "pdf:Keywords" 	 * @param date 	 *            The date to add to the sequence property. 	 */
specifier|public
name|void
name|addSequenceDateValue
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|addSequenceValue
argument_list|(
name|qualifiedSeqName
argument_list|,
operator|new
name|DateType
argument_list|(
name|metadata
argument_list|,
literal|"rdf"
argument_list|,
literal|"li"
argument_list|,
name|date
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Get all the date values in a sequence property, using the current prefix. 	 *  	 * @param simpleName 	 *            the local name of property concerned 	 * @return A read-only list of java.util.Calendar objects or null if the 	 *         property does not exist. 	 */
specifier|public
name|List
argument_list|<
name|Calendar
argument_list|>
name|getSequenceDateValueListAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|this
operator|.
name|getSequenceDateValueList
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|)
return|;
block|}
comment|/** 	 * Get all the date values in a sequence property. 	 *  	 * @param qualifiedSeqName 	 *            The name of the sequence property, it must include the 	 *            namespace prefix. ie "pdf:Keywords". 	 *  	 * @return A read-only list of java.util.Calendar objects or null if the 	 *         property does not exist. 	 *  	 */
specifier|public
name|List
argument_list|<
name|Calendar
argument_list|>
name|getSequenceDateValueList
parameter_list|(
name|String
name|qualifiedSeqName
parameter_list|)
block|{
name|List
argument_list|<
name|Calendar
argument_list|>
name|retval
init|=
literal|null
decl_stmt|;
name|ComplexProperty
name|seq
init|=
operator|(
name|ComplexProperty
operator|)
name|getAbstractProperty
argument_list|(
name|qualifiedSeqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
operator|new
name|ArrayList
argument_list|<
name|Calendar
argument_list|>
argument_list|()
expr_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|seq
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|tmp
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|instanceof
name|DateType
condition|)
block|{
name|retval
operator|.
name|add
argument_list|(
operator|(
operator|(
name|DateType
operator|)
name|tmp
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/** 	 * Method used to place the 'x-default' value in first in Language 	 * alternatives as said in xmp spec 	 *  	 * @param alt 	 *            The property to reorganize 	 */
specifier|public
name|void
name|reorganizeAltOrder
parameter_list|(
name|ComplexPropertyContainer
name|alt
parameter_list|)
block|{
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|alt
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|xdefault
init|=
literal|null
decl_stmt|;
name|boolean
name|xdefaultFound
init|=
literal|false
decl_stmt|;
comment|// If alternatives contains x-default in first value
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|getAttribute
argument_list|(
literal|"xml:lang"
argument_list|)
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|"x-default"
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
comment|// Find the xdefault definition
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|xdefaultFound
condition|)
block|{
name|xdefault
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|xdefault
operator|.
name|getAttribute
argument_list|(
literal|"xml:lang"
argument_list|)
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|"x-default"
argument_list|)
condition|)
block|{
name|alt
operator|.
name|removeProperty
argument_list|(
name|xdefault
argument_list|)
expr_stmt|;
name|xdefaultFound
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xdefaultFound
condition|)
block|{
name|it
operator|=
name|alt
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
name|reordered
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
name|toDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|()
decl_stmt|;
name|reordered
operator|.
name|add
argument_list|(
name|xdefault
argument_list|)
expr_stmt|;
name|AbstractField
name|tmp
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|reordered
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|toDelete
operator|.
name|add
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|eraseProperties
init|=
name|toDelete
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|eraseProperties
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|alt
operator|.
name|removeProperty
argument_list|(
name|eraseProperties
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|it
operator|=
name|reordered
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|alt
operator|.
name|addProperty
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * Set a multi-lingual property on the schema, using the current prefix. 	 *  	 * @param simpleName 	 *            the local name of the property 	 * @param language 	 *            the language concerned 	 * @param value 	 *            the value to set for the language specified 	 */
specifier|public
name|void
name|setLanguagePropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|String
name|language
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|this
operator|.
name|setLanguagePropertyValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|,
name|language
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Set the value of a multi-lingual property. 	 *  	 * @param qualifiedName 	 *            The name of the property, it must include the namespace 	 *            prefix. ie "pdf:Keywords" 	 * @param language 	 *            The language code of the value. If null then "x-default" is 	 *            assumed. 	 * @param value 	 *            The value of the property in the specified language. 	 */
specifier|public
name|void
name|setLanguagePropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|String
name|language
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|AbstractField
name|property
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
name|ComplexProperty
name|prop
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
block|{
comment|// Analyzing content of property
if|if
condition|(
name|property
operator|instanceof
name|ComplexProperty
condition|)
block|{
name|prop
operator|=
operator|(
name|ComplexProperty
operator|)
name|property
expr_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|itCplx
init|=
name|prop
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|// try to find the same lang definition
name|AbstractField
name|tmp
decl_stmt|;
comment|// Try to find a definition
while|while
condition|(
name|itCplx
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|itCplx
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// System.err.println(tmp.getAttribute("xml:lang").getStringValue());
if|if
condition|(
name|tmp
operator|.
name|getAttribute
argument_list|(
literal|"xml:lang"
argument_list|)
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|language
argument_list|)
condition|)
block|{
comment|// the same language has been found
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// if value null, erase this definition
name|prop
operator|.
name|getContainer
argument_list|()
operator|.
name|removeProperty
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prop
operator|.
name|getContainer
argument_list|()
operator|.
name|removeProperty
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|TextType
name|langValue
decl_stmt|;
name|langValue
operator|=
operator|new
name|TextType
argument_list|(
name|metadata
argument_list|,
literal|"rdf"
argument_list|,
literal|"li"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|langValue
operator|.
name|setAttribute
argument_list|(
operator|new
name|Attribute
argument_list|(
literal|null
argument_list|,
literal|"xml"
argument_list|,
literal|"lang"
argument_list|,
name|language
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|langValue
argument_list|)
expr_stmt|;
block|}
name|reorganizeAltOrder
argument_list|(
name|prop
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// if no definition found, we add a new one
name|TextType
name|langValue
decl_stmt|;
name|langValue
operator|=
operator|new
name|TextType
argument_list|(
name|metadata
argument_list|,
literal|"rdf"
argument_list|,
literal|"li"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|langValue
operator|.
name|setAttribute
argument_list|(
operator|new
name|Attribute
argument_list|(
literal|null
argument_list|,
literal|"xml"
argument_list|,
literal|"lang"
argument_list|,
name|language
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|langValue
argument_list|)
expr_stmt|;
name|reorganizeAltOrder
argument_list|(
name|prop
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
index|[]
name|splittedQualifiedName
init|=
name|qualifiedName
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|prop
operator|=
operator|new
name|ComplexProperty
argument_list|(
name|metadata
argument_list|,
name|splittedQualifiedName
index|[
literal|0
index|]
argument_list|,
name|splittedQualifiedName
index|[
literal|1
index|]
argument_list|,
name|ComplexProperty
operator|.
name|ALTERNATIVE_ARRAY
argument_list|)
expr_stmt|;
name|TextType
name|langValue
decl_stmt|;
name|langValue
operator|=
operator|new
name|TextType
argument_list|(
name|metadata
argument_list|,
literal|"rdf"
argument_list|,
literal|"li"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|langValue
operator|.
name|setAttribute
argument_list|(
operator|new
name|Attribute
argument_list|(
literal|null
argument_list|,
literal|"xml"
argument_list|,
literal|"lang"
argument_list|,
name|language
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|langValue
argument_list|)
expr_stmt|;
name|content
operator|.
name|addProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Get the value of a multi-lingual property, using the current prefix. 	 *  	 * @param simpleName 	 *            the local name of the property 	 * @param language 	 *            The language code of the value. If null then "x-default" is 	 *            assumed. 	 *  	 * @return The value of the language property. 	 */
specifier|public
name|String
name|getLanguagePropertyValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|,
name|String
name|language
parameter_list|)
block|{
return|return
name|this
operator|.
name|getLanguagePropertyValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|,
name|language
argument_list|)
return|;
block|}
comment|/** 	 * Get the value of a multi-lingual property. 	 *  	 * @param qualifiedName 	 *            The name of the property, it must include the namespace 	 *            prefix. ie "pdf:Keywords" 	 * @param language 	 *            The language code of the value. If null then "x-default" is 	 *            assumed. 	 *  	 * @return The value of the language property. 	 */
specifier|public
name|String
name|getLanguagePropertyValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|String
name|language
parameter_list|)
block|{
if|if
condition|(
name|language
operator|==
literal|null
condition|)
block|{
name|language
operator|=
literal|"x-default"
expr_stmt|;
block|}
name|AbstractField
name|property
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|property
operator|instanceof
name|ComplexProperty
condition|)
block|{
name|ComplexProperty
name|prop
init|=
operator|(
name|ComplexProperty
operator|)
name|property
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|langsDef
init|=
name|prop
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|tmp
decl_stmt|;
name|Attribute
name|text
decl_stmt|;
while|while
condition|(
name|langsDef
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|langsDef
operator|.
name|next
argument_list|()
expr_stmt|;
name|text
operator|=
name|tmp
operator|.
name|getAttribute
argument_list|(
literal|"xml:lang"
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|text
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|language
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|TextType
operator|)
name|tmp
operator|)
operator|.
name|getStringValue
argument_list|()
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The property '"
operator|+
name|qualifiedName
operator|+
literal|"' is not of Lang Alt type"
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Get a list of all languages that are currently defined for a specific 	 * property, using the current prefix. 	 *  	 * @param simpleName 	 *            the local name of the property 	 * @return A list of all languages, this will return an non-null empty list 	 *         if none have been defined. 	 */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getLanguagePropertyLanguagesValueAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|this
operator|.
name|getLanguagePropertyLanguagesValue
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|)
return|;
block|}
comment|/** 	 * Get a list of all languages that are currently defined for a specific 	 * property. 	 *  	 * @param qualifiedName 	 *            The name of the property, it must include the namespace 	 *            prefix. ie "pdf:Keywords" 	 *  	 * @return A list of all languages, this will return an non-null empty list 	 *         if none have been defined. 	 */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getLanguagePropertyLanguagesValue
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|retval
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|AbstractField
name|property
init|=
name|getAbstractProperty
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|property
operator|instanceof
name|ComplexProperty
condition|)
block|{
name|ComplexProperty
name|prop
init|=
operator|(
name|ComplexProperty
operator|)
name|property
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|langsDef
init|=
name|prop
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|tmp
decl_stmt|;
name|Attribute
name|text
decl_stmt|;
while|while
condition|(
name|langsDef
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|langsDef
operator|.
name|next
argument_list|()
expr_stmt|;
name|text
operator|=
name|tmp
operator|.
name|getAttribute
argument_list|(
literal|"xml:lang"
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|!=
literal|null
condition|)
block|{
name|retval
operator|.
name|add
argument_list|(
name|text
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|.
name|add
argument_list|(
literal|"x-default"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The property '"
operator|+
name|qualifiedName
operator|+
literal|"' is not of Lang Alt type"
argument_list|)
throw|;
block|}
block|}
comment|// no property with that name
return|return
literal|null
return|;
block|}
comment|/** 	 * A basic schema merge, it merges bags and sequences and replace everything 	 * else. 	 *  	 * @param xmpSchema 	 *            The schema to merge. 	 * @throws IOException 	 *             If there is an error during the merge. 	 */
specifier|public
name|void
name|merge
parameter_list|(
name|XMPSchema
name|xmpSchema
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|xmpSchema
operator|.
name|getClass
argument_list|()
operator|.
name|equals
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can only merge schemas of the same type."
argument_list|)
throw|;
block|}
name|Iterator
argument_list|<
name|Attribute
argument_list|>
name|itAtt
init|=
name|xmpSchema
operator|.
name|content
operator|.
name|getAllAttributes
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Attribute
name|att
decl_stmt|;
while|while
condition|(
name|itAtt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|att
operator|=
name|itAtt
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|att
operator|.
name|getPrefix
argument_list|()
operator|.
name|equals
argument_list|(
name|getPrefix
argument_list|()
argument_list|)
condition|)
block|{
name|content
operator|.
name|setAttribute
argument_list|(
name|att
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|analyzedPropQualifiedName
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|itProp
init|=
name|xmpSchema
operator|.
name|content
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|prop
decl_stmt|;
while|while
condition|(
name|itProp
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|prop
operator|=
name|itProp
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|prop
operator|.
name|getPrefix
argument_list|()
operator|.
name|equals
argument_list|(
name|getPrefix
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|prop
operator|instanceof
name|ComplexProperty
condition|)
block|{
name|analyzedPropQualifiedName
operator|=
name|prop
operator|.
name|getQualifiedName
argument_list|()
expr_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|itActualEmbeddedProperties
init|=
name|content
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|tmpEmbeddedProperty
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|itNewValues
decl_stmt|;
name|TextType
name|tmpNewValue
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|itOldValues
decl_stmt|;
name|TextType
name|tmpOldValue
decl_stmt|;
name|boolean
name|alreadyPresent
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|itActualEmbeddedProperties
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmpEmbeddedProperty
operator|=
name|itActualEmbeddedProperties
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmpEmbeddedProperty
operator|instanceof
name|ComplexProperty
condition|)
block|{
if|if
condition|(
name|tmpEmbeddedProperty
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|analyzedPropQualifiedName
argument_list|)
condition|)
block|{
name|itNewValues
operator|=
operator|(
operator|(
name|ComplexProperty
operator|)
name|prop
operator|)
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
comment|// Merge a complex property
while|while
condition|(
name|itNewValues
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmpNewValue
operator|=
operator|(
name|TextType
operator|)
name|itNewValues
operator|.
name|next
argument_list|()
expr_stmt|;
name|itOldValues
operator|=
operator|(
operator|(
name|ComplexProperty
operator|)
name|tmpEmbeddedProperty
operator|)
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|itOldValues
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|alreadyPresent
condition|)
block|{
name|tmpOldValue
operator|=
operator|(
name|TextType
operator|)
name|itOldValues
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmpOldValue
operator|.
name|getStringValue
argument_list|()
operator|.
name|equals
argument_list|(
name|tmpNewValue
operator|.
name|getStringValue
argument_list|()
argument_list|)
condition|)
block|{
name|alreadyPresent
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|alreadyPresent
condition|)
block|{
operator|(
operator|(
name|ComplexProperty
operator|)
name|tmpEmbeddedProperty
operator|)
operator|.
name|getContainer
argument_list|()
operator|.
name|addProperty
argument_list|(
name|tmpNewValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|content
operator|.
name|addProperty
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** 	 * Get an AbstractField list corresponding to the content of an array Return 	 * null if the property is unknown 	 *  	 * @param qualifiedName 	 *            the full qualified name of the property concerned 	 * @return List of property contained in the complex property 	 * @throws BadFieldValueException 	 *             Property not contains property (not complex property) 	 */
specifier|public
name|List
argument_list|<
name|AbstractField
argument_list|>
name|getArrayList
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
throws|throws
name|BadFieldValueException
block|{
name|ComplexProperty
name|array
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|itProp
init|=
name|content
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|tmp
decl_stmt|;
while|while
condition|(
name|itProp
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|itProp
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|qualifiedName
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|instanceof
name|ComplexProperty
condition|)
block|{
name|array
operator|=
operator|(
name|ComplexProperty
operator|)
name|tmp
expr_stmt|;
break|break;
block|}
else|else
block|{
throw|throw
operator|new
name|BadFieldValueException
argument_list|(
literal|"Property asked not seems to be an array"
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|array
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|array
operator|.
name|getContainer
argument_list|()
operator|.
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AbstractField
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractField
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Get PropertyContainer of this Schema 	 *  	 * @return the ComplexProperty which represents the schema content 	 */
specifier|public
name|ComplexPropertyContainer
name|getContent
parameter_list|()
block|{
return|return
name|content
return|;
block|}
comment|/** 	 * Get All attributes defined for this schema 	 *  	 * @return Attributes list defined for this schema 	 */
specifier|public
name|List
argument_list|<
name|Attribute
argument_list|>
name|getAllAttributes
parameter_list|()
block|{
return|return
name|content
operator|.
name|getAllAttributes
argument_list|()
return|;
block|}
comment|/** 	 * Get All properties defined in this schema 	 *  	 * @return Properties list defined in this schema 	 */
specifier|public
name|List
argument_list|<
name|AbstractField
argument_list|>
name|getAllProperties
parameter_list|()
block|{
return|return
name|content
operator|.
name|getAllProperties
argument_list|()
return|;
block|}
comment|/** 	 * Set a new attribute for this schema 	 *  	 * @param attr 	 *            The new Attribute to set 	 */
specifier|public
name|void
name|setAttribute
parameter_list|(
name|Attribute
name|attr
parameter_list|)
block|{
name|content
operator|.
name|setAttribute
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Add a new Property to this schema 	 *  	 * @param obj 	 *            The new property to add 	 */
specifier|public
name|void
name|addProperty
parameter_list|(
name|AbstractField
name|obj
parameter_list|)
block|{
name|content
operator|.
name|addProperty
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Get DOM Element for rdf/xml serialization 	 *  	 * @return the DOM Element 	 */
specifier|public
name|Element
name|getElement
parameter_list|()
block|{
return|return
name|content
operator|.
name|getElement
argument_list|()
return|;
block|}
comment|/** 	 * get a Property with its name, using the current prefix 	 *  	 * @param simpleName 	 *            the local name of the property 	 * @return The property wanted 	 */
specifier|protected
name|AbstractField
name|getPropertyAsSimple
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|getProperty
argument_list|(
name|localPrefixSep
operator|+
name|simpleName
argument_list|)
return|;
block|}
comment|/** 	 * get a Property with its qualified Name (with its prefix) 	 *  	 * @param qualifiedName 	 *            The full qualified name of the property wanted 	 * @return the property wanted 	 */
specifier|protected
name|AbstractField
name|getProperty
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
name|Iterator
argument_list|<
name|AbstractField
argument_list|>
name|it
init|=
name|getAllProperties
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|AbstractField
name|tmp
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|equals
argument_list|(
name|qualifiedName
argument_list|)
condition|)
block|{
return|return
name|tmp
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** 	 * Return local prefix 	 *  	 * @return current prefix fixed for this schema 	 */
specifier|public
name|String
name|getLocalPrefix
parameter_list|()
block|{
return|return
name|this
operator|.
name|localPrefix
return|;
block|}
comment|/** 	 * Return local prefix with separator 	 *  	 * @return current prefix fixed for this schema with ':' separator 	 */
specifier|public
name|String
name|getLocalPrefixWithSeparator
parameter_list|()
block|{
return|return
name|this
operator|.
name|localPrefixSep
return|;
block|}
block|}
end_class

end_unit

