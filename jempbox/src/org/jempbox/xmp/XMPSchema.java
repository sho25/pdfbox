begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2006, www.jempbox.org  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  * 3. Neither the name of pdfbox; nor the names of its  *    contributors may be used to endorse or promote products derived from this  *    software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * http://www.jempbox.org  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|jempbox
operator|.
name|xmp
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jempbox
operator|.
name|impl
operator|.
name|DateConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|jempbox
operator|.
name|impl
operator|.
name|XMLUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NamedNodeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_comment
comment|/**  * This class represents a metadata schema that can be stored in an XMP  * document. It handles all generic properties that are available. See  * subclasses for access to specific properties.  *   * @author<a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>  * @version $Revision: 1.8 $  */
end_comment

begin_class
specifier|public
class|class
name|XMPSchema
block|{
comment|/**      * The standard xmlns namespace.      */
specifier|public
specifier|static
specifier|final
name|String
name|NS_NAMESPACE
init|=
literal|"http://www.w3.org/2000/xmlns/"
decl_stmt|;
comment|/**      * The XML schema prefix.      */
specifier|protected
name|String
name|prefix
decl_stmt|;
comment|/**      * The DOM representation of this object.      */
specifier|protected
name|Element
name|schema
init|=
literal|null
decl_stmt|;
comment|/**      * Create a new blank schema that can be populated.      *       * @param parent      *            The parent XMP document that this schema will be part of.      * @param namespaceName      *            The name of the namespace, ie pdf,dc,...      * @param namespaceURI      *            The URI of the namespace, ie "http://ns.adobe.com/pdf/1.3/"      */
specifier|public
name|XMPSchema
parameter_list|(
name|XMPMetadata
name|parent
parameter_list|,
name|String
name|namespaceName
parameter_list|,
name|String
name|namespaceURI
parameter_list|)
block|{
name|schema
operator|=
name|parent
operator|.
name|xmpDocument
operator|.
name|createElementNS
argument_list|(
literal|"http://www.w3.org/1999/02/22-rdf-syntax-ns#"
argument_list|,
literal|"rdf:Description"
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|namespaceName
expr_stmt|;
name|schema
operator|.
name|setAttributeNS
argument_list|(
name|NS_NAMESPACE
argument_list|,
literal|"xmlns:"
operator|+
name|namespaceName
argument_list|,
name|namespaceURI
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create schema from an existing XML element.      *       * @param element      *            The existing XML element.      * @param aPrefix      *            The XML prefix.      */
specifier|public
name|XMPSchema
parameter_list|(
name|Element
name|element
parameter_list|,
name|String
name|aPrefix
parameter_list|)
block|{
name|schema
operator|=
name|element
expr_stmt|;
if|if
condition|(
name|aPrefix
operator|!=
literal|null
condition|)
block|{
name|prefix
operator|=
name|aPrefix
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
literal|""
expr_stmt|;
block|}
block|}
comment|/**      * Get the XML element that is represented by this schema.      *       * @return The root XML element of this schema.      */
specifier|public
name|Element
name|getElement
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
comment|/**      * Get the RDF about attribute.      *       * @return The RDF 'about' attribute.      */
specifier|public
name|String
name|getAbout
parameter_list|()
block|{
return|return
name|getTextProperty
argument_list|(
literal|"rdf:about"
argument_list|)
return|;
block|}
comment|/**      * Set the RDF 'about' attribute. Passing in null will clear this attribute.      *       * @param about      *            The new RFD about value.      */
specifier|public
name|void
name|setAbout
parameter_list|(
name|String
name|about
parameter_list|)
block|{
if|if
condition|(
name|about
operator|==
literal|null
condition|)
block|{
name|schema
operator|.
name|removeAttribute
argument_list|(
literal|"rdf:about"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|schema
operator|.
name|setAttribute
argument_list|(
literal|"rdf:about"
argument_list|,
name|about
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Set a simple text property on the schema.      *       * @param propertyName      *            The name of the property, it must contain the namespace      *            prefix, ie "pdf:Keywords"      * @param propertyValue      *            The value for the property, can be any string. Passing null      *            will remove the property.      */
specifier|public
name|void
name|setTextProperty
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|propertyValue
parameter_list|)
block|{
if|if
condition|(
name|propertyValue
operator|==
literal|null
condition|)
block|{
name|schema
operator|.
name|removeAttribute
argument_list|(
name|propertyName
argument_list|)
expr_stmt|;
name|NodeList
name|keywordList
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keywordList
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|schema
operator|.
name|removeChild
argument_list|(
name|keywordList
operator|.
name|item
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|schema
operator|.
name|hasAttribute
argument_list|(
name|propertyName
argument_list|)
condition|)
block|{
name|schema
operator|.
name|setAttribute
argument_list|(
name|propertyName
argument_list|,
name|propertyValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|schema
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
name|NodeList
name|nodeList
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|node
init|=
operator|(
name|Element
operator|)
name|nodeList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|node
operator|.
name|setNodeValue
argument_list|(
name|propertyValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Element
name|textNode
init|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
name|XMLUtil
operator|.
name|setStringValue
argument_list|(
name|textNode
argument_list|,
name|propertyValue
argument_list|)
expr_stmt|;
name|schema
operator|.
name|appendChild
argument_list|(
name|textNode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|schema
operator|.
name|setAttribute
argument_list|(
name|propertyName
argument_list|,
name|propertyValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Get the value of a simple text property.      *       * @param propertyName      *            The name of the property to get, it must include the namespace      *            prefix. ie "pdf:Keywords".      *       * @return The value of the text property or the null if there is no value.      */
specifier|public
name|String
name|getTextProperty
parameter_list|(
name|String
name|propertyName
parameter_list|)
block|{
comment|// propertyValue == null does not work, since getAttribute returns the
comment|// empty string if the attribute is not found
if|if
condition|(
name|schema
operator|.
name|hasAttribute
argument_list|(
name|propertyName
argument_list|)
condition|)
block|{
return|return
name|schema
operator|.
name|getAttribute
argument_list|(
name|propertyName
argument_list|)
return|;
block|}
else|else
block|{
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|node
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
return|return
name|XMLUtil
operator|.
name|getStringValue
argument_list|(
name|node
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Get the value of the property as a date.      *       * @param propertyName      *            The fully qualified property name for the date.      *       * @return The value of the property as a date.      *       * @throws IOException      *             If there is an error converting the value to a date.      */
specifier|public
name|Calendar
name|getDateProperty
parameter_list|(
name|String
name|propertyName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|DateConverter
operator|.
name|toCalendar
argument_list|(
name|getTextProperty
argument_list|(
name|propertyName
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Set the value of the property as a date.      *       * @param propertyName      *            The fully qualified property name for the date.      * @param date      *            The date to set, or null to clear.      */
specifier|public
name|void
name|setDateProperty
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|setTextProperty
argument_list|(
name|propertyName
argument_list|,
name|DateConverter
operator|.
name|toISO8601
argument_list|(
name|date
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the value of the property as a boolean.      *       * @param propertyName      *            The fully qualified property name for the boolean.      *       * @return The value of the property as a boolean.      */
specifier|public
name|Boolean
name|getBooleanProperty
parameter_list|(
name|String
name|propertyName
parameter_list|)
block|{
name|Boolean
name|value
init|=
literal|null
decl_stmt|;
name|String
name|stringValue
init|=
name|getTextProperty
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|stringValue
operator|!=
literal|null
condition|)
block|{
name|value
operator|=
name|stringValue
operator|.
name|equals
argument_list|(
literal|"True"
argument_list|)
condition|?
name|Boolean
operator|.
name|TRUE
else|:
name|Boolean
operator|.
name|FALSE
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/**      * Set the value of the property as a boolean.      *       * @param propertyName      *            The fully qualified property name for the boolean.      * @param bool      *            The boolean to set, or null to clear.      */
specifier|public
name|void
name|setBooleanProperty
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|Boolean
name|bool
parameter_list|)
block|{
name|String
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|bool
operator|!=
literal|null
condition|)
block|{
name|value
operator|=
name|bool
operator|.
name|booleanValue
argument_list|()
condition|?
literal|"True"
else|:
literal|"False"
expr_stmt|;
block|}
name|setTextProperty
argument_list|(
name|propertyName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the value of the property as an integer.      *       * @param propertyName      *            The fully qualified property name for the integer.      *       * @return The value of the property as an integer.      */
specifier|public
name|Integer
name|getIntegerProperty
parameter_list|(
name|String
name|propertyName
parameter_list|)
block|{
name|Integer
name|retval
init|=
literal|null
decl_stmt|;
name|String
name|intProperty
init|=
name|getTextProperty
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|intProperty
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|retval
operator|=
operator|new
name|Integer
argument_list|(
name|intProperty
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Set the value of the property as an integer.      *       * @param propertyName      *            The fully qualified property name for the integer.      * @param intValue      *            The int to set, or null to clear.      */
specifier|public
name|void
name|setIntegerProperty
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|Integer
name|intValue
parameter_list|)
block|{
name|String
name|textValue
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|intValue
operator|!=
literal|null
condition|)
block|{
name|textValue
operator|=
name|intValue
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|setTextProperty
argument_list|(
name|propertyName
argument_list|,
name|textValue
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove all matching entries with the given value from the bag.      *       * @param bagName      *            The name of the bag, it must include the namespace prefix. ie      *            "pdf:Keywords".      * @param bagValue      *            The value to remove from the bagList.      */
specifier|public
name|void
name|removeBagValue
parameter_list|(
name|String
name|bagName
parameter_list|,
name|String
name|bagValue
parameter_list|)
block|{
name|Element
name|bagElement
init|=
literal|null
decl_stmt|;
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|bagName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|contElement
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|bagList
init|=
name|contElement
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Bag"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bagList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|bagElement
operator|=
operator|(
name|Element
operator|)
name|bagList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|NodeList
name|items
init|=
name|bagElement
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|items
operator|.
name|getLength
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Element
name|li
init|=
operator|(
name|Element
operator|)
name|items
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|XMLUtil
operator|.
name|getStringValue
argument_list|(
name|li
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|equals
argument_list|(
name|bagValue
argument_list|)
condition|)
block|{
name|bagElement
operator|.
name|removeChild
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Add an entry to a bag property.      *       * @param bagName      *            The name of the bag, it must include the namespace prefix. ie      *            "pdf:Keywords".      * @param bagValue      *            The value to add to the bagList.      */
specifier|public
name|void
name|addBagValue
parameter_list|(
name|String
name|bagName
parameter_list|,
name|String
name|bagValue
parameter_list|)
block|{
name|Element
name|bagElement
init|=
literal|null
decl_stmt|;
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|bagName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|contElement
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|bagList
init|=
name|contElement
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Bag"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bagList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|bagElement
operator|=
operator|(
name|Element
operator|)
name|bagList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Element
name|contElement
init|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
name|bagName
argument_list|)
decl_stmt|;
name|schema
operator|.
name|appendChild
argument_list|(
name|contElement
argument_list|)
expr_stmt|;
name|bagElement
operator|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
literal|"rdf:Bag"
argument_list|)
expr_stmt|;
name|contElement
operator|.
name|appendChild
argument_list|(
name|bagElement
argument_list|)
expr_stmt|;
block|}
name|Element
name|liElement
init|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
name|XMLUtil
operator|.
name|setStringValue
argument_list|(
name|liElement
argument_list|,
name|bagValue
argument_list|)
expr_stmt|;
name|bagElement
operator|.
name|appendChild
argument_list|(
name|liElement
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get all the values of the bag property. This will return a list of      * java.lang.String objects, this is a read-only list.      *       * @param bagName      *            The name of the bag property to get, it must include the      *            namespace prefix. ie "pdf:Keywords"      *       * @return All of the values of the bag property in a list.      */
specifier|public
name|List
name|getBagList
parameter_list|(
name|String
name|bagName
parameter_list|)
block|{
name|List
name|retval
init|=
literal|null
decl_stmt|;
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|bagName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|contributor
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|bagList
init|=
name|contributor
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Bag"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bagList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|bag
init|=
operator|(
name|Element
operator|)
name|bagList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|retval
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
name|NodeList
name|items
init|=
name|bag
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Element
name|li
init|=
operator|(
name|Element
operator|)
name|items
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|retval
operator|.
name|add
argument_list|(
name|XMLUtil
operator|.
name|getStringValue
argument_list|(
name|li
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Remove all matching values from a sequence property.      *       * @param seqName      *            The name of the sequence property. It must include the      *            namespace prefix. ie "pdf:Keywords".      * @param seqValue      *            The value to remove from the list.      */
specifier|public
name|void
name|removeSequenceValue
parameter_list|(
name|String
name|seqName
parameter_list|,
name|String
name|seqValue
parameter_list|)
block|{
name|Element
name|bagElement
init|=
literal|null
decl_stmt|;
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|seqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|contElement
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|bagList
init|=
name|contElement
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Seq"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bagList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|bagElement
operator|=
operator|(
name|Element
operator|)
name|bagList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|NodeList
name|items
init|=
name|bagElement
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|items
operator|.
name|getLength
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Element
name|li
init|=
operator|(
name|Element
operator|)
name|items
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|XMLUtil
operator|.
name|getStringValue
argument_list|(
name|li
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|.
name|equals
argument_list|(
name|seqValue
argument_list|)
condition|)
block|{
name|bagElement
operator|.
name|removeChild
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Remove a value from a sequence property. This will remove all entries      * from the list.      *       * @param seqName      *            The name of the sequence property. It must include the      *            namespace prefix. ie "pdf:Keywords".      * @param seqValue      *            The value to remove from the list.      */
specifier|public
name|void
name|removeSequenceValue
parameter_list|(
name|String
name|seqName
parameter_list|,
name|Elementable
name|seqValue
parameter_list|)
block|{
name|Element
name|bagElement
init|=
literal|null
decl_stmt|;
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|seqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|contElement
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|bagList
init|=
name|contElement
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Seq"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bagList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|bagElement
operator|=
operator|(
name|Element
operator|)
name|bagList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|NodeList
name|items
init|=
name|bagElement
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Element
name|li
init|=
operator|(
name|Element
operator|)
name|items
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|li
operator|==
name|seqValue
operator|.
name|getElement
argument_list|()
condition|)
block|{
name|bagElement
operator|.
name|removeChild
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Add a new value to a sequence property.      *       * @param seqName      *            The name of the sequence property, it must include the      *            namespace prefix. ie "pdf:Keywords"      * @param seqValue      *            The value to add to the sequence.      */
specifier|public
name|void
name|addSequenceValue
parameter_list|(
name|String
name|seqName
parameter_list|,
name|String
name|seqValue
parameter_list|)
block|{
name|Element
name|bagElement
init|=
literal|null
decl_stmt|;
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|seqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|contElement
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|bagList
init|=
name|contElement
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Seq"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bagList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|bagElement
operator|=
operator|(
name|Element
operator|)
name|bagList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// xml is crap discard it
name|schema
operator|.
name|removeChild
argument_list|(
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bagElement
operator|==
literal|null
condition|)
block|{
name|Element
name|contElement
init|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
name|seqName
argument_list|)
decl_stmt|;
name|schema
operator|.
name|appendChild
argument_list|(
name|contElement
argument_list|)
expr_stmt|;
name|bagElement
operator|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
literal|"rdf:Seq"
argument_list|)
expr_stmt|;
name|contElement
operator|.
name|appendChild
argument_list|(
name|bagElement
argument_list|)
expr_stmt|;
block|}
name|Element
name|liElement
init|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
name|liElement
operator|.
name|appendChild
argument_list|(
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createTextNode
argument_list|(
name|seqValue
argument_list|)
argument_list|)
expr_stmt|;
name|bagElement
operator|.
name|appendChild
argument_list|(
name|liElement
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a new value to a sequence property.      *       * @param seqName      *            The name of the sequence property, it must include the      *            namespace prefix. ie "pdf:Keywords"      * @param seqValue      *            The value to add to the sequence.      */
specifier|public
name|void
name|addSequenceValue
parameter_list|(
name|String
name|seqName
parameter_list|,
name|Elementable
name|seqValue
parameter_list|)
block|{
name|Element
name|bagElement
init|=
literal|null
decl_stmt|;
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|seqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|contElement
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|bagList
init|=
name|contElement
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Seq"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bagList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|bagElement
operator|=
operator|(
name|Element
operator|)
name|bagList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Element
name|contElement
init|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
name|seqName
argument_list|)
decl_stmt|;
name|schema
operator|.
name|appendChild
argument_list|(
name|contElement
argument_list|)
expr_stmt|;
name|bagElement
operator|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
literal|"rdf:Seq"
argument_list|)
expr_stmt|;
name|contElement
operator|.
name|appendChild
argument_list|(
name|bagElement
argument_list|)
expr_stmt|;
block|}
name|bagElement
operator|.
name|appendChild
argument_list|(
name|seqValue
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get all the values in a sequence property.      *       * @param seqName      *            The name of the sequence property, it must include the      *            namespace prefix. ie "pdf:Keywords".      *       * @return A read-only list of java.lang.String objects or null if the      *         property does not exist.      */
specifier|public
name|List
name|getSequenceList
parameter_list|(
name|String
name|seqName
parameter_list|)
block|{
name|List
name|retval
init|=
literal|null
decl_stmt|;
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|seqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|contributor
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|bagList
init|=
name|contributor
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Seq"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bagList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|bag
init|=
operator|(
name|Element
operator|)
name|bagList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|retval
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
name|NodeList
name|items
init|=
name|bag
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Element
name|li
init|=
operator|(
name|Element
operator|)
name|items
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|retval
operator|.
name|add
argument_list|(
name|XMLUtil
operator|.
name|getStringValue
argument_list|(
name|li
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Get a list of ResourceEvent objects.      *       * @param seqName      *            The name of the sequence to retrieve.      *       * @return A list of ResourceEvent objects or null if they do not exist.      */
specifier|public
name|List
name|getEventSequenceList
parameter_list|(
name|String
name|seqName
parameter_list|)
block|{
name|List
name|retval
init|=
literal|null
decl_stmt|;
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|seqName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|contributor
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|bagList
init|=
name|contributor
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Seq"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bagList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|bag
init|=
operator|(
name|Element
operator|)
name|bagList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|retval
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
name|NodeList
name|items
init|=
name|bag
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Element
name|li
init|=
operator|(
name|Element
operator|)
name|items
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|retval
operator|.
name|add
argument_list|(
operator|new
name|ResourceEvent
argument_list|(
name|li
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Remove a date sequence value from the list.      *       * @param seqName      *            The name of the sequence property, it must include the      *            namespace prefix. ie "pdf:Keywords"      * @param date      *            The date to remove from the sequence property.      */
specifier|public
name|void
name|removeSequenceDateValue
parameter_list|(
name|String
name|seqName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|String
name|dateAsString
init|=
name|DateConverter
operator|.
name|toISO8601
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|removeSequenceValue
argument_list|(
name|seqName
argument_list|,
name|dateAsString
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a date sequence value to the list.      *       * @param seqName      *            The name of the sequence property, it must include the      *            namespace prefix. ie "pdf:Keywords"      * @param date      *            The date to add to the sequence property.      */
specifier|public
name|void
name|addSequenceDateValue
parameter_list|(
name|String
name|seqName
parameter_list|,
name|Calendar
name|date
parameter_list|)
block|{
name|String
name|dateAsString
init|=
name|DateConverter
operator|.
name|toISO8601
argument_list|(
name|date
argument_list|)
decl_stmt|;
name|addSequenceValue
argument_list|(
name|seqName
argument_list|,
name|dateAsString
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get all the date values in a sequence property.      *       * @param seqName      *            The name of the sequence property, it must include the      *            namespace prefix. ie "pdf:Keywords".      *       * @return A read-only list of java.util.Calendar objects or null if the      *         property does not exist.      *       * @throws IOException      *             If there is an error converting the value to a date.      */
specifier|public
name|List
name|getSequenceDateList
parameter_list|(
name|String
name|seqName
parameter_list|)
throws|throws
name|IOException
block|{
name|List
name|strings
init|=
name|getSequenceList
argument_list|(
name|seqName
argument_list|)
decl_stmt|;
name|List
name|retval
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|strings
operator|!=
literal|null
condition|)
block|{
name|retval
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|retval
operator|.
name|add
argument_list|(
name|DateConverter
operator|.
name|toCalendar
argument_list|(
operator|(
name|String
operator|)
name|strings
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Set the value of a multi-lingual property.      *       * @param propertyName      *            The name of the property, it must include the namespace      *            prefix. ie "pdf:Keywords"      * @param language      *            The language code of the value. If null then "x-default" is      *            assumed.      * @param value      *            The value of the property in the specified language.      */
specifier|public
name|void
name|setLanguageProperty
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|language
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
name|Element
name|property
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// value is null, it doesn't already exist so there
comment|// is nothing to do.
return|return;
block|}
name|property
operator|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
name|propertyName
argument_list|)
expr_stmt|;
name|schema
operator|.
name|appendChild
argument_list|(
name|property
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|property
operator|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|Element
name|alt
init|=
literal|null
decl_stmt|;
name|NodeList
name|altList
init|=
name|property
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Alt"
argument_list|)
decl_stmt|;
if|if
condition|(
name|altList
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// value is null, it doesn't already exist so there
comment|// is nothing to do.
return|return;
block|}
name|alt
operator|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
literal|"rdf:Alt"
argument_list|)
expr_stmt|;
name|property
operator|.
name|appendChild
argument_list|(
name|alt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt
operator|=
operator|(
name|Element
operator|)
name|altList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|NodeList
name|items
init|=
name|alt
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
if|if
condition|(
name|language
operator|==
literal|null
condition|)
block|{
name|language
operator|=
literal|"x-default"
expr_stmt|;
block|}
name|boolean
name|foundValue
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Element
name|li
init|=
operator|(
name|Element
operator|)
name|items
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|alt
operator|.
name|removeChild
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|language
operator|.
name|equals
argument_list|(
name|li
operator|.
name|getAttribute
argument_list|(
literal|"xml:lang"
argument_list|)
argument_list|)
condition|)
block|{
name|foundValue
operator|=
literal|true
expr_stmt|;
name|XMLUtil
operator|.
name|setStringValue
argument_list|(
name|li
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|foundValue
condition|)
block|{
name|Element
name|li
init|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
name|li
operator|.
name|setAttribute
argument_list|(
literal|"xml:lang"
argument_list|,
name|language
argument_list|)
expr_stmt|;
name|XMLUtil
operator|.
name|setStringValue
argument_list|(
name|li
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|language
operator|.
name|equals
argument_list|(
literal|"x-default"
argument_list|)
condition|)
block|{
comment|// default should be first element, see XMP spec
name|alt
operator|.
name|insertBefore
argument_list|(
name|li
argument_list|,
name|alt
operator|.
name|getFirstChild
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt
operator|.
name|appendChild
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Get the value of a multi-lingual property.      *       * @param propertyName      *            The name of the property, it must include the namespace      *            prefix. ie "pdf:Keywords"      * @param language      *            The language code of the value. If null then "x-default" is      *            assumed.      *       * @return The value of the language property.      */
specifier|public
name|String
name|getLanguageProperty
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|language
parameter_list|)
block|{
name|String
name|retval
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|language
operator|==
literal|null
condition|)
block|{
name|language
operator|=
literal|"x-default"
expr_stmt|;
block|}
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|property
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|altList
init|=
name|property
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Alt"
argument_list|)
decl_stmt|;
if|if
condition|(
name|altList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|alt
init|=
operator|(
name|Element
operator|)
name|altList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|items
init|=
name|alt
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|getLength
argument_list|()
operator|&&
name|retval
operator|==
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|Element
name|li
init|=
operator|(
name|Element
operator|)
name|items
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|elementLanguage
init|=
name|li
operator|.
name|getAttribute
argument_list|(
literal|"xml:lang"
argument_list|)
decl_stmt|;
if|if
condition|(
name|language
operator|.
name|equals
argument_list|(
name|elementLanguage
argument_list|)
condition|)
block|{
name|retval
operator|=
name|XMLUtil
operator|.
name|getStringValue
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Set the value of a multi-lingual property.      *       * @param propertyName      *            The name of the property, it must include the namespace      *            prefix. ie "pdf:Keywords"      * @param language      *            The language code of the value. If null then "x-default" is      *            assumed.      * @param value      *            The value of the property in the specified language.      */
specifier|public
name|void
name|setThumbnailProperty
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|language
parameter_list|,
name|Thumbnail
name|value
parameter_list|)
block|{
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
name|Element
name|property
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// value is null, it doesn't already exist so there
comment|// is nothing to do.
return|return;
block|}
name|property
operator|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
name|propertyName
argument_list|)
expr_stmt|;
name|schema
operator|.
name|appendChild
argument_list|(
name|property
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|property
operator|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|Element
name|alt
init|=
literal|null
decl_stmt|;
name|NodeList
name|altList
init|=
name|property
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Alt"
argument_list|)
decl_stmt|;
if|if
condition|(
name|altList
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// value is null, it doesn't already exist so there
comment|// is nothing to do.
return|return;
block|}
name|alt
operator|=
name|schema
operator|.
name|getOwnerDocument
argument_list|()
operator|.
name|createElement
argument_list|(
literal|"rdf:Alt"
argument_list|)
expr_stmt|;
name|property
operator|.
name|appendChild
argument_list|(
name|alt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt
operator|=
operator|(
name|Element
operator|)
name|altList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|NodeList
name|items
init|=
name|alt
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
if|if
condition|(
name|language
operator|==
literal|null
condition|)
block|{
name|language
operator|=
literal|"x-default"
expr_stmt|;
block|}
name|boolean
name|foundValue
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Element
name|li
init|=
operator|(
name|Element
operator|)
name|items
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|alt
operator|.
name|removeChild
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|language
operator|.
name|equals
argument_list|(
name|li
operator|.
name|getAttribute
argument_list|(
literal|"xml:lang"
argument_list|)
argument_list|)
condition|)
block|{
name|foundValue
operator|=
literal|true
expr_stmt|;
name|alt
operator|.
name|replaceChild
argument_list|(
name|li
argument_list|,
name|value
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|foundValue
condition|)
block|{
name|Element
name|li
init|=
name|value
operator|.
name|getElement
argument_list|()
decl_stmt|;
name|li
operator|.
name|setAttribute
argument_list|(
literal|"xml:lang"
argument_list|,
name|language
argument_list|)
expr_stmt|;
if|if
condition|(
name|language
operator|.
name|equals
argument_list|(
literal|"x-default"
argument_list|)
condition|)
block|{
comment|// default should be first element, see XMP spec
name|alt
operator|.
name|insertBefore
argument_list|(
name|li
argument_list|,
name|alt
operator|.
name|getFirstChild
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt
operator|.
name|appendChild
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Get the value of a multi-lingual property.      *       * @param propertyName      *            The name of the property, it must include the namespace      *            prefix. ie "pdf:Keywords"      * @param language      *            The language code of the value. If null then "x-default" is      *            assumed.      *       * @return The value of the language property.      */
specifier|public
name|Thumbnail
name|getThumbnailProperty
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|language
parameter_list|)
block|{
name|Thumbnail
name|retval
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|language
operator|==
literal|null
condition|)
block|{
name|language
operator|=
literal|"x-default"
expr_stmt|;
block|}
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|property
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|altList
init|=
name|property
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Alt"
argument_list|)
decl_stmt|;
if|if
condition|(
name|altList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|alt
init|=
operator|(
name|Element
operator|)
name|altList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|items
init|=
name|alt
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|getLength
argument_list|()
operator|&&
name|retval
operator|==
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|Element
name|li
init|=
operator|(
name|Element
operator|)
name|items
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|elementLanguage
init|=
name|li
operator|.
name|getAttribute
argument_list|(
literal|"xml:lang"
argument_list|)
decl_stmt|;
if|if
condition|(
name|language
operator|.
name|equals
argument_list|(
name|elementLanguage
argument_list|)
condition|)
block|{
name|retval
operator|=
operator|new
name|Thumbnail
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * Get a list of all languages that are currently defined for a specific      * property.      *       * @param propertyName      *            The name of the property, it must include the namespace      *            prefix. ie "pdf:Keywords"      *       * @return A list of all languages, this will return an non-null empty list      *         if none have been defined.      */
specifier|public
name|List
name|getLanguagePropertyLanguages
parameter_list|(
name|String
name|propertyName
parameter_list|)
block|{
name|List
name|retval
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|NodeList
name|nodes
init|=
name|schema
operator|.
name|getElementsByTagName
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|property
init|=
operator|(
name|Element
operator|)
name|nodes
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|altList
init|=
name|property
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Alt"
argument_list|)
decl_stmt|;
if|if
condition|(
name|altList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Element
name|alt
init|=
operator|(
name|Element
operator|)
name|altList
operator|.
name|item
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeList
name|items
init|=
name|alt
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:li"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|items
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Element
name|li
init|=
operator|(
name|Element
operator|)
name|items
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|elementLanguage
init|=
name|li
operator|.
name|getAttribute
argument_list|(
literal|"xml:lang"
argument_list|)
decl_stmt|;
if|if
condition|(
name|elementLanguage
operator|==
literal|null
condition|)
block|{
name|retval
operator|.
name|add
argument_list|(
literal|"x-default"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|.
name|add
argument_list|(
name|elementLanguage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|retval
return|;
block|}
comment|/**      * A basic schema merge, it merges bags and sequences and replace everything      * else.      *       * @param xmpSchema The schema to merge.      * @throws IOException If there is an error during the merge.      */
specifier|public
name|void
name|merge
parameter_list|(
name|XMPSchema
name|xmpSchema
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|xmpSchema
operator|.
name|getClass
argument_list|()
operator|.
name|equals
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can only merge schemas of the same type."
argument_list|)
throw|;
block|}
name|NamedNodeMap
name|attributes
init|=
name|xmpSchema
operator|.
name|getElement
argument_list|()
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attributes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|a
init|=
name|attributes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|a
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|String
name|newValue
init|=
name|xmpSchema
operator|.
name|getTextProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|setTextProperty
argument_list|(
name|name
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
name|NodeList
name|nodes
init|=
name|xmpSchema
operator|.
name|getElement
argument_list|()
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|a
init|=
name|nodes
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|a
operator|.
name|getNodeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
if|if
condition|(
name|a
operator|instanceof
name|Element
condition|)
block|{
name|Element
name|e
init|=
operator|(
name|Element
operator|)
name|a
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|NodeList
name|seqList
init|=
name|e
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Seq"
argument_list|)
decl_stmt|;
if|if
condition|(
name|seqList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
name|newList
init|=
name|xmpSchema
operator|.
name|getSequenceList
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|List
name|oldList
init|=
name|getSequenceList
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Iterator
name|it
init|=
name|newList
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|object
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldList
operator|==
literal|null
operator|||
operator|!
name|oldList
operator|.
name|contains
argument_list|(
name|object
argument_list|)
condition|)
block|{
name|addSequenceValue
argument_list|(
name|name
argument_list|,
operator|(
name|String
operator|)
name|object
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
name|NodeList
name|bagList
init|=
name|e
operator|.
name|getElementsByTagName
argument_list|(
literal|"rdf:Bag"
argument_list|)
decl_stmt|;
if|if
condition|(
name|bagList
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
name|newList
init|=
name|xmpSchema
operator|.
name|getBagList
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|List
name|oldList
init|=
name|getBagList
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Iterator
name|it
init|=
name|newList
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|object
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldList
operator|==
literal|null
operator|||
operator|!
name|oldList
operator|.
name|contains
argument_list|(
name|object
argument_list|)
condition|)
block|{
name|addBagValue
argument_list|(
name|name
argument_list|,
operator|(
name|String
operator|)
name|object
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
block|}
block|}
name|String
name|newValue
init|=
name|xmpSchema
operator|.
name|getTextProperty
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|setTextProperty
argument_list|(
name|name
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

