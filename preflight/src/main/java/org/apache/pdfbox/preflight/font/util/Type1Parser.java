begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************  *   * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  *   ****************************************************************************/
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|preflight
operator|.
name|font
operator|.
name|util
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|preflight
operator|.
name|PreflightConstants
operator|.
name|FONT_DICTIONARY_VALUE_ENCODING_MAC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|preflight
operator|.
name|PreflightConstants
operator|.
name|FONT_DICTIONARY_VALUE_ENCODING_MAC_EXP
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|preflight
operator|.
name|PreflightConstants
operator|.
name|FONT_DICTIONARY_VALUE_ENCODING_PDFDOC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|preflight
operator|.
name|PreflightConstants
operator|.
name|FONT_DICTIONARY_VALUE_ENCODING_WIN
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|cff
operator|.
name|IndexData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|cff
operator|.
name|Type1CharStringParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|fontbox
operator|.
name|cff
operator|.
name|Type1FontUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|Encoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|MacRomanEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|PdfDocEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|StandardEncoding
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|pdfbox
operator|.
name|encoding
operator|.
name|WinAnsiEncoding
import|;
end_import

begin_class
specifier|public
specifier|final
class|class
name|Type1Parser
block|{
specifier|protected
specifier|static
specifier|final
name|char
name|NAME_START
init|=
literal|'/'
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|NOTDEF
init|=
name|NAME_START
operator|+
literal|".notdef"
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_LEN_IV
init|=
literal|4
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|PS_STANDARD_ENCODING
init|=
literal|"StandardEncoding"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|PS_ISOLATIN_ENCODING
init|=
literal|"ISOLatin1Encoding"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|TOKEN_ENCODING
init|=
literal|"US-ASCII"
decl_stmt|;
comment|/** 	 * The PostScript font stream. 	 */
specifier|private
name|PeekInputStream
name|fontProgram
init|=
literal|null
decl_stmt|;
comment|/** 	 * The length in bytes of the clear-text portion of the Type1 font program. 	 */
specifier|private
name|int
name|clearTextSize
init|=
literal|0
decl_stmt|;
comment|/** 	 * The length in bytes of the eexec encrypted portion of the type1 font 	 * program. 	 */
specifier|private
name|int
name|eexecSize
init|=
literal|0
decl_stmt|;
comment|/** 	 * This counter is used to know how many byte have been read. 	 * It is used to read the clear part of the font. this computer is 	 * updated during the parsing of the encoding part too but it is not  	 * used. 	 */
specifier|private
name|int
name|numberOfReadBytes
init|=
literal|0
decl_stmt|;
comment|/** 	 * Object which contains information coming from the parsing. 	 */
specifier|private
name|Type1
name|type1Font
init|=
literal|null
decl_stmt|;
specifier|private
name|Type1Parser
parameter_list|(
name|InputStream
name|type1
parameter_list|,
name|int
name|length1
parameter_list|,
name|int
name|length2
parameter_list|,
name|Encoding
name|enc
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|fontProgram
operator|=
operator|new
name|PeekInputStream
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|this
operator|.
name|clearTextSize
operator|=
name|length1
expr_stmt|;
name|this
operator|.
name|eexecSize
operator|=
name|length2
expr_stmt|;
comment|// ---- Instantiate the Encoding Map
if|if
condition|(
name|enc
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|type1Font
operator|=
operator|new
name|Type1
argument_list|(
name|enc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|type1Font
operator|=
operator|new
name|Type1
argument_list|(
operator|new
name|StandardEncoding
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|type1Font
operator|.
name|addCidWithLabel
argument_list|(
operator|-
literal|1
argument_list|,
name|NOTDEF
argument_list|)
expr_stmt|;
block|}
comment|/** 	 *  	 * @param fontProgram the stream of the font program extracted from the PDF file. 	 * @param clearTextLength the length in bytes of the clear part of the font program. 	 * @param eexecLength the length in bytes of the encoded part. 	 * @return 	 * @throws IOException 	 */
specifier|public
specifier|static
name|Type1Parser
name|createParser
parameter_list|(
name|InputStream
name|fontProgram
parameter_list|,
name|int
name|clearTextLength
parameter_list|,
name|int
name|eexecLength
parameter_list|)
throws|throws
name|IOException
block|{
name|Encoding
name|encoding
init|=
name|getEncodingObject
argument_list|(
literal|""
argument_list|)
decl_stmt|;
return|return
name|createParserWithEncodingObject
argument_list|(
name|fontProgram
argument_list|,
name|clearTextLength
argument_list|,
name|eexecLength
argument_list|,
name|encoding
argument_list|)
return|;
block|}
comment|/** 	 *  	 * @param fontProgram the stream of the font program extracted from the PDF file. 	 * @param clearTextLength the length in bytes of the clear part of the font program. 	 * @param eexecLength the length in bytes of the encoded part. 	 * @param encodingName The name of encoding which is used by this font program. 	 * @return 	 * @throws IOException 	 */
specifier|public
specifier|static
name|Type1Parser
name|createParserWithEncodingName
parameter_list|(
name|InputStream
name|fontProgram
parameter_list|,
name|int
name|clearTextLength
parameter_list|,
name|int
name|eexecLength
parameter_list|,
name|String
name|encodingName
parameter_list|)
throws|throws
name|IOException
block|{
name|Encoding
name|encoding
init|=
name|getEncodingObject
argument_list|(
name|encodingName
argument_list|)
decl_stmt|;
return|return
name|createParserWithEncodingObject
argument_list|(
name|fontProgram
argument_list|,
name|clearTextLength
argument_list|,
name|eexecLength
argument_list|,
name|encoding
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Encoding
name|getEncodingObject
parameter_list|(
name|String
name|encodingName
parameter_list|)
block|{
name|Encoding
name|encoding
init|=
operator|new
name|StandardEncoding
argument_list|()
decl_stmt|;
if|if
condition|(
name|FONT_DICTIONARY_VALUE_ENCODING_MAC
operator|.
name|equals
argument_list|(
name|encodingName
argument_list|)
condition|)
block|{
name|encoding
operator|=
operator|new
name|MacRomanEncoding
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FONT_DICTIONARY_VALUE_ENCODING_MAC_EXP
operator|.
name|equals
argument_list|(
name|encodingName
argument_list|)
condition|)
block|{
name|encoding
operator|=
operator|new
name|MacRomanEncoding
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FONT_DICTIONARY_VALUE_ENCODING_WIN
operator|.
name|equals
argument_list|(
name|encodingName
argument_list|)
condition|)
block|{
name|encoding
operator|=
operator|new
name|WinAnsiEncoding
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FONT_DICTIONARY_VALUE_ENCODING_PDFDOC
operator|.
name|equals
argument_list|(
name|encodingName
argument_list|)
condition|)
block|{
name|encoding
operator|=
operator|new
name|PdfDocEncoding
argument_list|()
expr_stmt|;
block|}
return|return
name|encoding
return|;
block|}
comment|/** 	 *  	 * @param fontProgram the stream of the font program extracted from the PDF file. 	 * @param clearTextLength the length in bytes of the clear part of the font program. 	 * @param eexecLength the length in bytes of the encoded part. 	 * @param encodingName The encoding object which is used by this font program. 	 * @return 	 * @throws IOException 	 */
specifier|public
specifier|static
name|Type1Parser
name|createParserWithEncodingObject
parameter_list|(
name|InputStream
name|fontProgram
parameter_list|,
name|int
name|clearTextLength
parameter_list|,
name|int
name|eexecLength
parameter_list|,
name|Encoding
name|encoding
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Type1Parser
argument_list|(
name|fontProgram
argument_list|,
name|clearTextLength
argument_list|,
name|eexecLength
argument_list|,
name|encoding
argument_list|)
return|;
block|}
specifier|public
name|Type1
name|parse
parameter_list|()
throws|throws
name|IOException
block|{
name|parseClearPartOfFontProgram
argument_list|(
name|this
operator|.
name|fontProgram
argument_list|)
expr_stmt|;
name|decodeAndParseEExecPart
argument_list|(
name|this
operator|.
name|fontProgram
argument_list|)
expr_stmt|;
return|return
name|this
operator|.
name|type1Font
return|;
block|}
specifier|private
name|void
name|parseClearPartOfFontProgram
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|skipComments
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|parseFontInformationUntilEncodingPart
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|decodeAndParseEExecPart
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|eexecPart
init|=
name|readEexec
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|byte
index|[]
name|decodedEExecPart
init|=
name|decodeEexec
argument_list|(
name|eexecPart
argument_list|)
decl_stmt|;
name|PeekInputStream
name|eexecStream
init|=
operator|new
name|PeekInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|decodedEExecPart
argument_list|)
argument_list|)
decl_stmt|;
name|parseEExecPart
argument_list|(
name|eexecStream
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|skipComments
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|nextChar
init|=
name|stream
operator|.
name|peek
argument_list|()
decl_stmt|;
while|while
condition|(
name|nextChar
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|nextChar
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected End Of File during a comment parsing"
argument_list|)
throw|;
block|}
name|readLine
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|nextChar
operator|=
name|stream
operator|.
name|peek
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|parseFontInformationUntilEncodingPart
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|token
init|=
name|readToken
argument_list|(
name|stream
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|isEExecKeyWord
argument_list|(
name|token
argument_list|)
condition|)
block|{
comment|// add here specific operation to memorize useful information
if|if
condition|(
name|isEncodingKeyWord
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parseEncodingDefinition
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|readToken
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|isStartOfEExecReached
argument_list|()
condition|)
block|{
name|readNextCharacter
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|parseEncodingDefinition
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|token
init|=
name|readToken
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|String
name|readableToken
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
if|if
condition|(
name|PS_ISOLATIN_ENCODING
operator|.
name|equals
argument_list|(
name|readableToken
argument_list|)
condition|)
block|{
name|this
operator|.
name|type1Font
operator|.
name|initEncodingWithISOLatin1Encoding
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PS_STANDARD_ENCODING
operator|.
name|equals
argument_list|(
name|readableToken
argument_list|)
condition|)
block|{
name|this
operator|.
name|type1Font
operator|.
name|initEncodingWithStandardEncoding
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|Integer
operator|.
name|parseInt
argument_list|(
name|readableToken
argument_list|)
expr_stmt|;
name|throwExceptionIfUnexpectedToken
argument_list|(
literal|"array"
argument_list|,
name|readToken
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|readEndSetEncodingValues
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid encoding : Expected int value before \"array\" "
operator|+
literal|"key word if the Encoding isn't Standard or ISOLatin"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|parseEExecPart
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|lenIV
init|=
name|DEFAULT_LEN_IV
decl_stmt|;
name|byte
index|[]
name|previousToken
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
while|while
condition|(
operator|!
name|isEndOfStream
argument_list|(
name|stream
argument_list|)
condition|)
block|{
name|byte
index|[]
name|token
init|=
name|readToken
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|isLenIVKeyWord
argument_list|(
name|token
argument_list|)
condition|)
block|{
comment|// lenIV belong to Private Dictionary.
comment|// If you create a method to parse PrivateDict, please update this function
name|byte
index|[]
name|l
init|=
name|readToken
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|lenIV
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
operator|new
name|String
argument_list|(
name|l
argument_list|,
name|TOKEN_ENCODING
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isBeginOfBinaryPart
argument_list|(
name|token
argument_list|)
condition|)
block|{
try|try
block|{
name|int
name|lengthOfBinaryPart
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
operator|new
name|String
argument_list|(
name|previousToken
argument_list|,
name|TOKEN_ENCODING
argument_list|)
argument_list|)
decl_stmt|;
name|skipSingleBlankSeparator
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|.
name|read
argument_list|(
operator|new
name|byte
index|[
name|lengthOfBinaryPart
index|]
argument_list|,
literal|0
argument_list|,
name|lengthOfBinaryPart
argument_list|)
expr_stmt|;
name|token
operator|=
name|readToken
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|// read the end of binary part
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Binary part found but previous token wasn't an integer"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|isCharStringKeyWord
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|parseCharStringArray
argument_list|(
name|stream
argument_list|,
name|lenIV
argument_list|)
expr_stmt|;
block|}
name|previousToken
operator|=
name|token
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|parseCharStringArray
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|,
name|int
name|lenIV
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|numberOfElements
init|=
name|readNumberOfCharStrings
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|goToBeginOfCharStringElements
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
name|numberOfElements
operator|>
literal|0
condition|)
block|{
name|readCharStringElement
argument_list|(
name|stream
argument_list|,
name|lenIV
argument_list|)
expr_stmt|;
operator|--
name|numberOfElements
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|goToBeginOfCharStringElements
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|token
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
do|do
block|{
name|token
operator|=
name|readToken
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|isNotBeginKeyWord
argument_list|(
name|token
argument_list|)
condition|)
do|;
block|}
specifier|private
name|void
name|readCharStringElement
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|,
name|int
name|lenIV
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|labelToken
init|=
name|readToken
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|String
name|label
init|=
operator|new
name|String
argument_list|(
name|labelToken
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
name|byte
index|[]
name|sizeOfCharStringToken
init|=
name|readToken
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|int
name|sizeOfCharString
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
operator|new
name|String
argument_list|(
name|sizeOfCharStringToken
argument_list|,
name|TOKEN_ENCODING
argument_list|)
argument_list|)
decl_stmt|;
name|readToken
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|// skip "RD" or "-|" token
name|skipSingleBlankSeparator
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|// "RD" or "-|" are followed by a space
name|byte
index|[]
name|descBinary
init|=
operator|new
name|byte
index|[
name|sizeOfCharString
index|]
decl_stmt|;
name|stream
operator|.
name|read
argument_list|(
name|descBinary
argument_list|,
literal|0
argument_list|,
name|sizeOfCharString
argument_list|)
expr_stmt|;
name|byte
index|[]
name|description
init|=
name|Type1FontUtil
operator|.
name|charstringDecrypt
argument_list|(
name|descBinary
argument_list|,
name|lenIV
argument_list|)
decl_stmt|;
name|Type1CharStringParser
name|t1p
init|=
operator|new
name|Type1CharStringParser
argument_list|()
decl_stmt|;
comment|// TODO provide the local subroutine indexes
name|List
argument_list|<
name|Object
argument_list|>
name|operations
init|=
name|t1p
operator|.
name|parse
argument_list|(
name|description
argument_list|,
operator|new
name|IndexData
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|type1Font
operator|.
name|addGlyphDescription
argument_list|(
name|label
argument_list|,
operator|new
name|GlyphDescription
argument_list|(
name|operations
argument_list|)
argument_list|)
expr_stmt|;
name|readToken
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|// skip "ND" or "|-" token
block|}
specifier|private
name|boolean
name|isNotBeginKeyWord
parameter_list|(
name|byte
index|[]
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|word
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
return|return
operator|!
literal|"begin"
operator|.
name|equals
argument_list|(
name|word
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isBeginOfBinaryPart
parameter_list|(
name|byte
index|[]
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|word
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
return|return
operator|(
literal|"RD"
operator|.
name|equals
argument_list|(
name|word
argument_list|)
operator|||
literal|"-|"
operator|.
name|equals
argument_list|(
name|word
argument_list|)
operator|)
return|;
block|}
specifier|private
name|boolean
name|isLenIVKeyWord
parameter_list|(
name|byte
index|[]
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|word
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
return|return
literal|"/lenIV"
operator|.
name|equals
argument_list|(
name|word
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isCharStringKeyWord
parameter_list|(
name|byte
index|[]
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|word
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
return|return
literal|"/CharStrings"
operator|.
name|equals
argument_list|(
name|word
argument_list|)
return|;
block|}
specifier|private
name|int
name|readNumberOfCharStrings
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|token
init|=
name|readToken
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|String
name|word
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|word
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Number of CharStrings elements is expected."
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|throwExceptionIfUnexpectedToken
parameter_list|(
name|String
name|expectedValue
parameter_list|,
name|byte
index|[]
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|valueToCheck
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|expectedValue
operator|.
name|equals
argument_list|(
name|valueToCheck
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|expectedValue
operator|+
literal|" was expected but we received "
operator|+
name|valueToCheck
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|readEndSetEncodingValues
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|token
init|=
name|readToken
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|boolean
name|lastTokenWasReadOnly
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|lastTokenWasReadOnly
operator|&&
name|isDefKeyWord
argument_list|(
name|token
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|isDupKeyWord
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|byte
index|[]
name|cidToken
init|=
name|readToken
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|byte
index|[]
name|labelToken
init|=
name|readToken
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|String
name|cid
init|=
operator|new
name|String
argument_list|(
name|cidToken
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
name|String
name|label
init|=
operator|new
name|String
argument_list|(
name|labelToken
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|type1Font
operator|.
name|addCidWithLabel
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|cid
argument_list|)
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid encoding : Expected CID value before \""
operator|+
name|label
operator|+
literal|"\" label"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|lastTokenWasReadOnly
operator|=
name|isReadOnlyKeyWord
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|readToken
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|byte
index|[]
name|readEexec
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|BUFFER_SIZE
init|=
literal|1024
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|BUFFER_SIZE
index|]
decl_stmt|;
name|ByteArrayOutputStream
name|eexecPart
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|int
name|lr
init|=
literal|0
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
do|do
block|{
name|lr
operator|=
name|stream
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr
operator|==
name|BUFFER_SIZE
operator|&&
operator|(
name|total
operator|+
name|BUFFER_SIZE
operator|<
name|eexecSize
operator|)
condition|)
block|{
name|eexecPart
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
name|total
operator|+=
name|BUFFER_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lr
operator|>
literal|0
operator|&&
operator|(
name|total
operator|+
name|lr
operator|<
name|eexecSize
operator|)
condition|)
block|{
name|eexecPart
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|lr
argument_list|)
expr_stmt|;
name|total
operator|+=
name|lr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lr
operator|>
literal|0
operator|&&
operator|(
name|total
operator|+
name|lr
operator|>=
name|eexecSize
operator|)
condition|)
block|{
name|eexecPart
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|eexecSize
operator|-
name|total
argument_list|)
expr_stmt|;
name|total
operator|+=
operator|(
name|eexecSize
operator|-
name|total
operator|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|eexecSize
operator|>
name|total
operator|&&
name|lr
operator|>
literal|0
condition|)
do|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|eexecPart
argument_list|)
expr_stmt|;
return|return
name|eexecPart
operator|.
name|toByteArray
argument_list|()
return|;
block|}
specifier|private
name|byte
index|[]
name|decodeEexec
parameter_list|(
name|byte
index|[]
name|eexec
parameter_list|)
block|{
return|return
name|Type1FontUtil
operator|.
name|eexecDecrypt
argument_list|(
name|eexec
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|readLine
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|Byte
argument_list|>
name|bytes
init|=
operator|new
name|ArrayList
argument_list|<
name|Byte
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|currentCharacter
init|=
literal|0
decl_stmt|;
do|do
block|{
name|currentCharacter
operator|=
name|readNextCharacter
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|bytes
operator|.
name|add
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|currentCharacter
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
literal|'\n'
operator|==
name|currentCharacter
operator|||
literal|'\r'
operator|==
name|currentCharacter
operator|)
condition|)
do|;
if|if
condition|(
literal|'\r'
operator|==
name|currentCharacter
operator|&&
literal|'\n'
operator|==
name|stream
operator|.
name|peek
argument_list|()
condition|)
block|{
name|currentCharacter
operator|=
name|readNextCharacter
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|bytes
operator|.
name|add
argument_list|(
call|(
name|byte
call|)
argument_list|(
name|currentCharacter
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|bytes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|bytes
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|byte
index|[]
name|readToken
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|token
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
name|skipBlankSeparators
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|int
name|nextByte
init|=
name|stream
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextByte
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected End Of File"
argument_list|)
throw|;
block|}
if|if
condition|(
name|nextByte
operator|==
literal|'('
condition|)
block|{
name|token
operator|=
name|readStringLiteral
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextByte
operator|==
literal|'['
condition|)
block|{
name|token
operator|=
name|readArray
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextByte
operator|==
literal|'{'
condition|)
block|{
name|token
operator|=
name|readProcedure
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|token
operator|=
name|readNameOrArgument
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
return|return
name|token
return|;
block|}
specifier|private
name|byte
index|[]
name|readStringLiteral
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|opened
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|buffer
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|currentByte
init|=
literal|0
decl_stmt|;
do|do
block|{
name|currentByte
operator|=
name|readNextCharacter
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentByte
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected End Of File"
argument_list|)
throw|;
block|}
if|if
condition|(
name|currentByte
operator|==
literal|'('
condition|)
block|{
name|opened
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentByte
operator|==
literal|')'
condition|)
block|{
name|opened
operator|--
expr_stmt|;
block|}
name|buffer
operator|.
name|add
argument_list|(
name|currentByte
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|opened
operator|!=
literal|0
condition|)
do|;
return|return
name|convertListOfIntToByteArray
argument_list|(
name|buffer
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|readArray
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|opened
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|buffer
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|currentByte
init|=
literal|0
decl_stmt|;
do|do
block|{
name|currentByte
operator|=
name|readNextCharacter
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentByte
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected End Of File"
argument_list|)
throw|;
block|}
if|if
condition|(
name|currentByte
operator|==
literal|'['
condition|)
block|{
name|opened
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentByte
operator|==
literal|']'
condition|)
block|{
name|opened
operator|--
expr_stmt|;
block|}
name|buffer
operator|.
name|add
argument_list|(
name|currentByte
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|opened
operator|!=
literal|0
condition|)
do|;
return|return
name|convertListOfIntToByteArray
argument_list|(
name|buffer
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|readProcedure
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|opened
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|buffer
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|currentByte
init|=
literal|0
decl_stmt|;
do|do
block|{
name|currentByte
operator|=
name|readNextCharacter
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentByte
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected End Of File"
argument_list|)
throw|;
block|}
if|if
condition|(
name|currentByte
operator|==
literal|'{'
condition|)
block|{
name|opened
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentByte
operator|==
literal|'}'
condition|)
block|{
name|opened
operator|--
expr_stmt|;
block|}
name|buffer
operator|.
name|add
argument_list|(
name|currentByte
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|opened
operator|!=
literal|0
condition|)
do|;
return|return
name|convertListOfIntToByteArray
argument_list|(
name|buffer
argument_list|)
return|;
block|}
specifier|private
name|byte
index|[]
name|readNameOrArgument
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|buffer
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|nextByte
init|=
literal|0
decl_stmt|;
do|do
block|{
name|int
name|currentByte
init|=
name|readNextCharacter
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentByte
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected End Of File"
argument_list|)
throw|;
block|}
name|buffer
operator|.
name|add
argument_list|(
name|currentByte
argument_list|)
expr_stmt|;
name|nextByte
operator|=
name|stream
operator|.
name|peek
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isNotBlankSperator
argument_list|(
name|nextByte
argument_list|)
operator|&&
name|isNotBeginOfName
argument_list|(
name|nextByte
argument_list|)
operator|&&
name|isNotSeparator
argument_list|(
name|nextByte
argument_list|)
condition|)
do|;
return|return
name|convertListOfIntToByteArray
argument_list|(
name|buffer
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isNotBeginOfName
parameter_list|(
name|int
name|character
parameter_list|)
block|{
return|return
operator|(
literal|'/'
operator|!=
name|character
operator|)
return|;
block|}
specifier|private
name|boolean
name|isNotSeparator
parameter_list|(
name|int
name|character
parameter_list|)
block|{
return|return
operator|!
operator|(
literal|'{'
operator|==
name|character
operator|||
literal|'}'
operator|==
name|character
operator|||
literal|'['
operator|==
name|character
operator|||
literal|']'
operator|==
name|character
operator|)
return|;
block|}
specifier|private
name|byte
index|[]
name|convertListOfIntToByteArray
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|input
parameter_list|)
block|{
name|byte
index|[]
name|res
init|=
operator|new
name|byte
index|[
name|input
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|res
index|[
name|i
index|]
operator|=
name|input
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|byteValue
argument_list|()
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
specifier|private
name|int
name|readNextCharacter
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|currentByte
init|=
name|stream
operator|.
name|read
argument_list|()
decl_stmt|;
name|this
operator|.
name|numberOfReadBytes
operator|++
expr_stmt|;
return|return
name|currentByte
return|;
block|}
specifier|private
name|void
name|skipBlankSeparators
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|nextByte
init|=
name|stream
operator|.
name|peek
argument_list|()
decl_stmt|;
while|while
condition|(
name|isBlankSperator
argument_list|(
name|nextByte
argument_list|)
condition|)
block|{
name|readNextCharacter
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|nextByte
operator|=
name|stream
operator|.
name|peek
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|skipSingleBlankSeparator
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|nextByte
init|=
name|stream
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|isBlankSperator
argument_list|(
name|nextByte
argument_list|)
condition|)
block|{
name|readNextCharacter
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|isBlankSperator
parameter_list|(
name|int
name|character
parameter_list|)
block|{
return|return
operator|(
name|character
operator|==
literal|' '
operator|||
name|character
operator|==
literal|'\n'
operator|||
name|character
operator|==
literal|'\r'
operator|)
return|;
block|}
specifier|private
name|boolean
name|isNotBlankSperator
parameter_list|(
name|int
name|character
parameter_list|)
block|{
return|return
operator|!
name|isBlankSperator
argument_list|(
name|character
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isEExecKeyWord
parameter_list|(
name|byte
index|[]
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|word
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
return|return
literal|"eexec"
operator|.
name|equals
argument_list|(
name|word
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isDefKeyWord
parameter_list|(
name|byte
index|[]
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|word
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
return|return
literal|"def"
operator|.
name|equals
argument_list|(
name|word
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isReadOnlyKeyWord
parameter_list|(
name|byte
index|[]
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|word
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
return|return
literal|"readonly"
operator|.
name|equals
argument_list|(
name|word
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isEncodingKeyWord
parameter_list|(
name|byte
index|[]
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|word
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
return|return
literal|"/Encoding"
operator|.
name|equals
argument_list|(
name|word
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isDupKeyWord
parameter_list|(
name|byte
index|[]
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|word
init|=
operator|new
name|String
argument_list|(
name|token
argument_list|,
name|TOKEN_ENCODING
argument_list|)
decl_stmt|;
return|return
literal|"dup"
operator|.
name|equals
argument_list|(
name|word
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isStartOfEExecReached
parameter_list|()
block|{
return|return
operator|(
name|this
operator|.
name|numberOfReadBytes
operator|==
name|this
operator|.
name|clearTextSize
operator|)
return|;
block|}
specifier|private
name|boolean
name|isEndOfStream
parameter_list|(
name|PeekInputStream
name|stream
parameter_list|)
block|{
try|try
block|{
name|skipBlankSeparators
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
end_class

end_unit

